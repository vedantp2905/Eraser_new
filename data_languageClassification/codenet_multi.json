[
  {
    "code": "m1 = m2 = m3 = 0 for i in range ( 10 ) : m3 = max ( m3 , int ( input ( ) ) ) if m3 > m2 : m2 , m3 = m3 , m2 if m2 > m1 : m1 , m2 = m2 , m1 print ( m1 ) print ( m2 ) print ( m3 )",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for i in range ( 10 ) ] s . sort ( reverse = True ) for i in s [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "A = [ int ( input ( ) ) for i in range ( 10 ) ] for i in sorted ( A ) [ : - 4 : - 1 ] : print ( i )",
    "label": 0
  },
  {
    "code": "mount_list = [ ] for i in range ( 10 ) : mount_list . append ( int ( input ( ) ) ) mount_list . sort ( reverse = True ) for i in range ( 3 ) : print ( mount_list [ i ] )",
    "label": 0
  },
  {
    "code": "moutain = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : moutain [ i ] = int ( raw_input ( ) ) moutain . sort ( reverse = True ) for i in range ( 3 ) : print moutain [ i ]",
    "label": 0
  },
  {
    "code": "num = [ int ( input ( ) ) for i in range ( 10 ) ] num . sort ( reverse = True ) for i in range ( 3 ) : print ( num [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] while True : try : n = int ( input ( ) ) a . append ( n ) except : break print ( max ( a ) ) a . remove ( max ( a ) ) print ( max ( a ) ) a . remove ( max ( a ) ) print ( max ( a ) )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( ) for i in range ( 3 ) : print ( l [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "def __main ( ) : mountains = [ ] numOfMoun = 10 for c in range ( numOfMoun ) : mountains . insert ( c , int ( input ( ) ) ) sorted_mounts = sorted ( mountains , reverse = True ) for k in range ( 3 ) : print ( sorted_mounts [ k ] ) __main ( )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( ( int ) ( input ( ) ) ) h . sort ( ) h . reverse ( ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : : - 1 ] for i in h [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "mh = [ ] for i in range ( 1 , 11 ) : mh . append ( int ( input ( ) ) ) mh . sort ( reverse = True ) print ( mh [ 0 ] ) print ( mh [ 1 ] ) print ( mh [ 2 ] )",
    "label": 0
  },
  {
    "code": "a_list = [ ] for i in range ( 10 ) : while True : a = input ( ) a = int ( a ) if 0 <= a and a <= 10000 : break a_list . append ( a ) for i in range ( 3 ) : print ( max ( a_list ) ) a_list . remove ( max ( a_list ) )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for _ in range ( 10 ) : mountains . append ( int ( input ( ) ) ) mountains . sort ( reverse = True ) for height in mountains [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "Height = [ 0 ] * 10 for i in range ( 10 ) : Height [ i ] = int ( input ( ) ) Height . sort ( ) Height . reverse ( ) for j in range ( 3 ) : print ( Height [ j ] )",
    "label": 0
  },
  {
    "code": "arr = list ( [ ] ) for i in range ( 10 ) : arr . append ( int ( input ( ) ) ) arr . sort ( reverse = True ) for i in range ( 3 ) : print arr [ i ]",
    "label": 0
  },
  {
    "code": "arr = list ( [ input ( ) for _ in range ( 10 ) ] ) arr . sort ( reverse = True ) for i in range ( 3 ) : print arr [ i ]",
    "label": 0
  },
  {
    "code": "arr = list ( [ input ( ) for _ in range ( 10 ) ] ) arr . sort ( reverse = True ) for i in range ( 3 ) : print arr [ i ]",
    "label": 0
  },
  {
    "code": "i = 0 x = [ ] for i in range ( 10 ) : mount = int ( input ( ) ) x . append ( mount ) sorted_x = sorted ( x ) print ( sorted_x [ - 1 ] ) print ( sorted_x [ - 2 ] ) print ( sorted_x [ - 3 ] )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( reverse = True ) for i in range ( 3 ) : print ( m [ i ] )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for i in range ( 10 ) : m = int ( input ( ) ) mountains . append ( m ) mountains . sort ( reverse = True ) for i in range ( 3 ) : print ( mountains [ i ] )",
    "label": 0
  },
  {
    "code": "max = [ 0 , 0 , 0 ] for a in range ( 10 ) : s = int ( input ( ) ) if max [ 0 ] < s : max [ 2 ] = max [ 1 ] max [ 1 ] = max [ 0 ] max [ 0 ] = s elif max [ 1 ] < s : max [ 2 ] = max [ 1 ] max [ 1 ] = s elif max [ 2 ] < s : max [ 2 ] = s for a in max : print ( a )",
    "label": 0
  },
  {
    "code": "hs = [ int ( input ( ) ) for i in range ( 10 ) ] h = sorted ( hs , reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] heights . sort ( reverse = True ) for height in heights [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "import sys ff = sys . stdin arr = [ int ( x ) for x in ff . readlines ( ) ] arr . sort ( reverse = True ) for x in arr [ 0 : 3 ] : print ( x )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : n = int ( input ( ) ) list . append ( n ) list . sort ( ) print ( list [ - 1 ] ) print ( list [ - 2 ] ) print ( list [ - 3 ] )",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ input ( ) for _ in xrange ( 10 ) ] ) [ : - 4 : - 1 ] : print i",
    "label": 0
  },
  {
    "code": "import sys i = 0 list = [ ] for line in sys . stdin . readlines ( ) : list . append ( int ( line . strip ( \" \\n \" ) ) ) print sorted ( list , reverse = True ) [ 0 ] print sorted ( list , reverse = True ) [ 1 ] print sorted ( list , reverse = True ) [ 2 ]",
    "label": 0
  },
  {
    "code": "l = [ ] l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . append ( int ( input ( ) ) ) l . sort ( ) l . reverse ( ) print l [ 0 ] print l [ 1 ] print l [ 2 ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : a = input ( ) list . append ( a ) list = sorted ( list ) for i in range ( - 1 , - 4 , - 1 ) : print ( list [ i ] )",
    "label": 0
  },
  {
    "code": "li = [ ] for x in range ( 10 ) : s = input ( ) s = int ( s ) li . append ( s ) li . sort ( ) li . reverse ( ) for y in range ( 3 ) : print ( li [ y ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : x = input ( ) a . append ( x ) a . sort ( ) for i in range ( 9 , 6 , - 1 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "p1 = 0 p2 = 0 p3 = 0 for i in range ( 10 ) : d = int ( raw_input ( ) ) if ( d > p1 ) : p3 = p2 p2 = p1 p1 = d elif ( d > p2 ) : p3 = p2 p2 = d elif ( d > p3 ) : p3 = d print p1 print p2 print p3",
    "label": 0
  },
  {
    "code": "mount = [ ] for i in range ( 10 ) : tmp = int ( input ( ) ) mount . append ( tmp ) mount . sort ( ) mount . reverse ( ) for i in range ( 3 ) : print ( mount [ i ] )",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( map ( str , sorted ( [ input ( ) for _ in [ 0 ] * 10 ] ) ) [ : : - 1 ] [ 0 : 3 ] )",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( map ( str , sorted ( [ input ( ) for _ in [ 0 ] * 10 ] ) ) [ : : - 1 ] [ 0 : 3 ] )",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ input ( ) for _ in [ 0 ] * 10 ] ) [ - 1 : - 4 : - 1 ] : print i",
    "label": 0
  },
  {
    "code": "import sys mt_heights = map ( int , sys . stdin . readlines ( ) ) mt_heights . sort ( reverse = True ) for height in mt_heights [ : 3 ] : print height",
    "label": 0
  },
  {
    "code": "import sys data = map ( int , sys . stdin . read ( ) . split ( ) ) data . sort ( ) data . reverse ( ) for s in data [ : 3 ] : print s",
    "label": 0
  },
  {
    "code": "import sys a = [ ] s = sys . stdin . readline ( ) while s : a . append ( int ( s ) ) s = sys . stdin . readline ( ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print ( a [ i ] ) ;",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "import os import sys class Hoge ( object ) : def __init__ ( self ) : pass def func ( self ) : h = reversed ( sorted ( input ( ) for i in range ( 10 ) ) ) for i , e in enumerate ( h ) : if i <= 2 : print e return None if __name__ == ' __main__ ' : h = Hoge ( ) h . func ( )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 0 , 10 ) : m . append ( int ( input ( ) ) ) for i in range ( 0 , 3 ) : print ( list ( reversed ( sorted ( m ) ) ) [ i ] )",
    "label": 0
  },
  {
    "code": "h = list ( ) for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) for i in range ( - 1 , - 4 , - 1 ) : print h [ i ]",
    "label": 0
  },
  {
    "code": "import sys mount_list = map ( int , sys . stdin . readlines ( ) ) mount_list . sort ( reverse = True ) for x in mount_list [ : 3 ] : print x",
    "label": 0
  },
  {
    "code": "ret = [ ] for i in range ( 10 ) : ret . append ( int ( input ( ) ) ) ret . sort ( ) print ( ret [ - 1 ] ) print ( ret [ - 2 ] ) print ( ret [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "import sys tmp = [ ] for i in range ( 10 ) : line = input ( ) tmp . append ( line ) tmp . sort ( ) print tmp [ - 1 ] print tmp [ - 2 ] print tmp [ - 3 ]",
    "label": 0
  },
  {
    "code": "hills = [ input ( ) for x in xrange ( 10 ) ] hills . sort ( reverse = True ) for x in xrange ( 3 ) : print hills [ x ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( ) print ( list [ - 1 ] ) print ( list [ - 2 ] ) print ( list [ - 3 ] )",
    "label": 0
  },
  {
    "code": "lis = [ ] for i in range ( 10 ) : h = int ( input ( ) ) lis . append ( h ) for i in range ( 10 ) : for j in range ( i + 1 , 10 ) : if lis [ i ] < lis [ j ] : a = lis [ i ] lis [ i ] = lis [ j ] lis [ j ] = a for i in range ( 3 ) : print ( lis [ i ] )",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for _ in range ( 10 ) ] for height in sorted ( mountains ) [ - 3 : ] [ : : - 1 ] : print ( height )",
    "label": 0
  },
  {
    "code": "H = [ ] while True : try : H . append ( input ( ) ) except EOFError : break H . sort ( ) print ( H [ - 1 ] ) print ( H [ - 2 ] ) print ( H [ - 3 ] )",
    "label": 0
  },
  {
    "code": "hight = [ ] for i in range ( 10 ) : hight . append ( int ( input ( ) ) ) hight = sorted ( hight , reverse = True ) for i in range ( 3 ) : print ( hight [ i ] )",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for i in range ( 10 ) ] m . sort ( ) m . reverse ( ) print ( \" \\n \\n \" . format ( m [ 0 ] , m [ 1 ] , m [ 2 ] ) )",
    "label": 0
  },
  {
    "code": "inputs = [ ] for i in range ( 0 , 10 ) : inputs . append ( input ( ) ) inputs . sort ( reverse = True ) for i in range ( 0 , 3 ) : print inputs [ i ]",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 10 ) : data . append ( int ( raw_input ( ) ) ) data . sort ( reverse = True ) print data [ 0 ] print data [ 1 ] print data [ 2 ]",
    "label": 0
  },
  {
    "code": "import sys heights = [ int ( i ) for i in sys . stdin . read ( ) . split ( ) ] heights . sort ( reverse = True ) print ( \" \\n \" . join ( map ( str , heights [ : 3 ] ) ) )",
    "label": 0
  },
  {
    "code": "ls = [ ] while True : try : n = int ( raw_input ( ) ) except EOFError : break ls . append ( n ) ls . sort ( reverse = True ) print ls [ 0 ] print ls [ 1 ] print ls [ 2 ]",
    "label": 0
  },
  {
    "code": "L = [ ] for i in range ( 0 , 10 ) : x = raw_input ( ) L . append ( int ( x ) ) L . sort ( ) for i in range ( 0 , 3 ) : print L . pop ( )",
    "label": 0
  },
  {
    "code": "spam = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] spam . sort ( ) spam . reverse ( ) for i in range ( 0 , 3 ) : print ( spam [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( ) h . reverse ( ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "A = [ ] for i in range ( 10 ) : A . append ( int ( raw_input ( ) ) ) A . sort ( ) print A [ - 1 ] print A [ - 2 ] print A [ - 3 ]",
    "label": 0
  },
  {
    "code": "inputNum = [ ] for i in range ( 0 , 10 ) : inputNum . append ( int ( raw_input ( ) ) ) inputNum . sort ( reverse = True ) for i in range ( 0 , 3 ) : print inputNum [ i ]",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( map ( str , sorted ( [ input ( ) for _ in xrange ( 10 ) ] ) [ : - 4 : - 1 ] ) )",
    "label": 0
  },
  {
    "code": "a = list ( reversed ( sorted ( [ int ( raw_input ( ) ) for _ in range ( 10 ) ] ) ) ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 0 , 10 ) : t = int ( raw_input ( ) ) list . append ( t ) list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "lis = [ ] for i in range ( 10 ) : lis . append ( int ( input ( ) ) ) lis . sort ( ) for i in range ( 3 ) : print ( lis . pop ( ) )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( ) a . reverse ( ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : hills = [ ] for i in range ( 10 ) : tmp = raw_input ( ) hills . append ( int ( tmp ) ) hills . sort ( reverse = True ) for i in range ( 3 ) : print hills [ i ]",
    "label": 0
  },
  {
    "code": "mnts = [ ] for t in xrange ( 0 , 10 ) : mnts . append ( int ( raw_input ( ) ) ) tops = sorted ( mnts , reverse = True ) for i in xrange ( 0 , 3 ) : print tops [ i ]",
    "label": 0
  },
  {
    "code": "m = [ ] while True : try : m . append ( int ( raw_input ( ) ) ) except EOFError : break m . sort ( ) m . reverse ( ) for h in m [ 0 : 3 ] : print h",
    "label": 0
  },
  {
    "code": "for h in sorted ( [ input ( ) for i in range ( 10 ) ] ) [ : - 4 : - 1 ] : print h",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( map ( str , sorted ( [ int ( raw_input ( ) ) for i in range ( 10 ) ] , reverse = True ) [ : 3 ] ) )",
    "label": 0
  },
  {
    "code": "n = [ ] for i in range ( 10 ) : n . append ( input ( ) ) n . sort ( ) n . reverse ( ) for i in range ( 3 ) : print n [ i ]",
    "label": 0
  },
  {
    "code": "hills = [ ] for i in range ( 10 ) : hills . append ( int ( input ( ) ) ) hills . sort ( ) hills . reverse ( ) for i in range ( 3 ) : print ( hills [ i ] )",
    "label": 0
  },
  {
    "code": "array = [ ] for i in range ( 10 ) : num = int ( input ( ) ) array . append ( num ) list = sorted ( array ) print ( list [ 9 ] ) print ( list [ 8 ] ) print ( list [ 7 ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : altitude_lis = [ ] for i in range ( 10 ) : input_line = raw_input ( ) altitude = int ( input_line ) altitude_lis . append ( altitude ) altitude_lis . sort ( ) altitude_lis . reverse ( ) for i in range ( 3 ) : print ( altitude_lis [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "height = [ ] for i in range ( 10 ) : height . append ( int ( input ( ) ) ) height . sort ( ) height . reverse ( ) for i in range ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "firstMountainHeight = 0 secondMountainHeight = 0 thirdMountainHeight = 0 while 1 : try : i = int ( raw_input ( ) ) if firstMountainHeight < i : thirdMountainHeight = secondMountainHeight secondMountainHeight = firstMountainHeight firstMountainHeight = i elif secondMountainHeight < i : thirdMountainHeight = secondMountainHeight secondMountainHeight = i elif thirdMountainHeight < i : thirdMountainHeight = i except : print \" %d \" % ( firstMountainHeight ) print \" %d \" % ( secondMountainHeight ) print \" %d \" % ( thirdMountainHeight ) break",
    "label": 0
  },
  {
    "code": "firstMountainHeight = 0 secondMountainHeight = 0 thirdMountainHeight = 0 while 1 : try : i = int ( raw_input ( ) ) if firstMountainHeight < i : thirdMountainHeight = secondMountainHeight secondMountainHeight = firstMountainHeight firstMountainHeight = i elif secondMountainHeight < i : thirdMountainHeight = secondMountainHeight secondMountainHeight = i elif thirdMountainHeight < i : thirdMountainHeight = i except : print \" %d \" % ( firstMountainHeight ) print \" %d \" % ( secondMountainHeight ) print \" %d \" % ( thirdMountainHeight ) break",
    "label": 0
  },
  {
    "code": "one = 0 two = 0 three = 0 while 1 : try : i = int ( raw_input ( ) ) if one < i : three = two two = one one = i elif two < i : three = two two = i elif three < i : three = i except : print \" %d \" % ( one ) print \" %d \" % ( two ) print \" %d \" % ( three ) break",
    "label": 0
  },
  {
    "code": "one = 0 two = 0 three = 0 while 1 : try : i = int ( raw_input ( ) ) if one < i : three = two two = one one = i elif two < i : three = two two = i elif three < i : three = i except : print \" %d \" % ( one ) print \" %d \" % ( two ) print \" %d \" % ( three ) break",
    "label": 0
  },
  {
    "code": "heights = sorted ( [ input ( ) for _ in xrange ( 10 ) ] ) for i in xrange ( 1 , 4 ) : print heights [ - i ]",
    "label": 0
  },
  {
    "code": "data = [ 0 ] for i in range ( 10 ) : data . append ( int ( input ( ) ) ) data = sorted ( data ) data . reverse ( ) for i in range ( 3 ) : print data [ i ]",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for i in range ( 10 ) ] for i in sorted ( s ) [ : - 4 : - 1 ] : print ( i )",
    "label": 0
  },
  {
    "code": "height = [ ] for i in range ( 10 ) : height . append ( input ( ) ) height . sort ( reverse = True ) for i in range ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "height = [ 0 for _ in range ( 10 ) ] for i in range ( 10 ) : height [ i ] = int ( raw_input ( ) ) top3 = sorted ( height ) [ : 6 : - 1 ] for h in top3 : print h",
    "label": 0
  },
  {
    "code": "import sys def main ( ) : mountaines = [ ] for line in sys . stdin : mountaines . append ( int ( line ) ) mountaines . sort ( reverse = True ) for index , x in enumerate ( mountaines ) : print x if index >= 2 : break if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "heights = [ ] for i in range ( 0 , 10 ) : heights . append ( input ( ) ) heights . sort ( ) heights . reverse ( ) for i in range ( 0 , 3 ) : print heights [ i ]",
    "label": 0
  },
  {
    "code": "j = [ ] for i in range ( 10 ) : j . append ( int ( input ( ) ) ) j . sort ( reverse = True ) for k in range ( 3 ) : print ( j [ k ] )",
    "label": 0
  },
  {
    "code": "myList = [ ] for i in range ( 0 , 10 ) : myList . append ( int ( input ( ) ) ) myList . sort ( ) myList . reverse ( ) print ( myList [ 0 ] ) print ( myList [ 1 ] ) print ( myList [ 2 ] )",
    "label": 0
  },
  {
    "code": "if __name__ == \" __main__ \" : a = [ ] for i in range ( 0 , 10 ) : val = input ( ) a . append ( int ( val ) ) a . sort ( ) a . reverse ( ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ input ( ) for i in range ( 10 ) ] print max ( a ) b = max ( a ) a . remove ( b ) print max ( a ) b = max ( a ) a . remove ( b ) print max ( a )",
    "label": 0
  },
  {
    "code": "arr = [ ] for i in range ( 10 ) : arr = arr + [ int ( raw_input ( ) ) ] arr . sort ( ) arr . reverse ( ) for i in range ( 3 ) : print ( arr [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( input ( ) ) l . sort ( ) l . reverse ( ) for a in l [ : 3 ] : print a",
    "label": 0
  },
  {
    "code": "inputList = [ ] while True : try : num = int ( input ( ) ) except EOFError : break inputList . append ( num ) inputList . sort ( ) length = len ( inputList ) for i in range ( 3 ) : print ( inputList [ length - i - 1 ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : List = [ ] for i in range ( 10 ) : a = int ( input ( ) ) List . append ( a ) List . sort ( reverse = True ) print ( List [ 0 ] ) print ( List [ 1 ] ) print ( List [ 2 ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "import sys arr = [ ] for i in sys . stdin : arr . append ( int ( i ) ) arr . sort ( ) arr . reverse ( ) for i in range ( 3 ) : print ( arr [ i ] )",
    "label": 0
  },
  {
    "code": "lis = [ ] ; for i in range ( 10 ) : h = int ( input ( ) ) ; lis . append ( h ) ; for i in range ( 10 ) : for j in range ( i + 1 , 10 ) : if lis [ i ] < lis [ j ] : a = lis [ i ] ; lis [ i ] = lis [ j ] ; lis [ j ] = a ; for i in range ( 3 ) : print ( lis [ i ] ) ;",
    "label": 0
  },
  {
    "code": "mountain = [ ] for i in range ( 10 ) : mountain . append ( int ( input ( ) ) ) mountain . sort ( reverse = True ) for j in range ( 3 ) : print ( mountain [ j ] )",
    "label": 0
  },
  {
    "code": "li = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) print ( \" \\n \" . join ( map ( str , li [ : 3 ] ) ) )",
    "label": 0
  },
  {
    "code": "import sys def main ( ) : l = [ ] for line in sys . stdin . readlines ( ) : l . append ( int ( line . rstrip ( ) ) ) for _ in range ( 3 ) : print max ( l ) l . remove ( max ( l ) ) main ( )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( ) a . reverse ( ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "s = 10 * [ 0 ] for i in range ( 10 ) : s [ i ] = input ( ) s . sort ( reverse = True ) for i in range ( 3 ) : print s [ i ]",
    "label": 0
  },
  {
    "code": "heap = [ ] while True : try : n = int ( raw_input ( ) ) if len ( heap ) == 0 : heap . append ( n ) elif len ( heap ) == 1 : if n <= heap [ 0 ] : heap . append ( n ) else : heap . insert ( 0 , n ) elif len ( heap ) == 2 : if n > heap [ 0 ] : heap . insert ( 0 , n ) elif n <= heap [ 1 ] : heap . append ( n ) else : heap . insert ( 1 , n ) elif n > heap [ 2 ] : if n >= heap [ 0 ] : heap . insert ( 0 , n ) elif n >= heap [ 1 ] : heap . insert ( 1 , n ) else : heap . insert ( 2 , n ) heap . pop ( ) except ( EOFError ) : break for num in heap : print num",
    "label": 0
  },
  {
    "code": "lst = [ int ( raw_input ( ) ) for i in range ( 10 ) ] lst . sort ( ) lst . reverse ( ) print lst [ 0 ] print lst [ 1 ] print lst [ 2 ]",
    "label": 0
  },
  {
    "code": "mt = [ ] for i in range ( 10 ) : mt . append ( int ( input ( ) ) ) mt . sort ( ) print ( mt [ 9 ] ) print ( mt [ 8 ] ) print ( mt [ 7 ] )",
    "label": 0
  },
  {
    "code": "x = sorted ( [ input ( ) for _ in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] for y in x : print y",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for x in range ( 10 ) ] print ( sorted ( s ) [ - 1 ] ) print ( sorted ( s ) [ - 2 ] ) print ( sorted ( s ) [ - 3 ] )",
    "label": 0
  },
  {
    "code": "res = [ ] while True : try : n = input ( ) res . append ( n ) except EOFError : break res . sort ( ) res = res [ len ( res ) - 3 : ] for x in reversed ( res ) : print x",
    "label": 0
  },
  {
    "code": "import sys heights = [ ] for i in range ( 10 ) : line = sys . stdin . readline ( ) height = int ( line ) heights . append ( height ) heights . sort ( ) heights . reverse ( ) for i in range ( 3 ) : print ( heights [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 1 , 11 ) : b = int ( input ( ) ) a . append ( b ) a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "def get_input ( ) : while True : try : yield ' ' . join ( raw_input ( ) . strip ( ) ) except EOFError : break height = list ( get_input ( ) ) height = sorted ( map ( int , height ) , reverse = True ) print height [ 0 ] print height [ 1 ] print height [ 2 ]",
    "label": 0
  },
  {
    "code": "li = [ ] for i in xrange ( 10 ) : s = map ( str , raw_input ( ) . split ( ) ) li . append ( int ( s [ - 1 ] ) ) li . sort ( reverse = True ) for i in xrange ( 3 ) : print li [ i ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) for i in sorted ( a ) [ - 1 : - 4 : - 1 ] : print ( i )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for x in range ( 10 ) : mountains . append ( int ( raw_input ( ) ) ) mountains . sort ( ) mountains . reverse ( ) print mountains [ 0 ] print mountains [ 1 ] print mountains [ 2 ]",
    "label": 0
  },
  {
    "code": "import sys def solve ( ) : a = [ ] for line in sys . stdin : a . append ( int ( line ) ) a . sort ( ) a . reverse ( ) for k in xrange ( 3 ) : print a [ k ] if __name__ == ' __main__ ' : solve ( )",
    "label": 0
  },
  {
    "code": "import sys print ( ' \\n ' . join ( map ( str , sorted ( [ int ( h . strip ( ) ) for h in sys . stdin ] , reverse = True ) [ : 3 ] ) ) )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for line in sys . stdin : a . append ( int ( line ) ) b = [ 0 , 0 , 0 ] for i in a : j = 0 while j < 3 : if i > b [ j ] : b . insert ( j , i ) break j += 1 for i in b [ : 3 ] : print i",
    "label": 0
  },
  {
    "code": "list1 = [ ] for i in range ( 10 ) : list1 . append ( int ( input ( ) ) ) list1 = sorted ( list1 ) list1 . reverse ( ) for i in range ( 3 ) : print ( list1 [ i ] )",
    "label": 0
  },
  {
    "code": "array = [ ] for i in range ( 10 ) : line = int ( input ( ) ) array += [ line ] result = sorted ( array ) [ : : - 1 ] print ( result [ 0 ] ) print ( result [ 1 ] ) print ( result [ 2 ] )",
    "label": 0
  },
  {
    "code": "mt = [ ] high = [ 0 , 0 , 0 ] for i in range ( 10 ) : mt . append ( int ( input ( ) ) ) if mt [ i ] > high [ 0 ] : high = [ mt [ i ] ] + high [ : 2 ] elif mt [ i ] > high [ 1 ] : high = [ high [ 0 ] ] + [ mt [ i ] ] + [ high [ 1 ] ] elif mt [ i ] > high [ 2 ] : high = high [ : 2 ] + [ mt [ i ] ] print ( ' \\n ' . join ( map ( str , high ) ) )",
    "label": 0
  },
  {
    "code": "import string import sys ip = sys . stdin . readlines ( ) for i in range ( len ( ip ) ) : ip [ i ] = int ( ip [ i ] . strip ( \" \\n \" ) ) h = [ 0 ] * 3 for i in range ( len ( ip ) ) : for j in range ( len ( ip ) ) : if ip [ i ] > ip [ j ] : tmp = ip [ i ] ip [ i ] = ip [ j ] ip [ j ] = tmp for i in range ( 3 ) : if h != 0 : print ( ip [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( raw_input ( ) ) ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "mountains = [ ] for i in range ( 10 ) : mountains . append ( int ( input ( ) ) ) for m in sorted ( mountains ) [ - 1 : - 4 : - 1 ] : print ( m )",
    "label": 0
  },
  {
    "code": "a = [ 0 ] for i in range ( 10 ) : if i == 0 : a [ 0 ] = input ( ) else : a . append ( input ( ) ) else : a . sort ( ) a . reverse ( ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "M = [ 0 for i in xrange ( 10 ) ] for i in xrange ( 10 ) : M [ i ] = int ( raw_input ( ) ) M . sort ( ) M . reverse ( ) for i in xrange ( 3 ) : print M [ i ]",
    "label": 0
  },
  {
    "code": "height = [ ] for i in xrange ( 10 ) : mountain = input ( ) height . append ( mountain ) height . sort ( ) height . reverse ( ) for i in xrange ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "mtheight = [ ] for i in xrange ( 0 , 10 ) : mtheight . append ( input ( ) ) mtheight . sort ( ) for i in xrange ( 0 , 3 ) : print mtheight [ 9 - i ]",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : x = input ( ) m . append ( x ) m . sort ( ) m . reverse ( ) for i in range ( 0 , 3 ) : print m [ i ]",
    "label": 0
  },
  {
    "code": "yama = [ ] for i in range ( 10 ) : yama . append ( int ( input ( ) ) ) yama . sort ( ) print ( yama [ 9 ] ) print ( yama [ 8 ] ) print ( yama [ 7 ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in xrange ( 10 ) : a = input ( ) l . append ( a ) for n in xrange ( 3 ) : print ( max ( l ) ) l . remove ( max ( l ) )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in xrange ( 10 ) : x . append ( input ( ) ) x . sort ( ) x = x [ : : - 1 ] for i in xrange ( 3 ) : print x [ i ]",
    "label": 0
  },
  {
    "code": "A = [ ] for i in range ( 10 ) : A . append ( int ( input ( ) ) ) A . sort ( ) A . reverse ( ) for i in range ( 3 ) : print ( A [ i ] )",
    "label": 0
  },
  {
    "code": "hills = [ ] for i in range ( 10 ) : hills . append ( int ( input ( ) ) ) hills . sort ( ) hills . reverse ( ) for i in range ( 3 ) : print ( hills [ i ] )",
    "label": 0
  },
  {
    "code": "hills_list = [ ] while len ( hills_list ) != 10 : hills = raw_input ( ) if ( 10000 >= int ( hills ) ) and ( int ( hills ) >= 0 ) : hills_list . append ( int ( hills ) ) hills_list . sort ( ) print hills_list [ - 1 ] print hills_list [ - 2 ] print hills_list [ - 3 ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a . sort ( ) a = a [ : : - 1 ] a = a [ : 3 ] print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print ( a [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for n in range ( 10 ) : mountains . append ( int ( input ( ) ) ) mountains . sort ( ) mountains . reverse ( ) for n in [ 0 , 1 , 2 ] : print ( mountains [ n ] )",
    "label": 0
  },
  {
    "code": "import sys def merge ( A , left , mid , right ) : n1 = mid - left n2 = right - mid L = [ 0 ] * ( n1 + 1 ) R = [ 0 ] * ( n2 + 1 ) for i in range ( n1 ) : L [ i ] = A [ left + i ] for i in range ( n2 ) : R [ i ] = A [ mid + i ] L [ n1 ] = R [ n2 ] = sys . maxint i = j = 0 for k in range ( left , right ) : if L [ i ] <= R [ j ] : A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 def mergeSort ( A , left , right ) : if left + 1 < right : mid = ( left + right ) / 2 mergeSort ( A , left , mid ) mergeSort ( A , mid , right ) merge ( A , left , mid , right ) M = [ int ( raw_input ( ) ) for i in range ( 10 ) ] mergeSort ( M , 0 , len ( M ) ) for i in range ( 1 , 4 ) : print M [ len ( M ) - i ]",
    "label": 0
  },
  {
    "code": "import sys ms = list ( map ( int , sys . stdin . read ( ) . rstrip ( ' \\n ' ) . split ( ' \\n ' ) ) ) ms . sort ( ) ms . reverse ( ) for i in range ( 3 ) : print ( ms [ i ] )",
    "label": 0
  },
  {
    "code": "height_list = [ ] for i in range ( 10 ) : height_list . append ( input ( ) ) height_list . sort ( ) height_list . reverse ( ) for height in height_list [ : 3 ] : print height",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( raw_input ( ) ) ) for i in range ( 3 ) : max = list [ 0 ] idx = 0 for i in range ( len ( list ) ) : if i != idx and list [ i ] > max : max = list [ i ] idx = i print max del list [ idx ]",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 10 ) : data . append ( int ( input ( ) ) ) data . sort ( ) data . reverse ( ) for i in range ( 3 ) : print ( data [ i ] )",
    "label": 0
  },
  {
    "code": "hight = [ ] for i in range ( 10 ) : hight . append ( int ( input ( ) ) ) hight . sort ( reverse = True ) print ( hight [ 0 ] ) print ( hight [ 1 ] ) print ( hight [ 2 ] )",
    "label": 0
  },
  {
    "code": "set = [ ] a = 9 for i in range ( 10 ) : n = int ( input ( ) ) set . append ( n ) set . sort ( ) while a >= 7 : print ( set [ a ] ) a -= 1",
    "label": 0
  },
  {
    "code": "s = list ( ) for i in range ( 10 ) : s . append ( input ( ) ) s . sort ( reverse = True ) for i in range ( 3 ) : print s [ i ]",
    "label": 0
  },
  {
    "code": "mounts = [ ] for i in range ( 10 ) : mounts . append ( int ( input ( ) ) ) mounts . sort ( ) mounts . reverse ( ) for i in range ( 3 ) : print ( mounts [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( ) for i in range ( 3 ) : print ( l [ - 1 * ( i + 1 ) ] )",
    "label": 0
  },
  {
    "code": "mounts = [ int ( input ( ) ) for i in range ( 10 ) ] mounts . sort ( reverse = True ) for i in range ( 3 ) : print ( mounts [ i ] )",
    "label": 0
  },
  {
    "code": "A = [ ] F = [ ] for i in range ( 0 , 10 ) : B1 = raw_input ( ) B = int ( B1 ) A . append ( B ) for i in range ( 0 , 10 ) : F . append ( 1 ) for num in range ( 0 , 3 ) : M = 0 m = 0 for i in range ( 0 , 10 ) : if ( M < A [ i ] ) : if ( F [ i ] == 1 ) : M = A [ i ] m = i print ( M ) F [ m ] = 0",
    "label": 0
  },
  {
    "code": "import sys list = [ ] for i in range ( 10 ) : list . append ( input ( ) ) list . sort ( ) list . reverse ( ) print list [ 0 ] print list [ 1 ] print list [ 2 ]",
    "label": 0
  },
  {
    "code": "first = 0 second = 0 third = 0 i = 0 for i in range ( 0 , 10 ) : line = int ( input ( ) ) if first < int ( line ) : third = second second = first first = int ( line ) elif second < int ( line ) : third = second second = int ( line ) elif third < int ( line ) : third = int ( line ) print ( first ) print ( second ) print ( third )",
    "label": 0
  },
  {
    "code": "d = [ int ( input ( ) ) for _ in range ( 10 ) ] d . sort ( reverse = True ) [ print ( x ) for x in d [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "n = 0 list = [ ] while n < 10 : x = int ( input ( ) ) list . append ( x ) n += 1 list . sort ( ) print ( list [ 9 ] ) print ( list [ 8 ] ) print ( list [ 7 ] )",
    "label": 0
  },
  {
    "code": "hills = [ ] for i in range ( 10 ) : hills . append ( int ( input ( ) ) ) hills . sort ( reverse = True ) for i in range ( 3 ) : print ( hills [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for i in range ( 10 ) ] for i in sorted ( l , reverse = True ) [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for _ in range ( 10 ) ] [ print ( x ) for x in sorted ( l , reverse = True ) [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for _ in range ( 10 ) ] [ print ( x ) for x in sorted ( l , reverse = True ) [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "import itertools l = [ int ( input ( ) ) for i in range ( 10 ) ] r = reversed ( sorted ( l ) ) for x in itertools . islice ( r , 3 ) : print ( x )",
    "label": 0
  },
  {
    "code": "def qsort ( l ) : if l == [ ] : return [ ] else : pv = l [ 0 ] left = [ ] right = [ ] for i in range ( 1 , len ( l ) ) : if l [ i ] > pv : left . append ( l [ i ] ) else : right . append ( l [ i ] ) left = qsort ( left ) right = qsort ( right ) left . append ( pv ) return left + right def main ( ) : lst = [ ] for i in range ( 0 , 10 ) : lst . append ( int ( raw_input ( ) ) ) lst = qsort ( lst ) for i in range ( 0 , 3 ) : print ( lst [ i ] ) main ( )",
    "label": 0
  },
  {
    "code": "L = list ( range ( 10 ) ) for i in range ( 10 ) : L [ i ] = int ( input ( ) ) print ( max ( L ) ) L . remove ( max ( L ) ) print ( max ( L ) ) L . remove ( max ( L ) ) print ( max ( L ) )",
    "label": 0
  },
  {
    "code": "order = [ ] for number in range ( 10 ) : hight = int ( input ( ) ) order . append ( hight ) for j in range ( 9 ) : for i in range ( 9 ) : if order [ i ] < order [ i + 1 ] : a = order [ i ] b = order [ i + 1 ] order [ i ] = b order [ i + 1 ] = a for i in range ( 3 ) : print ( order [ i ] )",
    "label": 0
  },
  {
    "code": "arr = [ ] for i in range ( 10 ) : arr . append ( int ( input ( ) ) ) arr . sort ( ) arr . reverse ( ) for i in range ( 3 ) : print ( arr [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for i in range ( 3 ) : print ( a [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for x in range ( 10 ) : mountains . append ( int ( raw_input ( ) ) ) mountains . sort ( ) print ( mountains [ - 1 ] ) print ( mountains [ - 2 ] ) print ( mountains [ - 3 ] )",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 10 ) : data . append ( int ( input ( ) ) ) sdata = sorted ( data ) for i in range ( 3 ) : print ( sdata [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "M = [ ] for i in range ( 10 ) : k = int ( input ( ) ) M . append ( k ) N = sorted ( M ) print ( N [ - 1 ] ) print ( N [ - 2 ] ) print ( N [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ input ( ) for i in range ( 10 ) ] a . sort ( reverse = True ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) a . reverse ( ) print ( \" \\n \\n \" % ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) )",
    "label": 0
  },
  {
    "code": "mountain = [ int ( input ( ) ) for i in range ( 10 ) ] for i in range ( 3 ) : print ( max ( mountain ) ) mountain . remove ( max ( mountain ) )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h = sorted ( h , reverse = True ) for i in h [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "[ print ( x ) for x in sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ - 1 : - 4 : - 1 ] ]",
    "label": 0
  },
  {
    "code": "s = [ ] for i in range ( 10 ) : s . append ( int ( raw_input ( ) ) ) s . sort ( ) for i in range ( 3 ) : print s [ 9 - i ]",
    "label": 0
  },
  {
    "code": "m = [ ] for _ in range ( 10 ) : r = int ( input ( ) ) m . append ( r ) m . sort ( ) print ( m [ 9 ] ) ; print ( m [ 8 ] ) ; print ( m [ 7 ] ) ;",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a . sort ( ) a . reverse ( ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "f = s = t = 0 for i in range ( 10 ) : n = int ( input ( ) ) if ( n > f ) : t = s s = f f = n elif ( n > s ) : t = s s = n elif ( n > t ) : t = n print ( ' \\n \\n ' % ( f , s , t ) )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( input ( ) ) m . sort ( ) m . reverse ( ) for i in range ( 3 ) : print m [ i ]",
    "label": 0
  },
  {
    "code": "heightlist = list ( ) for i in range ( 10 ) : heightlist . append ( eval ( input ( ) ) ) heightlist . sort ( ) for i in range ( - 1 , - 4 , - 1 ) : print ( heightlist [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for _ in range ( 10 ) : heights . append ( int ( input ( ) ) ) heights . sort ( reverse = True ) for i in range ( 3 ) : print ( heights [ i ] )",
    "label": 0
  },
  {
    "code": "import sys a = sorted ( [ int ( x ) for x in sys . stdin . readlines ( ) ] , reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "L = [ ] for _ in range ( 10 ) : L . append ( int ( input ( ) ) ) L . sort ( reverse = True ) for m in L [ : 3 ] : print ( m )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for line in sys . stdin : a . append ( int ( line ) ) a . sort ( ) a . reverse ( ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "import sys hills = [ ] for _ in range ( 10 ) : height = int ( sys . stdin . readline ( ) . strip ( ) ) hills . append ( height ) hills . sort ( reverse = True ) for i in range ( 3 ) : print ( hills [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : inp = input ( ) a . append ( inp ) if i >= 3 : a . sort ( ) del a [ 0 ] print a [ 2 ] print a [ 1 ] print a [ 0 ]",
    "label": 0
  },
  {
    "code": "high = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : high [ i ] = int ( input ( ) ) ans = [ 0 for i in range ( 3 ) ] for i in range ( 3 ) : ans [ i ] = max ( high ) high . remove ( ans [ i ] ) print ( ans [ i ] )",
    "label": 0
  },
  {
    "code": "import sys l = sorted ( map ( int , sys . stdin . readlines ( ) ) , reverse = True ) for i in l [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "mons = list ( ) for i in range ( 0 , 10 ) : mons . append ( int ( input ( ) ) ) mons = sorted ( mons ) for i in range ( 9 , 6 , - 1 ) : print ( mons [ i ] )",
    "label": 0
  },
  {
    "code": "import sys heights = [ ] for l in sys . stdin : heights . append ( int ( l ) ) heights = sorted ( heights , reverse = True ) print ( heights [ 0 ] ) print ( heights [ 1 ] ) print ( heights [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : num = int ( input ( ) ) a . append ( num ) a = sorted ( a ) for i in range ( 3 ) : print ( ' {0} ' . format ( a [ 9 - i ] ) )",
    "label": 0
  },
  {
    "code": "import sys li = [ ] for line in sys . stdin : li . append ( int ( line ) ) if len ( li ) == 10 : break li . sort ( reverse = True ) li = li [ 0 : 3 ] for i in li : print ( i )",
    "label": 0
  },
  {
    "code": "mount = [ ] for i in range ( 0 , 10 ) : n = input ( ) mount . append ( n ) mount . sort ( reverse = True ) for i in range ( 0 , 3 ) : print mount [ i ]",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "def LoT ( List ) : List2 = sorted ( List ) for i in range ( 3 ) : print ( List2 [ len ( List ) - 1 - i ] ) if __name__ == \" __main__ \" : List = [ ] for i in range ( 10 ) : List . append ( int ( input ( ) ) ) LoT ( List )",
    "label": 0
  },
  {
    "code": "lis = [ ] for i in range ( 10 ) : lis . append ( int ( input ( ) ) ) for i in sorted ( lis , reverse = True ) [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for line in sys . stdin : line . rstrip ( ' rn ' ) tmp = line . split ( \" \" ) a . append ( int ( tmp [ - 1 ] ) ) a . sort ( reverse = True ) y = 0 for i in a : if y == 3 : break if i >= 0 and i <= 10000 : print ( i ) y = y + 1",
    "label": 0
  },
  {
    "code": "def main ( ) : mountain = [ ] for i in range ( 10 ) : num = int ( input ( ) ) mountain . append ( num ) mountain = sorted ( mountain ) mountain = mountain [ : : - 1 ] for i in range ( 3 ) : print ( mountain [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ int ( input ( ) ) for n in xrange ( 10 ) ] for x in xrange ( 3 ) : v = max ( heights ) print v heights . remove ( v )",
    "label": 0
  },
  {
    "code": "heights = sorted ( [ int ( input ( ) ) for n in xrange ( 10 ) ] ) for idx in range ( - 1 , - 4 , - 1 ) : print heights [ idx ]",
    "label": 0
  },
  {
    "code": "l = sorted ( [ input ( ) for x in xrange ( 10 ) ] , reverse = True ) for h in l [ : 3 ] : print h",
    "label": 0
  },
  {
    "code": "ans = [ ] for i in range ( 0 , 10 ) : ans . append ( int ( input ( ) ) ) ans . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( ans [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) [ print ( i ) for i in h [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "a = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) a . reverse ( ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "import fileinput def main ( ) : numbers = [ ] for line in fileinput . input ( ) : numbers . append ( int ( line ) ) numbers = sorted ( numbers , reverse = True ) for n in numbers [ 0 : 3 ] : print n main ( )",
    "label": 0
  },
  {
    "code": "a = [ 0 , 0 , 0 , 0 ] for t in range ( 10 ) : a [ 3 ] = input ( ) for i in range ( 2 , - 1 , - 1 ) : if ( a [ i ] < a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] for i in range ( 0 , 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "import sys heights = sorted ( [ int ( h ) for h in sys . stdin ] , reverse = True ) print ( heights [ 0 ] ) print ( heights [ 1 ] ) print ( heights [ 2 ] )",
    "label": 0
  },
  {
    "code": "hs = [ ] for i in range ( 10 ) : hs . append ( int ( input ( ) ) ) hs . sort ( reverse = True ) for i in range ( 3 ) : print ( hs [ i ] )",
    "label": 0
  },
  {
    "code": "import sys def top_k_sort ( data , k = 3 , reverse = True ) : data . sort ( reverse = True ) return data [ : k ] def main ( ) : data = [ ] for line in sys . stdin : data . append ( int ( line ) ) for h in top_k_sort ( data ) : print ( h ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "mol = [ ] for i in range ( 10 ) : mol . append ( int ( input ( ) ) ) mol . sort ( key = None , reverse = True ) for i in range ( 3 ) : print ( mol [ i ] )",
    "label": 0
  },
  {
    "code": "for a in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ : 3 ] : print ( a )",
    "label": 0
  },
  {
    "code": "data_set = [ ] for i in range ( 0 , 10 ) : data_set . append ( input ( ) ) top = sorted ( data_set , reverse = True ) for i in range ( 0 , 3 ) : print ( top [ i ] )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for i in sys . stdin : a . append ( int ( i . replace ( \" \\n \" , \" \" ) ) ) a . sort ( reverse = True ) del a [ 3 : ] print ( \" \\n \" . join ( map ( str , a ) ) )",
    "label": 0
  },
  {
    "code": "height_list = [ int ( input ( ) ) for i in range ( 10 ) ] for i in range ( 1 , 4 ) : print ( sorted ( height_list ) [ - i ] )",
    "label": 0
  },
  {
    "code": "mountain = [ ] for i in range ( 10 ) : mountain . append ( int ( input ( ) ) ) mountain . sort ( ) mountain . reverse ( ) for i in range ( 3 ) : print ( mountain [ i ] )",
    "label": 0
  },
  {
    "code": "n = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] for i in range ( 0 , 10 ) : n [ i ] = int ( input ( ) ) mv = 0 ma = 0 for i in range ( 0 , 3 ) : for j in range ( 0 , 10 ) : if mv < n [ j ] : mv = n [ j ] ma = j print ( mv ) n [ ma ] = - 1 mv = 0",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 0 , 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) l = l [ : 3 ] for j in l : print ( j )",
    "label": 0
  },
  {
    "code": "import sys height_li = [ ] for i in range ( 10 ) : height_li . append ( int ( input ( ) ) ) for i in range ( 3 ) : print ( sorted ( height_li , reverse = True ) [ i ] )",
    "label": 0
  },
  {
    "code": "A = sorted ( [ int ( raw_input ( ) ) for _ in xrange ( 10 ) ] ) print A [ 9 ] print A [ 8 ] print A [ 7 ]",
    "label": 0
  },
  {
    "code": "s = [ int ( raw_input ( ) ) for i in range ( 10 ) ] s . sort ( ) for i in range ( 3 ) : print s [ 9 - i ]",
    "label": 0
  },
  {
    "code": "[ print ( x ) for x in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] ]",
    "label": 0
  },
  {
    "code": "[ print ( y ) for y in sorted ( [ int ( input ( ) ) for x in range ( 10 ) ] , reverse = True ) [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "[ print ( i ) for i in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] ]",
    "label": 0
  },
  {
    "code": "[ print ( i ) for i in sorted ( [ input ( ) for j in range ( 10 ) ] , key = int , reverse = True ) [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "hill = [ ] while True : try : hill . append ( int ( input ( ) ) ) except : break for i in range ( 1 , len ( hill ) ) : key = hill [ i ] j = i - 1 while j >= 0 and hill [ j ] < key : hill [ j + 1 ] = hill [ j ] j -= 1 hill [ j + 1 ] = key for i in range ( 3 ) : print ( hill [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for _ in range ( 10 ) : heights . append ( int ( input ( ) ) ) heights . sort ( ) print ( heights [ 9 ] ) print ( heights [ 8 ] ) print ( heights [ 7 ] )",
    "label": 0
  },
  {
    "code": "[ print ( e ) for e in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] ]",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( ) for i in range ( 1 , 4 ) : print ( a [ - i ] )",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for _ in range ( 10 ) ] [ print ( x ) for x in sorted ( l , reverse = True ) [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for i in range ( 10 ) ] for i in sorted ( mountains ) [ 7 : 10 ] [ : : - 1 ] : print ( i )",
    "label": 0
  },
  {
    "code": "temp = [ ] for i in range ( 10 ) : N = input ( ) temp . append ( N ) temp . sort ( ) print temp [ - 1 ] print temp [ - 2 ] print temp [ - 3 ]",
    "label": 0
  },
  {
    "code": "High = [ ] for i in range ( 10 ) : High . append ( int ( input ( ) ) ) for i in range ( 3 ) : print ( max ( High ) ) High . remove ( max ( High ) )",
    "label": 0
  },
  {
    "code": "values = [ ] for i in range ( 10 ) : values . append ( int ( input ( ) ) ) top3 = [ ] for i in range ( 3 ) : Max = max ( values ) top3 . append ( Max ) values . remove ( Max ) for x in top3 : print ( x )",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : mountains = [ int ( input ( ) ) for _ in range ( 10 ) ] mountains . sort ( reverse = True ) print ( ' \\n \\n ' . format ( mountains [ 0 ] , mountains [ 1 ] , mountains [ 2 ] ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a1_list = [ int ( i ) for i in a ] a1_list . sort ( ) for i in range ( 3 ) : print ( a1_list [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) print ( l [ 0 ] ) print ( l [ 1 ] ) print ( l [ 2 ] )",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for i in range ( 10 ) ] m . sort ( reverse = True ) for i in range ( 3 ) : print ( m [ i ] )",
    "label": 0
  },
  {
    "code": "N = 10 h = [ ] for n in range ( N ) : h . append ( int ( input ( ) ) ) h = sorted ( h , reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "import sys heights = [ ] for height in sys . stdin : heights . append ( int ( height . rstrip ( ) ) ) heights . sort ( ) heights . reverse ( ) for i in range ( 3 ) : print heights [ i ]",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] while 1 : try : a . append ( int ( input ( ) ) ) except : break a . sort ( reverse = 1 ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "import sys data = [ ] count = 0 for i in sys . stdin : data . append ( int ( i ) ) count = count + 1 if count == 10 : break N = len ( data ) m = 100 for i in range ( m ) : for n in range ( N - 1 ) : a = data [ n ] b = data [ n + 1 ] if a <= b : data [ n ] = b data [ n + 1 ] = a else : pass for i in range ( 3 ) : print ( data [ i ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : arr = [ ] for i in range ( 0 , 10 ) : arr . append ( input ( ) ) arr . sort ( ) arr . reverse ( ) for i in range ( 0 , 3 ) : print arr [ i ] if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for i in range ( 10 ) : mountains . append ( int ( input ( ) ) ) mountains . sort ( reverse = True ) for i in range ( 3 ) : print ( mountains [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( raw_input ( ) ) for _ in range ( 10 ) ] b = sorted ( a , reverse = True ) for c in b [ 0 : 3 ] : print c",
    "label": 0
  },
  {
    "code": "[ print ( i ) for i in ( sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : 6 : - 1 ] ) ]",
    "label": 0
  },
  {
    "code": "def calc_mount_1 ( height_list ) : for i in range ( len ( height_list ) ) : for i in range ( len ( height_list ) - 1 ) : if height_list [ i + 1 ] < height_list [ i ] : tmp = height_list [ i + 1 ] height_list [ i + 1 ] = height_list [ i ] height_list [ i ] = tmp else : continue return height_list N = 10 l = [ input ( ) for i in range ( N ) ] answer_array = calc_mount_1 ( l ) print \" %d \" % answer_array [ - 1 ] print \" %d \" % answer_array [ - 2 ] print \" %d \" % answer_array [ - 3 ]",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for i in range ( 10 ) ] mountains . sort ( reverse = True ) for i in range ( 3 ) : print ( mountains [ i ] )",
    "label": 0
  },
  {
    "code": "heights = list ( ) for i in range ( 10 ) : heights . append ( int ( input ( ) ) ) for height in list ( reversed ( sorted ( heights ) ) ) [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "import fileinput mountains = [ ] for cnt in range ( 10 ) : a = input ( ) mountains . append ( int ( a ) ) mountains . sort ( ) print ( mountains [ 9 ] ) print ( mountains [ 8 ] ) print ( mountains [ 7 ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : mountains = [ ] for i in range ( 10 ) : mountains . append ( int ( input ( ) ) ) mountains = sorted ( mountains , reverse = True ) for i in range ( 3 ) : print ( mountains [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "import sys m = [ int ( l ) for l in sys . stdin ] m . sort ( ) print ( m [ - 1 ] ) print ( m [ - 2 ] ) print ( m [ - 3 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) max1 = max ( h ) h . remove ( max1 ) max2 = max ( h ) h . remove ( max2 ) max3 = max ( h ) print ( max1 ) print ( max2 ) print ( max3 )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] , a [ 8 ] , a [ 7 ] , sep = ' \\n ' ) ;",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 0 , 10 ) : m . append ( int ( input ( ) ) ) m . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( m [ i ] )",
    "label": 0
  },
  {
    "code": "for h in sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) [ : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "[ print ( h ) for h in sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "height = [ 0 for i in range ( 10 ) ] sort_height = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : height [ i ] = int ( input ( ) ) for i in range ( 10 ) : for j in range ( 10 ) : if height [ i ] >= sort_height [ j ] : for k in range ( 9 , j , - 1 ) : sort_height [ k ] = sort_height [ k - 1 ] sort_height [ j ] = height [ i ] break for i in range ( 3 ) : print ( sort_height [ i ] )",
    "label": 0
  },
  {
    "code": "import sys a = list ( map ( int , sys . stdin . readlines ( ) ) ) for i in range ( 10 ) : for j in range ( i + 1 , 10 ) : if a [ i ] < a [ j ] : a [ i ] , a [ j ] = a [ j ] , a [ i ] for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( reverse = True ) for j in range ( 3 ) : print ( list [ j ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for i in range ( 10 ) : heights . append ( int ( input ( ) ) ) for i in range ( 10 ) : for j in range ( i , 10 ) : if ( heights [ j ] > heights [ i ] ) : w = heights [ i ] heights [ i ] = heights [ j ] heights [ j ] = w for i in range ( 3 ) : print ( heights [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for i in range ( 10 ) : heights . append ( int ( input ( ) ) ) for i in range ( 10 ) : for j in range ( i , 10 ) : if ( heights [ j ] > heights [ i ] ) : w = heights [ i ] heights [ i ] = heights [ j ] heights [ j ] = w print ( heights [ 0 ] ) print ( heights [ 1 ] ) print ( heights [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for j in range ( 3 ) : print ( a [ - ( j + 1 ) ] )",
    "label": 0
  },
  {
    "code": "array = [ int ( input ( ) ) for i in range ( 10 ) ] array . sort ( ) num = len ( array ) for i in range ( num - 1 , num - 4 , - 1 ) : print ( array [ i ] )",
    "label": 0
  },
  {
    "code": "import sys if __name__ == ' __main__ ' : nums = [ ] for line in sys . stdin : if line == \" \\n \" : break else : nums . append ( int ( line ) ) for n in sorted ( nums , reverse = True ) [ : 3 ] : print ( n )",
    "label": 0
  },
  {
    "code": "mountains = [ ] [ mountains . append ( int ( input ( ) ) ) for i in range ( 10 ) ] mountains = sorted ( mountains ) [ : : - 1 ] for j in range ( 3 ) : print ( mountains [ j ] )",
    "label": 0
  },
  {
    "code": "def quicksort ( array ) : if len ( array ) < 2 : return array else : pivot = array [ 0 ] less = [ i for i in array [ 1 : ] if i <= pivot ] greater = [ i for i in array [ 1 : ] if i > pivot ] return quicksort ( less ) + [ pivot ] + quicksort ( greater ) array = [ ] for _ in range ( 10 ) : array . append ( int ( input ( ) ) ) sorted_array = quicksort ( array ) for i in range ( 3 ) : print ( sorted_array [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "array = [ ] for _ in range ( 10 ) : array . append ( int ( input ( ) ) ) sorted_array = sorted ( array , reverse = True ) for i in range ( 3 ) : print ( sorted_array [ i ] )",
    "label": 0
  },
  {
    "code": "array = [ int ( input ( ) ) for i in range ( 10 ) ] array . sort ( ) for i in range ( 9 , 6 , - 1 ) : print ( array [ i ] )",
    "label": 0
  },
  {
    "code": "values = [ ] for i in range ( 10 ) : v = int ( input ( ) ) values . append ( v ) values . sort ( reverse = True ) for i in range ( 3 ) : print ( values [ i ] )",
    "label": 0
  },
  {
    "code": "import sys def qsort ( a ) : if not isinstance ( a , list ) : raise TypeError ( ' \\' \\' ' ) if len ( a ) <= 1 : return a p = a [ 0 ] for i in range ( 1 , len ( a ) ) : if a [ 0 ] != a [ i ] : if a [ 0 ] < a [ i ] : p = a [ i ] break elif i == len ( a ) - 1 : return a while True : i = 0 j = len ( a ) for i in range ( 0 , len ( a ) ) : if p <= a [ i ] : break for j in range ( len ( a ) - 1 , - 1 , - 1 ) : if a [ j ] < p : break if i >= j : a1 = qsort ( a [ : i ] ) if i < len ( a ) : a2 = qsort ( a [ i : ] ) a1 . extend ( a2 ) return a1 else : tmp = a [ i ] a [ i ] = a [ j ] a [ j ] = tmp if __name__ == ' __main__ ' : m_list = [ ] for i in range ( 0 , 10 ) : m_list . append ( int ( sys . stdin . readline ( ) ) ) s = qsort ( m_list ) s . reverse ( ) for i in range ( 0 , 3 ) : print ( ' {} ' . format ( s [ i ] ) )",
    "label": 0
  },
  {
    "code": "inp = [ int ( input ( ) ) for i in range ( 10 ) ] m1 , m2 , m3 = 0 , 0 , 0 for h in inp : if ( h > m1 ) : m3 = m2 m2 = m1 m1 = h elif ( h > m2 ) : m3 = m2 m2 = h elif ( h > m3 ) : m3 = h print ( m1 ) print ( m2 ) print ( m3 )",
    "label": 0
  },
  {
    "code": "A = [ ] for i in range ( 10 ) : A . append ( int ( input ( ) ) ) A . sort ( ) A . reverse ( ) for i in range ( 3 ) : print ( A [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for _ in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) slist = sorted ( list ) for i in range ( 3 ) : print ( slist [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "rank = [ 0 ] * 4 for _ in range ( 10 ) : rank [ 0 ] = int ( input ( ) ) rank . sort ( ) for r in reversed ( rank [ 1 : ] ) : print ( r )",
    "label": 0
  },
  {
    "code": "mt_list = [ ] for i in range ( 10 ) : mt_list . append ( int ( input ( ) ) ) mt_list . sort ( reverse = True ) for i in range ( 3 ) : print ( mt_list [ i ] )",
    "label": 0
  },
  {
    "code": "first = 0 second = 0 third = 0 for i in range ( 10 ) : mountain = int ( input ( ) ) if mountain > first : third = second second = first first = mountain elif mountain > second : third = second second = mountain elif mountain > third : third = mountain print ( first ) print ( second ) print ( third )",
    "label": 0
  },
  {
    "code": "a = [ input ( ) for i in range ( 10 ) ] a . sort ( reverse = True ) for i in range ( 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "mountain = [ int ( input ( ) ) for _ in range ( 10 ) ] mountain . sort ( ) for _ in - 1 , - 2 , - 3 : print ( mountain [ _ ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : a = int ( input ( ) ) list . append ( a ) list . sort ( ) list . reverse ( ) for i in range ( 3 ) : print ( list [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : tmp = int ( input ( ) ) a . append ( tmp ) b = sorted ( a , reverse = True ) print ( b [ 0 ] ) print ( b [ 1 ] ) print ( b [ 2 ] )",
    "label": 0
  },
  {
    "code": "def getint ( ) : return int ( input ( ) . rstrip ( ) ) def main ( ) : ls = [ ] num_of_mount = 10 num_of_top = 3 for i in range ( num_of_mount ) : ls . append ( getint ( ) ) ls . sort ( reverse = True ) for i in range ( num_of_top ) : print ( ls [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "arr = [ ] for i in range ( 10 ) : arr . append ( int ( input ( ) ) ) arr . sort ( ) arr . reverse ( ) for a in range ( 3 ) : print ( arr [ a ] )",
    "label": 0
  },
  {
    "code": "mt = list ( ) n = 10 for i in range ( n ) : mt . append ( int ( input ( ) ) ) mt . sort ( reverse = True ) for j in range ( 3 ) : print ( mt [ j ] )",
    "label": 0
  },
  {
    "code": "f , s , t = 3 , 2 , 1 for i in range ( 10 ) : z = int ( input ( ) ) if z >= f : f , s , t = z , f , s ; elif z >= s : s , t = z , s ; elif z >= t : t = z print ( f ) ; print ( s ) ; print ( t )",
    "label": 0
  },
  {
    "code": "import sys def solve ( ) : a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) print ( * a [ : 3 ] , sep = ' \\n ' ) if __name__ == ' __main__ ' : solve ( )",
    "label": 0
  },
  {
    "code": "def main ( ) : l = [ ] for _ in range ( 10 ) : l . append ( int ( input ( ) ) ) l = sorted ( l , reverse = True ) for i in range ( 3 ) : print ( l [ i ] ) return None if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "n = list ( ) for var in range ( 0 , 10 ) : n . append ( int ( input ( ) ) ) n . sort ( reverse = True ) for i in n [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "main = ( lambda a : [ print ( i ) for i in a [ : 3 ] ] ) ( sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : : - 1 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a . sort ( ) a . reverse ( ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "l = [ int ( raw_input ( ) ) for i in range ( 10 ) ] l . sort ( ) for i in range ( 3 ) : print l [ 9 - i ]",
    "label": 0
  },
  {
    "code": "ranking = [ ] while True : try : height = int ( input ( ) ) ranking . append ( height ) except : break sortedRanking = sorted ( ranking , reverse = True ) print ( sortedRanking [ 0 ] ) print ( sortedRanking [ 1 ] ) print ( sortedRanking [ 2 ] )",
    "label": 0
  },
  {
    "code": "import sys l = [ ] for i in range ( 10 ) : l . append ( int ( sys . stdin . readline ( ) . rstrip ( ) ) ) for h in sorted ( l , reverse = True ) [ : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( \" \\n \" . join ( list ( map ( str , a [ 9 : 6 : - 1 ] ) ) ) )",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a = sorted ( a , key = int , reverse = True ) for i in a [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "hillheight = [ ] for i in range ( 0 , 10 ) : hillheight . append ( int ( raw_input ( ) ) ) hillheight . sort ( ) for i in range ( 0 , 3 ) : print ( hillheight [ - 1 - i ] )",
    "label": 0
  },
  {
    "code": "list = list ( ) for i in range ( 10 ) : t = input ( ) list . append ( int ( t ) ) list . sort ( reverse = True ) for i in range ( 3 ) : print ( list [ i ] )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for i in range ( 10 ) : mountains . append ( int ( input ( ) ) ) outputCount = 3 for height in list ( reversed ( sorted ( mountains ) ) ) : print ( height ) outputCount -= 1 if outputCount == 0 : break",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 10 ) : data . append ( int ( input ( ) ) ) data = sorted ( data ) print ( data [ - 1 ] ) print ( data [ - 2 ] ) print ( data [ - 3 ] )",
    "label": 0
  },
  {
    "code": "m = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : m [ i ] = int ( input ( ) ) m . sort ( ) print ( m [ 9 ] ) print ( m [ 8 ] ) print ( m [ 7 ] )",
    "label": 0
  },
  {
    "code": "m1 = 0 ; m2 = 0 ; m3 = 0 for i in range ( 1 , 11 ) : m = int ( input ( ) ) if m >= m1 : m3 = m2 ; m2 = m1 ; m1 = m elif m2 <= m < m1 : m3 = m2 ; m2 = m elif m3 <= m < m2 : m3 = m print ( m1 ) print ( m2 ) print ( m3 )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "s = [ ] for i in range ( 10 ) : s . append ( int ( input ( ) ) ) s . sort ( ) for i in range ( 3 ) : print ( s [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "lis = list ( ) for a in range ( 1 , 11 ) : num = int ( input ( ) ) lis . append ( num ) lis . sort ( ) for va in range ( 9 , 6 , - 1 ) : print ( lis [ va ] )",
    "label": 0
  },
  {
    "code": "lists = [ ] for i in range ( 10 ) : a = int ( input ( ) ) lists . append ( a ) f = sorted ( lists , reverse = True ) for i in range ( 3 ) : print ( f [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 0 , 10 ) : a . append ( input ( ) ) inp = list ( map ( int , a ) ) INP = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] for i in range ( 0 , 10 ) : for j in range ( i + 1 , 10 ) : if inp [ i ] < inp [ j ] : INP [ j ] + = 1 elif inp [ i ] > inp [ j ] : INP [ i ] + = 1 else : INP [ i ] + = 1 INP [ j ] + = 1 z = 0 for i in range ( 9 , - 1 , - 1 ) : if z >= 3 : break for j in range ( 0 , 10 ) : if i == INP [ j ] : print ( inp [ j ] ) z += 1 if z >= 3 : break",
    "label": 0
  },
  {
    "code": "mount = [ int ( input ( ) ) for i in range ( 10 ) ] a = max ( mount ) mount . remove ( a ) b = max ( mount ) mount . remove ( b ) print ( a ) print ( b ) print ( max ( mount ) )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) for i , iv in enumerate ( a ) : print ( iv ) if i >= 2 : break",
    "label": 0
  },
  {
    "code": "heightOfMountains = [ ] for i in range ( 1 , 11 ) : heightOfMountains . append ( int ( input ( ) ) ) heightOfMountains . sort ( ) for i in range ( 1 , 4 ) : print ( heightOfMountains [ - i ] )",
    "label": 0
  },
  {
    "code": "def ListofTopHills ( ) : h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h = sorted ( h ) for i in range ( 3 ) : print ( h [ 9 - i ] ) ListofTopHills ( )",
    "label": 0
  },
  {
    "code": "def get_input ( ) : while True : try : yield ' ' . join ( raw_input ( ) ) except EOFError : break if __name__ == ' __main__ ' : l = map ( int , list ( get_input ( ) ) ) for elem in sorted ( l ) [ : - 4 : - 1 ] : print elem",
    "label": 0
  },
  {
    "code": "import sys heights = sorted ( [ int ( h ) for h in sys . stdin ] , reverse = True ) print ( heights [ 0 ] ) print ( heights [ 1 ] ) print ( heights [ 2 ] )",
    "label": 0
  },
  {
    "code": "ans = [ ] for i in range ( 0 , 10 ) : ans . append ( int ( input ( ) ) ) ans . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( ans [ i ] )",
    "label": 0
  },
  {
    "code": "mountain = [ ] for s in range ( 0 , 10 ) : mountain . append ( int ( input ( ) ) ) mountain . sort ( reverse = True ) for s in range ( 0 , 3 ) : print ( mountain [ s ] )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for _ in [ 0 ] * 10 ] ) [ : 6 : - 1 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "m_h = [ int ( input ( ) ) for i in range ( 10 ) ] m_h . sort ( reverse = True ) print ( m_h [ 0 ] ) print ( m_h [ 1 ] ) print ( m_h [ 2 ] )",
    "label": 0
  },
  {
    "code": "m_h = [ int ( input ( ) ) for i in range ( 10 ) ] m_h . sort ( reverse = True ) print ( m_h [ 0 ] ) print ( m_h [ 1 ] ) print ( m_h [ 2 ] )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for line in sys . stdin : a . append ( int ( line ) ) a . sort ( ) a . reverse ( ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "height = [ ] inp = \" \" for i in range ( 0 , 10 ) : inp = input ( ) height . append ( int ( inp ) ) height . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( str ( height [ i ] ) )",
    "label": 0
  },
  {
    "code": "l = [ ] a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) ) d = int ( input ( ) ) e = int ( input ( ) ) f = int ( input ( ) ) g = int ( input ( ) ) h = int ( input ( ) ) i = int ( input ( ) ) j = int ( input ( ) ) l . append ( a ) l . append ( b ) l . append ( c ) l . append ( d ) l . append ( e ) l . append ( f ) l . append ( g ) l . append ( h ) l . append ( i ) l . append ( j ) l . sort ( ) print ( l [ - 1 ] ) print ( l [ - 2 ] ) print ( l [ - 3 ] )",
    "label": 0
  },
  {
    "code": "ls = [ ] for i in range ( 0 , 10 ) : ls . append ( int ( input ( ) ) ) ls . sort ( ) print ( ls [ 9 ] ) print ( ls [ 8 ] ) print ( ls [ 7 ] )",
    "label": 0
  },
  {
    "code": "mounts = [ int ( input ( ) ) for i in range ( 1 , 11 ) ] mounts . sort ( ) print ( mounts . pop ( ) ) print ( mounts . pop ( ) ) print ( mounts . pop ( ) )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( reverse = True ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 1 , 11 ) : h = int ( input ( ) ) data . append ( h ) for i in sorted ( data ) [ : : - 1 ] [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "u = [ ] for i in range ( 10 ) : u . append ( int ( input ( ) ) ) u . sort ( reverse = True ) for i in range ( 3 ) : print ( u [ i ] )",
    "label": 0
  },
  {
    "code": "height = [ int ( input ( ) ) for i in range ( 10 ) ] sort = sorted ( height , reverse = True ) for i in range ( 3 ) : print ( sort [ i ] )",
    "label": 0
  },
  {
    "code": "spam = [ ] for i in range ( 10 ) : spam . append ( int ( input ( ) ) ) spam . sort ( ) print ( spam [ - 1 ] ) print ( spam [ - 2 ] ) print ( spam [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] ; for i in range ( 0 , 10 ) : a . append ( int ( input ( ) ) ) ; a . sort ( reverse = True ) ; for i in range ( 0 , 3 ) : print ( a [ i ] ) ;",
    "label": 0
  },
  {
    "code": "lists = [ ] for x in range ( 0 , 10 ) : num = int ( input ( ) ) lists . append ( num ) results = sorted ( lists , reverse = True ) print ( results [ 0 ] ) print ( results [ 1 ] ) print ( results [ 2 ] )",
    "label": 0
  },
  {
    "code": "line = [ 0 ] * 10 for i in range ( 0 , 10 ) : line [ i ] = int ( input ( ) ) line . sort ( reverse = True , key = int ) for i in range ( 0 , 3 ) : print ( line [ i ] )",
    "label": 0
  },
  {
    "code": "rank = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) print ( ' \\n ' . join ( map ( str , rank [ : 3 ] ) ) )",
    "label": 0
  },
  {
    "code": "N = 10 A = [ int ( input ( ) ) for i in range ( N ) ] A . sort ( reverse = True ) for i in range ( 3 ) : print ( A [ i ] )",
    "label": 0
  },
  {
    "code": "mylist = [ ] for i in range ( 10 ) : mylist . append ( int ( input ( ) ) ) mylist . sort ( reverse = True ) print ( mylist [ 0 ] ) print ( mylist [ 1 ] ) print ( mylist [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ( int ) ( input ( ) ) for i in range ( 10 ) ] for i in range ( 3 ) : print ( max ( a ) ) a . remove ( max ( a ) )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) for j in range ( 3 ) : print max ( lst ) lst . remove ( max ( lst ) )",
    "label": 0
  },
  {
    "code": "def main ( ) : m = [ ] for i in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( reverse = True ) for i in range ( 3 ) : print ( m [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "values = [ ] for n in range ( 10 ) : values . append ( int ( input ( ) ) ) values . sort ( reverse = True ) for v in values [ : 3 ] : print ( v )",
    "label": 0
  },
  {
    "code": "def main ( ) : m = [ ] for _ in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( reverse = True ) for i in range ( 3 ) : print ( m [ i ] ) if __name__ == \" __main__ \" : main ( )",
    "label": 0
  },
  {
    "code": "for h in sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "mountain = [ ] for _ in range ( 10 ) : mountain . append ( int ( input ( ) ) ) mountain . sort ( ) mountain . reverse ( ) print ( mountain [ 0 ] ) print ( mountain [ 1 ] ) print ( mountain [ 2 ] )",
    "label": 0
  },
  {
    "code": "print ( \" \\n \" . join ( map ( str , sorted ( [ int ( input ( ) ) for _ in [ 0 ] * 10 ] ) [ : - 4 : - 1 ] ) ) )",
    "label": 0
  },
  {
    "code": "import sys , math , os PYDEV = os . environ . get ( ' PYDEV ' ) if PYDEV == \" True \" : sys . stdin = open ( \" sample-input2.txt \" , \" rt \" ) for h in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "import sys n = [ int ( input ( ) ) for i in range ( 1 , 11 ) ] n . sort ( ) n . reverse ( ) for j in range ( 0 , 3 ) : print ( n [ j ] )",
    "label": 0
  },
  {
    "code": "import sys def qsort ( seq ) : if seq == [ ] : return seq return qsort ( [ x for x in seq [ 1 : ] if x < seq [ 0 ] ] ) + seq [ 0 : 1 ] + qsort ( [ x for x in seq [ 1 : ] if x >= seq [ 0 ] ] ) data_set = [ ] for i in range ( 0 , 10 ) : data_set . append ( int ( input ( ) ) ) rank = qsort ( data_set ) for i in range ( 0 , 3 ) : print ( rank . pop ( - 1 ) )",
    "label": 0
  },
  {
    "code": "if __name__ == \" __main__ \" : dataset = [ ] for i in range ( 10 ) : a = int ( input ( ) ) dataset . append ( a ) for j in range ( 3 ) : print ( max ( dataset ) ) dataset . remove ( max ( dataset ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a = sorted ( a ) [ : : - 1 ] for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "from sys import stdin ns = [ int ( n ) for n in stdin ] ns . sort ( reverse = True ) for i in range ( 3 ) : print ( ns [ i ] )",
    "label": 0
  },
  {
    "code": "from sys import stdin for x in sorted ( [ int ( l ) for l in stdin ] , reverse = True ) [ 0 : 3 ] : print ( x )",
    "label": 0
  },
  {
    "code": "mountains_high = [ ] for i in range ( 10 ) : mountains_high . append ( int ( input ( ) ) ) mountains_high_copy = mountains_high . copy ( ) for i in range ( 9 ) : for j in range ( 9 ) : if mountains_high_copy [ j ] > mountains_high_copy [ j + 1 ] : num = mountains_high_copy [ j ] mountains_high_copy [ j ] = mountains_high_copy [ j + 1 ] mountains_high_copy [ j + 1 ] = num for i in range ( 3 ) : print ( mountains_high_copy [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "num = [ 0 , 0 , 0 ] for a in range ( 10 ) : x = int ( input ( ) . rstrip ( ) ) if x > num [ 0 ] : num [ 2 ] = num [ 1 ] num [ 1 ] = num [ 0 ] num [ 0 ] = x continue elif x > num [ 1 ] : num [ 2 ] = num [ 1 ] num [ 1 ] = x continue elif x > num [ 2 ] : num [ 2 ] = x for a in range ( 3 ) : print ( num [ a ] )",
    "label": 0
  },
  {
    "code": "x = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 10 ) : data . append ( int ( input ( ) ) ) data . sort ( reverse = True ) for i in range ( 3 ) : print ( data [ i ] )",
    "label": 0
  },
  {
    "code": "mountlist = [ ] for _ in range ( 10 ) : height = int ( input ( ) ) mountlist . append ( height ) mountlist . sort ( ) mountlist . reverse ( ) [ print ( x ) for x in mountlist [ : 3 ] ]",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for i in range ( 10 ) ] mountains . sort ( reverse = True ) for i in range ( 3 ) : print ( mountains [ i ] )",
    "label": 0
  },
  {
    "code": "import sys line = sys . stdin . readlines ( ) top = [ 0 , 0 , 0 ] for i in range ( len ( line ) ) : line [ i ] = int ( line [ i ] . rstrip ( \" \\n \" ) ) if top [ 0 ] < line [ i ] : top [ 2 ] = top [ 1 ] top [ 1 ] = top [ 0 ] top [ 0 ] = line [ i ] elif top [ 1 ] < line [ i ] : top [ 2 ] = top [ 1 ] top [ 1 ] = line [ i ] elif top [ 2 ] < line [ i ] : top [ 2 ] = line [ i ] for i in range ( 3 ) : print ( top [ i ] )",
    "label": 0
  },
  {
    "code": "mt = list ( ) for i in range ( 10 ) : mt . append ( int ( raw_input ( ) ) ) mt = sorted ( mt , reverse = True ) for i in range ( 3 ) : print mt [ i ]",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : inp = input ( ) l . append ( int ( inp ) ) l . sort ( ) l . reverse ( ) for i in range ( 3 ) : print ( l [ i ] )",
    "label": 0
  },
  {
    "code": "import sys data = [ ] for d in sys . stdin : data . append ( int ( d ) ) data . sort ( reverse = True ) for i in xrange ( 3 ) : print data [ i ]",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : N = 10 l = list ( ) for i in range ( N ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) for x in l [ : 3 ] : print ( x ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "result = [ 0 , 0 , 0 ] for i in range ( 10 ) : inp = int ( raw_input ( ) ) if result [ 2 ] >= inp : continue elif result [ 1 ] >= inp > result [ 2 ] : result [ 2 ] = inp elif result [ 0 ] >= inp > result [ 1 ] : result [ 2 ] = result [ 1 ] result [ 1 ] = inp else : result [ 2 ] = result [ 1 ] result [ 1 ] = result [ 0 ] result [ 0 ] = inp for i in range ( 3 ) : print result [ i ]",
    "label": 0
  },
  {
    "code": "import sys data = sys . stdin . readline ( ) l = list ( ) while data : l . append ( int ( data ) ) data = sys . stdin . readline ( ) for x in sorted ( l , reverse = True ) [ : 3 ] : print ( x )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "import codecs import sys sys . stdout = codecs . getwriter ( \" shift_jis \" ) ( sys . stdout ) sys . stdin = codecs . getreader ( \" shift_jis \" ) ( sys . stdin ) a = [ ] for i in range ( 10 ) : n = input ( ) a . append ( n ) a . sort ( reverse = True ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for i in range ( 1 , 4 ) : print ( a [ - i ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : mountains_list = [ int ( input ( ) ) for n in range ( 10 ) ] for i in range ( 3 ) : print ( list ( reversed ( sorted ( mountains_list ) ) ) [ i ] ) main ( )",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : height = [ ] for _ in range ( 0 , 10 ) : height . append ( ( int ) ( input ( ) ) ) height . sort ( reverse = True ) print ( height [ 0 ] ) print ( height [ 1 ] ) print ( height [ 2 ] )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for line in sys . stdin : a . append ( int ( line ) ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "l = [ ] while True : try : x = int ( input ( ) ) l . append ( x ) except Exception : break l . sort ( reverse = True ) print ( \" \\n \" . join ( [ str ( l [ 0 ] ) , str ( l [ 1 ] ) , str ( l [ 2 ] ) ] ) )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for i in range ( 10 ) : mountains . append ( int ( input ( ) ) ) mountains . sort ( reverse = True ) for m in mountains [ 0 : 3 ] : print ( m )",
    "label": 0
  },
  {
    "code": "m = [ ] for line in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( reverse = True ) for h in m [ 0 : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "import sys def solve ( ) : m = [ ] for line in sys . stdin : m . append ( int ( line ) ) m . sort ( reverse = True ) for h in m [ 0 : 3 ] : print ( h ) solve ( )",
    "label": 0
  },
  {
    "code": "import sys import operator l = [ ] for i in xrange ( 10 ) : l . append ( int ( sys . stdin . readline ( ) ) ) first = max ( l ) print ( first ) del l [ l . index ( first ) ] first = max ( l ) print ( first ) del l [ l . index ( first ) ] first = max ( l ) print ( first ) del l [ l . index ( first ) ]",
    "label": 0
  },
  {
    "code": "n = [ ] for i in range ( 0 , 10 ) : n . append ( int ( raw_input ( ) ) ) for i in sorted ( n , reverse = True ) [ : 3 ] : print i",
    "label": 0
  },
  {
    "code": "mountain_hills = [ int ( input ( ) ) for j in range ( 10 ) ] mountain_hills . sort ( ) mountain_hills . reverse ( ) mountain_hills = mountain_hills [ : 3 ] for i in range ( 3 ) : print ( mountain_hills [ i ] )",
    "label": 0
  },
  {
    "code": "M = [ ] for i in range ( 10 ) : M . append ( int ( input ( ) ) ) M . sort ( ) M . reverse ( ) for j in range ( 3 ) : print ( M [ j ] )",
    "label": 0
  },
  {
    "code": "if __name__ == \" __main__ \" : hight_of_mount = [ 0 ] * 10 for i in range ( 0 , 10 ) : hight_of_mount [ i ] = int ( input ( ) ) hight_of_mount . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( hight_of_mount [ i ] ) exit ( 0 )",
    "label": 0
  },
  {
    "code": "def main ( ) : moutain = [ ] for i in range ( 0 , 10 ) : n = int ( input ( ) ) moutain . append ( n ) temp = sorted ( moutain , reverse = True ) for i in range ( 0 , 3 ) : print ( temp [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "rank = [ 0 , 0 , 0 ] for i in range ( 10 ) : t = input ( ) if t > rank [ 0 ] : rank . insert ( 0 , t ) rank . pop ( ) elif t > rank [ 1 ] : rank . insert ( 1 , t ) rank . pop ( ) elif t > rank [ 2 ] : rank . insert ( 2 , t ) rank . pop ( ) print \" \\n \\n \" . format ( rank [ 0 ] , rank [ 1 ] , rank [ 2 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for x in range ( 0 , 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) h . reverse ( ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "hills = [ int ( input ( ) ) for i in range ( 10 ) ] hills . sort ( ) print ( hills [ - 1 ] ) print ( hills [ - 2 ] ) print ( hills [ - 3 ] )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : - 4 : - 1 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "lst = [ ] for n in range ( 10 ) : lst . append ( int ( input ( ) ) ) res = sorted ( lst , reverse = True ) for i in range ( 3 ) : print ( res [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) counter = 3 for u in list ( reversed ( sorted ( a ) ) ) : print ( u ) counter -= 1 if counter == 0 : break",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) c = 3 for u in list ( reversed ( sorted ( a ) ) ) : print ( u ) c -= 1 if c == 0 : break",
    "label": 0
  },
  {
    "code": "list = [ ] while True : try : n = int ( raw_input ( ) ) list . append ( n ) except : break list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 0 , 10 ) : n = int ( raw_input ( ) ) list . append ( n ) list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "def main ( ) : Array = [ ] for i in range ( 10 ) : Array . append ( int ( input ( ) ) ) Array . sort ( ) Array . reverse ( ) count = 0 for value in Array : if count == 3 : break print ( value ) count += 1 if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for i in range ( 10 ) ] l . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( l [ i ] )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "mountains = [ ] for i in range ( 0 , 10 ) : input_line = input ( ) mountains . append ( int ( input_line ) ) sorted_mountains = sorted ( mountains , reverse = True ) for i in range ( 0 , 3 ) : print ( sorted_mountains [ i ] )",
    "label": 0
  },
  {
    "code": "import sys a = \" \" l = [ ] for input in sys . stdin : a += input for i in a . split ( ) : l . append ( int ( i ) ) l = sorted ( l ) for i in range ( len ( l ) - 1 , len ( l ) - 4 , - 1 ) : print int ( l [ i ] )",
    "label": 0
  },
  {
    "code": "try : meters = [ ] while True : meters . append ( int ( input ( ) . strip ( ) ) ) except EOFError : meters . sort ( reverse = True ) for i in range ( 3 ) : print ( meters [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for u in range ( 10 ) : a . append ( int ( input ( ) ) ) for i in range ( 3 ) : print ( max ( a ) ) a . remove ( max ( a ) )",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) print ( h [ 9 ] , h [ 8 ] , h [ 7 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( int ( input ( ) ) for _ in range ( 10 ) ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( int ( input ( ) ) for _ in [ 0 ] * 10 ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "import sys e = sys . stdin . readlines ( ) e = [ int ( i ) for i in e ] for i in range ( 3 ) : m = max ( e ) e . remove ( m ) print ( m )",
    "label": 0
  },
  {
    "code": "import sys e = [ int ( i ) for i in sys . stdin . readlines ( ) ] for i in range ( 3 ) : m = max ( e ) e . remove ( m ) print ( m )",
    "label": 0
  },
  {
    "code": "import sys e = [ int ( i ) for i in sys . stdin . readlines ( ) ] for i in range ( 3 ) : m = max ( e ) e . remove ( m ) print ( m )",
    "label": 0
  },
  {
    "code": "def main ( ) : mount = [ ] for i in range ( 10 ) : mount . append ( int ( input ( ) ) ) mount . sort ( reverse = True ) for i in range ( 3 ) : print ( mount [ i ] ) if __name__ == \" __main__ \" : main ( )",
    "label": 0
  },
  {
    "code": "from sys import stdin highest = [ 0 ] * 3 for line in stdin : highest . append ( int ( line ) ) highest . sort ( reverse = True ) highest = highest [ : - 1 ] print ( ' \\n ' . join ( map ( str , highest ) ) )",
    "label": 0
  },
  {
    "code": "mountains = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) for i in range ( 3 ) : print ( mountains [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for count in range ( 10 ) : list . append ( input ( ) ) list = sorted ( list , key = int ) a = 9 for count in range ( 3 ) : print ( list [ a ] ) a -= 1",
    "label": 0
  },
  {
    "code": "hill_list = [ ] for i in range ( 10 ) : hill_list . append ( int ( input ( ) ) ) for i in sorted ( hill_list , reverse = True ) [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "import sys import functools import itertools import math x = sorted ( list ( map ( int , sys . stdin . readlines ( ) ) ) ) [ print ( n ) for n in x [ : - 4 : - 1 ] ]",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( ) lst . reverse ( ) for i in range ( 3 ) : print ( lst [ i ] )",
    "label": 0
  },
  {
    "code": "mountains = [ ] count = 0 while True : height = int ( input ( ) ) if height >= 0 and height <= 10000 : mountains . append ( height ) count += 1 if count == 10 : break mountains . sort ( ) for i in mountains [ : 6 : - 1 ] : print ( i )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for count in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "N = 10 mnts = [ ] for i in range ( N ) : mnts . append ( int ( input ( ) ) ) mnts . sort ( reverse = True ) for mnt in mnts [ : 3 ] : print ( mnt )",
    "label": 0
  },
  {
    "code": "cnt = 10 top3 = [ 0 , 0 , 0 ] for x in xrange ( cnt ) : n = int ( raw_input ( ) ) if top3 [ 2 ] > n : continue top3 [ 2 ] = n if top3 [ 1 ] > top3 [ 2 ] : continue top3 [ 1 ] , top3 [ 2 ] = top3 [ 2 ] , top3 [ 1 ] if top3 [ 0 ] > top3 [ 1 ] : continue top3 [ 0 ] , top3 [ 1 ] = top3 [ 1 ] , top3 [ 0 ] print top3 [ 0 ] print top3 [ 1 ] print top3 [ 2 ]",
    "label": 0
  },
  {
    "code": "li2 = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) print ( li2 [ 0 ] ) print ( li2 [ 1 ] ) print ( li2 [ 2 ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for num in range ( 10 ) : heights . append ( input ( ) ) top_heights = [ int ( i ) for i in heights ] top_heights . sort ( ) top_heights . reverse ( ) for top in range ( 3 ) : print ( top_heights [ top ] )",
    "label": 0
  },
  {
    "code": "num = 10 top = 3 mountains = [ int ( input ( ) ) for i in range ( num ) ] mountains = sorted ( mountains , reverse = True ) for i in range ( top ) : print ( mountains [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "def ListOfTop3Hill ( l ) : l . sort ( ) l . reverse ( ) for i in range ( 3 ) : print ( l [ i ] ) def main ( ) : N = 10 l = [ int ( input ( ) ) for i in range ( N ) ] ListOfTop3Hill ( l ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for _ in range ( 10 ) ] for height in sorted ( mountains , reverse = True ) [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for _ in range ( 10 ) ] print ( * sorted ( mountains , reverse = True ) [ : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : height = int ( input ( ) ) a . append ( height ) a . sort ( ) a . reverse ( ) for j in range ( 3 ) : print ( a [ j ] )",
    "label": 0
  },
  {
    "code": "mount = [ ] for i in range ( 10 ) : n = int ( input ( ) ) mount . append ( n ) s = sorted ( mount ) [ : : - 1 ] for i in range ( 3 ) : print ( s [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for i in range ( 10 ) : heights . append ( input ( ) ) print ' \\n ' . join ( str ( x ) for x in sorted ( heights , reverse = True ) [ 0 : 3 ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( ) print ( lst [ 9 ] ) print ( lst [ 8 ] ) print ( lst [ 7 ] )",
    "label": 0
  },
  {
    "code": "alllist = [ ] for _ in range ( 10 ) : alllist . append ( int ( input ( ) ) ) for x in sorted ( alllist , reverse = True ) [ 0 : 3 ] : print ( x )",
    "label": 0
  },
  {
    "code": "import collections import sys def read_prob ( ) : inputs = [ ] try : while True : line = input ( ) . strip ( ) inputs . append ( int ( line ) ) except EOFError : pass return inputs if __name__ == ' __main__ ' : inputs = read_prob ( ) so = sorted ( inputs ) so . reverse ( ) for i in range ( 3 ) : print ( so [ i ] )",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 0 , 10 ) : data . append ( int ( input ( ) ) ) data . sort ( ) data . reverse ( ) for i in range ( 0 , 3 ) : print ( data [ i ] )",
    "label": 0
  },
  {
    "code": "hills = [ input ( ) for _ in range ( 10 ) ] hills = list ( map ( int , hills ) ) hills . sort ( ) for i in range ( 3 ) : print ( hills . pop ( ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) a . reverse ( ) print ( str ( a [ 0 ] ) + \" \\n \" + str ( a [ 1 ] ) + \" \\n \" + str ( a [ 2 ] ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : n = input ( ) a . append ( n ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for _ in range ( 10 ) ] m . sort ( ) [ print ( m [ - i ] ) for i in range ( 1 , 4 ) ]",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) print ( h [ 9 ] ) print ( h [ 8 ] ) print ( h [ 7 ] )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : x . append ( int ( input ( ) ) ) x . sort ( ) x . reverse ( ) for i in range ( 3 ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for j in range ( - 1 , - 4 , - 1 ) : print ( a [ j ] )",
    "label": 0
  },
  {
    "code": "high = [ ] for i in range ( 10 ) : high . append ( int ( input ( ) ) ) high = sorted ( high , reverse = True ) for i in range ( 3 ) : print ( high [ i ] )",
    "label": 0
  },
  {
    "code": "t = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ print ( i ) for i in [ t [ - 1 ] , t [ - 2 ] , t [ - 3 ] ] ]",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for _ in range ( 10 ) ] mountains . sort ( reverse = True ) for i in range ( 3 ) : print ( mountains [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "arr = [ ] for i in range ( 0 , 10 ) : temp = int ( input ( \" \" ) ) arr . append ( temp ) arr . sort ( ) print ( arr [ 9 ] ) print ( arr [ 8 ] ) print ( arr [ 7 ] )",
    "label": 0
  },
  {
    "code": "lst = [ int ( input ( ) ) for _ in range ( 10 ) ] lst . sort ( ) for i in range ( 3 ) : print ( lst [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) h . reverse ( ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "num = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : num [ i ] = int ( input ( ) ) num . sort ( ) num . reverse ( ) print ( num [ 0 ] ) print ( num [ 1 ] ) print ( num [ 2 ] )",
    "label": 0
  },
  {
    "code": "first = 0 ; second = 0 ; third = 0 ; for var in range ( 0 , 10 ) : N = int ( input ( ) ) if ( N > first ) : third = second second = first first = N elif ( N > second ) : third = second second = N elif ( N > third ) : third = N print ( first ) print ( second ) print ( third )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) print ( * a [ 0 : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "hlist = [ ] for i in range ( 10 ) : hlist . append ( int ( input ( ) ) ) hlist . sort ( ) hlist . reverse ( ) for i in range ( 3 ) : print ( hlist [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] print ( * sorted ( a , reverse = True ) [ 0 : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "def run ( ) : mount_t = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) for i in range ( 3 ) : print ( mount_t [ 9 - i ] ) if __name__ == ' __main__ ' : run ( )",
    "label": 0
  },
  {
    "code": "def run ( ) : n = [ ] for _ in range ( 10 ) : n . append ( int ( input ( ) ) ) n = sorted ( n , reverse = True ) print ( ' \\n ' . join ( [ str ( _n ) for _n in n [ : 3 ] ] ) ) if __name__ == ' __main__ ' : run ( )",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( [ str ( x ) for x in ( sorted ( [ input ( ) for i in range ( 10 ) ] ) [ : - 4 : - 1 ] ) ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 0 , 10 ) : n = int ( raw_input ( ) ) list . append ( n ) list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 0 , 10 ) : n = int ( raw_input ( ) ) list . append ( n ) list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for line in sys . stdin : a . append ( int ( line ) ) a . sort ( lambda x , y : y - x ) for i in range ( 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "def sort ( lst ) : for i in range ( len ( lst ) ) : m = i for j in range ( i + 1 , len ( lst ) ) : if lst [ j ] > lst [ m ] : m = j tmp = lst [ i ] lst [ i ] = lst [ m ] lst [ m ] = tmp return lst lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst = sort ( lst ) print ( \" \\n \\n \" % ( lst [ 0 ] , lst [ 1 ] , lst [ 2 ] ) )",
    "label": 0
  },
  {
    "code": "hill = [ 0 ] * 10 for i in range ( 10 ) : hill [ i ] = input ( ) hill . sort ( reverse = True ) print hill [ 0 ] print hill [ 1 ] print hill [ 2 ]",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( input ( ) ) h . sort ( reverse = True ) for i in range ( 3 ) : print h [ i ]",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( input ( ) ) h . sort ( ) for i in range ( 3 ) : print h [ 9 - i ]",
    "label": 0
  },
  {
    "code": "h = [ ] while len ( h ) < 10 : h . append ( input ( ) ) h . sort ( ) for i in range ( 3 ) : print h [ 9 - i ]",
    "label": 0
  },
  {
    "code": "import sys def main ( ) : list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( lambda num_1 , num_2 : num_2 - num_1 ) for i in range ( 3 ) : print ( list [ i ] ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "import sys input_list = list ( ) for i in sys . stdin . readlines ( ) : i = i . strip ( ) i = int ( i ) input_list . append ( i ) for i in sorted ( input_list , reverse = True ) [ : 3 ] : print i",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : b = int ( input ( ) ) a . append ( b ) a . sort ( ) print a [ 9 ] print a [ 8 ] print a [ 7 ]",
    "label": 0
  },
  {
    "code": "b = [ ] for i in range ( 10 ) : a = int ( input ( ) ) b . append ( a ) b . sort ( ) for i in range ( 9 , 6 , - 1 ) : print b [ i ]",
    "label": 0
  },
  {
    "code": "i = 0 arr = list ( ) while i < 10 : j = int ( raw_input ( ) ) arr . append ( j ) i += 1 for h in sorted ( arr , reverse = True ) [ : 3 ] : print h",
    "label": 0
  },
  {
    "code": "i = 0 arr = list ( ) for i in range ( 10 ) : arr . append ( raw_input ( ) ) for h in sorted ( map ( int , arr ) , reverse = True ) [ : 3 ] : print h",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( input ( ) ) lst . sort ( reverse = True ) for i in range ( 3 ) : print lst [ i ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 0 , 10 ) : input = int ( raw_input ( ) ) list . append ( input ) list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "a = [ ] for x in range ( 10 ) : a . append ( input ( ) ) a . sort ( reverse = True ) for x in range ( 3 ) : print a [ x ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : n = int ( raw_input ( ) ) list . append ( n ) list . sort ( reverse = True ) for i in range ( 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "height = [ ] while 1 : try : height . append ( input ( ) ) except EOFError : break height . sort ( reverse = True ) for i in range ( 3 ) : print height [ i ]",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( input ( ) ) m . sort ( ) print m [ - 1 ] print m [ - 2 ] print m [ - 3 ]",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( input ( ) ) list . sort ( reverse = True ) for i in range ( 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "def main ( ) : inputs = [ ] for i in xrange ( 10 ) : inputs . append ( int ( raw_input ( ) ) ) inputs . sort ( ) inputs . reverse ( ) for i in inputs [ : 3 ] : print i if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "a = [ input ( ) for i in xrange ( 10 ) ] a . sort ( reverse = True ) for i in range ( 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "def sort_hills ( lists ) : lists . sort ( ) lists . reverse ( ) return lists x1 = input ( ) x2 = input ( ) x3 = input ( ) x4 = input ( ) x5 = input ( ) x6 = input ( ) x7 = input ( ) x8 = input ( ) x9 = input ( ) x10 = input ( ) listA = [ x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 ] listA = sort_hills ( listA ) print listA [ 0 ] print listA [ 1 ] print listA [ 2 ]",
    "label": 0
  },
  {
    "code": "print ' \\n ' . join ( map ( str , list ( reversed ( list ( sorted ( map ( lambda x : int ( raw_input ( ) ) , range ( 10 ) ) ) ) [ 7 : ] ) ) ) )",
    "label": 0
  },
  {
    "code": "l = [ ] ; for i in range ( 10 ) : l . append ( int ( raw_input ( ) . strip ( ) ) ) l . sort ( lambda x , y : y - x ) ; for a in l [ : 3 ] : print a",
    "label": 0
  },
  {
    "code": "l = [ ] ; for i in range ( 10 ) : l . append ( int ( raw_input ( ) . strip ( ) ) ) l . sort ( lambda x , y : y - x ) ; for a in l [ : 3 ] : print a",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( input ( ) ) l . sort ( lambda x , y : y - x ) ; for k in l [ : 3 ] : print k ;",
    "label": 0
  },
  {
    "code": "nums = [ ] while True : try : nums . append ( int ( raw_input ( ) ) ) except ( EOFError ) : break nums . sort ( reverse = True ) for i in range ( 3 ) : print nums [ i ]",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( [ str ( x ) for x in ( sorted ( [ input ( ) for i in range ( 10 ) ] ) [ : - 4 : - 1 ] ) ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for x in range ( 10 ) : y = input ( ) list . append ( y ) list = sorted ( list ) list . reverse ( ) for x in range ( 3 ) : print list [ x ]",
    "label": 0
  },
  {
    "code": "import sys a = 10 * [ 0 ] for i in range ( 10 ) : h = raw_input ( ) a [ i ] = int ( h ) a . sort ( ) print a [ - 1 ] print a [ - 2 ] print a [ - 3 ]",
    "label": 0
  },
  {
    "code": "l = [ ] while True : try : l . append ( input ( ) ) except EOFError : break l . sort ( reverse = True ) for i in range ( 3 ) : print l [ i ]",
    "label": 0
  },
  {
    "code": "from __future__ import absolute_import , print_function , unicode_literals import sys for h in sorted ( ( int ( line ) for line in sys . stdin ) , reverse = True ) [ : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "x = [ ] a = 1 while True : if a != 11 : x . append ( int ( raw_input ( ) ) ) a += 1 continue else : break x . sort ( ) print x [ 9 ] print x [ 8 ] print x [ 7 ]",
    "label": 0
  },
  {
    "code": "ans = [ ] def main ( ) : for i in range ( 10 ) : ans . append ( input ( ) ) else : ans . sort ( ) print \" \\n \\n \" . format ( ans [ - 1 ] , ans [ - 2 ] , ans [ - 3 ] ) main ( )",
    "label": 0
  },
  {
    "code": "for x in sorted ( [ int ( raw_input ( ) ) for _ in range ( 10 ) ] , reverse = 1 ) [ : 3 ] : print x",
    "label": 0
  },
  {
    "code": "from sys import stdin x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in x [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "a = [ ] ; for i in range ( 10 ) : a . append ( input ( ) ) ; a . sort ( lambda x , y : y - x ) ; for i in a [ : 3 ] : print i ;",
    "label": 0
  },
  {
    "code": "res = [ ] for l in range ( 0 , 10 ) : res . append ( input ( ) ) res = sorted ( res , reverse = True ) for i in range ( 0 , 3 ) : print res [ i ]",
    "label": 0
  },
  {
    "code": "a = [ input ( ) for i in range ( 10 ) ] a . sort ( ) print \" \\n \\n \" % ( a [ - 1 ] , a [ - 2 ] , a [ - 3 ] )",
    "label": 0
  },
  {
    "code": "hs = [ input ( ) for _ in xrange ( 10 ) ] hs . sort ( ) for _ in xrange ( 3 ) : print hs . pop ( )",
    "label": 0
  },
  {
    "code": "for j in sorted ( [ input ( ) for i in range ( 10 ) ] ) [ - 1 : - 4 : - 1 ] : print j",
    "label": 0
  },
  {
    "code": "data = [ ] for i in range ( 10 ) : data . append ( int ( raw_input ( ) ) ) m1 = m2 = m3 = 0 for i in data : if 0 <= i <= 10000 : if m1 <= i : m3 = m2 m2 = m1 m1 = i elif m2 <= i < m1 : m3 = m2 m2 = i elif m3 <= i < m2 : m3 = i print \" \\n \\n \" . format ( m1 , m2 , m3 )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 0 , 10 ) : x . append ( input ( ) ) x . sort ( reverse = True ) for i in range ( 0 , 3 ) : print x [ i ]",
    "label": 0
  },
  {
    "code": "lis = [ ] for i in xrange ( 10 ) : lis . append ( input ( ) ) for a in sorted ( lis , reverse = True ) [ : 3 ] : print a",
    "label": 0
  },
  {
    "code": "import sys file = sys . stdin lis = file . readlines ( ) lis = map ( int , lis ) lis . sort ( ) lis . reverse ( ) for height in lis [ 0 : 3 ] : print height",
    "label": 0
  },
  {
    "code": "import sys import fileinput def main ( ) : for height in sorted ( map ( lambda x : int ( x ) , fileinput . input ( ) ) , reverse = True ) [ : 3 ] : print height return 0 if __name__ == \" __main__ \" : sys . exit ( main ( ) )",
    "label": 0
  },
  {
    "code": "list = list ( ) for i in xrange ( 10 ) : list . append ( input ( ) ) list . sort ( ) list . reverse ( ) for i in xrange ( 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( map ( str , sorted ( [ input ( ) for _ in xrange ( 10 ) ] , reverse = True ) [ : 3 ] ) )",
    "label": 0
  },
  {
    "code": "from sys import stdin x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in range ( 3 ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "ans = [ ] while True : try : ans . append ( raw_input ( ) ) except : break ans . sort ( key = int ) ans . reverse ( ) print \" \\n \" . join ( ans [ : 3 ] )",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( sorted ( [ raw_input ( ) for x in xrange ( 10 ) ] , key = int ) [ : : - 1 ] [ : 3 ] )",
    "label": 0
  },
  {
    "code": "print \" \\n \" . join ( sorted ( [ raw_input ( ) for x in xrange ( 10 ) ] , key = int ) [ : : - 1 ] [ : 3 ] )",
    "label": 0
  },
  {
    "code": "mo = [ ] ; for i in range ( 10 ) : mo . append ( int ( raw_input ( ) ) ) mo . sort ( reverse = True ) for i in range ( 3 ) : print mo [ i ]",
    "label": 0
  },
  {
    "code": "l = [ ] for x in range ( 10 ) : n = int ( raw_input ( ) ) l . append ( n ) print ' \\n ' . join ( map ( str , reversed ( sorted ( l ) ) ) [ : 3 ] )",
    "label": 0
  },
  {
    "code": "import sys tmp = [ ] for i in range ( 10 ) : line = input ( ) tmp . append ( line ) tmp . sort ( ) print tmp [ - 1 ] print tmp [ - 2 ] print tmp [ - 3 ]",
    "label": 0
  },
  {
    "code": "for j in sorted ( [ input ( ) for i in range ( 10 ) ] ) [ - 1 : - 4 : - 1 ] : print j",
    "label": 0
  },
  {
    "code": "num = [ ] for i in range ( 10 ) : num . append ( input ( ) ) num . sort ( ) print num [ - 1 ] print num [ - 2 ] print num [ - 3 ]",
    "label": 0
  },
  {
    "code": "import sys n = 10 x = [ ] for i in range ( n ) : tmp = input ( ) x . append ( tmp ) for i in sorted ( x ) [ : : - 1 ] [ : 3 ] : print i",
    "label": 0
  },
  {
    "code": "fir = 0 sec = 0 thi = 0 for a in range ( 0 , 10 ) : a = input ( ) if a >= fir : sec , thi = fir , sec fir = a elif a >= sec : thi = sec sec = a elif a >= thi : thi = a print fir print sec print thi",
    "label": 0
  },
  {
    "code": "m = sorted ( [ int ( raw_input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in m [ : 3 ] : print i",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ input ( ) for i in range ( 10 ) ] ) [ - 1 : - 4 : - 1 ] : print i",
    "label": 0
  },
  {
    "code": "import sys mountains = [ ] for line in sys . stdin : mountains . append ( int ( line ) ) mountains . sort ( reverse = True ) print mountains [ 0 ] print mountains [ 1 ] print mountains [ 2 ]",
    "label": 0
  },
  {
    "code": "a = [ ] for x in range ( 10 ) : a += [ int ( input ( ) ) ] for x in range ( 3 ) : print ( max ( a ) ) a . remove ( max ( a ) )",
    "label": 0
  },
  {
    "code": "hs = [ ] for i in xrange ( 10 ) : hs . append ( int ( raw_input ( ) ) ) hs . sort ( ) print hs [ 9 ] print hs [ 8 ] print hs [ 7 ]",
    "label": 0
  },
  {
    "code": "import sys heights = [ ] for line in sys . stdin : heights . append ( int ( line . rstrip ( ' \\n ' ) ) ) for height in sorted ( heights , reverse = True ) [ : 3 ] : print height",
    "label": 0
  },
  {
    "code": "def lot3h ( ) : mounts = [ ] for i in range ( 10 ) : mounts . append ( int ( raw_input ( ) ) ) mounts . sort ( ) mounts . reverse ( ) for i in range ( 3 ) : print \" \\n \" % mounts [ i ] , return if __name__ == \" __main__ \" : lot3h ( )",
    "label": 0
  },
  {
    "code": "import sys l = sorted ( [ int ( s ) for s in sys . stdin ] , reverse = True ) [ : 3 ] print ' \\n ' . join ( [ str ( s ) for s in l ] )",
    "label": 0
  },
  {
    "code": "import sys dat = [ ] for i in range ( 0 , 10 ) : val = raw_input ( ) dat . append ( int ( val ) ) dat . sort ( ) dat . reverse ( ) for i in range ( 0 , 3 ) : print dat [ i ]",
    "label": 0
  },
  {
    "code": "dat = [ ] for i in range ( 0 , 10 ) : val = raw_input ( ) dat . append ( int ( val ) ) dat . sort ( ) dat . reverse ( ) for i in range ( 0 , 3 ) : print dat [ i ]",
    "label": 0
  },
  {
    "code": "first = - 1 second = - 1 third = - 1 for i in xrange ( 10 ) : height = int ( raw_input ( ) ) if first < height : third = second second = first first = height else : if second < height : third = second second = height else : if third < height : third = height print first print second print third",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : x . append ( input ( ) ) x . sort ( ) for j in range ( - 1 , - 4 , - 1 ) : print ( x [ j ] )",
    "label": 0
  },
  {
    "code": "import sys x = [ ] for i in range ( 10 ) : x += [ input ( ) ] for i in sorted ( x ) [ : - 4 : - 1 ] : print i",
    "label": 0
  },
  {
    "code": "import sys for i in sorted ( map ( int , sys . stdin ) ) [ : - 4 : - 1 ] : print i",
    "label": 0
  },
  {
    "code": "import sys x = sorted ( map ( int , sys . stdin ) ) [ : - 4 : - 1 ] for i in x : print i",
    "label": 0
  },
  {
    "code": "x = sorted ( [ input ( ) for i in range ( 10 ) ] ) [ : - 4 : - 1 ] for i in x : print i",
    "label": 0
  },
  {
    "code": "for i in sorted ( [ input ( ) for i in range ( 10 ) ] ) [ : - 4 : - 1 ] : print i",
    "label": 0
  },
  {
    "code": "n = list ( ) for var in range ( 0 , 10 ) : n . append ( int ( raw_input ( ) ) ) n . sort ( reverse = True ) for var in range ( 0 , 3 ) : print n [ var ]",
    "label": 0
  },
  {
    "code": "a = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : a [ i ] = int ( raw_input ( ) ) a . sort ( ) a . reverse ( ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "heights = [ ] for n in range ( 10 ) : heights . append ( int ( raw_input ( ) ) ) heights = sorted ( heights ) [ : : - 1 ] for h in heights [ : 3 ] : print h",
    "label": 0
  },
  {
    "code": "import sys array = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : array [ i ] = int ( raw_input ( ) ) array . sort ( ) array . reverse ( ) for j in range ( 3 ) : print str ( array [ j ] ) sys . exit ( )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( int ( raw_input ( ) ) ) m . sort ( ) for i in range ( - 1 , - 4 , - 1 ) : print m [ i ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) for i in range ( len ( a ) ) : for s in range ( i + 1 , len ( a ) ) : if a [ i ] < a [ s ] : tmp = a [ s ] a [ s ] = a [ i ] a [ i ] = tmp for i in range ( 3 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a . sort ( reverse = True ) for j in range ( 3 ) : print a [ j ]",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( input ( ) ) m . sort ( reverse = True ) print ' \\n ' . join ( map ( str , m [ : 3 ] ) )",
    "label": 0
  },
  {
    "code": "a = [ ] try : while True : a . append ( int ( raw_input ( ) ) ) except : pass a . sort ( ) for i in range ( - 1 , - 4 , - 1 ) : print a [ i ]",
    "label": 0
  },
  {
    "code": "from sys import stdin x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in x [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "from sys import stdin x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in x [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "a = [ int ( raw_input ( ) ) for i in xrange ( 10 ) ] a . sort ( ) a . reverse ( ) print a [ 0 ] print a [ 1 ] print a [ 2 ]",
    "label": 0
  },
  {
    "code": "x = [ int ( raw_input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in x [ : 3 ] : print i",
    "label": 0
  },
  {
    "code": "s = [ ] for i in xrange ( 10 ) : s . append ( int ( raw_input ( ) ) ) s . sort ( ) s . reverse ( ) for i in xrange ( 3 ) : print s [ i ]",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] a . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : num = input ( ) a . append ( int ( num ) ) a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : x = input ( ) m . append ( x ) m . sort ( ) m . reverse ( ) for i in range ( 0 , 3 ) : print m [ i ]",
    "label": 0
  },
  {
    "code": "tmp_max = [ 0 , 0 , 0 ] import sys for line in iter ( sys . stdin . readline , \" \" ) : if int ( line ) > tmp_max [ 2 ] : tmp_max [ 2 ] = int ( line ) if tmp_max [ 2 ] > tmp_max [ 1 ] : tmp_max [ 1 ] , tmp_max [ 2 ] = tmp_max [ 2 ] , tmp_max [ 1 ] if tmp_max [ 1 ] > tmp_max [ 0 ] : tmp_max [ 0 ] , tmp_max [ 1 ] = tmp_max [ 1 ] , tmp_max [ 0 ] print tmp_max [ 0 ] print tmp_max [ 1 ] print tmp_max [ 2 ]",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : n = int ( input ( ) ) l . append ( n ) l . sort ( reverse = True ) print ( l [ 0 ] ) print ( l [ 1 ] ) print ( l [ 2 ] )",
    "label": 0
  },
  {
    "code": "a , b = [ ] , [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] a . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for i in range ( 10 ) ] m . sort ( reverse = True ) for i in range ( 3 ) : print ( m [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a = sorted ( a , key = int , reverse = True ) for i in a [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : c = int ( input ( ) ) a . append ( c ) d = sorted ( a ) print ( d [ - 1 ] ) print ( d [ - 2 ] ) print ( d [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : b = int ( input ( ) ) a . append ( b ) for i in range ( 3 ) : print ( max ( a ) ) a . remove ( max ( a ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : n = int ( input ( ) ) a . append ( n ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "mountain_heights = [ ] for i in range ( 10 ) : mountain_heights . append ( int ( input ( ) ) ) for i in range ( 3 ) : maximum = 0 index = i for j in range ( i , 10 ) : if mountain_heights [ j ] > maximum : maximum = mountain_heights [ j ] index = j temp = mountain_heights [ i ] mountain_heights [ i ] = mountain_heights [ index ] mountain_heights [ index ] = temp print ( maximum )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] b = [ ] for i in range ( 10 ) : h = int ( input ( ) ) a . append ( h ) for n in range ( 3 ) : s = max ( a ) b . append ( s ) print ( s ) a . remove ( s )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( ) print ( m [ 9 ] ) print ( m [ 8 ] ) print ( m [ 7 ] )",
    "label": 0
  },
  {
    "code": "S = [ int ( input ( ) ) for i in range ( 10 ) ] S . sort ( reverse = 1 ) print ( * S [ : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( f' { a [ - 1 ] } \\n { a [ - 2 ] } \\n { a [ - 3 ] } ' )",
    "label": 0
  },
  {
    "code": "h = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : : - 1 ] for i in h [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "A = list ( int ( input ( ) ) for i in range ( 10 ) ) A . sort ( reverse = True ) for i in range ( 3 ) : print ( A [ i ] )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for i in sys . stdin : a . append ( int ( i ) ) x = sorted ( a , reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : n = int ( input ( ) ) x . append ( n ) x1 = sorted ( x , reverse = True ) print ( x1 [ 0 ] ) print ( x1 [ 1 ] ) print ( x1 [ 2 ] )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] for i in sys . stdin : a . append ( int ( i ) ) x = sorted ( a , reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] a . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "x = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] x . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : n = int ( input ( ) ) list . append ( n ) list . sort ( ) print ( list [ 9 ] ) print ( list [ 8 ] ) print ( list [ 7 ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( ) h . reverse ( ) for j in range ( 3 ) : print ( h [ j ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( ) for i in range ( 3 ) : print ( l [ 9 - i ] )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : a = int ( input ( ) ) x . append ( a ) x . sort ( reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) b = sorted ( a , reverse = True ) print ( b [ 0 ] ) print ( b [ 1 ] ) print ( b [ 2 ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for i in range ( 3 ) : print ( a [ - 1 ] ) del a [ - 1 ]",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for i in range ( 10 ) ] s . sort ( reverse = True ) for i in s [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : - 4 : - 1 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : - 4 : - 1 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] s = sys . stdin . readline ( ) while s : a . append ( int ( s ) ) s = sys . stdin . readline ( ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print ( a [ i ] ) ;",
    "label": 0
  },
  {
    "code": "LIST = [ ] for i in range ( 10 ) : LIST . append ( int ( input ( ) ) ) LIST . sort ( reverse = True ) print ( LIST [ 0 ] ) print ( LIST [ 1 ] ) print ( LIST [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a = sorted ( a , key = int , reverse = True ) for i in a [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( ( int ) ( input ( ) ) ) h . sort ( ) h . reverse ( ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "mountain = [ ] for i in range ( 10 ) : mountain . append ( int ( input ( ) ) ) mountain . sort ( ) print ( mountain [ 9 ] ) print ( mountain [ 8 ] ) print ( mountain [ 7 ] )",
    "label": 0
  },
  {
    "code": "x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in range ( 3 ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) for i in range ( 3 ) : maximum = 0 index = i for j in range ( i , 10 ) : if a [ j ] > maximum : maximum = a [ j ] index = j temp = a [ i ] a [ i ] = a [ index ] a [ index ] = temp print ( maximum )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "Mountain = [ int ( input ( ) ) for i in range ( 10 ) ] Mountain . sort ( reverse = True ) for i in range ( 3 ) : print ( Mountain [ i ] )",
    "label": 0
  },
  {
    "code": "N = 10 i = 0 I = [ int ( input ( ) ) for _ in range ( N ) ] I . sort ( ) for i in range ( 3 ) : print ( max ( I ) ) I . pop ( )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "h = list ( ) for i in range ( 10 ) : a = input ( ) a = int ( a ) h . append ( a ) h . sort ( ) print ( h [ 9 ] ) print ( h [ 8 ] ) print ( h [ 7 ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( ) print ( list [ - 1 ] ) print ( list [ - 2 ] ) print ( list [ - 3 ] )",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for _ in range ( 10 ) ] for i in range ( 3 ) : n = max ( s ) print ( n ) s . remove ( n )",
    "label": 0
  },
  {
    "code": "lst = [ int ( input ( ) ) for i in range ( 10 ) ] lst . sort ( ) lst . reverse ( ) print ( lst [ 0 ] ) print ( lst [ 1 ] ) print ( lst [ 2 ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : n = int ( input ( ) ) lst . append ( n ) ld = sorted ( lst , reverse = True ) for n in ld [ : 3 ] : print ( n )",
    "label": 0
  },
  {
    "code": "num = [ ] for i in range ( 10 ) : x = int ( input ( ) ) num . append ( x ) num . sort ( ) print ( num [ 9 ] ) print ( num [ 8 ] ) print ( num [ 7 ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : x = int ( input ( ) ) list . append ( x ) list = sorted ( list , reverse = True ) print ( list [ 0 ] ) print ( list [ 1 ] ) print ( list [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : n = int ( input ( ) ) a . append ( n ) a . sort ( ) print ( a [ 9 ] , a [ 8 ] , a [ 7 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "takasa = [ ] for a in range ( 10 ) : takasa . append ( int ( input ( ) ) ) for b in range ( 3 ) : print ( max ( takasa ) ) takasa . remove ( max ( takasa ) )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : s = int ( input ( ) ) x . append ( int ( s ) ) y = sorted ( x ) print ( y [ 9 ] ) print ( y [ 8 ] ) print ( y [ 7 ] )",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for i in range ( 10 ) ] s . sort ( ) print ( s [ 9 ] ) print ( s [ 8 ] ) print ( s [ 7 ] )",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for _ in range ( 10 ) ] m . sort ( ) [ print ( m [ - i ] ) for i in range ( 1 , 4 ) ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) b = sorted ( a ) print ( b [ 9 ] ) print ( b [ 8 ] ) print ( b [ 7 ] )",
    "label": 0
  },
  {
    "code": "li = [ ] for i in range ( 10 ) : li . append ( int ( input ( ) ) ) li = sorted ( li ) print ( li [ - 1 ] ) print ( li [ - 2 ] ) print ( li [ - 3 ] )",
    "label": 0
  },
  {
    "code": "S = [ int ( input ( ) ) for i in range ( 10 ) ] S . sort ( reverse = 1 ) print ( * S [ : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) b = sorted ( a , reverse = True ) print ( b [ 0 ] ) print ( b [ 1 ] ) print ( b [ 2 ] )",
    "label": 0
  },
  {
    "code": "high = [ ] for i in range ( 10 ) : high . append ( int ( input ( ) ) ) high . sort ( ) high . reverse ( ) print ( high [ 0 ] ) print ( high [ 1 ] ) print ( high [ 2 ] )",
    "label": 0
  },
  {
    "code": "x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( ) print ( ' \\n \\n ' . format ( x [ 9 ] , x [ 8 ] , x [ 7 ] ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a = sorted ( a , key = int , reverse = True ) for i in a [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : s = int ( input ( ) ) x . append ( int ( s ) ) y = sorted ( x ) print ( y [ 9 ] ) print ( y [ 8 ] ) print ( y [ 7 ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( reverse = True ) print ( list [ 0 ] ) print ( list [ 1 ] ) print ( list [ 2 ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : x = int ( input ( ) ) list . append ( x ) list = sorted ( list , reverse = True ) print ( list [ 0 ] ) print ( list [ 1 ] ) print ( list [ 2 ] )",
    "label": 0
  },
  {
    "code": "L = [ ] for i in range ( 10 ) : a = int ( input ( ) ) L . append ( a ) i += 1 for k in range ( 9 , 0 , - 1 ) : for l in range ( k ) : if L [ l ] > L [ l + 1 ] : L [ l ] , L [ l + 1 ] = L [ l + 1 ] , L [ l ] l += 1 k += 1 for j in range ( 3 ) : print ( L [ - 1 ] ) L . remove ( L [ - 1 ] ) j += 1",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : a = int ( input ( ) ) l . append ( a ) l . sort ( ) l . reverse ( ) print ( l [ 0 ] ) print ( l [ 1 ] ) print ( l [ 2 ] )",
    "label": 0
  },
  {
    "code": "i = [ int ( input ( ) ) for i in range ( 10 ) ] x = sorted ( i ) print ( x [ 9 ] ) print ( x [ 8 ] ) print ( x [ 7 ] )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : x . append ( int ( input ( ) ) ) x . sort ( ) print ( x [ - 1 ] ) print ( x [ - 2 ] ) print ( x [ - 3 ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : x = int ( input ( ) ) lst . append ( x ) lst . sort ( reverse = True ) lst1 = lst [ 0 : 3 ] lst2 = lst [ 1 ] print ( max ( lst1 ) ) print ( lst2 ) print ( min ( lst1 ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( f' { a [ - 1 ] } \\n { a [ - 2 ] } \\n { a [ - 3 ] } ' )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : x = int ( input ( ) ) lst . append ( x ) print ( sorted ( lst ) [ - 1 ] ) print ( sorted ( lst ) [ - 2 ] ) print ( sorted ( lst ) [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] print ( sorted ( a ) [ - 1 ] ) print ( sorted ( a ) [ - 2 ] ) print ( sorted ( a ) [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for i in range ( 3 ) : print ( a [ - 1 ] ) del a [ - 1 ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) a . reverse ( ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( ) print ( list [ 9 ] , list [ 8 ] , list [ 7 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ - 1 ] ) print ( a [ - 2 ] ) print ( a [ - 3 ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : n = int ( input ( ) ) l . append ( n ) l . sort ( reverse = True ) print ( l [ 0 ] ) print ( l [ 1 ] ) print ( l [ 2 ] )",
    "label": 0
  },
  {
    "code": "Y = [ ] for i in range ( 10 ) : Y . append ( int ( input ( ) ) ) Y = sorted ( Y ) print ( Y [ 9 ] ) print ( Y [ 8 ] ) print ( Y [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] b = sorted ( a ) print ( b [ 9 ] ) print ( b [ 8 ] ) print ( b [ 7 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) for j in range ( 3 ) : print ( max ( h ) ) h . remove ( max ( h ) )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : a = int ( input ( ) ) x . append ( a ) print ( max ( x ) ) print ( sorted ( x ) [ - 2 ] ) print ( sorted ( x ) [ - 3 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) print ( h [ 9 ] , h [ 8 ] , h [ 7 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) for i in range ( 3 ) : print ( a [ - 1 ] ) del a [ - 1 ]",
    "label": 0
  },
  {
    "code": "list = [ ] for x in range ( 10 ) : n = int ( input ( ) ) list . append ( n ) list . sort ( ) size = len ( list ) print ( list [ size - 1 ] ) print ( list [ size - 2 ] ) print ( list [ size - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : x = int ( input ( ) ) a . append ( x ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( ) print ( a [ - 1 ] ) print ( a [ - 2 ] ) print ( a [ - 3 ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : x = int ( input ( ) ) l . append ( x ) l1 = sorted ( l , reverse = True ) print ( l1 [ 0 ] ) print ( l1 [ 1 ] ) print ( l1 [ 2 ] )",
    "label": 0
  },
  {
    "code": "L = [ ] M = [ ] for i in range ( 10 ) : n = int ( input ( ) ) L . append ( n ) for j in range ( 3 ) : b = max ( L ) M . append ( b ) L . remove ( b ) print ( M [ 0 ] ) print ( M [ 1 ] ) print ( M [ 2 ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for x in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( ) lst . reverse ( ) print ( lst [ 0 ] ) print ( lst [ 1 ] ) print ( lst [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : n = int ( input ( ) ) a . append ( n ) for j in range ( 3 ) : b = max ( a ) print ( b ) a . remove ( b )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( reverse = True ) print ( a [ 0 ] , a [ 1 ] , a [ 2 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : x = int ( input ( ) ) lst . append ( x ) lstx = sorted ( lst ) [ 7 : ] print ( lstx [ 2 ] ) print ( lstx [ 1 ] ) print ( lstx [ 0 ] )",
    "label": 0
  },
  {
    "code": "h_list = [ ] for i in range ( 0 , 10 ) : h_input = int ( input ( ) ) if ( 0 <= h_input <= 10000 ) : h_list . append ( h_input ) h_list = sorted ( h_list , reverse = True ) for i in range ( 0 , 3 ) : print ( h_list [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : a = int ( input ( ) ) l . append ( a ) L = sorted ( l ) print ( L [ len ( L ) - 1 ] ) print ( L [ len ( L ) - 2 ] ) print ( L [ len ( L ) - 3 ] )",
    "label": 0
  },
  {
    "code": "x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "List = [ ] for i in range ( 10 ) : List . append ( int ( input ( ) ) ) List . sort ( reverse = True ) print ( List [ 0 ] ) print ( List [ 1 ] ) print ( List [ 2 ] )",
    "label": 0
  },
  {
    "code": "list = [ int ( input ( ) ) for i in range ( 10 ) ] s = 0 t = 0 u = 0 for i in range ( 10 ) : if s < list [ i ] : u = t t = s s = list [ i ] elif t < list [ i ] : u = t t = list [ i ] elif u < list [ i ] : u = list [ i ] print ( s ) print ( t ) print ( u )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : hight = int ( input ( ) ) x . append ( hight ) list . sort ( x , reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = list ( ) for i in range ( 10 ) : h = int ( input ( ) ) a . append ( h ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : h = int ( input ( ) ) l . append ( h ) l . sort ( ) print ( l [ 9 ] ) print ( l [ 8 ] ) print ( l [ 7 ] )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : n = int ( input ( ) ) x . append ( n ) print ( max ( x ) ) x . remove ( max ( x ) ) print ( max ( x ) ) x . remove ( max ( x ) ) print ( max ( x ) )",
    "label": 0
  },
  {
    "code": "S = [ int ( input ( ) ) for i in range ( 10 ) ] S . sort ( reverse = True ) print ( S [ 0 ] ) print ( S [ 1 ] ) print ( S [ 2 ] )",
    "label": 0
  },
  {
    "code": "i = 1 H = [ ] while i <= 10 : h = int ( input ( ) ) H . append ( h ) i += 1 H . sort ( reverse = True ) for i in range ( 3 ) : print ( f' { H [ i ] } ' )",
    "label": 0
  },
  {
    "code": "mo = [ ] for i in range ( 10 ) : h = int ( input ( ) ) mo . append ( h ) for i in range ( 10 ) : for j in range ( 9 , i , - 1 ) : if mo [ j ] < mo [ j - 1 ] : mo [ j ] , mo [ j - 1 ] = mo [ j - 1 ] , mo [ j ] print ( mo [ 9 ] ) print ( mo [ 8 ] ) print ( mo [ 7 ] )",
    "label": 0
  },
  {
    "code": "H = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) print ( H [ - 1 ] ) print ( H [ - 2 ] ) print ( H [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ None ] * 10 i = 0 for i in range ( 10 ) : a [ i ] = input ( ) a = list ( map ( int , a ) ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for _ in range ( 10 ) ] h = sorted ( h ) [ : : - 1 ] for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] b = sorted ( a , reverse = True ) print ( b [ 0 ] ) print ( b [ 1 ] ) print ( b [ 2 ] )",
    "label": 0
  },
  {
    "code": "n1 = int ( input ( ) ) n2 = int ( input ( ) ) n3 = int ( input ( ) ) n4 = int ( input ( ) ) n5 = int ( input ( ) ) n6 = int ( input ( ) ) n7 = int ( input ( ) ) n8 = int ( input ( ) ) n9 = int ( input ( ) ) n10 = int ( input ( ) ) n1 , n2 , n3 , n4 , n5 , n6 , n7 , n8 , n9 , n10 = sorted ( [ n1 , n2 , n3 , n4 , n5 , n6 , n7 , n8 , n9 , n10 ] ) print ( n10 ) print ( n9 ) print ( n8 )",
    "label": 0
  },
  {
    "code": "A = [ ] for _ in range ( 10 ) : A . append ( int ( input ( ) ) ) for i in range ( 3 ) : print ( sorted ( A , reverse = True ) [ i ] )",
    "label": 0
  },
  {
    "code": "from collections import deque lis = [ ] for i in range ( 10 ) : height = int ( input ( ) ) lis . append ( height ) lis . sort ( ) d = deque ( lis ) for j in range ( 3 ) : print ( d . pop ( ) )",
    "label": 0
  },
  {
    "code": "mount_list = [ int ( input ( ) ) for i in range ( 10 ) ] top_mount_list = sorted ( mount_list , reverse = True ) for i in top_mount_list [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "max_1 = 0 max_2 = 0 max_3 = 0 for i in range ( 10 ) : m = int ( input ( ) ) if max_1 < m : max_3 = max_2 max_2 = max_1 max_1 = m elif max_2 < m : max_3 = max_2 max_2 = m elif max_3 < m : max_3 = m print ( max_1 ) print ( max_2 ) print ( max_3 )",
    "label": 0
  },
  {
    "code": "A = [ ] for i in range ( 10 ) : m = int ( input ( ) ) A . append ( m ) B = sorted ( A ) print ( B [ - 1 ] ) print ( B [ - 2 ] ) print ( B [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) ) d = int ( input ( ) ) e = int ( input ( ) ) f = int ( input ( ) ) g = int ( input ( ) ) h = int ( input ( ) ) i = int ( input ( ) ) j = int ( input ( ) ) k = [ a , b , c , d , e , f , g , h , i , j ] k . sort ( reverse = True ) t = k [ : 3 ] for i in t [ 0 : ] : print ( i )",
    "label": 0
  },
  {
    "code": "lit = [ ] while True : try : lit . append ( input ( ) ) except EOFError : break result = [ 0 , 0 , 0 ] for i in lit : if int ( i ) > result [ 0 ] : result [ 2 ] = result [ 1 ] result [ 1 ] = result [ 0 ] result [ 0 ] = int ( i ) elif int ( i ) > result [ 1 ] : result [ 2 ] = result [ 1 ] result [ 1 ] = int ( i ) elif int ( i ) > result [ 2 ] : result [ 2 ] = int ( i ) for i in result : print ( i )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "data = [ int ( input ( ) ) for i in range ( 10 ) ] datah = sorted ( data , reverse = True ) print ( * ( datah [ : 1 ] ) ) print ( * ( datah [ 1 : 2 ] ) ) print ( * ( datah [ 2 : 3 ] ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) print ( int ( a [ 9 ] ) ) print ( int ( a [ 8 ] ) ) print ( int ( a [ 7 ] ) )",
    "label": 0
  },
  {
    "code": "W = [ ] i = 0 for i in range ( 0 , 10 ) : a = int ( input ( ) ) W . append ( a ) i += 1 j = sorted ( W , reverse = True ) [ : 3 ] [ print ( i ) for i in j ]",
    "label": 0
  },
  {
    "code": "list = [ ] for I in range ( 10 ) : h = int ( input ( ) ) list . append ( h ) list . sort ( reverse = True ) for j in range ( 3 ) : print ( list [ j ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : h = int ( input ( ) ) a . append ( h ) a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for _ in range ( 10 ) ] for height in sorted ( mountains , reverse = True ) [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : x = int ( input ( ) ) l . append ( x ) l . sort ( ) print ( l [ 9 ] ) print ( l [ 8 ] ) print ( l [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) j = 0 while j < 10 : k = 0 while k < 9 : if int ( a [ k ] ) < int ( a [ k + 1 ] ) : tmp = a [ k ] a [ k ] = a [ k + 1 ] a [ k + 1 ] = tmp k = k + 1 j = j + 1 print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "mou1 = mou2 = mou3 = 0 for i in range ( 10 ) : a = int ( input ( ) ) if a > mou1 : mou3 = mou2 mou2 = mou1 mou1 = a elif a > mou2 : mou3 = mou2 mou2 = a elif a > mou3 : mou3 = a else : pass print ( mou1 ) print ( mou2 ) print ( mou3 )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) a = sorted ( a , reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) print ( h [ 9 ] ) print ( h [ 8 ] ) print ( h [ 7 ] )",
    "label": 0
  },
  {
    "code": "T = [ int ( input ( ) ) for i in range ( 10 ) ] T . sort ( ) print ( T [ 9 ] ) print ( T [ 8 ] ) print ( T [ 7 ] )",
    "label": 0
  },
  {
    "code": "n = [ int ( input ( ) ) for i in range ( 10 ) ] b = sorted ( n ) print ( b [ 9 ] ) print ( b [ 8 ] ) print ( b [ 7 ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( reverse = True ) for i in range ( 3 ) : print ( lst [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) y = sorted ( l , reverse = True ) print ( y [ 0 ] ) print ( y [ 1 ] ) print ( y [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = 0 b = 0 c = 0 for i in range ( 10 ) : x = int ( input ( ) ) if x > c : a = b b = c c = x elif x > b : a = b b = x elif x > a : a = x print ( c ) print ( b ) print ( a )",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for i in range ( 10 ) ] list . sort ( m ) print ( m [ - 1 ] ) print ( m [ - 2 ] ) print ( m [ - 3 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( int ( input ( ) ) ) h . sort ( ) h . reverse ( ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "hlist = [ ] for i in range ( 10 ) : h = int ( input ( ) ) hlist . append ( h ) for i in range ( 10 ) : for j in range ( 9 , 0 , - 1 ) : if hlist [ j - 1 ] < hlist [ j ] : hlist [ j - 1 ] , hlist [ j ] = hlist [ j ] , hlist [ j - 1 ] print ( hlist [ 0 ] ) print ( hlist [ 1 ] ) print ( hlist [ 2 ] )",
    "label": 0
  },
  {
    "code": "i = 1 x = [ ] while i <= 10 : n = int ( input ( ) ) x . append ( n ) i += 1 a = sorted ( x , reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "num = [ ] for i in range ( 10 ) : num . append ( int ( input ( ) ) ) num . sort ( ) print ( num [ 9 ] ) print ( num [ 8 ] ) print ( num [ 7 ] )",
    "label": 0
  },
  {
    "code": "import sys x = [ ] for i in range ( 10 ) : x . append ( int ( input ( ) ) ) x . sort ( reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "x = [ int ( input ( ) ) for i in range ( 10 ) ] x . sort ( reverse = True ) for i in range ( 3 ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for i in range ( 10 ) ] l . sort ( reverse = True ) print ( l [ 0 ] ) print ( l [ 1 ] ) print ( l [ 2 ] )",
    "label": 0
  },
  {
    "code": "max1 = 0 ; max2 = 0 ; max3 = 0 for i in range ( 10 ) : x = int ( input ( ) ) if max1 < x : max3 = max2 max2 = max1 max1 = x elif max2 < x : max3 = max2 max2 = x elif max3 < x : max3 = x print ( max1 ) print ( max2 ) print ( max3 )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : n = int ( input ( ) ) x . append ( n ) x1 = sorted ( x , reverse = True ) print ( x1 [ 0 ] ) print ( x1 [ 1 ] ) print ( x1 [ 2 ] )",
    "label": 0
  },
  {
    "code": "x1 = [ ] for i in range ( 10 ) : h = int ( input ( ) ) x1 . append ( h ) x = sorted ( x1 , reverse = True ) print ( x [ 0 ] ) print ( x [ 1 ] ) print ( x [ 2 ] )",
    "label": 0
  },
  {
    "code": "a1 = int ( input ( ) ) a2 = int ( input ( ) ) a3 = int ( input ( ) ) a4 = int ( input ( ) ) a5 = int ( input ( ) ) a6 = int ( input ( ) ) a7 = int ( input ( ) ) a8 = int ( input ( ) ) a9 = int ( input ( ) ) a10 = int ( input ( ) ) s = [ ] s = [ a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 ] s . sort ( ) print ( s [ 9 ] ) print ( s [ 8 ] ) print ( s [ 7 ] )",
    "label": 0
  },
  {
    "code": "mountain_heights = [ ] for i in range ( 10 ) : mountain_heights . append ( int ( input ( ) ) ) for i in range ( 3 ) : maximum = 0 index = i for j in range ( i , 10 ) : if mountain_heights [ j ] > maximum : maximum = mountain_heights [ j ] index = j temp = mountain_heights [ i ] mountain_heights [ i ] = mountain_heights [ index ] mountain_heights [ index ] = temp print ( maximum )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : s = int ( input ( ) ) x . append ( int ( s ) ) y = sorted ( x ) print ( y [ 9 ] ) print ( y [ 8 ] ) print ( y [ 7 ] )",
    "label": 0
  },
  {
    "code": "LIST = [ ] for i in range ( 10 ) : LIST . append ( int ( input ( ) ) ) LIST . sort ( reverse = True ) print ( LIST [ 0 ] ) print ( LIST [ 1 ] ) print ( LIST [ 2 ] )",
    "label": 0
  },
  {
    "code": "S = [ int ( input ( ) ) for i in range ( 10 ) ] S . sort ( reverse = 1 ) print ( * S [ : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "y = [ ] for i in range ( 1 , 11 ) : x = int ( input ( ) ) y . append ( x ) for i in range ( 1 , 4 ) : ma = max ( y ) print ( ma ) y . remove ( ma )",
    "label": 0
  },
  {
    "code": "from collections import deque Meter = [ ] for i in range ( 10 ) : Meter . append ( int ( input ( ) ) ) Meter_new = deque ( sorted ( Meter , reverse = True ) ) for i in range ( 3 ) : print ( Meter_new . popleft ( ) )",
    "label": 0
  },
  {
    "code": "def main ( ) : import heapq h = [ 0 ] * 10 for i in range ( 10 ) : h [ i ] = int ( input ( ) ) * ( - 1 ) heapq . heapify ( h ) for _ in range ( 3 ) : print ( heapq . heappop ( h ) * ( - 1 ) ) main ( )",
    "label": 0
  },
  {
    "code": "int_list = [ ] for num in range ( 10 ) : int_line = int ( input ( ) ) int_list . append ( int_line ) int_list . sort ( ) print ( int_list [ 9 ] ) print ( int_list [ 8 ] ) print ( int_list [ 7 ] )",
    "label": 0
  },
  {
    "code": "line = [ ] for i in range ( 10 ) : line . append ( int ( input ( ) ) ) line . sort ( reverse = True ) top3 = line [ : 3 ] for j in top3 : print ( j )",
    "label": 0
  },
  {
    "code": "M = [ ] for i in range ( 10 ) : M . append ( int ( input ( ) ) ) Ms = sorted ( M , reverse = True ) for j in range ( 3 ) : print ( Ms [ j ] )",
    "label": 0
  },
  {
    "code": "mountain_high = [ ] for i in range ( 10 ) : a = int ( input ( ) ) mountain_high . append ( a ) mountain_high . sort ( reverse = True ) for i in range ( 3 ) : print ( mountain_high [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l = sorted ( l , reverse = True ) for i in range ( 3 ) : print ( l [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( ) l . reverse ( ) print ( l [ 0 ] ) print ( l [ 1 ] ) print ( l [ 2 ] )",
    "label": 0
  },
  {
    "code": "list = [ int ( input ( ) ) for _ in range ( 10 ) ] list . sort ( reverse = True ) print ( list [ 0 ] ) print ( list [ 1 ] ) print ( list [ 2 ] )",
    "label": 0
  },
  {
    "code": "ans = [ ] for i in range ( 10 ) : a = int ( input ( ) ) ans . append ( a ) ans = sorted ( ans , reverse = True ) print ( * ans [ : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) for i in range ( 3 ) : print ( l [ i ] )",
    "label": 0
  },
  {
    "code": "array = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : array [ i ] = int ( input ( ) ) array . sort ( ) for i in range ( 9 , 6 , - 1 ) : print ( array [ i ] )",
    "label": 0
  },
  {
    "code": "mountainList = [ ] for i in range ( 10 ) : mountainList . append ( int ( input ( ) ) ) mountainList . sort ( reverse = True ) for i in range ( 3 ) : print ( mountainList [ i ] )",
    "label": 0
  },
  {
    "code": "height = [ int ( input ( ) ) for _ in range ( 10 ) ] height = list ( reversed ( sorted ( height ) ) ) for i in range ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "hs = [ 0 ] * 10 for i in range ( 10 ) : hs [ i ] = int ( input ( ) ) hs = sorted ( hs ) for i in range ( 1 , 4 ) : print ( hs [ - i ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for i in range ( 0 , 10 ) : heights . append ( int ( input ( ) ) ) heights . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( heights [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 10 ) ] a = sorted ( a ) [ : : - 1 ] for i in a [ : 3 ] : print ( * i , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) ) d = int ( input ( ) ) e = int ( input ( ) ) f = int ( input ( ) ) g = int ( input ( ) ) h = int ( input ( ) ) i = int ( input ( ) ) j = int ( input ( ) ) hights = [ a , b , c , d , e , f , g , h , i , j ] hights . sort ( reverse = True ) print ( hights [ 0 ] , hights [ 1 ] , hights [ 2 ] , sep = \" \\n \" )",
    "label": 0
  },
  {
    "code": "i = 0 input_null = 0 input_list = [ ] n = 10 while i < n : input_list . append ( int ( input ( ) ) ) i += 1 sort_input_list = sorted ( input_list , reverse = True ) j = 0 while j < 3 : print ( sort_input_list [ j ] ) j += 1",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( ) print ( h [ - 1 ] ) print ( h [ - 2 ] ) print ( h [ - 3 ] )",
    "label": 0
  },
  {
    "code": "lul = [ ] for i in range ( 10 ) : line = input ( ) n = int ( line ) lul . append ( n ) lul . sort ( ) print ( str ( lul [ 9 ] ) ) print ( str ( lul [ 8 ] ) ) print ( str ( lul [ 7 ] ) )",
    "label": 0
  },
  {
    "code": "L = list ( ) for i in range ( 10 ) : L . append ( int ( input ( ) ) ) L . sort ( reverse = True ) print ( L [ 0 ] ) print ( L [ 1 ] ) print ( L [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = 0 b = 0 c = 0 for i in range ( 10 ) : x = int ( input ( ) ) if x >= a : c = b b = a a = x elif x >= b : c = b b = x elif x >= c : c = x print ( a ) print ( b ) print ( c )",
    "label": 0
  },
  {
    "code": "arr = [ ] for _ in range ( 10 ) : arr . append ( int ( input ( ) . strip ( ) ) ) for x in sorted ( arr , reverse = True ) [ : 3 ] : print ( x )",
    "label": 0
  },
  {
    "code": "height_list = [ ] for _ in range ( 0 , 10 ) : height_list . append ( int ( input ( ) ) ) for height in sorted ( height_list ) [ : : - 1 ] [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "a = [ ] for _ in range ( 10 ) : b = int ( input ( ) ) a . append ( b ) a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "M = [ ] for i in range ( 10 ) : M += [ int ( input ( ) ) ] M . sort ( ) for i in range ( 3 ) : print M [ - 1 - i ]",
    "label": 0
  },
  {
    "code": "M = [ ] for i in range ( 1 , 11 ) : i = input ( ) M . append ( int ( i ) ) M . sort ( reverse = True ) print ( M [ 0 ] ) print ( M [ 1 ] ) print ( M [ 2 ] )",
    "label": 0
  },
  {
    "code": "def solve ( ) : from sys import stdin f_i = stdin M = list ( int ( f_i . readline ( ) ) for m in range ( 10 ) ) M . sort ( reverse = True ) print ( * M [ : 3 ] , sep = ' \\n ' ) solve ( )",
    "label": 0
  },
  {
    "code": "m = list ( int ( input ( ) ) for i in range ( 10 ) ) m . sort ( ) h = [ print ( m [ i ] ) for i in range ( 9 , 6 , - 1 ) ]",
    "label": 0
  },
  {
    "code": "print ( \" \\n \" . join ( map ( str , sorted ( int ( input ( ) ) for x in range ( 10 ) ) [ : - 4 : - 1 ] ) ) )",
    "label": 0
  },
  {
    "code": "l = list ( int ( input ( ) ) for i in range ( 10 ) ) l . sort ( ) print ( l [ - 1 ] ) print ( l [ - 2 ] ) print ( l [ - 3 ] )",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for i in range ( 10 ) ] mountains = sorted ( mountains ) rmountains = mountains [ : : - 1 ] for i in range ( 3 ) : print ( rmountains [ i ] )",
    "label": 0
  },
  {
    "code": "T = 10 li = [ ] while T > 0 : H = int ( input ( ) ) li . append ( H ) T -= 1 li . sort ( ) H = len ( li ) print ( li [ H - 1 ] ) print ( li [ H - 2 ] ) print ( li [ H - 3 ] )",
    "label": 0
  },
  {
    "code": "L = [ ] for i in range ( 10 ) : L . append ( int ( input ( ) ) ) L . sort ( reverse = True ) for i in range ( 3 ) : print ( L [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 0 , 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) l = l [ : 3 ] ; for j in l : print ( j ) ;",
    "label": 0
  },
  {
    "code": "mountain = [ ] for i in range ( 10 ) : mountain . append ( int ( input ( ) ) ) mountain . sort ( ) mountain . reverse ( ) for i in range ( 3 ) : print ( mountain [ i ] )",
    "label": 0
  },
  {
    "code": "m = [ int ( input ( ) ) for _ in range ( 10 ) ] m . sort ( reverse = True ) print ( m [ 0 ] ) print ( m [ 1 ] ) print ( m [ 2 ] )",
    "label": 0
  },
  {
    "code": "mountains = list ( ) for i in range ( 10 ) : mountains . append ( int ( input ( ) ) ) for j in range ( 3 ) : print ( mountains . pop ( mountains . index ( max ( mountains ) ) ) )",
    "label": 0
  },
  {
    "code": "lst = [ 0 ] * 10 for i in range ( 10 ) : lst [ i ] = int ( input ( ) ) lst . sort ( reverse = True ) for i in range ( 3 ) : print ( lst [ i ] )",
    "label": 0
  },
  {
    "code": "k = [ ] try : while True : k . append ( int ( input ( ) ) ) except EOFError : pass k . sort ( ) print ( k [ - 1 ] ) print ( k [ - 2 ] ) print ( k [ - 3 ] )",
    "label": 0
  },
  {
    "code": "s = [ ] for i in range ( 10 ) : s . append ( int ( input ( ) ) ) s . sort ( reverse = True ) for i in range ( 3 ) : print ( s [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "a = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "height = [ int ( input ( ) ) for i in range ( 10 ) ] height . sort ( reverse = 1 ) for i in range ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( ) print ( lst [ 9 ] ) print ( lst [ 8 ] ) print ( lst [ 7 ] )",
    "label": 0
  },
  {
    "code": "import sys a = [ ] s = sys . stdin . readline ( ) while s : a . append ( int ( s ) ) s = sys . stdin . readline ( ) a . sort ( ) a . reverse ( ) for i in range ( 3 ) : print ( a [ i ] ) ;",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( ( int ) ( input ( ) ) ) h . sort ( ) h . reverse ( ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( ) print ( list [ - 1 ] ) print ( list [ - 2 ] ) print ( list [ - 3 ] )",
    "label": 0
  },
  {
    "code": "h = [ ] for i in range ( 10 ) : h . append ( ( int ) ( input ( ) ) ) h . sort ( ) h . reverse ( ) for i in range ( 3 ) : print ( h [ i ] )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( reverse = True ) for i in range ( 3 ) : print ( m [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for _ in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) for ll in l [ : 3 ] : print ( ll )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( input ( ) ) a = sorted ( a , key = int , reverse = True ) for i in a [ 0 : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "list = [ ] for x in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( ) print ( list [ 9 ] ) print ( list [ 8 ] ) print ( list [ 7 ] )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( ) print ( lst [ 9 ] ) print ( lst [ 8 ] ) print ( lst [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ ] x = 0 for i in range ( 10 ) : a . append ( int ( input ( ) ) ) for i in range ( 3 ) : x = a . index ( max ( a ) ) print ( a [ x ] ) del a [ x ]",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] a . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) print ( a [ 0 ] ) print ( a [ 1 ] ) print ( a [ 2 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( reverse = True ) for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "[ print ( i ) for i in ( sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) [ : 6 : - 1 ] ) ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 0 , 10 ) : a . append ( int ( input ( ) ) ) a . sort ( ) ; print ( a [ 9 ] ) print ( a [ 8 ] ) print ( a [ 7 ] )",
    "label": 0
  },
  {
    "code": "import sys heights = sorted ( [ int ( h ) for h in sys . stdin ] , reverse = True ) print ( heights [ 0 ] ) print ( heights [ 1 ] ) print ( heights [ 2 ] )",
    "label": 0
  },
  {
    "code": "yama = [ ] for i in range ( 10 ) : yama . append ( int ( input ( ) ) ) yama = sorted ( yama , reverse = True ) for n in range ( 3 ) : print ( yama [ n ] )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 0 , 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) l = l [ : 3 ] for j in l : print ( j )",
    "label": 0
  },
  {
    "code": "l = [ ] for i in range ( 0 , 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) l = l [ : 3 ] for j in l : print ( j )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "lst = [ ] for i in range ( 10 ) : lst . append ( int ( input ( ) ) ) lst . sort ( ) print ( lst [ 9 ] ) print ( lst [ 8 ] ) print ( lst [ 7 ] )",
    "label": 0
  },
  {
    "code": "mou = [ ] for i in range ( 10 ) : mou . append ( int ( input ( ) ) ) mou . sort ( ) print ( mou [ 9 ] ) print ( mou [ 8 ] ) print ( mou [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 0 , 10 ) ] a . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "list1 = [ int ( input ( ) ) for i in range ( 10 ) ] list1 . sort ( ) print ( list1 [ 9 ] ) print ( list1 [ 8 ] ) print ( list1 [ 7 ] )",
    "label": 0
  },
  {
    "code": "a = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] ) print ( a [ 9 ] , a [ 8 ] , a [ 7 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "A = [ ] for i in range ( 10 ) : n = int ( input ( ) ) A . append ( n ) A . sort ( ) A . reverse ( ) for i in range ( 0 , 3 ) : print ( A [ i ] )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "print ( * sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] ) [ : 6 : - 1 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "top_three = [ 0 , 0 , 0 ] for i in range ( 10 ) : input_height = int ( input ( ) ) if top_three [ 0 ] < input_height : top_three [ 2 ] = top_three [ 1 ] top_three [ 1 ] = top_three [ 0 ] top_three [ 0 ] = input_height elif top_three [ 1 ] < input_height : top_three [ 2 ] = top_three [ 1 ] top_three [ 1 ] = input_height elif top_three [ 2 ] < input_height : top_three [ 2 ] = input_height print ( top_three [ 0 ] ) print ( top_three [ 1 ] ) print ( top_three [ 2 ] )",
    "label": 0
  },
  {
    "code": "height = [ ] for i in range ( 10 ) : height . append ( int ( input ( ) ) ) height . sort ( reverse = True ) for i in range ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "height = [ int ( input ( ) ) for i in range ( 10 ) ] height . sort ( reverse = True ) for i in range ( 3 ) : print ( height [ i ] )",
    "label": 0
  },
  {
    "code": "yama = [ ] for i in range ( 10 ) : n = int ( input ( ) ) yama . append ( n ) yama . sort ( reverse = True ) for i in range ( 3 ) : print ( yama [ i ] )",
    "label": 0
  },
  {
    "code": "l = [ int ( input ( ) ) for i in range ( 10 ) ] list . sort ( l ) print ( l [ - 1 ] ) print ( l [ - 2 ] ) print ( l [ - 3 ] )",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : tmp = [ int ( input ( ) ) for _ in range ( 10 ) ] ans = sorted ( tmp , reverse = True ) for i in range ( 3 ) : print ( ans [ i ] )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( ) print ( m [ 9 ] ) print ( m [ 8 ] ) print ( m [ 7 ] )",
    "label": 0
  },
  {
    "code": "list = [ int ( input ( ) ) for i in range ( 10 ) ] for h in sorted ( list , reverse = True ) [ : 3 ] : print h",
    "label": 0
  },
  {
    "code": "height = [ ] for i in range ( 10 ) : height . append ( int ( input ( ) ) ) height . sort ( ) for i in range ( 3 ) : print ( height [ - 1 - i ] )",
    "label": 0
  },
  {
    "code": "high = [ ] for i in range ( 10 ) : high . append ( int ( input ( ) ) ) high . sort ( ) high . reverse ( ) for i in high [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "number = [ ] while ( 1 ) : try : s = int ( input ( \" \" ) ) number . append ( s ) except : break print ( * sorted ( number , reverse = True ) [ 0 : 3 ] , sep = ' \\n ' )",
    "label": 0
  },
  {
    "code": "h = [ 0 ] * 10 for i in range ( 10 ) : h [ i ] = int ( input ( ) ) h . sort ( ) h . reverse ( ) print ( h [ 0 ] ) print ( h [ 1 ] ) print ( h [ 2 ] )",
    "label": 0
  },
  {
    "code": "hills = [ ] for i in range ( 10 ) : hills . append ( int ( input ( ) ) ) hills . sort ( reverse = True ) print ( hills [ 0 ] ) print ( hills [ 1 ] ) print ( hills [ 2 ] )",
    "label": 0
  },
  {
    "code": "N_DATA = 10 input_data = [ int ( input ( ) ) for i in range ( N_DATA ) ] sorted_data = sorted ( input_data , reverse = True ) N_PRINT_DATA = 3 [ print ( sorted_data [ i ] ) for i in range ( N_PRINT_DATA ) ]",
    "label": 0
  },
  {
    "code": "mountain = [ ] for i in range ( 0 , 10 ) : mountain . append ( int ( raw_input ( ) ) ) mountain . sort ( ) mountain . reverse ( ) for i in range ( 0 , 3 ) : print mountain [ i ]",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) for i in range ( 3 ) : c = 0 for sample in a : if c < sample : c = sample print ( c ) a . remove ( c )",
    "label": 0
  },
  {
    "code": "mountain = [ ] for i in range ( 10 ) : mountain . append ( int ( input ( ) ) ) for i in range ( 3 ) : for j in range ( i , 10 ) : if mountain [ i ] < mountain [ j ] : buff_mt = mountain [ i ] mountain [ i ] = mountain [ j ] mountain [ j ] = buff_mt for i in range ( 3 ) : print ( mountain [ i ] )",
    "label": 0
  },
  {
    "code": "from sys import argv , stdin , stderr , stdout heights = [ ] for i in range ( 0 , 10 ) : heights . append ( int ( stdin . readline ( ) ) ) heights . sort ( reverse = True ) for i in range ( 0 , 3 ) : stdout . write ( \" \\n \" % heights [ i ] )",
    "label": 0
  },
  {
    "code": "mount = [ ] for i in range ( 10 ) : mount . append ( int ( input ( ) ) ) mount . sort ( ) for j in range ( 1 , 4 ) : print ( mount [ - j ] )",
    "label": 0
  },
  {
    "code": "top = 0 sec = 0 thi = 0 for num in range ( 10 ) : input_num = input ( ) x = int ( input_num ) if x > top : thi = sec sec = top top = x elif x <= top and x > sec : thi = sec sec = x elif x <= sec and x > thi : thi = x print ( top ) print ( sec ) print ( thi )",
    "label": 0
  },
  {
    "code": "import sys h = [ int ( i ) for i in sys . stdin ] h . sort ( ) print ( h [ - 1 ] ) print ( h [ - 2 ] ) print ( h [ - 3 ] )",
    "label": 0
  },
  {
    "code": "i = 0 arr = list ( ) for i in range ( 10 ) : arr . append ( int ( raw_input ( ) ) ) fst = sec = thr = - 1 for i in range ( 10 ) : if fst < arr [ i ] : thr = sec sec = fst fst = arr [ i ] elif sec < arr [ i ] : thr = sec sec = arr [ i ] elif thr < arr [ i ] : thr = arr [ i ] print fst print sec print thr",
    "label": 0
  },
  {
    "code": "data = [ int ( input ( ) ) for i in range ( 10 ) ] data . sort ( ) for j in range ( 9 , 6 , - 1 ) : print ( data [ j ] )",
    "label": 0
  },
  {
    "code": "j = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] for i in range ( 0 , 10 ) : j [ i ] = int ( input ( ) ) j . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( j [ i ] )",
    "label": 0
  },
  {
    "code": "mnt = [ ] for i in range ( 10 ) : mnt . append ( int ( input ( ) ) ) mnt . sort ( ) print ( f' { mnt [ 9 ] } \\n { mnt [ 8 ] } \\n { mnt [ 7 ] } ' )",
    "label": 0
  },
  {
    "code": "Lheight = [ int ( input ( ) ) for i in range ( 10 ) ] Lheight . sort ( reverse = True ) for j in range ( 3 ) : print ( Lheight [ j ] )",
    "label": 0
  },
  {
    "code": "mountains = [ 0 for i in range ( 10 ) ] for i in range ( 10 ) : mountains [ i ] = int ( input ( ) ) highest1 = mountains [ 0 ] if highest1 < mountains [ 1 ] : highest2 = highest1 highest1 = mountains [ 1 ] else : highest2 = mountains [ 1 ] if highest1 < mountains [ 2 ] : highest2 , highest3 = highest1 , highest2 highest1 = mountains [ 2 ] elif highest2 < mountains [ 2 ] : highest3 = highest2 highest2 = mountains [ 2 ] else : highest3 = mountains [ 2 ] for i in range ( 3 , 10 ) : if highest1 < mountains [ i ] : highest1 , highest2 , highest3 = mountains [ i ] , highest1 , highest2 elif highest2 < mountains [ i ] : highest2 , highest3 = mountains [ i ] , highest2 elif highest3 < mountains [ i ] : highest3 = mountains [ i ] print ( highest1 ) print ( highest2 ) print ( highest3 )",
    "label": 0
  },
  {
    "code": "mt = [ int ( input ( ) ) for i in range ( 10 ) ] mt . sort ( ) mt . reverse ( ) for i in range ( 3 ) : print ( mt [ i ] )",
    "label": 0
  },
  {
    "code": "high = [ 0 ] * 10 for i in range ( 10 ) : high [ i ] = int ( input ( ) ) high . sort ( reverse = True ) for i in range ( 3 ) : print ( high [ i ] )",
    "label": 0
  },
  {
    "code": "list1 = [ ] for i in range ( 1 , 11 ) : list1 . append ( input ( ) ) for x in range ( 1 , 11 ) : for y in range ( 0 , 9 ) : if int ( list1 [ y ] ) < int ( list1 [ y + 1 ] ) : temp = list1 [ y ] list1 [ y ] = list1 [ y + 1 ] list1 [ y + 1 ] = temp print ( list1 [ 0 ] ) print ( list1 [ 1 ] ) print ( list1 [ 2 ] )",
    "label": 0
  },
  {
    "code": "list1 = [ ] for i in range ( 1 , 11 ) : list1 . append ( input ( ) ) for x in range ( 1 , 11 ) : for y in range ( 0 , 9 ) : if list1 [ y ] < list1 [ y + 1 ] : temp = list1 [ y ] list1 [ y ] = list1 [ y + 1 ] list1 [ y + 1 ] = temp print ( list1 [ 0 ] ) print ( list1 [ 1 ] ) print ( list1 [ 2 ] )",
    "label": 0
  },
  {
    "code": "input_arr = [ ] for i in range ( 10 ) : input_arr . append ( int ( input ( ) ) ) input_arr . sort ( reverse = True ) for i in range ( 3 ) : print ( input_arr [ i ] )",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for i in range ( 10 ) ] h . sort ( reverse = True ) for i in h [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "H = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) for i in range ( 3 ) : print ( H [ i ] )",
    "label": 0
  },
  {
    "code": "x = [ ] for i in range ( 10 ) : x . append ( int ( input ( ) ) ) x . sort ( ) for i in reversed ( range ( 7 , 10 ) ) : print ( x [ i ] )",
    "label": 0
  },
  {
    "code": "N = 10 a = [ ] for i in range ( N ) : a . append ( int ( input ( ) ) ) a . sort ( ) for i in range ( 3 ) : print ( a . pop ( ) )",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : lst = [ ] for i in range ( 10 ) : n = int ( input ( ) ) lst . append ( n ) lst . sort ( reverse = True ) for i in range ( 3 ) : print ( lst [ i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 10 ) : list . append ( int ( input ( ) ) ) list . sort ( ) list . reverse ( ) for i in range ( 3 ) : print ( list [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : list = [ int ( input ( ) ) ] a += list srt = sorted ( a ) x = srt [ : 6 : - 1 ] for k in x : print ( k )",
    "label": 0
  },
  {
    "code": "l = [ input ( ) for i in range ( 10 ) ] m = list ( map ( int , l ) ) lst = sorted ( m , reverse = True ) for i in range ( 3 ) : print ( lst [ i ] )",
    "label": 0
  },
  {
    "code": "a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) ) if b > a : tmp = a a = b b = tmp if c > b : tmp = c c = b b = tmp if b > a : tmp = b b = a a = tmp for x in range ( 7 ) : d = int ( input ( ) ) if d > a : c = b b = a a = d elif d > b : c = b b = d elif d > c : c = d print ( a ) print ( b ) print ( c )",
    "label": 0
  },
  {
    "code": "mountain_height = [ ] for i in range ( 10 ) : new_data = int ( input ( ) ) mountain_height . append ( new_data ) mountain_height . sort ( ) mountain_height . reverse ( ) for i in range ( 3 ) : print ( mountain_height [ i ] )",
    "label": 0
  },
  {
    "code": "heights = [ ] for _ in range ( 10 ) : heights . append ( int ( input ( ) ) ) heights . sort ( ) print ( heights [ - 1 ] ) print ( heights [ - 2 ] ) print ( heights [ - 3 ] )",
    "label": 0
  },
  {
    "code": "hills = [ ] for i in range ( 10 ) : hills . append ( int ( input ( ) ) ) for i in range ( 3 ) : print ( max ( hills ) ) hills . remove ( max ( hills ) )",
    "label": 0
  },
  {
    "code": "for h in sorted ( [ int ( input ( ) ) for n in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] : print ( h )",
    "label": 0
  },
  {
    "code": "l = [ ] for _ in range ( 10 ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) for ll in l [ : 3 ] : print ( ll )",
    "label": 0
  },
  {
    "code": "m = [ ] for i in range ( 10 ) : m . append ( int ( input ( ) ) ) m . sort ( ) print ( m [ - 1 ] ) print ( m [ - 2 ] ) print ( m [ - 3 ] )",
    "label": 0
  },
  {
    "code": "High = [ int ( input ( ) ) for i in range ( 10 ) ] High . sort ( reverse = True ) for i in range ( 3 ) : print ( High [ i ] )",
    "label": 0
  },
  {
    "code": "import sys l = [ int ( i ) for i in sys . stdin ] l . sort ( reverse = True ) for i in range ( 0 , 3 ) : print ( l [ i ] )",
    "label": 0
  },
  {
    "code": "a = [ ( 1 << 29 ) * - 1 ] * 3 for i in range ( 10 ) : h = int ( input ( ) ) if h > a [ 0 ] : a [ 2 ] = a [ 1 ] a [ 1 ] = a [ 0 ] a [ 0 ] = h elif h > a [ 1 ] : a [ 2 ] = a [ 1 ] a [ 1 ] = h elif h > a [ 2 ] : a [ 2 ] = h for i in range ( 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "mountains = [ int ( input ( ) ) for i in range ( 10 ) ] mountains . sort ( reverse = True ) print ( ' \\n \\n ' . format ( mountains [ 0 ] , mountains [ 1 ] , mountains [ 2 ] ) )",
    "label": 0
  },
  {
    "code": "hills = [ int ( input ( ) ) for _ in range ( 10 ) ] hills . sort ( reverse = True ) top_3_hills = hills [ : 3 ] for i in top_3_hills : print ( i )",
    "label": 0
  },
  {
    "code": "mountain = sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) ans = mountain [ : 3 ] print ( ' \\n ' . join ( map ( str , ans ) ) )",
    "label": 0
  },
  {
    "code": "height = [ int ( input ( ) ) for _ in range ( 10 ) ] for x in sorted ( height , reverse = True ) [ : 3 ] : print ( x )",
    "label": 0
  },
  {
    "code": "a = list ( map ( int , [ input ( ) for i in range ( 10 ) ] ) ) a . sort ( ) a . reverse ( ) for i in range ( 0 , 3 ) : print ( a [ i ] )",
    "label": 0
  },
  {
    "code": "first = 0 second = 0 third = 0 for i in range ( 10 ) : height = int ( input ( ) ) if first <= height : third = second second = first first = height elif second <= height : third = second second = height elif third <= height : third = height print ( first ) print ( second ) print ( third )",
    "label": 0
  },
  {
    "code": "Mountains = [ ] for x in range ( 10 ) : Mountains . append ( int ( input ( ) ) ) for y in range ( 3 ) : Top_idx = 0 for i in range ( 1 , 10 - y ) : if Mountains [ Top_idx ] < Mountains [ i ] : Top_idx = i print ( Mountains [ Top_idx ] ) Mountains . pop ( Top_idx )",
    "label": 0
  },
  {
    "code": "heights = [ ] for i in range ( 10 ) : n = int ( input ( ) ) heights . append ( n ) heights . sort ( ) print ( heights [ - 1 ] ) print ( heights [ - 2 ] ) print ( heights [ - 3 ] )",
    "label": 0
  },
  {
    "code": "a = [ int ( input ( ) ) for i in range ( 10 ) ] a . sort ( ) for i in range ( 1 , 4 ) : print ( \" %d \" % a [ - i ] )",
    "label": 0
  },
  {
    "code": "list = [ ] for i in range ( 0 , 10 ) : n = int ( raw_input ( ) ) list . append ( n ) list . sort ( reverse = True ) for i in range ( 0 , 3 ) : print list [ i ]",
    "label": 0
  },
  {
    "code": "h = [ int ( input ( ) ) for x in range ( 10 ) ] h_s = sorted ( h , reverse = True ) print ( h_s [ 0 ] ) print ( h_s [ 1 ] ) print ( h_s [ 2 ] )",
    "label": 0
  },
  {
    "code": "xs = [ int ( input ( ) ) for i in range ( 10 ) ] xs = list ( reversed ( sorted ( xs ) ) ) [ : 3 ] [ print ( x ) for x in xs ]",
    "label": 0
  },
  {
    "code": "print ( ' \\n ' . join ( sorted ( [ input ( ) for _ in range ( 10 ) ] , key = int , reverse = True ) [ : 3 ] ) )",
    "label": 0
  },
  {
    "code": "a = [ ] for i in range ( 10 ) : a . append ( int ( input ( ) ) ) ad = sorted ( a , reverse = True ) for i in ad [ : 3 ] : print ( \" {} \" . format ( i ) )",
    "label": 0
  },
  {
    "code": "h_list = [ ] for i in range ( 10 ) : h = int ( input ( ) ) h_list . append ( h ) h_list = sorted ( h_list , reverse = True ) for i in range ( 3 ) : print ( h_list [ i ] )",
    "label": 0
  },
  {
    "code": "s = [ int ( input ( ) ) for i in range ( 10 ) ] s . sort ( reverse = True ) for i in s [ : 3 ] : print ( i )",
    "label": 0
  },
  {
    "code": "height_list = [ ] for i in range ( 0 , 10 ) : height_list . append ( int ( input ( ) ) ) height_list . sort ( ) height_list . reverse ( ) for height in height_list [ : 3 ] : print ( height )",
    "label": 0
  },
  {
    "code": "n = 10 f , s , t = - 1 , - 2 , - 3 for _ in range ( n ) : inp = int ( input ( ) ) if inp > f : f , s , t = inp , f , s elif inp > s : s , t = inp , s elif inp > t : t = inp print ( f ) print ( s ) print ( t )",
    "label": 0
  },
  {
    "code": "import sys import math n = [ ] for i in range ( 0 , 10 ) : n . append ( input ( ) ) n . sort ( ) n = n [ : : - 1 ] for i in range ( 0 , 3 ) : print n [ i ]",
    "label": 0
  },
  {
    "code": "dat = [ int ( raw_input ( ) ) for _ in range ( 10 ) ] dat . sort ( reverse = True ) for i in range ( 3 ) : print dat [ i ]",
    "label": 0
  },
  {
    "code": "height = [ ] for apple in range ( 10 ) : mountain = input ( ) height . insert ( - 1 , mountain ) height . sort ( ) height . reverse ( ) print height [ 0 ] print height [ 1 ] print height [ 2 ]",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : a , b , c = map ( lambda x : int ( x ) ** 2 , input ( ) . split ( ) ) if a + b == c or b + c == a or c + a == b : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( n ) : num = map ( int , raw_input ( ) . split ( ) ) num . sort ( reverse = True ) if num [ 0 ] ** 2 == num [ 1 ] ** 2 + num [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import math N = int ( input ( ) ) for i in range ( N ) : side_len = list ( map ( int , input ( ) . split ( \" \" ) ) ) side_len . sort ( ) if int ( math . pow ( side_len [ 0 ] , 2 ) ) + int ( math . pow ( side_len [ 1 ] , 2 ) ) == int ( math . pow ( side_len [ 2 ] , 2 ) ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for _ in range ( n ) : a , b , c = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) print ( \" YES \" if c ** 2 == a ** 2 + b ** 2 else \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for i in range ( N ) : sides = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if sides [ 0 ] ** 2 + sides [ 1 ] ** 2 == sides [ 2 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for i in range ( N ) : adjacent_side_1 , adjacent_side_2 , hypotenuse = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if adjacent_side_1 ** 2 + adjacent_side_2 ** 2 == hypotenuse ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in range ( int ( n ) ) : a , b , c = list ( map ( int , input ( ) . split ( ) ) ) a , b , c = int ( a ) , int ( b ) , int ( c ) if a ** 2 + b ** 2 == c ** 2 or c ** 2 + a ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for _ in range ( n ) : a , b , c = list ( map ( int , input ( ) . split ( ) ) ) if a ** 2 + b ** 2 == c ** 2 or c ** 2 + b ** 2 == a ** 2 or a ** 2 + c ** 2 == b ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : p = list ( map ( int , input ( ) . split ( ) ) ) p . sort ( ) a = p [ 0 ] b = p [ 1 ] c = p [ 2 ] if a * a + b * b == c * c : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : p = list ( map ( int , input ( ) . split ( \" \" ) ) ) p . sort ( ) a = p [ 0 ] b = p [ 1 ] c = p [ 2 ] if pow ( a , 2 ) + pow ( b , 2 ) == pow ( c , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : p = list ( map ( int , input ( ) . split ( \" \" ) ) ) p . sort ( ) if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : p = list ( map ( int , input ( ) . split ( \" \" ) ) ) p . sort ( ) if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : a , b , c = input ( ) . split ( ) x = int ( a ) y = int ( b ) z = int ( c ) p = [ x , y , z ] p . sort ( ) if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : a , b , c = input ( ) . split ( ) x = int ( a ) y = int ( b ) z = int ( c ) p = [ x , y , z ] p . sort ( ) if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : p = list ( map ( int , input ( ) . split ( \" \" ) ) ) p . sort ( ) if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : tri_list = list ( map ( int , input ( ) . split ( \" \" ) ) ) tri_list . sort ( ) a = int ( tri_list [ 2 ] ) ** 2 b = int ( tri_list [ 0 ] ) ** 2 + int ( tri_list [ 1 ] ) ** 2 if a == b : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : a , b , c = input ( ) . split ( ) x = int ( a ) y = int ( b ) z = int ( c ) p = [ x , y , z ] p . sort ( ) if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : tri_list = list ( map ( int , input ( ) . split ( \" \" ) ) ) tri_list . sort ( ) a = int ( tri_list [ 2 ] ) ** 2 b = int ( tri_list [ 0 ] ) ** 2 + int ( tri_list [ 1 ] ) ** 2 if a == b : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : tri_list = list ( map ( int , input ( ) . split ( \" \" ) ) ) tri_list . sort ( ) a = int ( tri_list [ 2 ] ) ** 2 b = int ( tri_list [ 0 ] ) ** 2 + int ( tri_list [ 1 ] ) ** 2 if a == b : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : values = sorted ( map ( lambda x : int ( x ) ** 2 , input ( ) . split ( ' ' ) ) ) if values [ 2 ] == values [ 1 ] + values [ 0 ] : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : values = sorted ( map ( lambda x : int ( x ) ** 2 , input ( ) . split ( ' ' ) ) ) if values [ 2 ] == values [ 1 ] + values [ 0 ] : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for i in range ( N ) : a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if ( a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : x , y , z = map ( int , input ( ) . split ( ) ) if x * x + y * y == z * z or y * y + z * z == x * x or x * x + z * z == y * y : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( 0 , n ) : a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) print ( \" YES \" if c * c == a * a + b * b else \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for _ in xrange ( n ) : ls = sorted ( map ( int , raw_input ( ) . split ( ) ) ) if ls [ 2 ] ** 2 == ls [ 0 ] ** 2 + ls [ 1 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( 0 , n ) : a , b , c = sorted ( map ( int , input ( ) . strip ( \" \\n \" ) . split ( \" \" ) ) ) if c * c - ( a * a + b * b ) == 0 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in range ( n ) : l = map ( int , raw_input ( ) . split ( ) ) l . sort ( ) if ( l [ 0 ] * l [ 0 ] + l [ 1 ] * l [ 1 ] == l [ 2 ] * l [ 2 ] ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "rep = input ( ) while rep : rep -= 1 [ a , b , c ] = map ( int , raw_input ( ) . split ( ) ) if b < a and c < a : a ** = 2 b = b ** 2 + c ** 2 elif a < b and c < b : a = a ** 2 + c ** 2 b **= 2 else : a = a ** 2 + b ** 2 b = c ** 2 if a == b : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "n = raw_input ( ) while 1 : try : a = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) a . reverse ( ) if a [ 0 ] ** 2 == a [ 1 ] ** 2 + a [ 2 ] ** 2 : print \" YES \" else : print \" NO \" except EOFError : break",
    "label": 0
  },
  {
    "code": "import itertools def check ( a , b , c ) : for p in itertools . permutations ( [ a , b , c ] ) : ( x , y , z ) = p if x * x + y * y == z * z : return True return False n = input ( ) for i in range ( n ) : ( a , b , c ) = map ( eval , raw_input ( ) . split ( ) ) if check ( a , b , c ) : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( n ) : edge = map ( int , raw_input ( ) . split ( \" \" ) ) e0 = edge [ 0 ] * edge [ 0 ] e1 = edge [ 1 ] * edge [ 1 ] e2 = edge [ 2 ] * edge [ 2 ] ret = \" NO \" if ( edge [ 0 ] > edge [ 1 ] ) and ( edge [ 0 ] > edge [ 2 ] ) : if ( e0 - e1 - e2 ) == 0 : ret = \" YES \" if ( edge [ 1 ] > edge [ 0 ] ) and ( edge [ 1 ] > edge [ 2 ] ) : if ( e1 - e0 - e2 ) == 0 : ret = \" YES \" if ( edge [ 2 ] > edge [ 0 ] ) and ( edge [ 2 ] > edge [ 1 ] ) : if ( e2 - e0 - e1 ) == 0 : ret = \" YES \" print ret",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : edge = input ( ) . split ( ) edge = [ int ( j ) for j in edge ] edge . sort ( ) if ( edge [ 0 ] ** 2 + edge [ 1 ] ** 2 == edge [ 2 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "import sys N = int ( raw_input ( ) ) for line in sys . stdin : a , b , c = sorted ( map ( int , line . split ( ) ) ) if a ** 2 + b ** 2 == c ** 2 : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "import sys data_list = [ ] for s in sys . stdin : data_list . append ( map ( int , s . split ( ) ) ) for e in data_list [ 1 : ] : e . sort ( ) if e [ 0 ] * e [ 0 ] + e [ 1 ] * e [ 1 ] == e [ 2 ] * e [ 2 ] : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import math import itertools for i in range ( int ( input ( ) ) ) : a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) print ( ' YES ' if a * a + b * b == c * c else ' NO ' )",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in range ( n ) : s = map ( int , raw_input ( ) . split ( ) ) s . sort ( ) if s [ 2 ] ** 2 == ( s [ 0 ] ** 2 ) + ( s [ 1 ] ** 2 ) : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys data_list = sys . stdin . readlines ( ) data_length = int ( data_list . pop ( 0 ) ) for x in xrange ( data_length ) : lines = map ( int , data_list [ x ] . strip ( ) . split ( ) ) lines . sort ( reverse = True ) if lines [ 0 ] ** 2 == ( lines [ 1 ] ** 2 + lines [ 2 ] ** 2 ) : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for i in range ( N ) : a , b , c = map ( int , input ( ) . split ( ) ) flg = 0 if a * a + b * b == c * c : flg = 1 if c * c + a * a == b * b : flg = 1 if b * b + c * c == a * a : flg = 1 if flg == 1 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "for _ in range ( int ( input ( ) ) ) : a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) print ( \" YES \" ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 else print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "def pascal ( xdata ) : for x in xrange ( 3 ) : for y in xrange ( 3 ) : for z in xrange ( 3 ) : if xdata [ x ] ** 2 + xdata [ y ] ** 2 == xdata [ z ] ** 2 : return True return False N = input ( ) data = [ map ( int , raw_input ( ) . split ( ) ) for x in range ( N ) ] for x in data : if pascal ( x ) : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys n = int ( raw_input ( ) ) while True : try : a = sorted ( map ( int , raw_input ( ) . split ( ) ) ) print \" YES \" if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 else \" NO \" except : break",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) while n : n -= 1 lis = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) : for j in range ( i + 1 , 3 ) : if lis [ i ] < lis [ j ] : a = lis [ i ] lis [ i ] = lis [ j ] lis [ j ] = a c , a , b = lis if c ** 2 == a ** 2 + b ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : edge = input ( ) . split ( ) edge = [ int ( j ) for j in edge ] edge . sort ( ) if edge [ 2 ] ** 2 == edge [ 0 ] ** 2 + edge [ 1 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "def check_right_triangle ( side1 , side2 , side3 ) : pow = 2 if side1 ** pow == side2 ** pow + side3 ** pow : return True if side2 ** pow == side3 ** pow + side1 ** pow : return True if side3 ** pow == side1 ** pow + side2 ** pow : return True return False def check ( ) : for i in range ( int ( raw_input ( ) ) ) : sides = map ( int , raw_input ( ) . split ( ) ) if check_right_triangle ( sides [ 0 ] , sides [ 1 ] , sides [ 2 ] ) : print \" YES \" else : print \" NO \" if __name__ == \" __main__ \" : check ( )",
    "label": 0
  },
  {
    "code": "import sys raw_input ( ) for line in sys . stdin . readlines ( ) : a , b , c = map ( int , line . strip ( ) . split ( ) ) input_list = [ a , b , c ] input_list . sort ( ) if input_list [ 2 ] ** 2 == input_list [ 0 ] ** 2 + input_list [ 1 ] ** 2 : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "import sys n = int ( sys . stdin . readline ( ) ) for _ in range ( n ) : a , b , c = sorted ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) print ( ' YES ' if a * a + b * b == c * c else ' NO ' )",
    "label": 0
  },
  {
    "code": "N = input ( ) for i in range ( N ) : a , b , c = map ( int , raw_input ( ) . split ( ) ) t1 = a ** 2 + b ** 2 == c ** 2 t2 = b ** 2 + c ** 2 == a ** 2 t3 = c ** 2 + a ** 2 == b ** 2 if t1 or t2 or t3 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "import math n = input ( ) for i in range ( n ) : flag = 0 a = map ( int , raw_input ( ) . split ( ) ) if ( pow ( a [ 0 ] , 2 ) + pow ( a [ 1 ] , 2 ) == pow ( a [ 2 ] , 2 ) ) : flag = 1 if ( pow ( a [ 1 ] , 2 ) + pow ( a [ 2 ] , 2 ) == pow ( a [ 0 ] , 2 ) ) : flag = 1 if ( pow ( a [ 2 ] , 2 ) + pow ( a [ 0 ] , 2 ) == pow ( a [ 1 ] , 2 ) ) : flag = 1 if flag == 1 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "def right_triangle ( edge ) : return ( edge [ 0 ] ** 2 + edge [ 1 ] ** 2 == edge [ 2 ] ** 2 ) n = int ( input ( ) ) for i in range ( n ) : edge = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) if right_triangle ( edge ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "def right_triangle ( edge ) : return ( edge [ 0 ] ** 2 + edge [ 1 ] ** 2 == edge [ 2 ] ** 2 ) n = int ( input ( ) ) for i in range ( n ) : edge = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) if right_triangle ( edge ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for k in range ( n ) : [ a , b , c ] = map ( int , raw_input ( ) . split ( ) ) a , b , c = sorted ( [ a , b , c ] ) if a ** 2 + b ** 2 == c ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "a = int ( input ( ) ) for i in range ( a ) : l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if ( l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = input ( ) for n in range ( n ) : inputs = map ( int , raw_input ( ) . split ( ) ) if inputs [ 0 ] ** 2 == inputs [ 1 ] ** 2 + inputs [ 2 ] ** 2 or \\ inputs [ 1 ] ** 2 == inputs [ 0 ] ** 2 + inputs [ 2 ] ** 2 or \\ inputs [ 2 ] ** 2 == inputs [ 0 ] ** 2 + inputs [ 1 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( n ) : temp = [ int ( x ) for x in raw_input ( ) . split ( ) ] temp . sort ( reverse = True ) if temp [ 0 ] ** 2 == temp [ 1 ] ** 2 + temp [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys n = int ( sys . stdin . readline ( ) ) for i in range ( n ) : sides = [ int ( k ) for k in sys . stdin . readline ( ) . split ( ) ] sides . sort ( ) if sides [ 0 ] ** 2 + sides [ 1 ] ** 2 == sides [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "for i in range ( input ( ) ) : x = raw_input ( ) L = map ( int , x . split ( \" \" ) ) L . sort ( ) if L [ 0 ] ** 2 + L [ 1 ] ** 2 == L [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "count = int ( input ( ) ) for i in range ( 0 , count ) : a = map ( int , input ( ) . split ( ' ' ) ) a = [ j ** 2 for j in a ] a . sort ( ) if ( a [ 0 ] + a [ 1 ] == a [ 2 ] ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) x . sort ( ) if x [ 0 ] ** 2 + x [ 1 ] ** 2 == x [ 2 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "N = int ( raw_input ( ) ) for i in range ( N ) : a = range ( 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( 0 , n ) : li = map ( int , raw_input ( ) . split ( ) ) li . sort ( ) if li [ 0 ] ** 2 + li [ 1 ] ** 2 == li [ 2 ] ** 2 : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : ( a , b , c ) = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if ( a ** 2 ) + ( b ** 2 ) == ( c ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : s = input ( ) . split ( \" \" ) s = [ int ( j ) for j in s ] s . sort ( ) if ( s [ 0 ] ** 2 + s [ 1 ] ** 2 == s [ 2 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : for i in range ( int ( raw_input ( ) ) ) : nums = map ( lambda x : x ** 2 , map ( int , raw_input ( ) . split ( ) ) ) flg = False for i in range ( 3 ) : s = int ( 0 ) for j in range ( 3 ) : if i == j : continue s += nums [ j ] if s == nums [ i ] : flg = True if flg == True : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "if __name__ == ' __main__ ' : for i in range ( int ( raw_input ( ) ) ) : nums = map ( lambda x : x ** 2 , map ( int , raw_input ( ) . split ( ) ) ) nums . sort ( ) if nums [ 0 ] + nums [ 1 ] == nums [ 2 ] : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "for a , b , c in [ sorted ( map ( int , raw_input ( ) . split ( ) ) ) for i in range ( input ( ) ) ] : print \" NO \" if c * c - a * a - b * b else \" YES \"",
    "label": 0
  },
  {
    "code": "n = input ( ) a = [ ] for i in range ( n ) : a = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if ( a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 ) : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "def comp ( items ) : return ( items [ 0 ] ** 2 + items [ 1 ] ** 2 == items [ 2 ] ** 2 ) def main ( ) : n = int ( input ( ) ) items = [ 0 ] * 3 for tm in range ( n ) : str = ( input ( ) ) . split ( ) for i in range ( 3 ) : items [ i ] = int ( str [ i ] ) items . sort ( ) if ( comp ( items ) ) : print ( \" YES \" ) else : print ( \" NO \" ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "def main ( ) : input_line = raw_input ( ) N = int ( input_line ) for i in range ( N ) : input_line = raw_input ( ) num_lis = [ ] for num in input_line . split ( ' ' ) : num_lis . append ( int ( num ) ) num_lis . sort ( reverse = True ) if num_lis [ 0 ] ** 2 == num_lis [ 1 ] ** 2 + num_lis [ 2 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "num = int ( input ( ) ) for i in range ( num ) : a = list ( map ( int , input ( ) . split ( \" \" ) ) ) a . sort ( ) if ( a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "numberOfDataSets = 0 sideLengthList = [ ] while 1 : try : data = raw_input ( ) . split ( ) if len ( data ) == 1 : numberOfDataSets = int ( data [ 0 ] ) if numberOfDataSets != 0 : sideLengthList = [ ] elif len ( data ) == 3 and numberOfDataSets != 0 : numberOfDataSets -= 1 sideLengthList . append ( data ) if numberOfDataSets == 0 : for i in range ( 0 , len ( sideLengthList ) ) : a = int ( sideLengthList [ i ] [ 0 ] ) * int ( sideLengthList [ i ] [ 0 ] ) b = int ( sideLengthList [ i ] [ 1 ] ) * int ( sideLengthList [ i ] [ 1 ] ) c = int ( sideLengthList [ i ] [ 2 ] ) * int ( sideLengthList [ i ] [ 2 ] ) if a + b == c or b + c == a or c + a == b : print \" YES \" else : print \" NO \" except : break",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) i = 0 while ( i < n ) : L = map ( int , raw_input ( ) . split ( ) ) L . sort ( reverse = True ) if ( pow ( L [ 0 ] , 2 ) == pow ( L [ 1 ] , 2 ) + pow ( L [ 2 ] , 2 ) ) : print \" YES \" else : print \" NO \" i += 1",
    "label": 0
  },
  {
    "code": "import sys n = int ( input ( ) ) for i in range ( n ) : a = sorted ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) print ( ' YES ' if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 else ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : a = sorted ( map ( int , input ( ) . split ( ) ) ) print ( ' YES ' if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 else ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( n ) : side = sorted ( map ( int , raw_input ( ) . split ( ' ' ) ) ) if side [ 0 ] ** 2 + side [ 1 ] ** 2 - side [ 2 ] ** 2 : print ' NO ' else : print ' YES '",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in range ( 0 , n ) : num = map ( int , raw_input ( ) . split ( ) ) num . sort ( ) a = num [ 0 ] b = num [ 1 ] c = num [ 2 ] if c * c == a * a + b * b : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "num = int ( input ( ) ) for j in range ( num ) : inputed = list ( map ( int , input ( ) . split ( ) ) ) maxIndex = inputed . index ( max ( inputed ) ) judger = 0 ; for k in range ( 3 ) : if ( maxIndex != k ) : judger + = inputed [ k ] ** 2 if judger == ( inputed [ maxIndex ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "times = int ( input ( ) ) for i in range ( 0 , times ) : edge = [ ] for e in input ( ) . split ( \" \" ) : edge . append ( int ( e ) ) edge . sort ( ) if pow ( int ( edge [ 0 ] ) , 2 ) + pow ( int ( edge [ 1 ] ) , 2 ) == pow ( int ( edge [ 2 ] ) , 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "for val in range ( input ( ) ) : x = map ( int , raw_input ( ) . split ( ' ' ) ) x . sort ( ) if x [ 0 ] ** 2 + x [ 1 ] ** 2 == x [ 2 ] ** 2 : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "count = input ( ) for i in range ( count ) : l = map ( int , raw_input ( ) . split ( ) ) l . sort ( ) if ( l [ 2 ] ** 2 == l [ 0 ] ** 2 + l [ 1 ] ** 2 ) : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys N = ( int ) ( raw_input ( ) ) a = [ 0 , 0 , 0 ] for i in range ( N ) : a [ 0 ] , a [ 1 ] , a [ 2 ] = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for i in range ( N ) : num = list ( map ( int , input ( ) . split ( ) ) ) num . sort ( ) if num [ 0 ] ** 2 + num [ 1 ] ** 2 == num [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for i in range ( N ) : num = sorted ( map ( int , input ( ) . split ( ) ) ) if num [ 0 ] ** 2 + num [ 1 ] ** 2 == num [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : li = sorted ( [ int ( j ) for j in input ( ) . split ( ) ] ) print ( \" YES \" if li [ 0 ] ** 2 + li [ 1 ] ** 2 == li [ 2 ] ** 2 else \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) while n > 0 : l = [ int ( i ) for i in input ( ) . split ( ) ] l . sort ( ) if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' ) n -= 1",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in range ( n ) : a , b , c = sorted ( map ( int , raw_input ( ) . split ( ) ) ) if c ** 2 == a ** 2 + b ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for line in range ( N ) : a , b , c = ( int ( i ) for i in input ( ) . split ( ) ) if ( a ** 2 + b ** 2 == c ** 2 ) or ( b ** 2 + c ** 2 == a ** 2 ) or ( c ** 2 + a ** 2 == b ** 2 ) : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in range ( n ) : a , b , c = map ( int , raw_input ( ) . strip ( ) . split ( ' ' ) ) if a * a + b * b == c * c or a * a + c * c == b * b or c * c + b * b == a * a : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys size = int ( sys . stdin . readline ( ) ) for i in range ( size ) : line = sys . stdin . readline ( ) line = line . split ( \" \" ) inp = [ ] for j in line : inp . append ( int ( j ) ) inp . sort ( ) if ( inp [ 0 ] ** 2 + inp [ 1 ] ** 2 == inp [ 2 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "import sys N = int ( sys . stdin . readline ( ) ) ans = [ ] for i in range ( N ) : tri = sys . stdin . readline ( ) [ : - 1 ] . split ( ' ' , 3 ) newlist = [ ] for n in tri : newlist . append ( int ( n ) ) newlist . sort ( ) if newlist [ 0 ] * newlist [ 0 ] + newlist [ 1 ] * newlist [ 1 ] == newlist [ 2 ] * newlist [ 2 ] : ans . append ( \" YES \" ) else : ans . append ( \" NO \" ) for a in ans : print ( a )",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : a = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) if a [ 0 ] ** 2 == a [ 1 ] ** 2 + a [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) a = [ ] c = [ ] for i in range ( n ) : a . append ( [ ] ) for j in range ( 3 ) : a [ i ] . append ( [ ] ) for i in range ( n ) : a [ i ] [ 0 ] , a [ i ] [ 1 ] , a [ i ] [ 2 ] = map ( int , input ( ) . split ( ) ) a [ i ] . sort ( ) if ( ( ( a [ i ] [ 0 ] * a [ i ] [ 0 ] ) + ( a [ i ] [ 1 ] * a [ i ] [ 1 ] ) ) == ( a [ i ] [ 2 ] * a [ i ] [ 2 ] ) ) : k = \" YES \" c . append ( k ) else : k = \" NO \" c . append ( k ) for i in range ( n ) : print ( c [ i ] )",
    "label": 0
  },
  {
    "code": "n = input ( ) for x in xrange ( n ) : sides = map ( int , raw_input ( ) . split ( ) ) sides = sorted ( sides ) if sides [ 0 ] ** 2 + sides [ 1 ] ** 2 == sides [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in xrange ( n ) : li = map ( int , raw_input ( ) . split ( ) ) li . sort ( ) if li [ 0 ] ** 2 + li [ 1 ] ** 2 == li [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "a = int ( input ( ) ) for _ in range ( a ) : b , c , d = sorted ( map ( int , input ( ) . split ( ) ) ) if b ** 2 + c ** 2 == d ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( raw_input ( ) ) for n in range ( N ) : data_set = map ( int , raw_input ( ) . split ( ) ) a = data_set [ 0 ] b = data_set [ 1 ] c = data_set [ 2 ] if ( a ** 2 + b ** 2 ) == ( c ** 2 ) or ( a ** 2 + c ** 2 ) == ( b ** 2 ) or ( b ** 2 + c ** 2 ) == ( a ** 2 ) : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys input ( ) print ( ' \\n ' . join ( ' YES ' if t [ 0 ] ** 2 + t [ 1 ] ** 2 == t [ 2 ] ** 2 else ' NO ' for t in [ sorted ( map ( int , l . split ( ) ) ) for l in sys . stdin ] ) )",
    "label": 0
  },
  {
    "code": "N = input ( ) a = [ ] for i in range ( N ) : a = map ( int , raw_input ( ) . split ( ) ) b = [ 0 ] for i in a : j = 0 while j < 3 : if i > b [ j ] : b . insert ( j , i ) break j += 1 if b [ 0 ] ** 2 == b [ 1 ] ** 2 + b [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "num = int ( input ( ) ) for i in range ( num ) : a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == ( a [ 2 ] ) ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "import string import sys import math ip = sys . stdin . readlines ( ) ip_list = { } for i in range ( len ( ip ) ) : ip_list [ i ] = ip [ i ] . strip ( \" \\n \" ) . split ( ) for i in range ( 1 , len ( ip ) ) : for j in range ( 3 ) : for t in range ( 3 ) : for k in range ( 3 ) : if int ( ip_list [ i ] [ t ] ) > int ( ip_list [ i ] [ k ] ) : tmp = ip_list [ i ] [ t ] ip_list [ i ] [ t ] = ip_list [ i ] [ k ] ip_list [ i ] [ k ] = tmp for i in range ( 1 , len ( ip ) ) : if int ( ip_list [ i ] [ 0 ] ) ** 2 == int ( ip_list [ i ] [ 1 ] ) ** 2 + int ( ip_list [ i ] [ 2 ] ) ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) ary = [ ] ans = [ ] for i in range ( N ) : ary . append ( list ( map ( int , ( input ( ) . split ( ) ) ) ) ) if 2 * max ( ary [ - 1 ] ) ** 2 == sum ( ary [ - 1 ] [ j ] ** 2 for j in range ( 3 ) ) : ans . append ( ' YES ' ) else : ans . append ( ' NO ' ) print ( ' \\n ' . join ( ans ) )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( n ) : a = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if ( a [ 0 ] ** 2 + a [ 1 ] ** 2 ) == a [ 2 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "import sys n = int ( raw_input ( ) ) a = [ 0 , 0 , 0 ] for i in range ( n ) : a [ 0 ] , a [ 1 ] , a [ 2 ] = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) a = [ 0 , 0 , 0 ] for i in range ( n ) : a [ 0 ] , a [ 1 ] , a [ 2 ] = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in xrange ( n ) : tmp = map ( int , raw_input ( ) . split ( ) ) if tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 == tmp [ 2 ] ** 2 or tmp [ 1 ] ** 2 + tmp [ 2 ] ** 2 == tmp [ 0 ] ** 2 or tmp [ 2 ] ** 2 + tmp [ 0 ] ** 2 == tmp [ 1 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "i = input ( ) q = [ ] for n in range ( i ) : l = map ( int , raw_input ( ) . split ( ) ) a = min ( l ) l . remove ( min ( l ) ) b = min ( l ) c = max ( l ) if a ** 2 + b ** 2 == c ** 2 : q . append ( \" YES \" ) else : q . append ( \" NO \" ) for s in xrange ( len ( q ) ) : print ( q [ 0 ] ) q . pop ( 0 )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : A = [ int ( j ) for j in input ( ) . split ( ) ] A . sort ( ) if A [ 0 ] ** 2 + A [ 1 ] ** 2 == A [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "x = input ( ) for i in xrange ( x ) : inp = map ( int , raw_input ( ) . split ( ) ) inp . sort ( ) if inp [ 2 ] ** 2 == inp [ 0 ] ** 2 + inp [ 1 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : s = input ( ) . split ( \" \" ) s = [ int ( j ) for j in s ] s . sort ( ) a = s [ 0 ] b = s [ 1 ] c = s [ 2 ] if ( a ** 2 + b ** 2 == c ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for n in range ( N ) : sides = list ( map ( int , input ( ) . split ( ) ) ) sides . sort ( ) if sides [ - 1 ] ** 2 == sides [ - 2 ] ** 2 + sides [ - 3 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "N = int ( raw_input ( ) ) for i in range ( N ) : a , b , c = map ( int , raw_input ( ) . split ( ) ) if a > c : a , c = c , a if b > c : b , c = c , b if a * a + b * b == c * c : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for cnt in range ( n ) : t = list ( map ( int , input ( ) . split ( ) ) ) t . sort ( ) if t [ 2 ] ** 2 == t [ 1 ] ** 2 + t [ 0 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "N = int ( raw_input ( ) ) dataList = [ ] for i in range ( N ) : list = map ( int , raw_input ( ) . split ( ) ) dataList . append ( list ) for i in range ( len ( dataList ) ) : idx = dataList [ i ] . index ( max ( dataList [ i ] ) ) lar = dataList [ i ] [ idx ] del dataList [ i ] [ idx ] if lar ** 2 == dataList [ i ] [ 0 ] ** 2 + dataList [ i ] [ 1 ] ** 2 : print \" YES \" else : print \" NO \"",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : a , b , c = map ( int , input ( ) . split ( \" \" ) ) if a ** 2 == b ** 2 + c ** 2 : print ( \" YES \" ) elif b ** 2 == a ** 2 + c ** 2 : print ( \" YES \" ) elif c ** 2 == a ** 2 + b ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : set = input ( ) . split ( ) set = [ int ( a ) for a in set ] set . sort ( ) if set [ 0 ] ** 2 + set [ 1 ] ** 2 == set [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "delta = int ( input ( ) ) tri_all = [ ] for i in range ( delta ) : tri = list ( map ( int , input ( ) . split ( ' ' ) ) ) tri . sort ( ) tri_all . append ( tri ) for i in range ( len ( tri_all ) ) : if tri_all [ i ] [ 0 ] ** 2 + tri_all [ i ] [ 1 ] ** 2 == tri_all [ i ] [ 2 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = input ( ) for i in xrange ( n ) : a , b , c = map ( int , raw_input ( ) . split ( ) ) if a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "def check ( List ) : List . sort ( ) List . reverse ( ) if List [ 0 ] ** 2 == List [ 1 ] ** 2 + List [ 2 ] ** 2 : return \" YES \" else : return \" NO \" N = input ( ) for i in range ( N ) : list = map ( int , raw_input ( ) . split ( ) ) print check ( list )",
    "label": 0
  },
  {
    "code": "def get_input ( ) : for i in range ( int ( input ( ) ) ) : yield \" \" . join ( input ( ) ) if __name__ == \" __main__ \" : array = list ( get_input ( ) ) for i in range ( len ( array ) ) : a , b , c = array [ i ] . split ( ) if int ( a ) ** 2 + int ( b ) ** 2 == int ( c ) ** 2 : print ( u\" YES \" ) elif int ( c ) ** 2 + int ( a ) ** 2 == int ( b ) ** 2 : print ( u\" YES \" ) elif int ( b ) ** 2 + int ( c ) ** 2 == int ( a ) ** 2 : print ( u\" YES \" ) else : print ( u\" NO \" )",
    "label": 0
  },
  {
    "code": "def main ( ) : num = int ( input ( ) ) for i in range ( num ) : tri = [ int ( x ) for x in input ( ) . split ( \" \" ) ] tri . sort ( ) if tri [ 2 ] ** 2 == tri [ 0 ] ** 2 + tri [ 1 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "import itertools import operator line = int ( input ( ) ) inputs = [ input ( ) for _ in range ( line ) ] def is_right_triangle ( a , b , c ) : a , b , c = list ( sorted ( [ a , b , c ] ) ) return a ** 2 + b ** 2 == c ** 2 for line in inputs : a , b , c = line . split ( ) print ( \" YES \" if is_right_triangle ( int ( a ) , int ( b ) , int ( c ) ) else \" NO \" )",
    "label": 0
  },
  {
    "code": "for i in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) if a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) a_list = [ ] for i in range ( n ) : k = list ( map ( int , input ( ) . split ( \" \" ) ) ) L , M , N = sorted ( k ) if L ** 2 + M ** 2 == N ** 2 : a_list . append ( \" YES \" ) else : a_list . append ( \" NO \" ) for i in a_list : print ( i )",
    "label": 0
  },
  {
    "code": "import sys r = [ ] n = int ( input ( ) ) l = sys . stdin . readlines ( ) for i in l : x , y , z = sorted ( map ( lambda x : x * x , map ( int , i . split ( ) ) ) ) if x + y == z : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "import sys n = int ( input ( ) ) l = sys . stdin . readlines ( ) s = \" \" for i in l : x , y , z = sorted ( map ( lambda x : x * x , map ( int , i . split ( ) ) ) ) if x + y == z : s + = \" \\n \" else : s + = \" \\n \" print ( s , end = \" \" )",
    "label": 0
  },
  {
    "code": "import sys n = int ( sys . stdin . readline ( ) ) l = sys . stdin . readlines ( ) s = \" \" for i in l : x , y , z = sorted ( map ( lambda x : x * x , map ( int , i . split ( ) ) ) ) if x + y == z : s + = \" \\n \" else : s + = \" \\n \" print ( s , end = \" \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) s = \" \" for i in range ( n ) : l = list ( map ( lambda x : x * x , map ( int , input ( ) . split ( ) ) ) ) l . sort ( ) if l [ 0 ] + l [ 1 ] == l [ 2 ] : s + = \" \\n \" else : s + = \" \\n \" print ( s , end = \" \" )",
    "label": 0
  },
  {
    "code": "num = int ( input ( ) ) for i in range ( num ) : ls = list ( [ int ( i ) for i in input ( ) . split ( ) ] ) ls . sort ( ) if ls [ 0 ] ** 2 + ls [ 1 ] ** 2 == ls [ 2 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "line = int ( input ( ) ) for i in range ( line ) : a , b , c = sorted ( [ int ( i ) for i in input ( ) . split ( ' ' ) ] ) if a ** 2 + b ** 2 == c ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "n = int ( raw_input ( ) ) for i in range ( n ) : a = map ( int , raw_input ( ) . split ( ) ) a . sort ( ) if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "N = int ( input ( ) ) for _ in range ( N ) : a = sorted ( map ( int , input ( ) . split ( ) ) ) if a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "n = int ( input ( ) ) for i in range ( n ) : side = list ( map ( int , input ( ) . split ( ) ) ) side . sort ( ) if ( side [ 0 ] ** 2 + side [ 1 ] ** 2 == side [ 2 ] ** 2 ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "def IsRightTriangle ( tri ) : tri . sort ( ) return tri [ 0 ] ** 2 + tri [ 1 ] ** 2 == tri [ 2 ] ** 2 N = eval ( input ( ) ) for i in range ( N ) : tri = [ eval ( item ) for item in input ( ) . split ( ) ] print ( ' YES ' if IsRightTriangle ( tri ) else ' NO ' )",
    "label": 0
  },
  {
    "code": "for _ in range ( int ( input ( ) ) ) : l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 : print ( ' YES ' ) else : print ( ' NO ' )",
    "label": 0
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { private static Scanner scan ; public static void main ( String a [ ] ) { scan = new Scanner ( System . in ) ; int [ ] list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { list [ i ] = scan . nextInt ( ) ; } Arrays . sort ( list ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( list [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int scInt ; int [ ] check = new int [ 3 ] ; while ( sc . hasNext ( ) ) { scInt = sc . nextInt ( ) ; if ( check [ 0 ] < scInt ) { check [ 2 ] = check [ 1 ] ; check [ 1 ] = check [ 0 ] ; check [ 0 ] = scInt ; } else if ( check [ 1 ] < scInt ) { check [ 2 ] = check [ 1 ] ; check [ 1 ] = scInt ; } else if ( check [ 2 ] < scInt ) { check [ 2 ] = scInt ; } else { } } System . out . println ( check [ 0 ] ) ; System . out . println ( check [ 1 ] ) ; System . out . println ( check [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] foo = { sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) } ; Arrays . sort ( foo , Collections . reverseOrder ( ) ) ; System . out . println ( foo [ 0 ] ) ; System . out . println ( foo [ 1 ] ) ; System . out . println ( foo [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] yama = { sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) } ; Arrays . sort ( yama , Collections . reverseOrder ( ) ) ; System . out . println ( yama [ 0 ] ) ; System . out . println ( yama [ 1 ] ) ; System . out . println ( yama [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] yama = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { yama [ i ] = sc . nextInt ( ) ; } Arrays . sort ( yama , Collections . reverseOrder ( ) ) ; System . out . println ( yama [ 0 ] ) ; System . out . println ( yama [ 1 ] ) ; System . out . println ( yama [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] yama = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { yama [ i ] = sc . nextInt ( ) ; } Arrays . sort ( yama , Collections . reverseOrder ( ) ) ; System . out . println ( yama [ 0 ] ) ; System . out . println ( yama [ 1 ] ) ; System . out . println ( yama [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int higth [ ] = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) higth [ i ] = sc . nextInt ( ) ; Arrays . sort ( higth ) ; System . out . println ( higth [ 9 ] ) ; System . out . println ( higth [ 8 ] ) ; System . out . println ( higth [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Integer [ ] a = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; Arrays . sort ( a , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String ... args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } Arrays . sort ( h ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { int [ ] hills = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < hills . length ; i ++ ) { hills [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hills ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( hills [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public String [ ] inputMountain = new String [ 10 ] ; public int [ ] mountain = new int [ 10 ] ; public static void main ( String args [ ] ) throws IOException { int i ; Main app = new Main ( ) ; app . input ( ) ; app . stringToInteger ( ) ; app . sortMountain ( ) ; app . output ( ) ; } public void input ( ) throws IOException { InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; int i ; for ( i = 0 ; i < 10 ; i ++ ) inputMountain [ i ] = br . readLine ( ) ; } public void stringToInteger ( ) { int i ; for ( i = 0 ; i < 10 ; i ++ ) mountain [ i ] = Integer . parseInt ( inputMountain [ i ] ) ; } public void sortMountain ( ) { int i , j , t ; for ( i = 0 ; i < 9 ; i ++ ) { for ( j = 9 ; j > i ; j -- ) { if ( mountain [ j ] < mountain [ j - 1 ] ) { t = mountain [ j ] ; mountain [ j ] = mountain [ j - 1 ] ; mountain [ j - 1 ] = t ; } } } } public void output ( ) { int i ; for ( i = 9 ; i > 6 ; i -- ) System . out . println ( mountain [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { private static int a [ ] ; private static int N = 10 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; a = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < N ; i ++ ) { int max = i ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( a [ j ] > a [ max ] ) { max = j ; } } int t = a [ i ] ; a [ i ] = a [ max ] ; a [ max ] = t ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int [ ] list = new int [ 10 ] ; int i , j ; for ( i = 0 ; i < 10 ; i ++ ) { list [ i ] = sc . nextInt ( ) ; } Arrays . sort ( list ) ; for ( j = 0 ; j < 3 ; j ++ ) { System . out . println ( list [ 9 - j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) in [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; Arrays . sort ( in ) ; System . out . println ( in [ 9 ] ) ; System . out . println ( in [ 8 ] ) ; System . out . println ( in [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mtn = new int [ 10 ] ; for ( int i = 0 ; i < mtn . length ; i ++ ) { mtn [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < mtn . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < mtn . length ; j ++ ) { if ( mtn [ i ] < mtn [ j ] ) { int tmp ; tmp = mtn [ i ] ; mtn [ i ] = mtn [ j ] ; mtn [ j ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( mtn [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJ ( ) . doIt ( ) ; } class AOJ { void doIt ( ) { ArrayList < Integer > list = new ArrayList < Integer > ( ) ; while ( in . hasNext ( ) ) list . add ( in . nextInt ( ) ) ; Collections . sort ( list ) ; for ( int i = list . size ( ) - 1 ; i >= list . size ( ) - 3 ; i -- ) System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . lang . Exception ; import java . lang . Integer ; import java . lang . String ; import java . lang . System ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; int i = 0 ; while ( true ) { String s = r . readLine ( ) ; mountains [ i ++ ] = Integer . valueOf ( s ) ; if ( i >= 10 ) break ; } Arrays . sort ( mountains ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . lang . Exception ; import java . lang . Integer ; import java . lang . String ; import java . lang . System ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; int i = 0 ; while ( true ) { String s = r . readLine ( ) ; mountains [ i ++ ] = Integer . valueOf ( s ) ; if ( i >= 10 ) break ; } Arrays . sort ( mountains ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { static int rank1 = - 1 ; static int rank2 = - 1 ; static int rank3 = - 1 ; public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { try { int readVal = Integer . parseInt ( br . readLine ( ) ) ; updateRank ( readVal ) ; } catch ( Exception e ) { } } System . out . println ( rank1 ) ; System . out . println ( rank2 ) ; System . out . println ( rank3 ) ; } static void updateRank ( int rank ) { if ( rank > rank1 ) { rank3 = rank2 ; rank2 = rank1 ; rank1 = rank ; } else if ( rank > rank2 ) { rank3 = rank2 ; rank2 = rank ; } else if ( rank > rank3 ) { rank3 = rank ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . lang . System ; import java . lang . reflect . Array ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int tmp = Integer . parseInt ( r . readLine ( ) ) ; mountains [ i ] = tmp ; } Arrays . sort ( mountains ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int high [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { high [ i ] = sc . nextInt ( ) ; } Arrays . sort ( high ) ; for ( int i = 9 ; i > 6 ; i -- ) System . out . println ( high [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = stdIn . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) { Integer [ ] input = new Integer [ 10 ] ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { try { input [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } Arrays . sort ( input , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( input [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { Integer [ ] input = new Integer [ 10 ] ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( input , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( input [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { List < Integer > list = new ArrayList < Integer > ( ) ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( scan . nextInt ( ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] hillHeights = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) hillHeights [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; Arrays . sort ( hillHeights ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( hillHeights [ hillHeights . length - i - 1 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int result [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { result [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int maxIndex = i ; for ( int j = i + 1 ; j < result . length ; j ++ ) { if ( result [ maxIndex ] < result [ j ] ) { maxIndex = j ; } } System . out . println ( result [ maxIndex ] ) ; result [ maxIndex ] = 0 ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Collections ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { Integer [ ] ls = new Integer [ 10 ] ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = in . readLine ( ) ; ls [ i ] = Integer . valueOf ( s ) ; } Arrays . sort ( ls , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( ls [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int first = 0 ; int second = 0 ; int third = 0 ; Scanner in = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = in . nextInt ( ) ; if ( h > first ) { third = second ; second = first ; first = h ; } else if ( h > second ) { third = second ; second = h ; } else if ( h > third ) { third = h ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Collections ; import java . util . PriorityQueue ; public class Main { public static void main ( String [ ] args ) throws IOException { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( 3 , Collections . reverseOrder ( ) ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String s ; while ( ( s = in . readLine ( ) ) != null && s . length ( ) != 0 ) { pq . add ( Integer . parseInt ( s ) ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( pq . poll ( ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int A [ ] = { 1819 , 2003 , 876 , 2840 , 1723 , 1673 , 3776 , 2848 , 1592 , 922 } ; int len = A . length ; for ( int i = 0 ; i < len ; i ++ ) A [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( A ) ; System . out . println ( A [ len - 1 ] ) ; System . out . println ( A [ len - 2 ] ) ; System . out . println ( A [ len - 3 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int [ ] x = new int [ 3 ] ; int temp = 0 ; Scanner scanner = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { temp = scanner . nextInt ( ) ; if ( temp > x [ 0 ] ) { x [ 2 ] = x [ 1 ] ; x [ 1 ] = x [ 0 ] ; x [ 0 ] = temp ; } else if ( temp > x [ 1 ] ) { x [ 2 ] = x [ 1 ] ; x [ 1 ] = temp ; } else if ( temp > x [ 2 ] ) { x [ 2 ] = temp ; } } scanner . close ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String input [ ] ) { int a = 0 , b = 0 , c = 0 ; BufferedReader buffRead = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String fileline ; try { while ( ( fileline = buffRead . readLine ( ) ) != null ) { int height = Integer . parseInt ( fileline ) ; if ( height > a ) { c = b ; b = a ; a = height ; } else if ( height > b ) { c = b ; b = height ; } else if ( height > c ) { c = height ; } else { } } } catch ( Exception e ) { System . out . println ( \" Failure \" ) ; } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; int hi = 0 ; int me = 0 ; int low = 0 ; for ( int i = 0 ; i < heights . length ; i ++ ) { int height = s . nextInt ( ) ; if ( height >= hi ) { low = me ; me = hi ; hi = height ; } if ( height >= me && height < hi ) { low = me ; me = height ; } if ( height >= low && height < me ) { low = height ; } } System . out . println ( hi ) ; System . out . println ( me ) ; System . out . println ( low ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; ArrayList < Integer > t = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) t . add ( input . nextInt ( ) ) ; Collections . sort ( t ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( t . get ( 9 - i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; ArrayList < Integer > numbers = new ArrayList < Integer > ( ) ; while ( ( line = reader . readLine ( ) ) != null ) { numbers . add ( Integer . parseInt ( line ) ) ; } Collections . sort ( numbers ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( numbers . get ( numbers . size ( ) - ( i + 1 ) ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; int temp ; for ( int i = 0 ; i < 10 ; i ++ ) { heights [ i ] = Integer . parseInt ( scan . nextLine ( ) ) ; } for ( int i = 0 ; i < heights . length ; i ++ ) { for ( int k = 1 ; k < heights . length - i ; k ++ ) { if ( heights [ k - 1 ] > heights [ k ] ) { temp = heights [ k ] ; heights [ k ] = heights [ k - 1 ] ; heights [ k - 1 ] = temp ; } } } for ( int i = heights . length - 1 ; i > heights . length - 4 ; i -- ) { System . out . println ( heights [ i ] ) ; } scan . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { int [ ] height = new int [ 10 ] ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int a = Integer . parseInt ( in . readLine ( ) ) ; height [ i ] = a ; } int length = height . length ; for ( int i = 0 ; i < length ; i ++ ) { for ( int j = ( i + 1 ) ; j < length ; j ++ ) { if ( height [ i ] < height [ j ] ) { int temp = height [ j ] ; height [ j ] = height [ i ] ; height [ i ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int one = 0 ; int two = 0 ; int three = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int x = input . nextInt ( ) ; if ( x > one ) { three = two ; two = one ; one = x ; } else if ( x > two ) { three = two ; two = x ; } else if ( x > three ) { three = x ; } } System . out . println ( one ) ; System . out . println ( two ) ; System . out . println ( three ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] mountainList = new int [ 10 ] ; String line = \" \" ; BufferedReader br = null ; try { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { line = br . readLine ( ) ; mountainList [ i ] = Integer . parseInt ( line ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } Arrays . sort ( mountainList ) ; for ( int j = 0 ; j > - 3 ; j -- ) { System . out . println ( mountainList [ j + 9 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { int first = 0 ; int second = 0 ; int third = 0 ; int temp ; Scanner input = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { temp = input . nextInt ( ) ; if ( temp > first ) { int temp2 = first ; first = temp ; temp = temp2 ; if ( temp > second ) { int temp3 = second ; second = temp ; temp = temp3 ; if ( temp3 > third ) { third = temp3 ; } } } else if ( temp > second ) { int temp3 = second ; second = temp ; temp = temp3 ; if ( temp3 > third ) { third = temp3 ; } } else if ( temp > third ) { third = temp ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; ++ i ) { arr [ i ] = scan . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ 9 ] ) ; System . out . println ( arr [ 8 ] ) ; System . out . println ( arr [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int A [ ] = { 1819 , 2003 , 876 , 2840 , 1723 , 1673 , 3776 , 2848 , 1592 , 922 } ; int len = A . length ; for ( int i = 0 ; i < len ; i ++ ) A [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( A ) ; System . out . println ( A [ len - 1 ] ) ; System . out . println ( A [ len - 2 ] ) ; System . out . println ( A [ len - 3 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . io . * ; public class Main { public static int [ ] source = new int [ 10 ] ; static int b1 = 0 ; static int b2 = 0 ; static int b3 = 0 ; public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { source [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } sort ( ) ; System . out . println ( b1 ) ; System . out . println ( b2 ) ; System . out . println ( b3 ) ; } public static void sort ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( b1 < source [ i ] ) { b3 = b2 ; b2 = b1 ; b1 = source [ i ] ; } else if ( b2 < source [ i ] ) { b3 = b2 ; b2 = source [ i ] ; } else if ( b3 < source [ i ] ) { b3 = source [ i ] ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { int j ; Scanner in = new Scanner ( System . in ) ; int height [ ] = new int [ 10 ] ; int i ; int x ; for ( i = 0 ; i < 10 ; i ++ ) { height [ i ] = in . nextInt ( ) ; } for ( i = 0 ; i < 10 ; i ++ ) { for ( j = i + 1 ; j < 10 ; j ++ ) if ( height [ i ] > height [ j ] ) { int temp = height [ i ] ; height [ i ] = height [ j ] ; height [ j ] = temp ; } } for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] input = new int [ 10 ] ; Scanner s = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = s . nextInt ( ) ; } Arrays . sort ( input ) ; int i = input . length - 1 ; while ( i > input . length - 4 ) { System . out . println ( input [ i ] ) ; i -- ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void topThreeHills ( ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; for ( int i = 0 ; i < heights . length ; i ++ ) { heights [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( heights ) ; System . out . println ( heights [ 9 ] ) ; System . out . println ( heights [ 8 ] ) ; System . out . println ( heights [ 7 ] ) ; } public static void main ( String args [ ] ) { topThreeHills ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] hs = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hs [ i ] = in . nextInt ( ) ; } Arrays . sort ( hs ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hs [ 10 - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; int [ ] inputs = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { inputs [ i ] = s . nextInt ( ) ; } Arrays . sort ( inputs ) ; System . out . println ( inputs [ 9 ] ) ; System . out . println ( inputs [ 8 ] ) ; System . out . println ( inputs [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] m = new int [ 4 ] ; m [ 0 ] = sc . nextInt ( ) ; m [ 1 ] = sc . nextInt ( ) ; m [ 2 ] = sc . nextInt ( ) ; int work , a ; for ( int j = 1 ; j <= 2 ; j ++ ) { for ( int i = j ; i > 0 ; i -- ) { if ( m [ i - 1 ] < m [ i ] ) { m [ 3 ] = m [ i - 1 ] ; m [ i - 1 ] = m [ i ] ; m [ i ] = m [ 3 ] ; } } } a = 3 ; while ( a < 10 ) { int i = 2 ; work = sc . nextInt ( ) ; a ++ ; while ( ( ( i >= 0 ) && work > m [ i ] ) ) { m [ i + 1 ] = m [ i ] ; i -- ; } if ( i != 2 ) { m [ i + 1 ] = work ; } } System . out . println ( m [ 0 ] + \" \\n \" + m [ 1 ] + \" \\n \" + m [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int max1 = 0 ; int max2 = 0 ; int max3 = 0 ; for ( int n = 1 ; n <= 10 ; n ++ ) { int t = sc . nextInt ( ) ; if ( t >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = t ; } else if ( t >= max2 ) { max3 = max2 ; max2 = t ; } else if ( t >= max3 ) { max3 = t ; } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] Num ; Num = new int [ 11 ] ; Scanner n = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Num [ i ] = n . nextInt ( ) ; } for ( int a = 9 ; a >= 0 ; a -- ) { for ( int b = 0 ; b < a ; b ++ ) { if ( Num [ b ] < Num [ b + 1 ] ) { Num [ 10 ] = Num [ b ] ; Num [ b ] = Num [ b + 1 ] ; Num [ b + 1 ] = Num [ 10 ] ; } } } System . out . println ( Num [ 0 ] ) ; System . out . println ( Num [ 1 ] ) ; System . out . println ( Num [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] Num = new int [ 11 ] ; Scanner n = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Num [ i ] = n . nextInt ( ) ; } for ( int a = 9 ; a >= 0 ; a -- ) { for ( int b = 0 ; b < a ; b ++ ) { if ( Num [ b ] < Num [ b + 1 ] ) { Num [ 10 ] = Num [ b ] ; Num [ b ] = Num [ b + 1 ] ; Num [ b + 1 ] = Num [ 10 ] ; } } } System . out . println ( Num [ 0 ] ) ; System . out . println ( Num [ 1 ] ) ; System . out . println ( Num [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] data = new int [ 3 ] ; int tmp ; for ( int i = 0 ; i < 10 ; i ++ ) { tmp = scan . nextInt ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( data [ j ] <= tmp ) { for ( int k = 2 ; k > j ; k -- ) { data [ k ] = data [ k - 1 ] ; } data [ j ] = tmp ; break ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String args [ ] ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int num [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { try { num [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; } catch ( IOException e ) { } } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int k = 0 ; k < 10 - 1 ; k ++ ) { if ( num [ k ] < num [ k + 1 ] ) { int tmp = num [ k ] ; num [ k ] = num [ k + 1 ] ; num [ k + 1 ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( num [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; } sc . close ( ) ; Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = stdIn . nextInt ( ) ; } Arrays . sort ( data ) ; for ( int i = data . length - 1 ; i >= data . length - 3 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . Stack ; import java . util . Scanner ; import java . util . Queue ; class Main { static final boolean DEBUG = false ; static Scanner sc = new Scanner ( new InputStreamReader ( System . in ) ) ; static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public static void main ( String args [ ] ) throws Exception { int [ ] m = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) m [ i ] = readInt ( ) ; Arrays . sort ( m ) ; for ( int i = 0 ; i < 3 ; i ++ ) p ( m [ 9 - i ] ) ; } public static String readLine ( ) throws IOException { return br . readLine ( ) ; } public static int readInt ( ) { return sc . nextInt ( ) ; } public static void pa ( Object [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void pa ( int [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void pa ( double [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void pa ( boolean [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void p ( Object o ) { System . out . println ( o . toString ( ) ) ; } public static void d ( Object o ) { if ( DEBUG ) System . out . println ( o . toString ( ) ) ; } public static int [ ] parseInt ( String [ ] arr ) { int [ ] res = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) res [ i ] = Integer . parseInt ( arr [ i ] ) ; return res ; } public static int parseInt ( Object o ) { return Integer . parseInt ( o . toString ( ) ) ; } ; } class MyHashMap < E > extends HashMap < E , Integer > { ArrayList < E > keyArray = new ArrayList < E > ( ) ; public void add ( E key ) { add ( key , 1 ) ; } public void add ( E key , Integer value ) { if ( containsKey ( key ) ) { value += get ( key ) ; } else { keyArray . add ( key ) ; } put ( key , value ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String args [ ] ) { int [ ] h = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = Integer . parseInt ( scan . next ( ) ) ; } Arrays . sort ( h ) ; System . out . println ( h [ 9 ] ) ; System . out . println ( h [ 8 ] ) ; System . out . println ( h [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; ArrayList < Integer > out = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { out . add ( input . nextInt ( ) ) ; } Collections . sort ( out ) ; System . out . println ( out . get ( out . size ( ) - 1 ) ) ; System . out . println ( out . get ( out . size ( ) - 2 ) ) ; System . out . println ( out . get ( out . size ( ) - 3 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . awt . List ; import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String str ; str = br . readLine ( ) ; arr [ i ] = Integer . parseInt ( str ) ; } Arrays . sort ( arr ) ; for ( int i = 9 ; i > 6 ; i -- ) System . out . println ( arr [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } Collections . sort ( list ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int mountains [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } Arrays . sort ( mountains ) ; for ( int i = mountains . length - 1 ; i > mountains . length - 4 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int tmp = sc . nextInt ( ) ; list . add ( tmp ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int tmp = list . get ( i ) ; System . out . println ( tmp ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int tmp = sc . nextInt ( ) ; list . add ( tmp ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int tmp = list . get ( i ) ; System . out . println ( tmp ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; final int input [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = sc . nextInt ( ) ; } Arrays . sort ( input ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( input [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String ... args ) { final Scanner scanner = new Scanner ( System . in ) ; final ArrayList < Integer > heights = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { heights . add ( scanner . nextInt ( ) ) ; } Collections . sort ( heights , new Comparator < Integer > ( ) { @ Override public int compare ( Integer height1 , Integer height2 ) { return height1 . compareTo ( height2 ) * - 1 ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { private static Scanner scan ; public static void main ( String [ ] args ) { scan = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; int value ; for ( int i = 0 ; i < 10 ; i ++ ) { value = scan . nextInt ( ) ; if ( value <= 10000 ) { list . add ( value ) ; } } Collections . sort ( list ) ; System . out . println ( list . get ( 9 ) ) ; System . out . println ( list . get ( 8 ) ) ; System . out . println ( list . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int arr [ ] = new int [ 10 ] ; int i = 0 ; while ( sc . hasNext ( ) ) { String line [ ] = sc . nextLine ( ) . split ( \" \" ) ; arr [ i ] = Integer . parseInt ( line [ 0 ] ) ; i ++ ; } Arrays . sort ( arr ) ; System . out . println ( arr [ 9 ] ) ; System . out . println ( arr [ 8 ] ) ; System . out . println ( arr [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = br . readLine ( ) ; height [ i ] = Integer . parseInt ( s ) ; } Arrays . sort ( height ) ; System . out . println ( height [ height . length - 1 ] ) ; System . out . println ( height [ height . length - 2 ] ) ; System . out . println ( height [ height . length - 3 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . StringTokenizer ; public class Main { private StringTokenizer st ; private BufferedReader bf ; private int w ; Main ( ) { readData ( ) ; } private void readData ( ) { try { bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; st = new StringTokenizer ( bf . readLine ( ) ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = nextInt ( ) ; } Arrays . sort ( h ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( h [ i ] ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } private String next ( ) throws IOException { if ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( bf . readLine ( ) ) ; return st . nextToken ( ) ; } public static void main ( String [ ] args ) { Main m = new Main ( ) ; } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] av ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; java . util . ArrayList < Integer > vec = new java . util . ArrayList < Integer > ( ) ; while ( sc . hasNextInt ( ) ) { vec . add ( sc . nextInt ( ) ) ; } java . util . Collections . sort ( vec ) ; java . util . Collections . reverse ( vec ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( vec . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] av ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; int [ ] vec = new int [ 10 ] ; int j = 0 ; while ( sc . hasNextInt ( ) && j < 10 ) { vec [ j ++ ] = ( sc . nextInt ( ) ) ; } java . util . Arrays . sort ( vec ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( vec [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mtns = new int [ 10 ] ; int first , second , third ; for ( int i = 0 ; i < 10 ; i ++ ) { mtns [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mtns ) ; System . out . println ( mtns [ 9 ] ) ; System . out . println ( mtns [ 8 ] ) ; System . out . println ( mtns [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( num ) ; for ( int i = num . length - 1 ; i > num . length - 4 ; i -- ) { System . out . println ( num [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder builder = new StringBuilder ( ) ; int [ ] yama = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { yama [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; } Arrays . sort ( yama ) ; for ( int i = 9 ; i > 6 ; i -- ) { builder . append ( yama [ i ] ) . append ( '\\n' ) ; } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; class Main { public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < Integer > heightList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { heightList . add ( getHeight ( reader ) ) ; } Collections . sort ( heightList ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heightList . get ( 9 - i ) ) ; } } private static Integer getHeight ( BufferedReader reader ) { Integer height = null ; try { String line = reader . readLine ( ) ; height = new Integer ( line ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } return height ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static int [ ] a = new int [ 10 ] ; public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = cin . nextInt ( ) ; } solve ( ) ; } public static void solve ( ) { Arrays . sort ( a ) ; for ( int i = a . length - 1 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; String str = \" \" ; int num [ ] = new int [ 10 ] ; int top [ ] = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { str = br . readLine ( ) ; num [ i ] = Integer . parseInt ( str ) ; if ( top [ 0 ] < num [ i ] ) { top [ 2 ] = top [ 1 ] ; top [ 1 ] = top [ 0 ] ; top [ 0 ] = num [ i ] ; } else if ( top [ 1 ] < num [ i ] ) { top [ 2 ] = top [ 1 ] ; top [ 1 ] = num [ i ] ; } else if ( top [ 2 ] < num [ i ] ) { top [ 2 ] = num [ i ] ; } } System . out . println ( top [ 0 ] ) ; System . out . println ( top [ 1 ] ) ; System . out . println ( top [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String args [ ] ) { InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; ArrayList < Integer > List = new ArrayList < Integer > ( ) ; try { for ( int i = 0 ; i < 10 ; i ++ ) { String buf = br . readLine ( ) ; List . add ( Integer . parseInt ( buf ) ) ; } Collections . sort ( List ) ; Collections . reverse ( List ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( List . get ( i ) ) ; } } catch ( Exception e ) { System . out . println ( \" Exception! \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] heightArray = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { heightArray [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( heightArray ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( heightArray [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int [ ] hills = new int [ 10001 ] ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { hills [ parseInt ( line ) ] ++ ; } int count = 0 ; outer : for ( int i = hills . length - 1 ; ; i -- ) { if ( hills [ i ] > 0 ) { for ( int j = 0 ; j < hills [ i ] ; j ++ ) { System . out . println ( i ) ; count ++ ; if ( count == 3 ) break outer ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] top3 = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { try { String line = br . readLine ( ) ; if ( line != null ) { int tmp = Integer . parseInt ( line . trim ( ) ) ; if ( tmp > top3 [ 0 ] ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = top3 [ 0 ] ; top3 [ 0 ] = tmp ; } else if ( tmp > top3 [ 1 ] ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = tmp ; } else if ( tmp > top3 [ 2 ] ) { top3 [ 2 ] = tmp ; } } } catch ( IOException e ) { } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( top3 [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Top3 { int fst = 0 ; int snd = 0 ; int thd = 0 ; } public class Main { public static void main ( String args [ ] ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int mnt [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String s ; try { s = br . readLine ( ) ; mnt [ i ] = Integer . parseInt ( s ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } Top3 m = new Top3 ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( mnt [ i ] > m . fst ) { m . thd = m . snd ; m . snd = m . fst ; m . fst = mnt [ i ] ; } else if ( mnt [ i ] > m . snd ) { m . thd = m . snd ; m . snd = mnt [ i ] ; } else if ( mnt [ i ] > m . thd ) { m . thd = mnt [ i ] ; } } System . out . println ( m . fst ) ; System . out . println ( m . snd ) ; System . out . println ( m . thd ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { int [ ] takasa = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { takasa [ i ] = Integer . valueOf ( scan . next ( ) ) ; } Arrays . sort ( takasa ) ; for ( int i = 9 ; i > 6 ; i -- ) System . out . println ( takasa [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . Arrays ; public class Main { private static Scanner sc ; public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . lang . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; while ( sc . hasNext ( ) ) list . add ( sc . nextInt ( ) ) ; Collections . sort ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( list . get ( list . size ( ) - i - 1 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int height [ ] = new int [ 10 ] ; for ( int i = 0 ; i < height . length ; i ++ ) { try { height [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } Arrays . sort ( height ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ height . length - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( height ) ; for ( int j = 9 ; j > 6 ; j -- ) { System . out . println ( height [ j ] ) ; } } finally { br . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( scan . nextInt ( ) ) ; } Collections . sort ( list , Collections . reverseOrder ( ) ) ; System . out . println ( list . get ( 0 ) ) ; System . out . println ( list . get ( 1 ) ) ; System . out . println ( list . get ( 2 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = s . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = s . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] a ; a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = r . readLine ( ) ; a [ i ] = Integer . valueOf ( s ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int hight [ ] ; hight = new int [ 10 ] ; for ( int i = 0 ; i < hight . length ; i ++ ) { hight [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hight ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hight [ ( hight . length - 1 - i ) ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountainHigh = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountainHigh [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountainHigh ) ; for ( int i = 9 ; i > 9 - 3 ; i -- ) { System . out . println ( mountainHigh [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; public class Main { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final String LINE_SPR = System . getProperty ( \" line.separator \" ) ; final int BIG_MOD = 1000000007 ; void run ( ) throws Exception { String line ; PriorityQueue < Integer > nums = new PriorityQueue < Integer > ( ) ; while ( ( line = br . readLine ( ) ) != null ) nums . add ( Integer . parseInt ( line ) * - 1 ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( nums . poll ( ) * - 1 ) ; } void dumpObjArr ( Object [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] ) ; if ( i < n - 1 ) System . out . print ( \" \" ) ; } System . out . println ( \" \" ) ; } void dumpObjArr2 ( Object [ ] [ ] arr , int m , int n ) { for ( int j = 0 ; j < m ; j ++ ) dumpObjArr ( arr [ j ] , n ) ; } int ni ( ) throws Exception { return Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; } long nl ( ) throws Exception { return Long . parseLong ( br . readLine ( ) . trim ( ) ) ; } String ns ( ) throws Exception { return br . readLine ( ) ; } boolean isPrime ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int getPrime ( int n ) { List < Integer > primes = new ArrayList < Integer > ( ) ; primes . add ( 2 ) ; int count = 1 ; int x = 1 ; while ( primes . size ( ) < n ) { x += 2 ; int m = ( int ) Math . sqrt ( x ) ; for ( int p : primes ) { if ( p > m ) { primes . add ( x ) ; break ; } if ( x % p == 0 ) break ; } } return primes . get ( primes . size ( ) - 1 ) ; } void gcjPrint ( String str , int t ) { System . out . println ( \" Case # \" + t + \" : \" + str ) ; } public static void main ( String [ ] args ) throws Exception { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Random ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Random ra = new Random ( ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = sc . nextInt ( ) ; Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; Integer [ ] ar = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) ar [ i ] = sc . nextInt ( ) ; Arrays . sort ( ar , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( ar [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; ++ i ) list [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; QuickSort ( list , 0 , 10 ) ; for ( int i = 9 ; i > 6 ; -- i ) System . out . println ( list [ i ] ) ; } public static void QuickSort ( int [ ] array , int first , int n ) { if ( n <= 1 ) return ; int Pivot = array [ first + n / 2 - 1 ] ; int Left = first ; int Right = first + n - 1 ; while ( Left <= Right ) { while ( array [ Left ] < Pivot ) Left ++ ; while ( array [ Right ] > Pivot ) Right -- ; if ( Left <= Right ) { int tmp = array [ Left ] ; array [ Left ] = array [ Right ] ; array [ Right ] = tmp ; Left ++ ; Right -- ; } } QuickSort ( array , first , Right - first + 1 ) ; QuickSort ( array , Left , first + n - Left ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int i ; int ar [ ] = new int [ 100 ] ; int idx = 0 ; while ( sc . hasNext ( ) ) { int n = sc . nextInt ( ) ; i = idx - 1 ; while ( i >= 0 && n < ar [ i ] ) { ar [ i + 1 ] = ar [ i ] ; -- i ; } ar [ i + 1 ] = n ; ++ idx ; } for ( i = idx - 1 ; i >= 0 && i >= idx - 3 ; -- i ) { System . out . println ( ar [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . PrintStream ; import java . util . * ; import java . util . Scanner ; import java . math . BigInteger ; import java . util . Arrays ; import java . text . DecimalFormat ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; int n ; for ( int i = 0 ; i < 10 ; i ++ ) { n = sc . nextInt ( ) ; a [ i ] = n ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] + \" \\n \" + a [ 8 ] + \" \\n \" + a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = reader . readLine ( ) ; arr . add ( Integer . parseInt ( str ) ) ; } Collections . sort ( arr ) ; Collections . reverse ( arr ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( \" \" + arr . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; public class Main { final static private int MAX_DATA_COUNT = 10 ; public static void main ( String [ ] args ) throws java . io . IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountainsHeightArr = new Integer [ 10 ] ; for ( int i = 0 ; i < MAX_DATA_COUNT ; i ++ ) mountainsHeightArr [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( mountainsHeightArr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( mountainsHeightArr [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; class Main { public static void main ( String [ ] args ) throws IOException { ArrayList < Integer > heights = new ArrayList < Integer > ( ) ; InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = Integer . parseInt ( br . readLine ( ) ) ; heights . add ( h ) ; } Collections . sort ( heights ) ; Collections . reverse ( heights ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = 10 ; int [ ] k = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { k [ i ] = sc . nextInt ( ) ; } Arrays . sort ( k ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( k [ n - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { private static int [ ] data = new int [ 10 ] ; public static void main ( String args [ ] ) { BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { for ( int i = 0 ; i < 10 ; i ++ ) { String s = input . readLine ( ) ; data [ i ] = Integer . parseInt ( s ) ; } } catch ( IOException e ) { } Arrays . sort ( data ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { int [ ] heightOfHills = getHeightOfHills ( ) ; printTop3 ( heightOfHills ) ; } private static int [ ] getHeightOfHills ( ) throws NumberFormatException , IOException { InputStreamReader streamReader = new InputStreamReader ( System . in ) ; BufferedReader bufferedReader = new BufferedReader ( streamReader ) ; String line = null ; int [ ] heightOfHills = new int [ 10 ] ; int count = 0 ; try { while ( ( line = bufferedReader . readLine ( ) ) != null ) { heightOfHills [ count ] = Integer . parseInt ( line ) ; ++ count ; } } finally { bufferedReader . close ( ) ; streamReader . close ( ) ; } return heightOfHills ; } private static void printTop3 ( int [ ] array ) { Arrays . sort ( array ) ; for ( int i = 1 ; i <= 3 ; ++ i ) { System . out . println ( array [ array . length - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < Integer > heightsOfMountain = new ArrayList < Integer > ( ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { heightsOfMountain . add ( Integer . valueOf ( line ) ) ; } Collections . sort ( heightsOfMountain ) ; Collections . reverse ( heightsOfMountain ) ; System . out . println ( heightsOfMountain . get ( 0 ) ) ; System . out . println ( heightsOfMountain . get ( 1 ) ) ; System . out . println ( heightsOfMountain . get ( 2 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; List < Integer > hillList = new ArrayList < Integer > ( ) ; while ( scanner . hasNextInt ( ) ) { hillList . add ( scanner . nextInt ( ) ) ; } Comparator < Integer > comparator = new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ; Collections . sort ( hillList , comparator ) ; System . out . println ( hillList . get ( 0 ) ) ; System . out . println ( hillList . get ( 1 ) ) ; System . out . println ( hillList . get ( 2 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws IOException { ArrayList < Integer > mountainList = getMountainList ( ) ; Collections . sort ( mountainList ) ; Collections . reverse ( mountainList ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountainList . get ( i ) ) ; } } private static ArrayList < Integer > getMountainList ( ) throws IOException { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > mountainList = new ArrayList < Integer > ( ) ; String strInput ; for ( int i = 0 ; i < 10 ; i ++ ) { strInput = bufferedReader . readLine ( ) ; mountainList . add ( Integer . parseInt ( strInput ) ) ; } bufferedReader . close ( ) ; return mountainList ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { private static final int NUMBER_OF_INPUT_MOUNTAIN = 10 ; private static final int NUMBER_OF_OUTPUT_MOUNTAIN = 3 ; public static void main ( String [ ] args ) throws IOException { List < Integer > heightList = readHeight ( ) ; Collections . sort ( heightList ) ; Collections . reverse ( heightList ) ; printHeight ( heightList ) ; } protected static List < Integer > readHeight ( ) throws IOException { List < Integer > heightList = new ArrayList < Integer > ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < NUMBER_OF_INPUT_MOUNTAIN ; i ++ ) { String line = reader . readLine ( ) ; heightList . add ( Integer . parseInt ( line ) ) ; } if ( reader != null ) { reader . close ( ) ; } return heightList ; } protected static void printHeight ( List < Integer > heightList ) { for ( int i = 0 ; i < NUMBER_OF_OUTPUT_MOUNTAIN ; i ++ ) { System . out . println ( heightList . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < height . length ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int j = 9 ; 6 < j ; j -- ) { System . out . println ( height [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner n = new Scanner ( System . in ) ; int i [ ] = new int [ 10 ] ; for ( int j = 0 ; j <= 9 ; j ++ ) { i [ j ] = n . nextInt ( ) ; } Arrays . sort ( i ) ; System . out . println ( i [ 9 ] ) ; System . out . println ( i [ 8 ] ) ; System . out . println ( i [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] b = new int [ 10 ] ; int i = 0 ; for ( ; i < b . length ; i ++ ) { String s = br . readLine ( ) ; b [ i ] = Integer . parseInt ( s ) ; } Arrays . sort ( b ) ; for ( int d = 9 ; d > 6 ; d -- ) { System . out . println ( b [ d ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a [ ] ; a = new int [ 10 ] ; for ( int b = 0 ; b < 10 ; b ++ ) { a [ b ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { Scanner scan = new Scanner ( System . in ) ; int M [ ] = new int [ 10 ] ; for ( int a = 0 ; a < 10 ; a ++ ) { M [ a ] = scan . nextInt ( ) ; } int No1 = M [ 0 ] ; int No2 = M [ 1 ] ; int No3 = M [ 2 ] ; if ( No1 < No2 ) { No1 = M [ 1 ] ; No2 = M [ 0 ] ; } if ( No1 < No3 ) { No3 = No2 ; No2 = No1 ; No1 = M [ 2 ] ; } else if ( No2 < No3 ) { No3 = No2 ; No2 = M [ 2 ] ; } for ( int b = 3 ; b < 10 ; b ++ ) { if ( No1 < M [ b ] ) { No3 = No2 ; No2 = No1 ; No1 = M [ b ] ; } else if ( No2 < M [ b ] ) { No3 = No2 ; No2 = M [ b ] ; } else if ( No3 < M [ b ] ) { No3 = M [ b ] ; } } System . out . println ( No1 + \" \\n \" + No2 + \" \\n \" + No3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sn = new Scanner ( System . in ) ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a . add ( sn . nextInt ( ) ) ; } Collections . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a . get ( a . size ( ) - i - 1 ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = 10 ; int [ ] k = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { k [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( k ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( k [ n - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { List < Integer > list = new ArrayList < Integer > ( ) ; Scanner scanner = new Scanner ( System . in ) ; while ( scanner . hasNext ( ) ) { list . add ( Integer . parseInt ( scanner . next ( ) ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . lang . * ; import java . util . Scanner ; public class Main { public static void main ( String [ ] arg ) { int [ ] a = new int [ 10 ] ; Scanner in = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = sc . nextInt ( ) ; list . add ( h ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( list . size ( ) - 1 ) ) ; System . out . println ( list . get ( list . size ( ) - 2 ) ) ; System . out . println ( list . get ( list . size ( ) - 3 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = 0 , b = 0 , c = 0 ; int [ ] n = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { n [ i ] = sc . nextInt ( ) ; if ( n [ i ] > a ) { c = b ; b = a ; a = n [ i ] ; } else if ( n [ i ] > b ) { c = b ; b = n [ i ] ; } else if ( n [ i ] > c ) { c = n [ i ] ; } } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int first = 0 , second = 0 , third = 0 ; int set ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { set = sc . nextInt ( ) ; if ( first < set ) { third = second ; second = first ; first = set ; } else if ( second < set ) { third = second ; second = set ; } else if ( third < set ) { third = set ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String args [ ] ) { try { int x [ ] = new int [ 10 ] ; int a [ ] = { 0 , 0 , 0 } ; int temp ; InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = Integer . parseInt ( br . readLine ( ) ) ; if ( a [ 0 ] < x [ i ] ) { temp = a [ 0 ] ; a [ 0 ] = x [ i ] ; x [ i ] = temp ; } if ( a [ 1 ] < x [ i ] ) { temp = a [ 1 ] ; a [ 1 ] = x [ i ] ; x [ i ] = temp ; } if ( a [ 2 ] < x [ i ] ) { temp = a [ 2 ] ; a [ 2 ] = x [ i ] ; x [ i ] = temp ; } } System . out . println ( a [ 0 ] ) ; System . out . println ( a [ 1 ] ) ; System . out . println ( a [ 2 ] ) ; } catch ( Exception e ) { System . out . printf ( \" error \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = 10 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i < x . length ; i ++ ) { x [ i ] = sc . nextInt ( ) ; } Arrays . sort ( x ) ; System . out . println ( x [ 9 ] ) ; System . out . println ( x [ 8 ] ) ; System . out . println ( x [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountHill = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountHill [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountHill ) ; System . out . println ( mountHill [ 9 ] ) ; System . out . println ( mountHill [ 8 ] ) ; System . out . println ( mountHill [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( stdIn . nextInt ( ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] str = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { str [ i ] = scan . nextInt ( ) ; } Arrays . sort ( str ) ; for ( int j = 9 ; j > 6 ; j -- ) { System . out . println ( str [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] args ) { String [ ] x = new String [ 10 ] ; int [ ] mountain = new int [ 10 ] ; try { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; for ( int i = 0 ; i < 10 ; i ++ ) x [ i ] = br . readLine ( ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } for ( int i = 0 ; i < 10 ; i ++ ) mountain [ i ] = Integer . parseInt ( x [ i ] ) ; for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) if ( mountain [ j ] < mountain [ j - 1 ] ) { int t = mountain [ j ] ; mountain [ j ] = mountain [ j - 1 ] ; mountain [ j - 1 ] = t ; } for ( int i = 9 ; i > 6 ; i -- ) System . out . println ( mountain [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { in [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; int [ ] result = top3 ( in ) ; for ( int i : result ) System . out . println ( i ) ; } static int [ ] top3 ( int [ ] args ) { int [ ] copy = Arrays . copyOf ( args , args . length ) ; Arrays . sort ( copy ) ; int [ ] result = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { result [ i ] = copy [ copy . length - 1 - i ] ; } return result ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int top = 0 ; int second = 0 ; int third = 0 ; int n ; for ( int i = 0 ; i < 10 ; i ++ ) { n = Integer . parseInt ( in . readLine ( ) ) ; if ( n > third ) { third = n ; if ( n > second ) { third = second ; second = n ; if ( n > top ) { second = top ; top = n ; } } } } System . out . println ( top ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > ret = new ArrayList < Integer > ( ) ; int i ; for ( i = 0 ; i < 10 ; i ++ ) { ret . add ( sc . nextInt ( ) ) ; } Collections . sort ( ret ) ; Collections . reverse ( ret ) ; for ( i = 0 ; i < 3 ; i ++ ) { System . out . println ( ret . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { @ SuppressWarnings ( \" resource \" ) Scanner sc = new Scanner ( System . in ) ; int [ ] mountHill = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountHill [ i ] = sc . nextInt ( ) ; if ( mountHill [ i ] > 10000 || mountHill [ i ] < 0 ) { System . out . println ( \" error \" ) ; } } Arrays . sort ( mountHill ) ; System . out . println ( mountHill [ 9 ] + \" \\n \" + mountHill [ 8 ] + \" \\n \" + mountHill [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int datas [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { datas [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( datas ) ; System . out . println ( datas [ 9 ] ) ; System . out . println ( datas [ 8 ] ) ; System . out . println ( datas [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int datas [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { datas [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( datas ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( datas [ 10 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] hills = new int [ 10 ] ; int cnt = 0 ; while ( cnt < 10 ) { int hill = Integer . parseInt ( scan . next ( ) ) ; if ( hill >= 0 && hill <= 10000 ) { hills [ cnt ] = hill ; cnt ++ ; } else { continue ; } } for ( int i = 0 ; i < hills . length - 1 ; i ++ ) { for ( int j = hills . length - 1 ; j > i ; j -- ) { if ( hills [ j ] > hills [ j - 1 ] ) { int tmp = hills [ j ] ; hills [ j ] = hills [ j - 1 ] ; hills [ j - 1 ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hills [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { Scanner sc = new Scanner ( System . in ) ; int [ ] yama = new int [ 10 ] ; void s ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { yama [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = i ; j < 10 ; j ++ ) { if ( yama [ i ] <= yama [ j ] ) { int a = yama [ j ] ; yama [ j ] = yama [ i ] ; yama [ i ] = a ; } } } for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( yama [ j ] ) ; } } public static void main ( String [ ] agrs ) { new Main ( ) . s ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int a = scan . nextInt ( ) ; arr [ i ] = a ; } Arrays . sort ( arr ) ; System . out . println ( arr [ 9 ] ) ; System . out . println ( arr [ 8 ] ) ; System . out . println ( arr [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String args [ ] ) { Scanner input = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = input . nextInt ( ) ; } Arrays . sort ( array ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static Scanner scanner = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { ArrayList < Integer > hight = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { hight . add ( input ( ) ) ; } Collections . sort ( hight ) ; System . out . println ( hight . get ( 9 ) ) ; System . out . println ( hight . get ( 8 ) ) ; System . out . println ( hight . get ( 7 ) ) ; close ( ) ; } public static int input ( ) { return scanner . nextInt ( ) ; } public static void close ( ) { if ( scanner != null ) { scanner . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { MyScanner sc = new MyScanner ( ) ; Scanner sc2 = new Scanner ( System . in ) ; long start = System . currentTimeMillis ( ) ; long fin = System . currentTimeMillis ( ) ; final int MOD = 1000000007 ; int [ ] dx = { 1 , 0 , 0 , - 1 } ; int [ ] dy = { 0 , 1 , - 1 , 0 } ; void run ( ) { int n = 10 ; int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) array [ i ] = sc . nextInt ( ) ; mergeSort ( array , 0 , n ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } void mergeSort ( int a [ ] , int left , int right ) { if ( right - left <= 1 ) return ; int mid = ( left + right ) / 2 ; mergeSort ( a , left , mid ) ; mergeSort ( a , mid , right ) ; merge ( a , left , mid , right ) ; } void merge ( int [ ] a , int left , int mid , int right ) { int [ ] L = new int [ mid - left + 1 ] ; int [ ] R = new int [ right - mid + 1 ] ; int li = 0 ; int ri = 0 ; for ( int i = 0 ; i < L . length - 1 ; i ++ ) L [ i ] = a [ left + i ] ; for ( int i = 0 ; i < R . length - 1 ; i ++ ) R [ i ] = a [ mid + i ] ; L [ L . length - 1 ] = R [ R . length - 1 ] = Integer . MAX_VALUE / 2 ; for ( int i = left ; i < right ; i ++ ) { if ( L [ li ] < R [ ri ] ) a [ i ] = L [ li ++ ] ; else a [ i ] = R [ ri ++ ] ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void debug ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } void debug2 ( int [ ] [ ] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = 0 ; j < array [ i ] . length ; j ++ ) { System . out . print ( array [ i ] [ j ] ) ; } System . out . println ( ) ; } } boolean inner ( int h , int w , int limH , int limW ) { return 0 <= h && h < limH && 0 <= w && w < limW ; } void swap ( int [ ] x , int a , int b ) { int tmp = x [ a ] ; x [ a ] = x [ b ] ; x [ b ] = tmp ; } int lower_bound ( int a [ ] , int border ) { int l = - 1 ; int r = a . length ; while ( r - l > 1 ) { int mid = ( l + r ) / 2 ; if ( border <= a [ mid ] ) { r = mid ; } else { l = mid ; } } return r ; } boolean palindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - 1 - i ) ) { return false ; } } return true ; } class MyScanner { int nextInt ( ) { try { int c = System . in . read ( ) ; while ( c != '-' && ( c < '0' || '9' < c ) ) c = System . in . read ( ) ; if ( c == '-' ) return - nextInt ( ) ; int res = 0 ; do { res *= 10 ; res += c - '0' ; c = System . in . read ( ) ; } while ( '0' <= c && c <= '9' ) ; return res ; } catch ( Exception e ) { return - 1 ; } } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } String next ( ) { try { StringBuilder res = new StringBuilder ( \" \" ) ; int c = System . in . read ( ) ; while ( Character . isWhitespace ( c ) ) c = System . in . read ( ) ; do { res . append ( ( char ) c ) ; } while ( ! Character . isWhitespace ( c = System . in . read ( ) ) ) ; return res . toString ( ) ; } catch ( Exception e ) { return null ; } } int [ ] nextIntArray ( int n ) { int [ ] in = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { in [ i ] = nextInt ( ) ; } return in ; } int [ ] [ ] nextInt2dArray ( int n , int m ) { int [ ] [ ] in = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { in [ i ] = nextIntArray ( m ) ; } return in ; } double [ ] nextDoubleArray ( int n ) { double [ ] in = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { in [ i ] = nextDouble ( ) ; } return in ; } long [ ] nextLongArray ( int n ) { long [ ] in = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { in [ i ] = nextLong ( ) ; } return in ; } char [ ] [ ] nextCharField ( int n , int m ) { char [ ] [ ] in = new char [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; for ( int j = 0 ; j < m ; j ++ ) { in [ i ] [ j ] = s . charAt ( j ) ; } } return in ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { print ( ) ; } private static void print ( ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < Integer > list = new ArrayList < > ( ) ; int [ ] highs = new int [ 10 ] ; try { for ( int i = 0 ; i <= 9 ; i ++ ) { highs [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { list . add ( highs [ i ] ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i <= 2 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > l = new ArrayList < > ( ) ; while ( sc . hasNextInt ( ) ) { l . add ( sc . nextInt ( ) ) ; } Collections . sort ( l , Collections . reverseOrder ( ) ) ; l . stream ( ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . StringTokenizer ; public class Main { static InputReader in ; static PrintWriter out ; static class Solution { void solve ( ) throws IOException { int [ ] height = new int [ 10 ] ; int first ; int second ; int third ; height [ 0 ] = in . nextInt ( ) ; int max = height [ 0 ] ; int memmax = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) { height [ i ] = in . nextInt ( ) ; max = Math . max ( max , height [ i ] ) ; if ( max == height [ i ] ) { memmax = i ; } } first = max ; height [ memmax ] = - 1 ; max = height [ 0 ] ; memmax = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) { max = Math . max ( max , height [ i ] ) ; if ( max == height [ i ] ) { memmax = i ; } } second = max ; height [ memmax ] = - 1 ; max = height [ 0 ] ; memmax = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) { max = Math . max ( max , height [ i ] ) ; if ( max == height [ i ] ) { memmax = i ; } } third = max ; out . println ( first ) ; out . println ( second ) ; out . println ( third ) ; } } public static void main ( String [ ] args ) throws IOException { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out ) ; Solution solver = new Solution ( ) ; solver . solve ( ) ; out . close ( ) ; } static class InputReader { public BufferedReader br ; public StringTokenizer st ; public InputReader ( InputStream stream ) { br = new BufferedReader ( new InputStreamReader ( stream ) ) ; } public int nextInt ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return Integer . parseInt ( st . nextToken ( ) ) ; } public long nextLong ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return Long . parseLong ( st . nextToken ( ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } public double nextDouble ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return Double . parseDouble ( st . nextToken ( ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { Integer top3 [ ] = new Integer [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { top3 [ i ] = 0 ; } BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int x = 1 ; x <= 10 ; x ++ ) { Integer h = Integer . parseInt ( in . readLine ( ) ) ; if ( h >= 0 && h <= 10000 ) { ArrayList < Integer > tmpTop = new ArrayList < Integer > ( 4 ) ; for ( int i = 0 ; i < 3 ; i ++ ) { tmpTop . add ( top3 [ i ] ) ; } tmpTop . add ( h ) ; Collections . sort ( tmpTop ) ; Collections . reverse ( tmpTop ) ; for ( int i = 0 ; i < 3 ; i ++ ) { top3 [ i ] = tmpTop . get ( i ) ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( top3 [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int tbl [ ] = new int [ 10 ] ; int c = 9 ; int tmp ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { tbl [ i ] = sc . nextInt ( ) ; } while ( c > 0 ) { int i = 0 ; while ( i < c ) { if ( tbl [ i ] < tbl [ i + 1 ] ) { tmp = tbl [ i ] ; tbl [ i ] = tbl [ i + 1 ] ; tbl [ i + 1 ] = tmp ; } i ++ ; } c -- ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( tbl [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int mx1 = 0 , mx2 = 0 , mx3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int mtHeight = sc . nextInt ( ) ; if ( mx1 < mtHeight ) { mx3 = mx2 ; mx2 = mx1 ; mx1 = mtHeight ; } else if ( mx2 < mtHeight ) { mx3 = mx2 ; mx2 = mtHeight ; } else if ( mx3 < mtHeight ) { mx3 = mtHeight ; } } System . out . printf ( \" %d \\n %d \\n %d \\n \" , mx1 , mx2 , mx3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] tops = new int [ 3 ] ; int height ; for ( int h = 0 ; h < 10 ; h ++ ) { height = scan . nextInt ( ) ; for ( int i = 0 ; i < tops . length ; i ++ ) { if ( tops [ i ] < height ) { for ( int j = tops . length - 1 ; i < j ; j -- ) { tops [ j ] = tops [ j - 1 ] ; } tops [ i ] = height ; break ; } } } scan . close ( ) ; for ( int i = 0 ; i < tops . length ; i ++ ) { System . out . println ( tops [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( num ) ; System . out . println ( num [ 9 ] ) ; System . out . println ( num [ 8 ] ) ; System . out . println ( num [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int [ ] hills = new int [ 10 ] ; Scanner stdIn = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = stdIn . nextInt ( ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( hills [ i ] < hills [ j ] ) { int tmp = hills [ i ] ; hills [ i ] = hills [ j ] ; hills [ j ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hills [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static final Scanner scn = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { ArrayList < Integer > ali = new ArrayList < > ( ) ; while ( scn . hasNextInt ( ) ) { ali . add ( scn . nextInt ( ) ) ; } Collections . sort ( ali ) ; Collections . reverse ( ali ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( ali . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) in [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; Arrays . sort ( in ) ; System . out . println ( in [ 9 ] ) ; System . out . println ( in [ 8 ] ) ; System . out . println ( in [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { in [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; } Arrays . sort ( in ) ; System . out . println ( in [ 9 ] ) ; System . out . println ( in [ 8 ] ) ; System . out . println ( in [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] best = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { String line = br . readLine ( ) ; int height = Integer . parseInt ( line ) ; if ( height > best [ 0 ] ) { best [ 2 ] = best [ 1 ] ; best [ 1 ] = best [ 0 ] ; best [ 0 ] = height ; } else if ( height > best [ 1 ] ) { best [ 2 ] = best [ 1 ] ; best [ 1 ] = height ; } else if ( height > best [ 2 ] ) { best [ 2 ] = height ; } } for ( int h : best ) { System . out . println ( h ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] Mountain = new int [ 10 ] ; int i = 0 ; int first = 0 , second = 0 , third = 0 ; String line ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( i = 0 ; i < 10 ; i ++ ) { line = br . readLine ( ) ; Mountain [ i ] = Integer . parseInt ( line ) ; if ( Mountain [ i ] > first ) { third = second ; second = first ; first = Mountain [ i ] ; continue ; } else if ( Mountain [ i ] > second ) { third = second ; second = Mountain [ i ] ; continue ; } else if ( Mountain [ i ] > third ) { third = Mountain [ i ] ; continue ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; Integer [ ] input = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; } Arrays . sort ( input , Collections . reverseOrder ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( input [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int r1 = 0 , r2 = 0 , r3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int n = scan . nextInt ( ) ; if ( r3 < n ) { r3 = n ; if ( r2 < r3 ) { int t = r2 ; r2 = r3 ; r3 = t ; if ( r1 < r2 ) { t = r1 ; r1 = r2 ; r2 = t ; } } } } System . out . println ( r1 ) ; System . out . println ( r2 ) ; System . out . println ( r3 ) ; System . exit ( 0 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = br . readLine ( ) ; List < Integer > ans = new ArrayList < Integer > ( ) ; while ( line != null ) { ans . add ( Integer . parseInt ( line ) ) ; line = br . readLine ( ) ; } Collections . sort ( ans , new Comparator < Integer > ( ) { public int compare ( Integer a , Integer b ) { return b - a ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( ans . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] data = new int [ 10 ] ; final String BR = System . getProperty ( \" line.separator \" ) ; int first = 0 , second = 0 , third = 0 ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } for ( int datum : data ) { int temp1 = 0 , temp2 = 0 ; for ( int j = 1 ; j <= 3 ; j ++ ) { if ( first < datum ) { temp1 = first ; temp2 = second ; first = datum ; second = temp1 ; third = temp2 ; break ; } if ( second < datum ) { temp2 = second ; second = datum ; third = temp2 ; break ; } if ( third < datum ) { third = datum ; } } } System . out . println ( first + BR + second + BR + third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] data = new int [ 10 ] ; final String BR = System . getProperty ( \" line.separator \" ) ; int first = 0 , second = 0 , third = 0 ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } for ( int datum : data ) { int temp1 = 0 , temp2 = 0 ; if ( first < datum ) { temp1 = first ; temp2 = second ; first = datum ; second = temp1 ; third = temp2 ; } else if ( second < datum ) { temp2 = second ; second = datum ; third = temp2 ; } else if ( third < datum ) { third = datum ; } } System . out . println ( first + BR + second + BR + third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; int i = 0 ; while ( true ) { String s = r . readLine ( ) ; mountains [ i ++ ] = Integer . valueOf ( s ) ; if ( i >= 10 ) break ; } Arrays . sort ( mountains ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . InputStream ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . InputMismatchException ; import java . util . NoSuchElementException ; import java . math . BigInteger ; public class Main { static PrintWriter out ; static InputReader ir ; static void solve ( ) { int [ ] h = ir . nextIntArray ( 10 ) ; Arrays . sort ( h ) ; for ( int i = 0 ; i < 3 ; i ++ ) out . println ( h [ 9 - i ] ) ; } public static void main ( String [ ] args ) throws Exception { ir = new InputReader ( System . in ) ; out = new PrintWriter ( System . out ) ; solve ( ) ; out . flush ( ) ; } static class InputReader { private InputStream in ; private byte [ ] buffer = new byte [ 1024 ] ; private int curbuf ; private int lenbuf ; public InputReader ( InputStream in ) { this . in = in ; this . curbuf = this . lenbuf = 0 ; } public boolean hasNextByte ( ) { if ( curbuf >= lenbuf ) { curbuf = 0 ; try { lenbuf = in . read ( buffer ) ; } catch ( IOException e ) { throw new InputMismatchException ( ) ; } if ( lenbuf <= 0 ) return false ; } return true ; } private int readByte ( ) { if ( hasNextByte ( ) ) return buffer [ curbuf ++ ] ; else return - 1 ; } private boolean isSpaceChar ( int c ) { return ! ( c >= 33 && c <= 126 ) ; } private void skip ( ) { while ( hasNextByte ( ) && isSpaceChar ( buffer [ curbuf ] ) ) curbuf ++ ; } public boolean hasNext ( ) { skip ( ) ; return hasNextByte ( ) ; } public String next ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; StringBuilder sb = new StringBuilder ( ) ; int b = readByte ( ) ; while ( ! isSpaceChar ( b ) ) { sb . appendCodePoint ( b ) ; b = readByte ( ) ; } return sb . toString ( ) ; } public int nextInt ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; int c = readByte ( ) ; while ( isSpaceChar ( c ) ) c = readByte ( ) ; boolean minus = false ; if ( c == '-' ) { minus = true ; c = readByte ( ) ; } int res = 0 ; do { if ( c < '0' || c > '9' ) throw new InputMismatchException ( ) ; res = res * 10 + c - '0' ; c = readByte ( ) ; } while ( ! isSpaceChar ( c ) ) ; return ( minus ) ? - res : res ; } public long nextLong ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; int c = readByte ( ) ; while ( isSpaceChar ( c ) ) c = readByte ( ) ; boolean minus = false ; if ( c == '-' ) { minus = true ; c = readByte ( ) ; } long res = 0 ; do { if ( c < '0' || c > '9' ) throw new InputMismatchException ( ) ; res = res * 10 + c - '0' ; c = readByte ( ) ; } while ( ! isSpaceChar ( c ) ) ; return ( minus ) ? - res : res ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public int [ ] nextIntArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } public long [ ] nextLongArray ( int n ) { long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextLong ( ) ; return a ; } public char [ ] [ ] nextCharMap ( int n , int m ) { char [ ] [ ] map = new char [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) map [ i ] = next ( ) . toCharArray ( ) ; return map ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] k = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) k [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( k ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( k [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { int i [ ] = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( int j = 0 ; j < i . length ; j ++ ) { i [ j ] = scan . nextInt ( ) ; } Arrays . sort ( i ) ; for ( int k = 9 ; k >= 7 ; k -- ) { System . out . println ( i [ k ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] a ) { BufferedReader br ; br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { try { String str = br . readLine ( ) ; mountains [ i ] = Integer . parseInt ( str ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } for ( int h = mountains . length - 1 ; h > 0 ; h -- ) { for ( int i = 1 ; i <= h ; i ++ ) { if ( mountains [ i ] > mountains [ i - 1 ] ) { int tmp = mountains [ i ] ; mountains [ i ] = mountains [ i - 1 ] ; mountains [ i - 1 ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String args [ ] ) throws IOException { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; int tall [ ] = new int [ 10 ] ; int high [ ] = new int [ 3 ] ; int n = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { tall [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( high [ i ] < tall [ j ] ) { high [ i ] = tall [ j ] ; n = j ; } } tall [ n ] = 0 ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( high [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int n1 = 0 , n2 = 0 , n3 = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { String line = reader . readLine ( ) ; int n = Integer . parseInt ( line ) ; if ( n1 <= n ) { n3 = n2 ; n2 = n1 ; n1 = n ; } else if ( n2 <= n ) { n3 = n2 ; n2 = n ; } else if ( n3 <= n ) { n3 = n ; } } System . out . println ( n1 ) ; System . out . println ( n2 ) ; System . out . println ( n3 ) ; } catch ( IOException e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int heights [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { heights [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( heights ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( heights [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner in = new Scanner ( System . in ) ; int top , second , third , input ; top = - 1 ; second = - 2 ; third = - 3 ; for ( int i = 0 ; i < 10 ; i ++ ) { input = in . nextInt ( ) ; if ( input > top ) { third = second ; second = top ; top = input ; } else if ( input > second ) { third = second ; second = input ; } else if ( input > third ) { third = input ; } } System . out . println ( top ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { List < Integer > hills = new ArrayList < Integer > ( ) ; InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; for ( int i = 0 ; i < 10 ; ++ i ) { hills . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } Collections . sort ( hills ) ; System . out . println ( hills . get ( 9 ) ) ; System . out . println ( hills . get ( 8 ) ) ; System . out . println ( hills . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] hills = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( hills [ i ] < hills [ j ] ) { int tmp = hills [ i ] ; hills [ i ] = hills [ j ] ; hills [ j ] = tmp ; } } } System . out . println ( hills [ 0 ] ) ; System . out . println ( hills [ 1 ] ) ; System . out . println ( hills [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { ArrayList < Integer > mountain = new ArrayList < > ( 10 ) ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain . add ( sc . nextInt ( ) ) ; } Collections . sort ( mountain ) ; System . out . println ( mountain . get ( mountain . size ( ) - 1 ) ) ; System . out . println ( mountain . get ( mountain . size ( ) - 2 ) ) ; System . out . println ( mountain . get ( mountain . size ( ) - 3 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int [ ] intList = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int count = 0 ; count < 10 ; count ++ ) { int temp = sc . nextInt ( ) ; if ( temp <= 10000 ) { intList [ count ] = temp ; } } Arrays . sort ( intList ) ; for ( int j = 9 ; j >= 7 ; j -- ) { System . out . println ( intList [ j ] ) ; } sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] a ) { Integer [ ] values = new Integer [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) values [ i ] = scan . nextInt ( ) ; Arrays . sort ( values , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( values [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] a ) { int [ ] values = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) values [ i ] = scan . nextInt ( ) ; Arrays . sort ( values ) ; for ( int i = 9 ; i >= 7 ; i -- ) System . out . println ( values [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; int [ ] arrays = new int [ 10 ] ; String str = br . readLine ( ) ; for ( int i = 0 ; i < arrays . length ; i ++ ) { arrays [ i ] = Integer . parseInt ( str ) ; str = br . readLine ( ) ; } Arrays . sort ( arrays ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( arrays [ arrays . length - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . io . IOException ; class Main { public static void main ( String [ ] args ) throws IOException { int arr [ ] = new int [ 10 ] ; if ( args . length == 0 ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( arr ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( arr [ i ] ) ; } } else { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { int height1 = Integer . parseInt ( args [ i ] ) ; int height2 = Integer . parseInt ( args [ j ] ) ; if ( height1 > height2 ) { String temp = args [ i ] ; args [ i ] = args [ j ] ; args [ j ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( args [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] input = new int [ 10 ] ; for ( int i = 0 ; i < input . length ; i ++ ) { input [ i ] = sc . nextInt ( ) ; } Arrays . sort ( input ) ; for ( int i = input . length ; i > input . length - 3 ; i -- ) { System . out . println ( input [ i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < Integer > iList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { iList . add ( Integer . valueOf ( br . readLine ( ) ) ) ; } Collections . sort ( iList ) ; for ( int i = iList . size ( ) - 1 ; i > iList . size ( ) - 4 ; i -- ) { System . out . println ( iList . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountains = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . valueOf ( br . readLine ( ) ) ; } Arrays . sort ( mountains , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountains = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . valueOf ( br . readLine ( ) ) ; } Arrays . sort ( mountains , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = s . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str ; ArrayList < Integer > al = new ArrayList < Integer > ( ) ; try { while ( ( str = br . readLine ( ) ) != null ) { al . add ( Integer . parseInt ( str ) ) ; } } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Collections . sort ( al ) ; Collections . reverse ( al ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( al . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int yama [ ] = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < yama . length ; i ++ ) { yama [ i ] = sc . nextInt ( ) ; } Arrays . sort ( yama ) ; for ( int j = 9 ; j >= 7 ; j -- ) { System . out . println ( yama [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] a ) throws NumberFormatException , IOException { int arr [ ] = new int [ 10 ] ; BufferedReader read = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = Integer . parseInt ( read . readLine ( ) ) ; } Arrays . sort ( arr ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( arr [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > al = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int w = sc . nextInt ( ) ; al . add ( Integer . valueOf ( w ) ) ; } Collections . sort ( al ) ; System . out . println ( al . get ( 9 ) ) ; System . out . println ( al . get ( 8 ) ) ; System . out . println ( al . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int i = 0 ; int a = 0 ; Integer b [ ] = new Integer [ 10 ] ; for ( i = 0 ; i < 10 ; i ++ ) { a = scan . nextInt ( ) ; b [ i ] = a ; } for ( int j = 0 ; j < 3 ; j ++ ) { Arrays . sort ( b , Collections . reverseOrder ( ) ) ; System . out . println ( b [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner in = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; while ( in . hasNext ( ) ) { list . add ( in . nextInt ( ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > arrays = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int a = sc . nextInt ( ) ; arrays . add ( a ) ; } Collections . sort ( arrays ) ; for ( int j = arrays . size ( ) ; j > arrays . size ( ) - 3 ; j -- ) { System . out . println ( arrays . get ( j - 1 ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . math . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] hills = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = in . nextInt ( ) * - 1 ; } Arrays . sort ( hills ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hills [ i ] * - 1 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String args [ ] ) { ArrayList < Integer > heights = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextInt ( ) ) { heights . add ( sc . nextInt ( ) ) ; } Collections . sort ( heights ) ; Collections . reverse ( heights ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { ArrayList < Integer > heights = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextInt ( ) ) { heights . add ( sc . nextInt ( ) ) ; } Collections . sort ( heights , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int h [ ] = new int [ 10 ] ; int n = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( h [ i ] < h [ j ] ) { n = h [ j ] ; h [ j ] = h [ i ] ; h [ i ] = n ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { ArrayList < Integer > input = new ArrayList < Integer > ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) input . add ( Integer . parseInt ( br . readLine ( ) ) ) ; Collections . sort ( input , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( input . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( scan . nextInt ( ) ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( list . size ( ) - 1 ) ) ; System . out . println ( list . get ( list . size ( ) - 2 ) ) ; System . out . println ( list . get ( list . size ( ) - 3 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; int temp ; for ( int a = 0 ; a < height . length ; a ++ ) { height [ a ] = scanner . nextInt ( ) ; } for ( int i = 0 ; i < height . length ; i ++ ) { for ( int j = 0 ; j < height . length - 1 ; j ++ ) { if ( height [ j ] < height [ j + 1 ] ) { temp = height [ j ] ; height [ j ] = height [ j + 1 ] ; height [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; import java . lang . * ; import static java . util . Arrays . * ; import static java . util . Collections . reverseOrder ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; int i = 0 ; Integer [ ] mountains = new Integer [ 10 ] ; String line ; while ( ( line = br . readLine ( ) ) != null ) { mountains [ i ++ ] = Integer . valueOf ( line ) ; if ( i >= 10 ) break ; } sort ( mountains , Comparator . reverseOrder ( ) ) ; for ( i = 0 ; i < 3 ; i ++ ) { out . println ( mountains [ i ] ) ; } out . flush ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { List < Integer > a = new ArrayList < > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextInt ( ) ) { a . add ( sc . nextInt ( ) ) ; } a . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . parallel ( ) . forEachOrdered ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { List < Integer > a = new ArrayList < > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextInt ( ) ) { a . add ( sc . nextInt ( ) ) ; } a . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: new ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: new ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = 10 ; int [ ] ary = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ary [ i ] = sc . nextInt ( ) ; } for ( int i = 1 ; i < n ; i ++ ) { int value = ary [ i ] ; for ( int j = i - 1 ; ; j -- ) { if ( j < 0 ) { break ; } if ( ary [ j ] >= value ) { ary [ j + 1 ] = value ; break ; } ary [ j + 1 ] = ary [ j ] ; ary [ j ] = value ; } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( ary [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int i = 0 , j = 0 ; int [ ] mount = new int [ 10 ] ; int [ ] h_mount = { 0 , 0 , 0 } ; String str ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( i < 10 ) { str = new String ( in . readLine ( ) ) ; mount [ i ] = Integer . parseInt ( str ) ; if ( mount [ i ] < 0 || mount [ i ] > 10000 ) { i -- ; } i ++ ; } sortMethod ( mount , 10 ) ; for ( i = 0 ; i < 3 ; i ++ ) { h_mount [ i ] = mount [ i ] ; System . out . println ( h_mount [ i ] ) ; } } public static void sortMethod ( int [ ] array , int num ) { int tmp ; int x , y ; for ( x = 0 ; x < num - 1 ; x ++ ) { for ( y = x + 1 ; y < num ; y ++ ) { if ( array [ x ] < array [ y ] ) { tmp = array [ x ] ; array [ x ] = array [ y ] ; array [ y ] = tmp ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int i = 0 , j = 0 ; int [ ] mount = new int [ 10 ] ; int [ ] h_mount = { 0 , 0 , 0 } ; String str ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( i < 10 ) { str = new String ( in . readLine ( ) ) ; mount [ i ] = Integer . parseInt ( str ) ; if ( mount [ i ] < 0 || mount [ i ] > 10000 ) { i -- ; } i ++ ; } sortMethod ( mount , 10 ) ; for ( i = 0 ; i < 3 ; i ++ ) { h_mount [ i ] = mount [ i ] ; System . out . println ( h_mount [ i ] ) ; } } public static void sortMethod ( int [ ] array , int num ) { int tmp ; int x , y ; for ( x = 0 ; x < num - 1 ; x ++ ) { for ( y = x + 1 ; y < num ; y ++ ) { if ( array [ x ] < array [ y ] ) { tmp = array [ x ] ; array [ x ] = array [ y ] ; array [ y ] = tmp ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . Arrays ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = br . readLine ( ) ; int n = Integer . parseInt ( s ) ; list [ i ] = n ; } Arrays . sort ( list ) ; System . out . println ( list [ list . length - 1 ] ) ; System . out . println ( list [ list . length - 2 ] ) ; System . out . println ( list [ list . length - 3 ] ) ; br . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { static int rank1 = - 1 ; static int rank2 = - 1 ; static int rank3 = - 1 ; public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { try { int readVal = Integer . parseInt ( br . readLine ( ) ) ; updateRank ( readVal ) ; } catch ( Exception e ) { } } System . out . println ( rank1 ) ; System . out . println ( rank2 ) ; System . out . println ( rank3 ) ; } static void updateRank ( int rank ) { if ( rank > rank1 ) { rank3 = rank2 ; rank2 = rank1 ; rank1 = rank ; } else if ( rank > rank2 ) { rank3 = rank2 ; rank2 = rank ; } else if ( rank > rank3 ) { rank3 = rank ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int top1 = 0 , top2 = 0 , top3 = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int hill = scanner . nextInt ( ) ; if ( hill >= top1 ) { top3 = top2 ; top2 = top1 ; top1 = hill ; } else if ( hill >= top2 ) { top3 = top2 ; top2 = hill ; } else if ( hill >= top3 ) { top3 = hill ; } } System . out . println ( top1 ) ; System . out . println ( top2 ) ; System . out . println ( top3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] Hills = new int [ 10 ] ; for ( int i = 0 ; i < Hills . length ; i ++ ) { Hills [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } int no1 = 0 ; int no2 = 0 ; int no3 = 0 ; for ( int buf : Hills ) { if ( no1 < buf ) { no3 = no2 ; no2 = no1 ; no1 = buf ; } else if ( no2 < buf ) { no3 = no2 ; no2 = buf ; } else if ( no3 < buf ) { no3 = buf ; } } System . out . println ( no1 + \" \\n \" + no2 + \" \\n \" + no3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] a ) { int numMountain = 10 ; int minConst = 0 ; int maxConst = 10000 ; int [ ] mountainList = new int [ numMountain ] ; int topOne = 0 ; int topTwo = 0 ; int topThree = 0 ; BufferedReader stdin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int i = 0 ; try { while ( i < numMountain && ( line = stdin . readLine ( ) ) != null && line . length ( ) != 0 ) { try { int tempHeight = Integer . parseInt ( line ) ; if ( tempHeight < minConst || tempHeight > maxConst ) { } else { mountainList [ i ] = tempHeight ; i ++ ; } } catch ( NumberFormatException e ) { } } for ( int j = 0 ; j < numMountain ; j ++ ) { if ( mountainList [ j ] >= topOne ) { topThree = topTwo ; topTwo = topOne ; topOne = mountainList [ j ] ; } else if ( mountainList [ j ] >= topTwo ) { topThree = topTwo ; topTwo = mountainList [ j ] ; } else if ( mountainList [ j ] >= topThree ) { topThree = mountainList [ j ] ; } } System . out . println ( topOne + \" \\n \" + topTwo + \" \\n \" + topThree ) ; } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { in [ i ] = sc . nextInt ( ) ; } int big [ ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( big [ 0 ] < in [ i ] ) { big [ 2 ] = big [ 1 ] ; big [ 1 ] = big [ 0 ] ; big [ 0 ] = in [ i ] ; } else if ( big [ 1 ] < in [ i ] ) { big [ 2 ] = big [ 1 ] ; big [ 1 ] = in [ i ] ; } else if ( big [ 2 ] < in [ i ] ) { big [ 2 ] = in [ i ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( big [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = scan . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { try { height [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } Arrays . sort ( height ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] a ) throws IOException { int x [ ] = new int [ 100 ] ; int k = 0 ; BufferedReader d = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = d . readLine ( ) ; x [ i ] = Integer . parseInt ( str ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( x [ i ] > x [ j ] ) { k = x [ i ] ; x [ i ] = x [ j ] ; x [ j ] = k ; } } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( x [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int height [ ] = new int [ 10 ] ; int out [ ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { try { height [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } catch ( IOException e ) { } } for ( int i = 0 ; i < height . length ; i ++ ) { if ( out [ 0 ] < height [ i ] ) { out [ 2 ] = out [ 1 ] ; out [ 1 ] = out [ 0 ] ; out [ 0 ] = height [ i ] ; } else if ( out [ 1 ] < height [ i ] ) { out [ 2 ] = out [ 1 ] ; out [ 1 ] = height [ i ] ; } else if ( out [ 2 ] < height [ i ] ) { out [ 2 ] = height [ i ] ; } } for ( int i = 0 ; i < out . length ; i ++ ) { System . out . println ( out [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int m ; int [ ] tall ; tall = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { m = scan . nextInt ( ) ; if ( tall [ 0 ] < m ) { tall [ 2 ] = tall [ 1 ] ; tall [ 1 ] = tall [ 0 ] ; tall [ 0 ] = m ; } else if ( tall [ 1 ] < m ) { tall [ 2 ] = tall [ 1 ] ; tall [ 1 ] = m ; } else if ( tall [ 2 ] < m ) { tall [ 2 ] = m ; } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( tall [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int MOUNTAIN [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { MOUNTAIN [ i ] = sc . nextInt ( ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 - i ; j ++ ) { if ( MOUNTAIN [ j ] > MOUNTAIN [ j + 1 ] ) { int taihi ; taihi = MOUNTAIN [ j ] ; MOUNTAIN [ j ] = MOUNTAIN [ j + 1 ] ; MOUNTAIN [ j + 1 ] = taihi ; } } } for ( int i = 9 ; i != 6 ; i -- ) { System . out . println ( MOUNTAIN [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static int height [ ] = new int [ 10 ] ; public static void liner ( ) { int num ; for ( int i = 0 ; i <= 9 ; i ++ ) { for ( int j = i + 1 ; j <= 9 ; j ++ ) { if ( height [ i ] <= height [ j ] ) { num = height [ i ] ; height [ i ] = height [ j ] ; height [ j ] = num ; } } } for ( int i = 0 ; i <= 2 ; i ++ ) System . out . println ( height [ i ] ) ; } public static void main ( String [ ] a ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i <= 9 ; i ++ ) { height [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } liner ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int [ ] input = new int [ 10 ] ; int x ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int r = i + 1 ; r < 10 ; r ++ ) { if ( input [ i ] < input [ r ] ) { x = input [ i ] ; input [ i ] = input [ r ] ; input [ r ] = x ; } } } System . out . println ( input [ 0 ] ) ; System . out . println ( input [ 1 ] ) ; System . out . println ( input [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] kazu = new int [ 10 ] ; for ( int a = 0 ; a <= 9 ; a ++ ) { kazu [ a ] = Integer . parseInt ( br . readLine ( ) ) ; } int n = 10 ; int kari ; for ( int b = 0 ; b <= n - 2 ; b ++ ) { int x = b ; for ( int c = b + 1 ; c <= n - 1 ; c ++ ) { if ( kazu [ x ] < kazu [ c ] ) { x = c ; } } if ( x != b ) { kari = kazu [ x ] ; kazu [ x ] = kazu [ b ] ; kazu [ b ] = kari ; } } for ( int d = 0 ; d <= 2 ; d ++ ) { System . out . println ( kazu [ d ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] kazu = new int [ 10 ] ; for ( int a = 0 ; a <= 9 ; a ++ ) { kazu [ a ] = Integer . parseInt ( br . readLine ( ) ) ; } int n = 10 ; int kari ; for ( int b = 0 ; b <= n - 2 ; b ++ ) { int x = b ; for ( int c = b + 1 ; c <= n - 1 ; c ++ ) { if ( kazu [ x ] < kazu [ c ] ) { x = c ; } } if ( x != b ) { kari = kazu [ x ] ; kazu [ x ] = kazu [ b ] ; kazu [ b ] = kari ; } } for ( int d = 0 ; d <= 2 ; d ++ ) { System . out . println ( kazu [ d ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] k = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) k [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( k ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( k [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] k = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) k [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( k ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( k [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] kazu = new int [ 10 ] ; for ( int a = 0 ; a <= 9 ; a ++ ) { kazu [ a ] = Integer . parseInt ( br . readLine ( ) ) ; } int n = 10 ; int kari ; for ( int b = 0 ; b <= n - 2 ; b ++ ) { int x = b ; for ( int c = b + 1 ; c <= n - 1 ; c ++ ) { if ( kazu [ x ] < kazu [ c ] ) { x = c ; } } if ( x != b ) { kari = kazu [ x ] ; kazu [ x ] = kazu [ b ] ; kazu [ b ] = kari ; } } for ( int d = 0 ; d <= 2 ; d ++ ) { System . out . println ( kazu [ d ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; int [ ] input = new int [ 10 ] ; int w ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = s . nextInt ( ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( input [ j ] < input [ j + 1 ] ) { w = input [ j ] ; input [ j ] = input [ j + 1 ] ; input [ j + 1 ] = w ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( input [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { final int N = 10 ; int [ ] a = new int [ N ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < N ; ++ i ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( a [ N - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; import static java . util . Comparator . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: new ) . sorted ( reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; import static java . util . Comparator . * ; class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; in . lines ( ) . map ( Integer :: parseInt ) . sorted ( reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h1 = - 1 , h2 = - 1 , h3 = - 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = sc . nextInt ( ) ; if ( h > h1 ) { h3 = h2 ; h2 = h1 ; h1 = h ; } else if ( h > h2 ) { h3 = h2 ; h2 = h ; } else if ( h > h3 ) { h3 = h ; } } System . out . println ( h1 ) ; System . out . println ( h2 ) ; System . out . println ( h3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] m = new int [ 10 ] ; int [ ] max = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { m [ i ] = scan . nextInt ( ) ; if ( m [ i ] >= max [ 0 ] ) { max [ 2 ] = max [ 1 ] ; max [ 1 ] = max [ 0 ] ; max [ 0 ] = m [ i ] ; } else if ( m [ i ] >= max [ 1 ] ) { max [ 2 ] = max [ 1 ] ; max [ 1 ] = m [ i ] ; } else if ( m [ i ] >= max [ 2 ] ) { max [ 2 ] = m [ i ] ; } } for ( int i = 0 ; i <= 2 ; i ++ ) { System . out . println ( max [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] h = new int [ 11 ] ; int hz = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } for ( int i = 9 ; i >= 1 ; i -- ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( h [ j ] <= h [ j + 1 ] ) { hz = h [ j + 1 ] ; h [ j + 1 ] = h [ j ] ; h [ j ] = hz ; } } } for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int num [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( num ) ; for ( int j = 9 ; j > 6 ; j -- ) { System . out . println ( num [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int hight [ ] ; hight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hight [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( hight ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hight [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int hight [ ] ; hight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hight [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( hight ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hight [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountain = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( mountain ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountain [ mountain . length - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int data_num = 10 ; int top = 3 ; int [ ] data = new int [ data_num ] ; for ( int i = 0 ; i < data_num ; i ++ ) { data [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i < data_num ; i ++ ) { for ( int j = data_num - 1 ; j > i ; j -- ) { if ( data [ j - 1 ] < data [ j ] ) { int temp = data [ j - 1 ] ; data [ j - 1 ] = data [ j ] ; data [ j ] = temp ; } } } for ( int i = 0 ; i < top ; i ++ ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] arg ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > al = new ArrayList < > ( ) ; int i = 0 , j = 0 ; while ( i < 10 ) { int x = parseInt ( br . readLine ( ) ) ; if ( 0 <= x && x <= 10000 ) { al . add ( x ) ; } i ++ ; } Collections . sort ( al , Comparator . reverseOrder ( ) ) ; while ( j < 3 ) { System . out . println ( al . get ( j ) ) ; j ++ ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str ; String [ ] heightstr = new String [ 10 ] ; int [ ] heightint = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { str = br . readLine ( ) ; heightstr [ i ] = str ; heightint [ i ] = Integer . parseInt ( heightstr [ i ] ) ; } for ( int j = 0 ; j <= 8 ; j ++ ) { for ( int k = j + 1 ; k <= 9 ; k ++ ) { Boolean isBig = heightint [ j ] < heightint [ k ] ; if ( isBig ) { int temporary = heightint [ j ] ; heightint [ j ] = heightint [ k ] ; heightint [ k ] = temporary ; } } } System . out . println ( heightint [ 0 ] ) ; System . out . println ( heightint [ 1 ] ) ; System . out . println ( heightint [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner in = new Scanner ( System . in ) ; int x [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = in . nextInt ( ) ; } for ( int j = 0 ; j < 3 ; j ++ ) { int max = 0 ; int k = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( x [ i ] > max ) { k = i ; max = x [ i ] ; } } System . out . println ( x [ k ] ) ; x [ k ] = 0 ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] m = new int [ 10 ] ; int [ ] h = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { h [ i ] = - 1 ; } for ( int i = 0 ; i < 10 ; i ++ ) { m [ i ] = scanner . nextInt ( ) ; if ( h [ 0 ] < m [ i ] ) { h [ 0 ] = m [ i ] ; int r = 0 ; for ( int j = 1 ; j < 3 ; j ++ ) { if ( h [ j ] < h [ r ] ) { int buf = h [ r ] ; h [ r ] = h [ j ] ; h [ j ] = buf ; r = j ; } } } } for ( int i = 2 ; i >= 0 ; i -- ) { System . out . println ( h [ i ] + \" \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] yama = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { yama [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } int dami = 0 ; for ( int i = 0 ; i <= 8 ; i ++ ) { int x = i ; for ( int j = i + 1 ; j <= 9 ; j ++ ) { if ( yama [ x ] < yama [ j ] ) { x = j ; } } if ( x != i ) { dami = yama [ x ] ; yama [ x ] = yama [ i ] ; yama [ i ] = dami ; } } for ( int i = 0 ; i <= 2 ; i ++ ) { System . out . println ( yama [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { int a = data [ i ] ; int indexMin = i ; for ( int k = i + 1 ; k < 10 ; k ++ ) { if ( data [ k ] < a ) { a = data [ k ] ; indexMin = k ; } } int temp = data [ i ] ; data [ i ] = data [ indexMin ] ; data [ indexMin ] = temp ; } for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . text . ParseException ; import java . util . Arrays ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) throws ParseException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountainHeight = new Integer [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { mountainHeight [ i ] = Integer . valueOf ( br . readLine ( ) ) ; } Arrays . sort ( mountainHeight , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountainHeight [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { int maxIndex = i ; for ( int k = i + 1 ; k < 10 ; k ++ ) { if ( data [ maxIndex ] < data [ k ] ) { maxIndex = k ; } } int tmp = data [ maxIndex ] ; data [ maxIndex ] = data [ i ] ; data [ i ] = tmp ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountainsheight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountainsheight [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i < mountainsheight . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < mountainsheight . length ; j ++ ) { if ( mountainsheight [ i ] < mountainsheight [ j ] ) { int temporary = mountainsheight [ i ] ; mountainsheight [ i ] = mountainsheight [ j ] ; mountainsheight [ j ] = temporary ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountainsheight [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static int swap ( int a , int b ) { return a ; } public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int a [ ] = new int [ 4 ] ; for ( int t = 0 ; t < 10 ; t ++ ) { a [ 3 ] = input . nextInt ( ) ; for ( int i = 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) { a [ i + 1 ] = swap ( a [ i ] , a [ i ] = a [ i + 1 ] ) ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } input . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { private final static int LIST_MAX = 10 ; private final static int INPUT_MIN = 0 ; private final static int INPUT_MAX = 10000 ; public static void main ( String [ ] args ) { int Mt_list [ ] ; Mt_list = input ( ) ; sort ( Mt_list ) ; show ( Mt_list ) ; } public static void show ( int [ ] list ) { for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list [ i ] ) ; } } public static int [ ] input ( ) { Scanner stdIn = new Scanner ( System . in ) ; int list [ ] = new int [ LIST_MAX ] ; for ( int i = 0 ; i < LIST_MAX ; i ++ ) { int tmp = stdIn . nextInt ( ) ; if ( input_ck ( tmp ) ) { list [ i ] = tmp ; } else { continue ; } } stdIn . close ( ) ; return list ; } public static boolean input_ck ( int x ) { if ( INPUT_MIN <= x && x <= INPUT_MAX ) { return true ; } return false ; } public static int [ ] sort ( int [ ] list ) { for ( int i = 0 ; i < LIST_MAX - 1 ; i ++ ) { for ( int j = LIST_MAX - 1 ; j >= i + 1 ; j -- ) { if ( list [ j - 1 ] < list [ j ] ) { int work = list [ j - 1 ] ; list [ j - 1 ] = list [ j ] ; list [ j ] = work ; } } } return list ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] data = new int [ 10 ] ; try { for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } Arrays . sort ( data ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( data [ 9 - i ] ) ; } } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountains = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( mountains , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( mountains [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; final int DATA_SIZE = 10 ; int height ; int first = - 1 , second = - 1 , third = - 1 ; for ( int i = 0 ; i < DATA_SIZE ; i ++ ) { height = scanner . nextInt ( ) ; if ( height > first ) { third = second ; second = first ; first = height ; } else if ( height > second ) { third = second ; second = height ; } else if ( height > third ) { third = height ; } } System . out . printf ( \" %d \\n %d \\n %d \\n \" , first , second , third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; Integer [ ] data = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int number = scanner . nextInt ( ) ; while ( ! ( 0 <= number && number <= 10000 ) ) { number = scanner . nextInt ( ) ; } data [ i ] = number ; } scanner . close ( ) ; Arrays . sort ( data , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] value = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { int n = sc . nextInt ( ) ; if ( n > 0 && n <= 10000 ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( n > value [ j ] ) { for ( int k = 1 ; k >= j ; k -- ) { value [ k + 1 ] = value [ k ] ; } value [ j ] = n ; break ; } } } } sc . close ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( value [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > mountain = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain . add ( Integer . parseInt ( sc . nextLine ( ) ) ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { int max = mountain . get ( 0 ) ; int save = 0 ; for ( int j = 0 ; j < mountain . size ( ) ; j ++ ) { if ( max < mountain . get ( j ) ) { max = mountain . get ( j ) ; save = j ; } } System . out . println ( mountain . get ( save ) ) ; mountain . remove ( save ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int h1 = 0 , h2 = 0 , h3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int height = Integer . parseInt ( br . readLine ( ) ) ; if ( h1 < height ) { h3 = h2 ; h2 = h1 ; h1 = height ; } else if ( h2 < height ) { h3 = h2 ; h2 = height ; } else if ( h3 < height ) { h3 = height ; } } sb . append ( h1 ) . append ( \" \\n \" ) ; sb . append ( h2 ) . append ( \" \\n \" ) ; sb . append ( h3 ) . append ( \" \\n \" ) ; System . out . print ( sb ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static final int NUMBER = 10 ; public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int [ ] array = new int [ NUMBER ] ; int [ ] height = new int [ 3 ] ; for ( int i = 0 ; i < NUMBER ; i ++ ) { array [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { height [ i ] = array [ i ] ; int index = i ; for ( int j = i + 1 ; j < NUMBER ; j ++ ) { if ( array [ index ] < array [ j ] ) index = j ; } int tmp = height [ i ] ; height [ i ] = array [ index ] ; array [ index ] = tmp ; sb . append ( height [ i ] ) . append ( \" \\n \" ) ; } System . out . print ( sb ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static final Scanner scan = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = scan . nextInt ( ) ; mt [ i ] = h ; } for ( int i = 0 ; i < 10 - 1 ; i ++ ) { for ( int j = 10 - 1 ; j > i ; j -- ) { if ( mt [ i ] < mt [ j ] ) { int big = mt [ j ] ; mt [ j ] = mt [ i ] ; mt [ i ] = big ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . printf ( \" %d \\n \" , mt [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static final Scanner scan = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 10 - 1 ; i ++ ) { for ( int j = 10 - 1 ; j > i ; j -- ) { if ( mt [ i ] < mt [ j ] ) { int big = mt [ j ] ; mt [ j ] = mt [ i ] ; mt [ i ] = big ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . printf ( \" %d \\n \" , mt [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader sb = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] hList = new Integer [ 10 ] ; for ( int num = 0 ; num < 10 ; num ++ ) { int h = Integer . parseInt ( sb . readLine ( ) ) ; hList [ num ] = h ; } Arrays . sort ( hList , Collections . reverseOrder ( ) ) ; for ( int rank = 0 ; rank < 3 ; rank ++ ) { System . out . println ( hList [ rank ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; int [ ] rank3 = { 0 , 0 , 0 } ; int mountain ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain = Integer . parseInt ( r . readLine ( ) ) ; if ( rank3 [ 0 ] < mountain ) { rank3 [ 2 ] = rank3 [ 1 ] ; rank3 [ 1 ] = rank3 [ 0 ] ; rank3 [ 0 ] = mountain ; } else if ( rank3 [ 1 ] < mountain ) { rank3 [ 2 ] = rank3 [ 1 ] ; rank3 [ 1 ] = mountain ; } else if ( rank3 [ 2 ] < mountain ) { rank3 [ 2 ] = mountain ; } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( rank3 [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { List < Integer > inputs = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! sc . hasNextInt ( ) ) { break ; } int input = sc . nextInt ( ) ; inputs . add ( Integer . valueOf ( input ) ) ; } Collections . sort ( inputs , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ) ; for ( int height : inputs . subList ( 0 , Math . min ( inputs . size ( ) , 3 ) ) ) { System . out . println ( height ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Scanner ; import java . util . Set ; public class Main { public static void main ( String [ ] args ) { Map < Integer , Integer > heightsOfMountain = new HashMap < > ( ) ; Scanner scanner = new Scanner ( System . in ) ; for ( int i = 1 ; i <= 10 ; i ++ ) { int height = scanner . nextInt ( ) ; heightsOfMountain . put ( i , height ) ; } Set < Entry < Integer , Integer > > set = heightsOfMountain . entrySet ( ) ; List < Entry < Integer , Integer > > list = new ArrayList < Entry < Integer , Integer > > ( set ) ; Collections . sort ( list , new Comparator < Map . Entry < Integer , Integer > > ( ) { @ Override public int compare ( Entry < Integer , Integer > o1 , Entry < Integer , Integer > o2 ) { return ( o2 . getValue ( ) ) . compareTo ( o1 . getValue ( ) ) ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { Map . Entry < Integer , Integer > entry = list . get ( i ) ; System . out . println ( entry . getValue ( ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { int height [ ] = new int [ 10 ] ; Scanner in = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { try { height [ i ] = in . nextInt ( ) ; } catch ( Exception e ) { break ; } } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; int first = 0 , second = 0 , third = 0 ; int [ ] hills = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = scanner . nextInt ( ) ; if ( hills [ i ] > first ) { third = second ; second = first ; first = hills [ i ] ; } else if ( hills [ i ] > second ) { third = second ; second = hills [ i ] ; } else if ( hills [ i ] > third ) { third = hills [ i ] ; } } System . out . print ( first + \" \\n \" + second + \" \\n \" + third + \" \\n \" ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { heights [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( heights ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String stra = scan . next ( ) ; int str = Integer . parseInt ( stra ) ; list . add ( str ) ; } scan . close ( ) ; Collections . sort ( list ) ; System . out . println ( list . get ( 9 ) ) ; System . out . println ( list . get ( 8 ) ) ; System . out . println ( list . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String [ ] args ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; int first , second , third , temp ; first = sc . nextInt ( ) ; temp = sc . nextInt ( ) ; if ( temp > first ) { second = first ; first = temp ; } else { second = temp ; } temp = sc . nextInt ( ) ; if ( temp > first ) { third = second ; second = first ; first = temp ; } else if ( temp > second ) { third = second ; second = temp ; } else { third = temp ; } for ( int i = 3 ; i < 10 ; i ++ ) { temp = sc . nextInt ( ) ; if ( temp > first ) { third = second ; second = first ; first = temp ; } else if ( temp > second ) { third = second ; second = temp ; } else if ( temp > third ) { third = temp ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String [ ] args ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; int [ ] mini = new int [ ] { - 1 , - 2 , - 3 } ; int temp ; for ( int i = 0 ; i < 10 ; i ++ ) { temp = sc . nextInt ( ) ; if ( temp > mini [ 0 ] ) { mini [ 2 ] = mini [ 1 ] ; mini [ 1 ] = mini [ 0 ] ; mini [ 0 ] = temp ; } else if ( temp > mini [ 1 ] ) { mini [ 2 ] = mini [ 1 ] ; mini [ 1 ] = temp ; } else if ( temp > mini [ 2 ] ) { mini [ 2 ] = temp ; } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( mini [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; final int SIZE = 10 ; int [ ] height = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { height [ i ] = scanner . nextInt ( ) ; } int [ ] valueMax = max3 ( height ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( valueMax [ i ] ) ; } } static int [ ] max3 ( int [ ] args ) { final int MIN = Integer . MIN_VALUE ; int [ ] valueMax = { MIN , MIN , MIN } ; for ( int value : args ) { int tmp ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( value > valueMax [ i ] ) { tmp = valueMax [ i ] ; valueMax [ i ] = value ; value = tmp ; } } } return valueMax ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( System . in ) ) { solve ( in ) ; } } private static void solve ( Scanner in ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = in . nextInt ( ) ; if ( a < h ) { c = b ; b = a ; a = h ; } else if ( b < h ) { c = b ; b = h ; } else if ( c < h ) { c = h ; } } System . out . println ( a + \" \\n \" + b + \" \\n \" + c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws IOException { Integer [ ] height = new Integer [ 10 ] ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = Integer . valueOf ( br . readLine ( ) ) ; } int a = 0 ; for ( int j = 0 ; j < 9 ; j ++ ) { for ( int k = 9 ; k > j ; k -- ) { if ( height [ k ] < height [ k - 1 ] ) { a = height [ k ] ; height [ k ] = height [ k - 1 ] ; height [ k - 1 ] = a ; } } } for ( int l = 0 ; l < 3 ; l ++ ) { System . out . println ( height [ 9 - l ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static final int MAX = 200000 ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int highest = 0 ; int middle = 0 ; int lowest = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int now = Integer . parseInt ( br . readLine ( ) ) ; if ( highest <= now ) { lowest = middle ; middle = highest ; highest = now ; } else if ( middle <= now ) { lowest = middle ; middle = now ; } else if ( lowest <= now ) { lowest = now ; } } System . out . println ( highest + \" \\n \" + middle + \" \\n \" + lowest ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) throws Exception { Integer arrays [ ] = new Integer [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { arrays [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arrays , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( arrays [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountain = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( mountain ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountain [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int height = sc . nextInt ( ) ; heights [ i ] = height ; } Arrays . sort ( heights ) ; System . out . println ( heights [ 9 ] ) ; System . out . println ( heights [ 8 ] ) ; System . out . println ( heights [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] args ) throws java . io . IOException { int fst = 0 , snd = 0 , thi = 0 ; int temp ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int j = Integer . parseInt ( in . readLine ( ) ) ; if ( j > fst ) { temp = snd ; snd = fst ; thi = temp ; fst = j ; } else if ( j > snd ) { thi = snd ; snd = j ; } else if ( j > thi ) { thi = j ; } } System . out . println ( fst ) ; System . out . println ( snd ) ; System . out . println ( thi ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < String > list = new ArrayList < String > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( br . readLine ( ) ) ; } Collections . sort ( list , ( s1 , s2 ) -> Integer . parseInt ( s2 ) - Integer . parseInt ( s1 ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Calc calc = new Calc ( ) ; int [ ] height = { 0 , 0 , 0 } ; int newh ; ; for ( int cnt = 0 ; cnt < 10 ; cnt ++ ) { newh = sc . nextInt ( ) ; height = Calc . calc ( newh , height ) ; } ; System . out . println ( height [ 0 ] ) ; System . out . println ( height [ 1 ] ) ; System . out . println ( height [ 2 ] ) ; } } class Calc { public static int [ ] calc ( int h , int [ ] Pastheight ) { int Newheight [ ] = ( int [ ] ) Pastheight . clone ( ) ; if ( ( h > Pastheight [ 2 ] ) && ( h <= Pastheight [ 1 ] ) ) { Newheight [ 2 ] = h ; } else if ( ( h > Pastheight [ 1 ] ) && ( h <= Pastheight [ 0 ] ) ) { Newheight [ 1 ] = h ; Newheight [ 2 ] = Pastheight [ 1 ] ; } else if ( h > Pastheight [ 0 ] ) { Newheight [ 0 ] = h ; Newheight [ 1 ] = Pastheight [ 0 ] ; Newheight [ 2 ] = Pastheight [ 1 ] ; } return Newheight ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = Integer . parseInt ( sc . next ( ) ) ; } Arrays . sort ( mt ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mt [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] a ) { int [ ] h = new int [ 10 ] ; Scanner s = new Scanner ( System . in ) ; for ( int i = 0 ; i < h . length ; i ++ ) { h [ i ] = s . nextInt ( ) ; } Arrays . sort ( h ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { final int DATAMAX = 10 ; int a [ ] = new int [ DATAMAX ] ; InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; for ( int i = 0 ; i < DATAMAX ; i ++ ) { a [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } for ( int i = 0 ; i < DATAMAX ; i ++ ) { for ( int j = i + 1 ; j < DATAMAX ; j ++ ) { if ( a [ i ] < a [ j ] ) { int tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int max1 = 0 , max2 = 0 , max3 = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int h = sc . nextInt ( ) ; if ( h > max1 ) { max3 = max2 ; max2 = max1 ; max1 = h ; } else if ( h > max2 ) { max3 = max2 ; max2 = h ; } else if ( h > max3 ) max3 = h ; } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { Highest3 h3 = new Highest3 ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int a = Integer . parseInt ( sc . next ( ) ) ; h3 . renew ( a ) ; } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( h3 . get ( i ) ) ; } } } class Highest3 { private int [ ] height = new int [ 3 ] ; Highest3 ( ) { for ( int i = 0 ; i < 3 ; i ++ ) this . height [ i ] = 0 ; } public void renew ( int height ) { int [ ] h4 = new int [ 4 ] ; for ( int i = 0 ; i < 3 ; i ++ ) h4 [ i ] = this . height [ i ] ; h4 [ 3 ] = height ; Arrays . sort ( h4 ) ; for ( int i = 0 ; i < 3 ; i ++ ) this . height [ i ] = h4 [ 3 - i ] ; } public int get ( int i ) { return this . height [ i ] ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] height = new int [ 10 ] ; Scanner s = new Scanner ( System . in ) ; int temp ; for ( int i = 0 ; i < height . length ; i ++ ) { height [ i ] = s . nextInt ( ) ; } for ( int i = 0 ; i < height . length ; i ++ ) { for ( int j = i ; j < height . length ; j ++ ) { if ( i != j ) { if ( height [ i ] < height [ j ] ) { temp = height [ i ] ; height [ i ] = height [ j ] ; height [ j ] = temp ; } } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] mountain_height = new int [ 10 ] ; for ( int j = 0 ; j < mountain_height . length ; j ++ ) { mountain_height [ j ] = stdIn . nextInt ( ) ; } Arrays . sort ( mountain_height ) ; for ( int i = mountain_height . length - 1 ; i >= mountain_height . length - 3 ; i -- ) { System . out . println ( mountain_height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int max1 = 0 ; int max2 = 0 ; int max3 = 0 ; int tmp ; for ( int i = 0 ; i < 10 ; i ++ ) { tmp = scan . nextInt ( ) ; if ( tmp > max1 ) { max3 = max2 ; max2 = max1 ; max1 = tmp ; } else if ( tmp > max2 ) { max3 = max2 ; max2 = tmp ; } else if ( tmp > max3 ) { max3 = tmp ; } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; Integer array [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 10 ; ++ i ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ; ArrayList < Integer > mList = new ArrayList < > ( ) ; while ( sc . hasNext ( ) ) { mList . add ( sc . nextInt ( ) ) ; } mList . sort ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mList . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner scan = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( scan . nextInt ( ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int a = sc . nextInt ( ) ; list . add ( a ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( 9 ) ) ; System . out . println ( list . get ( 8 ) ) ; System . out . println ( list . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; Integer array [ ] ; array = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { Integer mountain = sc . nextInt ( ) ; array [ i ] = mountain ; } Arrays . sort ( array , Comparator . reverseOrder ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( array [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws java . lang . Exception { int [ ] x = new int [ 10 ] ; Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = cin . nextInt ( ) ; } Arrays . sort ( x ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( String . valueOf ( x [ i ] ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; int i ; for ( i = 0 ; i < 10 ; i ++ ) { x [ i ] = cin . nextInt ( ) ; } Arrays . sort ( x ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws java . lang . Exception { int [ ] x = new int [ 10 ] ; Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = cin . nextInt ( ) ; } Arrays . sort ( x ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = input . nextInt ( ) ; } Arrays . sort ( x ) ; for ( int i = 9 ; 6 < i ; i -- ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws java . lang . Exception { int a [ ] = new int [ 10 ] ; int i ; Scanner cin = new Scanner ( System . in ) ; for ( i = 0 ; i < 10 ; i ++ ) { a [ i ] = cin . nextInt ( ) ; } Arrays . sort ( a ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; MyArray myArray = new MyArray ( 10 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { myArray . input ( cin . nextInt ( ) ) ; } myArray . sort ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( myArray . top ( ) ) ; myArray . pop ( ) ; } } } class MyArray { private int num [ ] ; private int size = 0 ; MyArray ( int n ) { this . num = new int [ n ] ; } protected void sort ( ) { Arrays . sort ( num ) ; } protected int top ( ) { if ( size == 0 ) { return ( 0 ) ; } return ( num [ size - 1 ] ) ; } protected void pop ( ) { for ( int i = size - 1 ; i > 1 ; i -- ) { num [ i ] = num [ i - 1 ] ; } } protected void input ( int n ) { num [ size ] = n ; size ++ ; } protected int at ( int n ) { return ( num [ n ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { int [ ] m = new int [ 10 ] ; input ( m , 10 ) ; Arrays . sort ( m ) ; reverse ( m ) ; output ( m , 3 ) ; } private static final void reverse ( int [ ] m ) { int n = m . length ; for ( int i = 0 ; i < n / 2 ; i ++ ) { int tmp = m [ i ] ; m [ i ] = m [ n - i - 1 ] ; m [ n - i - 1 ] = tmp ; } } private static final void output ( int [ ] m , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( m [ i ] ) ; } } private static final void input ( int [ ] m , int n ) { Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = cin . nextInt ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { int [ ] m = new int [ 10 ] ; input ( m , 10 ) ; Arrays . sort ( m ) ; reverse ( m ) ; output ( m , 3 ) ; } private static void reverse ( int [ ] m ) { int n = m . length ; for ( int i = 0 ; i < n / 2 ; i ++ ) { int tmp = m [ i ] ; m [ i ] = m [ n - i - 1 ] ; m [ n - i - 1 ] = tmp ; } } private static void output ( int [ ] m , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( m [ i ] ) ; } } private static void input ( int [ ] m , int n ) { Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = cin . nextInt ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] a ) throws IOException { ; String strLine = \" \" ; BufferedReader stdReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] hill = new Integer [ 10 ] ; int i = 0 ; while ( ( strLine = stdReader . readLine ( ) ) != null ) { hill [ i ] = Integer . parseInt ( strLine ) ; i ++ ; } Arrays . sort ( hill ) ; for ( i = 9 ; i >= 7 ; i -- ) { System . out . println ( hill [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner std = new Scanner ( System . in ) ; int array [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = Integer . parseInt ( std . next ( ) ) ; } Arrays . sort ( array ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( data ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int [ ] m = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) m [ i ] = scan . nextInt ( ) ; Arrays . sort ( m ) ; for ( int i = 9 ; i >= 7 ; i -- ) System . out . println ( m [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { int [ ] a = new int [ 10 ] ; Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = cin . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] highests = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { int height = Integer . parseInt ( sc . nextLine ( ) ) ; if ( highests [ 0 ] <= height ) { highests [ 2 ] = highests [ 1 ] ; highests [ 1 ] = highests [ 0 ] ; highests [ 0 ] = height ; } else if ( highests [ 1 ] <= height ) { highests [ 2 ] = highests [ 1 ] ; highests [ 1 ] = height ; } else if ( highests [ 2 ] <= height ) { highests [ 2 ] = height ; } } System . out . println ( highests [ 0 ] ) ; System . out . println ( highests [ 1 ] ) ; System . out . println ( highests [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { int a [ ] = new int [ 10 ] ; Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = cin . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { int a [ ] = new int [ 10 ] ; Scanner x = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = x . nextInt ( ) ; } Arrays . sort ( a ) ; x . close ( ) ; for ( int j = 9 ; j >= 7 ; j -- ) System . out . println ( a [ j ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { static final Scanner s = new Scanner ( System . in ) ; public static void main ( String args [ ] ) { int in [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) in [ i ] = s . nextInt ( ) ; Arrays . sort ( in ) ; System . out . println ( in [ 9 ] ) ; System . out . println ( in [ 8 ] ) ; System . out . println ( in [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] a ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int [ ] mount = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = br . readLine ( ) ; int high = Integer . parseInt ( str ) ; if ( high >= 0 && high <= 10000 ) { mount [ i ] = high ; } for ( int k = 0 ; k <= i ; k ++ ) { if ( mount [ k ] < mount [ i ] ) { int h = mount [ i ] ; mount [ i ] = mount [ k ] ; mount [ k ] = h ; } } } for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( mount [ j ] ) ; } } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws IOException { ArrayList < Integer > array = new ArrayList < Integer > ( ) ; BufferedReader buf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int x = Integer . valueOf ( buf . readLine ( ) ) ; array . add ( x ) ; } Collections . sort ( array ) ; Collections . reverse ( array ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( array . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] hights = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hights [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( hights ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( hights [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { List < Integer > lines = new ArrayList < > ( ) ; while ( sc . hasNext ( ) ) { lines . add ( Integer . parseInt ( sc . nextLine ( ) ) ) ; } lines . sort ( Comparator . reverseOrder ( ) ) ; int len = Math . min ( lines . size ( ) , 3 ) ; for ( int i = 0 ; i < len ; i ++ ) { System . out . println ( lines . get ( i ) ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > heights = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { heights . add ( Integer . parseInt ( sc . next ( ) ) ) ; } Collections . sort ( heights , ( o1 , o2 ) -> { if ( o1 > o2 ) { return - 1 ; } if ( o1 < o2 ) { return 1 ; } return 0 ; } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . stream ( mt ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . stream ( mt ) . parallel ( ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . sequential ( ) . limit ( 3 ) . forEach ( System . out :: println ) ; } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; br . lines ( ) . parallel ( ) . map ( Integer :: parseInt ) . sorted ( Comparator . reverseOrder ( ) ) . sequential ( ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { private static int input_num , temp ; public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] best3_height = { 0 , 0 , 0 } ; while ( stdIn . hasNextInt ( ) ) { input_num = stdIn . nextInt ( ) ; if ( best3_height [ 0 ] < input_num ) { temp = best3_height [ 0 ] ; best3_height [ 0 ] = input_num ; best3_height [ 2 ] = best3_height [ 1 ] ; best3_height [ 1 ] = temp ; temp = 0 ; } else if ( best3_height [ 1 ] < input_num ) { temp = best3_height [ 1 ] ; best3_height [ 1 ] = input_num ; best3_height [ 2 ] = temp ; temp = 0 ; } else if ( best3_height [ 2 ] < input_num ) { best3_height [ 2 ] = input_num ; } else { continue ; } } for ( int height : best3_height ) { System . out . println ( height ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Comparator ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > lstInt = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { lstInt . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } lstInt . sort ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; ++ i ) System . out . println ( lstInt . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; int top = 0 ; int second = 0 ; int thard = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = s . nextInt ( ) ; if ( i > 0 ) { if ( top <= a [ i ] ) { thard = second ; second = top ; top = a [ i ] ; } else if ( second <= a [ i ] && top >= a [ i ] ) { thard = second ; second = a [ i ] ; } else if ( thard <= a [ i ] && second >= a [ i ] ) { thard = a [ i ] ; } } else { top = a [ i ] ; } } System . out . println ( top ) ; System . out . println ( second ) ; System . out . println ( thard ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Comparator ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountain = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( mountain , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountain [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { static Scanner scan = new Scanner ( System . in ) ; static int hills [ ] = new int [ 10 ] ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = scan . nextInt ( ) ; } Arrays . sort ( hills ) ; System . out . println ( hills [ 9 ] ) ; System . out . println ( hills [ 8 ] ) ; System . out . println ( hills [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int nums [ ] = new int [ 10 ] ; for ( byte i = 0 ; i < 10 ; i ++ ) nums [ i ] = in . nextInt ( ) ; Arrays . sort ( nums ) ; System . out . println ( nums [ 9 ] ) ; System . out . println ( nums [ 8 ] ) ; System . out . println ( nums [ 7 ] ) ; in . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] a = new int [ 10 ] ; String s ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; class Main { static List < Integer > list = new ArrayList < Integer > ( ) ; public static void main ( String [ ] args ) { Collections . addAll ( list , 0 , 0 , 0 ) ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int sc = scan . nextInt ( ) ; max ( sc ) ; } for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } public static void max ( int sc ) { for ( int j = 0 ; j < list . size ( ) ; j ++ ) { if ( list . get ( j ) <= sc ) { list . remove ( 2 ) ; list . add ( j , sc ) ; break ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; class Main { static List < Integer > list = new ArrayList < Integer > ( ) ; public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( scan . nextInt ( ) ) ; } Collections . sort ( list , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { heights [ i ] = scan . nextInt ( ) ; } Arrays . sort ( heights ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( heights [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int first = 0 ; int second = 0 ; int third = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int height = s . nextInt ( ) ; if ( height > first ) { third = second ; second = first ; first = height ; } else if ( height > second ) { third = second ; second = height ; } else if ( height > third ) { third = height ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; s . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Comparator ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > lstInt = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { lstInt . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } lstInt . sort ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; ++ i ) System . out . println ( lstInt . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; } int n = array . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( array [ j - 1 ] < array [ j ] ) { int box = array [ j - 1 ] ; array [ j - 1 ] = array [ j ] ; array [ j ] = box ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int array [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int nui [ ] = new int [ 10 ] ; Scanner docaonui = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { nui [ i ] = docaonui . nextInt ( ) ; } Arrays . sort ( nui ) ; System . out . println ( nui [ 9 ] ) ; System . out . println ( nui [ 8 ] ) ; System . out . println ( nui [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int nui [ ] = new int [ 10 ] ; Scanner docaonui = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { nui [ i ] = docaonui . nextInt ( ) ; } Arrays . sort ( nui ) ; System . out . println ( nui [ 9 ] ) ; System . out . println ( nui [ 8 ] ) ; System . out . println ( nui [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { int a [ ] = new int [ 10 ] ; Scanner docaoa = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = docaoa . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner inp = new Scanner ( System . in ) ; int [ ] mount = new int [ 10 ] ; for ( int i = 0 ; i < mount . length ; i ++ ) { mount [ i ] = inp . nextInt ( ) ; } Arrays . sort ( mount ) ; System . out . println ( mount [ 9 ] ) ; System . out . println ( mount [ 8 ] ) ; System . out . println ( mount [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( Integer . parseInt ( sc . nextLine ( ) ) ) ; } Collections . sort ( list , new Comparator < Integer > ( ) { @ Override public int compare ( Integer first , Integer second ) { int f = first ; int s = second ; return s - f ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . BufferedOutputStream ; import java . io . PrintWriter ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . io . IOException ; public class Main { public static void main ( String [ ] args ) { Scanner kb = new Scanner ( System . in ) ; out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int height [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = kb . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } public static PrintWriter out ; public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] + \" \\n \" + a [ 8 ] + \" \\n \" + a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader buf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = Integer . valueOf ( buf . readLine ( ) ) ; } Arrays . sort ( num ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( num [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int i ; int [ ] height = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( i = 0 ; i < 10 ; i ++ ) { height [ i ] = scan . nextInt ( ) ; } int st = 0 , nd = 0 , rd = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { if ( height [ i ] >= st ) { rd = nd ; nd = st ; st = height [ i ] ; } else if ( height [ i ] >= nd ) { rd = nd ; nd = height [ i ] ; } else if ( height [ i ] >= rd ) { rd = height [ i ] ; } } System . out . println ( st ) ; System . out . println ( nd ) ; System . out . println ( rd ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int i ; int [ ] height = new int [ 10 ] ; int [ ] h = new int [ ] { 0 , 0 , 0 } ; for ( i = 0 ; i < 10 ; i ++ ) { height [ i ] = stdIn . nextInt ( ) ; if ( h [ 0 ] <= height [ i ] ) { h [ 2 ] = h [ 1 ] ; h [ 1 ] = h [ 0 ] ; h [ 0 ] = height [ i ] ; } else if ( h [ 1 ] <= height [ i ] ) { h [ 2 ] = h [ 1 ] ; h [ 1 ] = height [ i ] ; } else if ( h [ 2 ] <= height [ i ] ) h [ 2 ] = height [ i ] ; } for ( int j = 0 ; j < 3 ; j ++ ) System . out . println ( h [ j ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int i ; int [ ] height = new int [ 10 ] ; int [ ] h = new int [ ] { 0 , 0 , 0 } ; for ( i = 0 ; i < 10 ; i ++ ) { height [ i ] = stdIn . nextInt ( ) ; if ( h [ 0 ] <= height [ i ] ) { h [ 2 ] = h [ 1 ] ; h [ 1 ] = h [ 0 ] ; h [ 0 ] = height [ i ] ; } else if ( h [ 1 ] <= height [ i ] ) { h [ 2 ] = h [ 1 ] ; h [ 1 ] = height [ i ] ; } else if ( h [ 2 ] <= height [ i ] ) h [ 2 ] = height [ i ] ; } for ( int j = 0 ; j < 3 ; j ++ ) System . out . println ( h [ j ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { try { BufferedReader stdReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = Integer . parseInt ( stdReader . readLine ( ) ) ; } Arrays . sort ( num ) ; System . out . println ( num [ 9 ] ) ; System . out . println ( num [ 8 ] ) ; System . out . println ( num [ 7 ] ) ; } catch ( Exception e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) throws IOException { try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < data . length ; i ++ ) { String line = br . readLine ( ) ; int value = Integer . parseInt ( line ) ; data [ i ] = value ; } Arrays . sort ( data ) ; System . out . println ( data [ 9 ] ) ; System . out . println ( data [ 8 ] ) ; System . out . println ( data [ 7 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] a ) { int n = 10 ; int [ ] num = new int [ n ] ; Scanner stdin = new Scanner ( System . in ) ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] = stdin . nextInt ( ) ; } boolean flag = true ; while ( flag ) { flag = false ; for ( int j = n - 1 ; j >= 1 ; j -- ) { if ( num [ j ] > num [ j - 1 ] ) { int tmp = num [ j ] ; num [ j ] = num [ j - 1 ] ; num [ j - 1 ] = tmp ; flag = true ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( num [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { static Scanner scanner = new Scanner ( System . in ) ; static int Hillta [ ] = new int [ 10 ] ; public static void main ( String args [ ] ) { for ( int i = 0 ; i <= 9 ; i ++ ) { Hillta [ i ] = S_content ( ) ; } judge ( ) ; } public static int S_content ( ) { int high = scanner . nextInt ( ) ; return high ; } public static void judge ( ) { int rank1 = 0 , rank2 = 0 , rank3 = 0 ; rank1 = Hillta [ 0 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { if ( Hillta [ i ] > rank3 ) { if ( Hillta [ i ] > rank2 ) { if ( Hillta [ i ] > rank1 ) { rank3 = rank2 ; rank2 = rank1 ; rank1 = Hillta [ i ] ; continue ; } rank3 = rank2 ; rank2 = Hillta [ i ] ; continue ; } rank3 = Hillta [ i ] ; continue ; } } System . out . println ( rank1 ) ; System . out . println ( rank2 ) ; System . out . println ( rank3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] mount = new Integer [ 10 ] ; int i = 0 ; while ( sc . hasNext ( ) ) { mount [ i ] = sc . nextInt ( ) ; i ++ ; } sort ( mount ) ; sc . close ( ) ; } public static void sort ( Integer [ ] mlist ) { Arrays . sort ( mlist ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( mlist [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] mount = new Integer [ 10 ] ; int i = 0 ; while ( i != 10 ) { mount [ i ] = sc . nextInt ( ) ; i ++ ; } sort ( mount ) ; sc . close ( ) ; } public static void sort ( Integer [ ] mlist ) { Arrays . sort ( mlist ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( mlist [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; Integer [ ] mount = new Integer [ 10 ] ; int i = 0 ; while ( i != 10 ) { mount [ i ] = sc . nextInt ( ) ; i ++ ; } sc . close ( ) ; Arrays . sort ( mount ) ; i = i - 1 ; for ( ; i >= 7 ; i -- ) { System . out . println ( mount [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] a ) throws IOException { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; int i = 0 ; int one = 0 ; int two = 0 ; int three = 0 ; while ( i < 10 ) { int num = Integer . parseInt ( br . readLine ( ) ) ; if ( one <= num ) { three = two ; two = one ; one = num ; } else if ( two <= num ) { three = two ; two = num ; } else if ( three <= num ) { three = num ; } i ++ ; } System . out . println ( one ) ; System . out . println ( two ) ; System . out . println ( three ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] input = new int [ 10 ] ; boolean [ ] checked = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = Integer . parseInt ( br . readLine ( ) ) ; checked [ i ] = false ; } for ( int i = 0 ; i < 3 ; i ++ ) { int maxIndex = - 1 ; int max = - 1 ; for ( int j = 0 ; j < 10 ; j ++ ) { if ( input [ j ] > max && checked [ j ] == false ) { max = input [ j ] ; maxIndex = j ; } } checked [ maxIndex ] = true ; System . out . println ( input [ maxIndex ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { list . add ( Integer . parseInt ( line ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; System . out . println ( list . get ( 0 ) ) ; System . out . println ( list . get ( 1 ) ) ; System . out . println ( list . get ( 2 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { static int [ ] mountains = new int [ 10 ] ; static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { for ( int count = 0 ; count < 10 ; count ++ ) { mountains [ count ] = sc . nextInt ( ) ; } Arrays . sort ( mountains ) ; System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int [ ] d = new int [ 10 ] ; for ( int i = 0 ; i < d . length ; i ++ ) { d [ i ] = sc . nextInt ( ) ; } Arrays . sort ( d ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( d [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] mountain ; int taihi ; Scanner sc = new Scanner ( System . in ) ; mountain = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < mountain . length ; i ++ ) { for ( int y = i + 1 ; y < mountain . length ; y ++ ) { if ( mountain [ i ] < mountain [ y ] ) { taihi = mountain [ i ] ; mountain [ i ] = mountain [ y ] ; mountain [ y ] = taihi ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountain [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] yama ; int work ; Scanner sc = new Scanner ( System . in ) ; yama = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { yama [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < yama . length ; i ++ ) { for ( int j = i + 1 ; j < yama . length ; j ++ ) { if ( yama [ i ] < yama [ j ] ) { work = yama [ i ] ; yama [ i ] = yama [ j ] ; yama [ j ] = work ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( yama [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { ArrayList < Integer > height = new ArrayList < Integer > ( ) ; Scanner sc = new java . util . Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { height . add ( sc . nextInt ( ) ) ; } Collections . sort ( height ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( height . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i < x . length ; i ++ ) { x [ i ] = stdin . nextInt ( ) ; } int n = 0 ; n = 10 ; int buble = n * ( n - 1 ) / 2 ; for ( int i = 0 ; i < buble ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( x [ j ] < x [ j + 1 ] ) { int temp = x [ j ] ; x [ j ] = x [ j + 1 ] ; x [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] a = new Integer [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( br . readLine ( ) ) ; if ( a [ i ] < 0 || a [ i ] > 10000 ) { i -- ; } } Arrays . sort ( a , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Integer [ ] mountainHigh = new Integer [ 10 ] ; Scanner stdin = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountainHigh [ i ] = stdin . nextInt ( ) ; } Arrays . sort ( mountainHigh , Comparator . reverseOrder ( ) ) ; for ( int high = 0 ; high < 3 ; high ++ ) { System . out . println ( mountainHigh [ high ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = null ; try { sc = new Scanner ( System . in ) ; int [ ] hillList = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hillList [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hillList ) ; int n = hillList . length - 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( hillList [ n ] ) ; n -- ; } } catch ( Exception e ) { System . out . println ( e ) ; } finally { if ( sc != null ) { try { sc . close ( ) ; } catch ( Exception e ) { } } } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { @ SuppressWarnings ( \" resource \" ) Scanner sc = new Scanner ( System . in ) ; int num1 = sc . nextInt ( ) ; int num2 = sc . nextInt ( ) ; int num3 = sc . nextInt ( ) ; int num4 = sc . nextInt ( ) ; int num5 = sc . nextInt ( ) ; int num6 = sc . nextInt ( ) ; int num7 = sc . nextInt ( ) ; int num8 = sc . nextInt ( ) ; int num9 = sc . nextInt ( ) ; int num10 = sc . nextInt ( ) ; checkNum ( num1 ) ; checkNum ( num2 ) ; checkNum ( num3 ) ; checkNum ( num4 ) ; checkNum ( num5 ) ; checkNum ( num6 ) ; checkNum ( num7 ) ; checkNum ( num8 ) ; checkNum ( num9 ) ; checkNum ( num10 ) ; List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( num1 ) ; list . add ( num2 ) ; list . add ( num3 ) ; list . add ( num4 ) ; list . add ( num5 ) ; list . add ( num6 ) ; list . add ( num7 ) ; list . add ( num8 ) ; list . add ( num9 ) ; list . add ( num10 ) ; Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int cnt = 0 ; cnt < 3 ; cnt ++ ) { System . out . println ( list . get ( cnt ) ) ; } } public static void checkNum ( int x ) { if ( x < 0 || 10000 < x ) { throw new IllegalArgumentException ( \" out of range \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner sc = new java . util . Scanner ( System . in ) ; public static void main ( String [ ] args ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int f = sc . nextInt ( ) ; int g = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int i = sc . nextInt ( ) ; int j = sc . nextInt ( ) ; int [ ] array = new int [ ] { a , b , c , d , e , f , g , h , i , j } ; Arrays . sort ( array ) ; for ( int n = 9 ; n >= 7 ; n -- ) { System . out . println ( array [ n ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new java . util . Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { int [ ] arg = new int [ 10 ] ; int i = 0 ; try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { String line ; while ( ( line = br . readLine ( ) ) != null ) { String tokens = line ; arg [ i ] = Integer . parseInt ( tokens ) ; i ++ ; } } int [ ] store = new int [ 3 ] ; for ( i = 0 ; i < 10 ; i ++ ) { int s = arg [ i ] ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( s > store [ j ] ) { if ( j == 0 ) { store [ j + 2 ] = store [ j + 1 ] ; store [ j + 1 ] = store [ j ] ; store [ j ] = s ; break ; } else if ( j == 1 ) { store [ j + 1 ] = store [ j ] ; store [ j ] = s ; break ; } else { store [ j ] = s ; } } } } for ( i = 0 ; i < store . length ; i ++ ) { System . out . println ( store [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > mountains = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains . add ( sc . nextInt ( ) ) ; } mountains . stream ( ) . sorted ( ( mount1 , mount2 ) -> mount2 - mount1 ) . limit ( 3 ) . forEach ( mountain -> System . out . println ( mountain . toString ( ) ) ) ; sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = scan . nextInt ( ) ; } int afterData , beforeIndex ; for ( int i = 1 ; i < 10 ; i ++ ) { afterData = data [ i ] ; beforeIndex = i - 1 ; while ( beforeIndex >= 0 && data [ beforeIndex ] > afterData ) { data [ beforeIndex + 1 ] = data [ beforeIndex ] ; beforeIndex -- ; } data [ beforeIndex + 1 ] = afterData ; } System . out . println ( data [ 9 ] ) ; System . out . println ( data [ 8 ] ) ; System . out . println ( data [ 7 ] ) ; scan . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { List < Long > hills = new ArrayList < > ( ) ; try ( Scanner scanner = new Scanner ( System . in ) ) { while ( scanner . hasNextLong ( ) ) { hills . add ( scanner . nextLong ( ) ) ; } } hills . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int [ ] n = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = br . readLine ( ) ; n [ i ] = Integer . parseInt ( str ) ; } Arrays . sort ( n ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( n [ i ] ) ; } } catch ( Exception e ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mt = new int [ 10 ] ; try { for ( int i = 0 ; i < mt . length ; i ++ ) { mt [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } } catch ( Exception e ) { } Arrays . sort ( mt ) ; System . out . println ( mt [ 9 ] ) ; System . out . println ( mt [ 8 ] ) ; System . out . println ( mt [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import static java . util . Comparator . reverseOrder ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < Integer > hillsHightList = new ArrayList < > ( ) ; try { while ( br . ready ( ) ) { hillsHightList . add ( Integer . valueOf ( br . readLine ( ) ) ) ; } } catch ( Exception e ) { } Collections . sort ( hillsHightList , reverseOrder ( ) ) ; System . out . println ( hillsHightList . get ( 0 ) ) ; System . out . println ( hillsHightList . get ( 1 ) ) ; System . out . println ( hillsHightList . get ( 2 ) ) ; System . exit ( 0 ) ; } }",
    "label": 1
  },
  {
    "code": "import static java . util . Comparator . reverseOrder ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < Integer > hillsHightList = new ArrayList < > ( ) ; try { while ( br . ready ( ) ) { hillsHightList . add ( Integer . valueOf ( br . readLine ( ) ) ) ; } } catch ( Exception e ) { } Collections . sort ( hillsHightList , reverseOrder ( ) ) ; System . out . println ( hillsHightList . get ( 0 ) ) ; System . out . println ( hillsHightList . get ( 1 ) ) ; System . out . println ( hillsHightList . get ( 2 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { static int first = 0 ; static int second = 0 ; static int third = 0 ; static int tmp = 0 ; public static void main ( String [ ] args ) { InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; try { String buf = br . readLine ( ) ; for ( int i = 0 ; i <= 9 ; i ++ ) { tmp = Integer . parseInt ( buf ) ; if ( first <= tmp ) { third = second ; second = first ; first = tmp ; } else if ( second <= tmp ) { third = second ; second = tmp ; } else if ( third <= tmp ) { third = tmp ; } buf = br . readLine ( ) ; } } catch ( Exception e ) { } System . out . println ( first + \" \\n \" + second + \" \\n \" + third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . Arrays ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; Integer [ ] mountains = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountains , Collections . reverseOrder ( ) ) ; StringBuilder sb = new StringBuilder ( \" \" ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sb . append ( mountains [ i ] ) ; sb . append ( '\\n' ) ; } System . out . print ( sb ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { List < Integer > integers = new ArrayList < > ( ) ; try ( Scanner scanner = new Scanner ( System . in ) ) { while ( scanner . hasNextInt ( ) ) { integers . add ( scanner . nextInt ( ) ) ; } } integers . sort ( Comparator . reverseOrder ( ) ) ; integers . stream ( ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { int [ ] d = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( byte i = 0 ; i < 10 ; i ++ ) { d [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; } Arrays . sort ( d ) ; System . out . println ( d [ 9 ] + \" \\n \" + d [ 8 ] + \" \\n \" + d [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { int i ; int j ; int temp ; int first ; int second ; int third ; int [ ] mountain = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = sc . nextInt ( ) ; } for ( i = 0 ; i < 10 ; i ++ ) { for ( j = 0 ; j < 10 ; j ++ ) { if ( mountain [ i ] < mountain [ j ] ) { temp = mountain [ i ] ; mountain [ i ] = mountain [ j ] ; mountain [ j ] = temp ; } } } first = mountain [ 0 ] ; second = mountain [ 1 ] ; third = mountain [ 2 ] ; for ( i = 9 ; i > 6 ; i -- ) { System . out . printf ( \" %d \" , mountain [ i ] ) ; System . out . println ( \" \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } Arrays . sort ( h ) ; System . out . printf ( \" %d \\n %d \\n %d \\n \" , h [ 9 ] , h [ 8 ] , h [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > h = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int buf = sc . nextInt ( ) ; if ( i == 0 ) { h . add ( 0 , buf ) ; } ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( buf <= h . get ( j ) ) { h . add ( j + 1 , buf ) ; break ; } else if ( j == 0 ) { h . add ( 0 , buf ) ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( h . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > mountains = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains . add ( sc . nextInt ( ) ) ; } Collections . sort ( mountains ) ; Collections . reverse ( mountains ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountains . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { List < Integer > numList = new ArrayList < > ( ) ; Scanner scanner = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { numList . add ( scanner . nextInt ( ) ) ; } numList . sort ( Comparator . reverseOrder ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( numList . get ( j ) ) ; } scanner . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] m = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { m [ i ] = sc . nextInt ( ) ; } Arrays . sort ( m ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( m [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] n = new int [ 10 ] ; for ( int i = 0 ; i < n . length ; i ++ ) { n [ i ] = sc . nextInt ( ) ; } Arrays . sort ( n ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( n [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int numone = 0 ; int numtwo = 0 ; int numthree = 0 ; int x ; for ( int i = 0 ; i < 10 ; i ++ ) { x = sc . nextInt ( ) ; if ( numone <= x ) { numthree = numtwo ; numtwo = numone ; numone = x ; } else if ( numtwo <= x ) { numthree = numtwo ; numtwo = x ; } else if ( numthree <= x ) { numthree = x ; } } System . out . println ( numone + \" \\n \" + numtwo + \" \\n \" + numthree ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; public class Main { static IO io = new IO ( ) ; public static void main ( String [ ] args ) { int n [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) n [ i ] = io . nextInt ( ) ; Arrays . sort ( n ) ; System . out . println ( n [ 9 ] ) ; System . out . println ( n [ 8 ] ) ; System . out . println ( n [ 7 ] ) ; } static class IO extends PrintWriter { private final InputStream in ; private final byte [ ] buffer = new byte [ 1024 ] ; private int ptr = 0 ; private int buflen = 0 ; IO ( ) { this ( System . in ) ; } IO ( InputStream source ) { super ( System . out ) ; this . in = source ; } boolean hasNextByte ( ) { if ( ptr < buflen ) return true ; else { ptr = 0 ; try { buflen = in . read ( buffer ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( buflen <= 0 ) return false ; } return true ; } int readByte ( ) { if ( hasNextByte ( ) ) return buffer [ ptr ++ ] ; else return - 1 ; } boolean isPrintableChar ( int c ) { return 33 <= c && c <= 126 ; } void skipUnprintable ( ) { while ( hasNextByte ( ) && ! isPrintableChar ( buffer [ ptr ] ) ) ptr ++ ; } boolean hasNext ( ) { skipUnprintable ( ) ; return hasNextByte ( ) ; } long nextLong ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; long n = 0 ; boolean minus = false ; int b = readByte ( ) ; if ( b == '-' ) { minus = true ; b = readByte ( ) ; } if ( b < '0' || '9' < b ) throw new NumberFormatException ( ) ; while ( true ) { if ( '0' <= b && b <= '9' ) { n *= 10 ; n += b - '0' ; } else if ( b == - 1 || ! isPrintableChar ( b ) ) return minus ? - n : n ; else throw new NumberFormatException ( ) ; b = readByte ( ) ; } } int nextInt ( ) { long nl = nextLong ( ) ; if ( nl < Integer . MIN_VALUE || nl > Integer . MAX_VALUE ) throw new NumberFormatException ( ) ; return ( int ) nl ; } public void close ( ) { super . close ( ) ; try { in . close ( ) ; } catch ( IOException ignored ) { } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] input = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { input [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( input ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( input [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int max1 = 0 , max2 = 0 , max3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int newNum = input . nextInt ( ) ; if ( newNum > max1 ) { max3 = max2 ; max2 = max1 ; max1 = newNum ; } else if ( newNum > max2 && newNum <= max1 ) { max3 = max2 ; max2 = newNum ; } else if ( newNum > max3 && newNum <= max2 ) { max3 = newNum ; } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > heights = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int val = sc . nextInt ( ) ; heights . add ( val ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( heights . get ( i ) > heights . get ( j ) ) { int tmp = heights . get ( i ) ; heights . set ( i , heights . get ( j ) ) ; heights . set ( j , tmp ) ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > heights = new ArrayList < > ( ) ; int x ; for ( int i = 0 ; i < 10 ; i ++ ) { x = Integer . parseInt ( br . readLine ( ) ) ; if ( 0 <= x && x <= 10000 ) { heights . add ( x ) ; } } int [ ] top3 = getTop3 ( heights ) ; for ( int i = 0 ; i < top3 . length ; i ++ ) { System . out . println ( top3 [ i ] ) ; } } private static int [ ] getTop3 ( ArrayList < Integer > heights ) { int [ ] top3 = new int [ 3 ] ; top3 [ 0 ] = 0 ; top3 [ 1 ] = 0 ; top3 [ 2 ] = 0 ; for ( int i = 0 ; i < heights . size ( ) ; i ++ ) { int element = heights . get ( i ) ; if ( element > top3 [ 0 ] ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = top3 [ 0 ] ; top3 [ 0 ] = element ; } else if ( element > top3 [ 1 ] ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = element ; } else if ( element > top3 [ 2 ] ) { top3 [ 2 ] = element ; } } return top3 ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { int highest [ ] = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { highest [ i ] = sc . nextInt ( ) ; } Arrays . sort ( highest ) ; for ( int k = 9 ; k > 6 ; k -- ) System . out . println ( highest [ k ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountains = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . valueOf ( br . readLine ( ) ) ; } Arrays . sort ( mountains , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h [ ] = new int [ 10 ] ; for ( int i = 0 ; i < h . length ; i ++ ) h [ i ] = sc . nextInt ( ) ; Arrays . sort ( h ) ; System . out . println ( h [ 9 ] ) ; System . out . println ( h [ 8 ] ) ; System . out . println ( h [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] top = { - 1 , - 1 , - 1 } ; for ( int i = 0 ; i < 10 ; i ++ ) { int hight = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( top [ j ] < hight ) { int store = top [ j ] ; top [ j ] = hight ; if ( j == 0 ) { hight = top [ j + 1 ] ; top [ j + 1 ] = store ; top [ j + 2 ] = hight ; } else if ( j == 1 ) { top [ j + 1 ] = store ; } break ; } } } System . out . println ( top [ 0 ] ) ; System . out . println ( top [ 1 ] ) ; System . out . println ( top [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] top = { - 1 , - 1 , - 1 } ; for ( int i = 0 ; i < 10 ; i ++ ) { int hight = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( top [ j ] < hight ) { int store = top [ j ] ; top [ j ] = hight ; if ( j == 0 ) { hight = top [ j + 1 ] ; top [ j + 1 ] = store ; top [ j + 2 ] = hight ; } else if ( j == 1 ) { top [ j + 1 ] = store ; } break ; } } } System . out . println ( top [ 0 ] ) ; System . out . println ( top [ 1 ] ) ; System . out . println ( top [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] ints = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { ints [ i ] = scanner . nextInt ( ) ; } int max1 = - 1 ; int index1 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( max1 < ints [ i ] ) { max1 = ints [ i ] ; index1 = i ; } } ints [ index1 ] = - 1 ; int max2 = - 1 ; int index2 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( max2 < ints [ i ] ) { max2 = ints [ i ] ; index2 = i ; } } ints [ index2 ] = - 1 ; int max3 = - 1 ; int index3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( max3 < ints [ i ] ) { max3 = ints [ i ] ; index3 = i ; } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] g ) { int i = 0 , a [ ] = new int [ 10 ] ; for ( Scanner S = new Scanner ( System . in ) ; i < 10 ; ) a [ i ++ ] = S . nextInt ( ) ; Arrays . sort ( a ) ; for ( i = 9 ; i > 6 ; ) System . out . println ( a [ i -- ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { int one = 0 ; int two = 0 ; int three = 0 ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i <= 9 ; i ++ ) { int n = sc . nextInt ( ) ; if ( n > one ) { three = two ; two = one ; one = n ; } else if ( n > two ) { three = two ; two = n ; } else if ( n > three ) { three = n ; } } System . out . println ( one ) ; System . out . println ( two ) ; System . out . println ( three ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { int one = 0 ; int two = 0 ; int three = 0 ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i <= 9 ; i ++ ) { int n = sc . nextInt ( ) ; if ( n > one ) { three = two ; two = one ; one = n ; } else if ( n > two ) { three = two ; two = n ; } else if ( n > three ) { three = n ; } } System . out . println ( one ) ; System . out . println ( two ) ; System . out . println ( three ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( sc . nextInt ( ) ) ; } list . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( sc . nextInt ( ) ) ; } list . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { Integer [ ] Ints = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { Ints [ i ] = sc . nextInt ( ) ; } Arrays . sort ( Ints , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( Ints [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int [ ] vec = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) vec [ i ] = in . nextInt ( ) ; Arrays . sort ( vec ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( vec [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { in [ i ] = sc . nextInt ( ) ; } Arrays . sort ( in ) ; for ( int i = 9 ; 7 <= i ; i -- ) { System . out . println ( in [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int [ ] height = new int [ 10 ] ; int [ ] rank = new int [ 3 ] ; int i ; Scanner scanner = new Scanner ( System . in ) ; for ( i = 0 ; i < 10 ; i ++ ) { height [ i ] = scanner . nextInt ( ) ; if ( height [ i ] >= rank [ 0 ] ) { rank [ 2 ] = rank [ 1 ] ; rank [ 1 ] = rank [ 0 ] ; rank [ 0 ] = height [ i ] ; } else if ( height [ i ] >= rank [ 1 ] ) { rank [ 2 ] = rank [ 1 ] ; rank [ 1 ] = height [ i ] ; } else if ( height [ i ] >= rank [ 2 ] ) { rank [ 2 ] = height [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { System . out . println ( rank [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { ArrayList < Integer > height = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { height . add ( sc . nextInt ( ) ) ; } top_three ( height ) ; } private static void top_three ( ArrayList < Integer > height ) { Collections . sort ( height , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } Collections . sort ( list , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { int [ ] raw = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { raw [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } int [ ] result = new int [ ] { - 1 , - 1 , - 1 } ; int target = - 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( result [ i ] < raw [ j ] ) { result [ i ] = raw [ j ] ; target = j ; } } raw [ target ] = - 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( result [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Comparator ; public class Main { public static void main ( String [ ] args ) throws IOException { try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { br . lines ( ) . map ( Integer :: valueOf ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] m = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { m [ i ] = sc . nextInt ( ) ; } Arrays . sort ( m ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( m [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] ary = new int [ 10 ] ; int i ; for ( i = 0 ; i < 10 ; i ++ ) { ary [ i ] = sc . nextInt ( ) ; } Arrays . sort ( ary ) ; System . out . println ( ary [ 9 ] ) ; System . out . println ( ary [ 8 ] ) ; System . out . println ( ary [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; int Hill [ ] = new int [ 10 ] ; int i ; for ( i = 0 ; i < 10 ; i ++ ) { Hill [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( Hill ) ; System . out . println ( Hill [ 9 ] ) ; System . out . println ( Hill [ 8 ] ) ; System . out . println ( Hill [ 7 ] ) ; scanner . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] hight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hight [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( hight [ i ] > hight [ j ] ) { int temp = hight [ i ] ; hight [ i ] = hight [ j ] ; hight [ j ] = temp ; } } } System . out . println ( hight [ 9 ] ) ; System . out . println ( hight [ 8 ] ) ; System . out . println ( hight [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] , i = 0 ; while ( i < 10 ) a [ i ++ ] = s . nextInt ( ) ; Arrays . sort ( a ) ; while ( i > 7 ) System . out . println ( a [ -- i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int data [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = cin . nextInt ( ) ; } Arrays . sort ( data ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( data [ data . length - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] _ ) { int i = 0 , a [ ] = new int [ 10 ] ; for ( Scanner S = new Scanner ( System . in ) ; i < 9 ; ) a [ i ++ ] = S . nextInt ( ) ; Arrays . sort ( a ) ; for ( i = 9 ; i > 6 ; ) System . out . println ( a [ i -- ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) { try { int i ; BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > height = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < 10 ; i ++ ) height . add ( Integer . parseInt ( bf . readLine ( ) ) ) ; Collections . sort ( height ) ; Collections . reverse ( height ) ; for ( i = 0 ; i < 3 ; i ++ ) System . out . println ( height . get ( i ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; List < Integer > h = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i ++ < 10 ; ) h . add ( s . nextInt ( ) ) ; Collections . sort ( h , Collections . reverseOrder ( ) ) ; System . out . printf ( \" %d \\n %d \\n %d \\n \" , h . toArray ( ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; List < Integer > h = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i ++ < 10 ; ) h . add ( s . nextInt ( ) ) ; Collections . sort ( h , Collections . reverseOrder ( ) ) ; System . out . printf ( \" %d \\n %d \\n %d \\n \" , h . toArray ( ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc ; static final int INF = 1 << 28 ; static final double EPS = 1e-9 ; void run ( ) { sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = sc . nextInt ( ) ; sort ( a ) ; println ( \" \" + a [ 9 ] ) ; println ( \" \" + a [ 8 ] ) ; println ( \" \" + a [ 7 ] ) ; sc . close ( ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . lang . * ; import java . math . * ; class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mt ) ; System . out . println ( mt [ 9 ] + \" \\n \" + mt [ 8 ] + \" \\n \" + mt [ 7 ] ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int top [ ] = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int n = sc . nextInt ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( Math . max ( top [ j ] , n ) == n ) { for ( int k = 2 ; k > j ; k -- ) top [ k ] = top [ k - 1 ] ; top [ j ] = n ; break ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( Integer . toString ( top [ i ] ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] highs = new int [ 10 ] ; for ( int i = 0 ; i < highs . length ; i ++ ) { highs [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( highs ) ; for ( int i = highs . length - 1 ; i >= highs . length - 3 ; i -- ) { System . out . println ( highs [ i ] ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] z ) { Scanner s = new Scanner ( System . in ) ; Long [ ] h = new Long [ 10 ] ; for ( int i = 10 ; i -- > 0 ; ) h [ i ] = s . nextLong ( ) ; Arrays . sort ( h , Collections . reverseOrder ( ) ) ; System . out . printf ( \" %d \\n %d \\n %d \\n \" , ( Object [ ] ) h ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] z ) { Scanner s = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 10 ; i -- > 0 ; ) h [ i ] = s . nextInt ( ) ; Arrays . sort ( h ) ; System . out . printf ( \" %d \\n %d \\n %d \\n \" , h [ 9 ] , h [ 8 ] , h [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] a ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static boolean read ( ) { a = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; int sum = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } return true ; } static void solve ( ) { sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import static java . util . Arrays . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int array [ ] = new int [ 10 ] ; static int i = 0 ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static boolean read ( ) { while ( sc . hasNextInt ( ) ) { array [ i ] = sc . nextInt ( ) ; i ++ ; } return true ; } static void solve ( ) { sort ( array ) ; for ( int i = array . length - 1 ; i >= array . length - 3 ; i -- ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] argv ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > m = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = in . readLine ( ) ; if ( s == null ) { break ; } m . add ( Integer . parseInt ( s ) ) ; } f ( m ) ; } public static void f ( ArrayList < Integer > m ) { Object [ ] mm = m . toArray ( ) ; Arrays . sort ( mm ) ; for ( int i = mm . length - 1 ; i > mm . length - 4 && i >= 0 ; i -- ) { System . out . println ( mm [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int [ ] list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) list [ i ] = scn . nextInt ( ) ; Arrays . sort ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( list [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = i ; j < 10 ; j ++ ) { if ( h [ i ] < h [ j ] ) { int temp = h [ j ] ; h [ j ] = h [ i ] ; h [ i ] = temp ; } } System . out . println ( h [ i ] ) ; } } public static void main ( String [ ] args ) { Main m = new Main ( ) ; m . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > mountains = new ArrayList < Integer > ( ) ; int i = 0 ; while ( true ) { String s = r . readLine ( ) ; mountains . add ( Integer . valueOf ( s ) ) ; if ( ++ i == 10 ) break ; } Collections . sort ( mountains ) ; Collections . reverse ( mountains ) ; i = 0 ; for ( int m : mountains ) { System . out . println ( m ) ; if ( ++ i >= 3 ) break ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; int i = 0 ; while ( true ) { String s = r . readLine ( ) ; mountains [ i ++ ] = Integer . valueOf ( s ) ; if ( i >= 10 ) break ; } Arrays . sort ( mountains ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < num . length ; i ++ ) { num [ i ] = stdin . nextInt ( ) ; } Arrays . sort ( num ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( num [ num . length - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { n [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( n ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . printf ( \" %d \\n \" , n [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { private static int [ ] mountains = new int [ 10 ] ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( mountains ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; int [ ] n = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = br . readLine ( ) ; n [ i ] = Integer . parseInt ( str ) ; } int [ ] max = new int [ 3 ] ; max [ 2 ] = n [ 0 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( max [ 2 ] <= n [ i ] ) { max [ 2 ] = n [ i ] ; if ( max [ 2 ] >= max [ 1 ] ) { int re = max [ 1 ] ; max [ 1 ] = max [ 2 ] ; max [ 2 ] = re ; if ( max [ 1 ] >= max [ 0 ] ) { int re2 = max [ 0 ] ; max [ 0 ] = max [ 1 ] ; max [ 1 ] = re2 ; } } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( max [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int i , j , k , h [ ] = new int [ 10 ] ; for ( i = 0 ; i < 10 ; i ++ ) h [ i ] = Integer . parseInt ( br . readLine ( ) ) ; for ( i = 0 ; i < 3 ; i ++ ) { for ( j = i + 1 ; j < 10 ; j ++ ) if ( h [ i ] < h [ j ] ) { k = h [ i ] ; h [ i ] = h [ j ] ; h [ j ] = k ; } System . out . println ( h [ i ] ) ; } return ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] dat = new int [ 10 ] ; for ( int tc = 0 ; tc < 10 ; ++ tc ) { dat [ tc ] = s . nextInt ( ) ; } Arrays . sort ( dat ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( dat [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { private void topThreeHills ( ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > hlist = new ArrayList < Integer > ( 10 ) ; while ( sc . hasNext ( ) ) { hlist . add ( sc . nextInt ( ) ) ; } Collections . sort ( hlist , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hlist . get ( i ) ) ; } } public static void main ( String [ ] args ) { ( new Main ( ) ) . topThreeHills ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Comparator ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Queue < Integer > q = new PriorityQueue < Integer > ( 10 , new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ) ; for ( int i = 0 ; i < 10 ; i ++ ) q . add ( sc . nextInt ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( q . poll ( ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner scanner = new Scanner ( System . in ) ; ArrayList < Integer > al = new ArrayList < Integer > ( ) ; while ( scanner . hasNextInt ( ) ) { al . add ( scanner . nextInt ( ) ) ; } Collections . sort ( al ) ; Collections . reverse ( al ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( al . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { private static void sort ( int [ ] a ) { for ( int i = 0 ; i < a . length - 1 ; i ++ ) { for ( int j = a . length - 1 ; j > i ; j -- ) { if ( a [ j ] > a [ j - 1 ] ) { int t = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = t ; } } } } private static void print_hill ( int [ ] a ) { for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } public static void main ( String args [ ] ) throws IOException { int hills [ ] = new int [ 10 ] ; InputStreamReader inp = new InputStreamReader ( System . in ) ; BufferedReader bre = new BufferedReader ( inp ) ; int n ; for ( int i = 0 ; i < 10 ; i ++ ) { String num = bre . readLine ( ) ; n = Integer . parseInt ( num ) ; hills [ i ] = n ; } sort ( hills ) ; print_hill ( hills ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { private static void sort ( int [ ] a ) { for ( int i = 0 ; i < a . length - 1 ; i ++ ) { for ( int j = a . length - 1 ; j > i ; j -- ) { if ( a [ j ] > a [ j - 1 ] ) { int t = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = t ; } } } } private static void print_hill ( int [ ] a ) { for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } public static void main ( String args [ ] ) throws IOException { int hills [ ] = new int [ 10 ] ; InputStreamReader inp = new InputStreamReader ( System . in ) ; BufferedReader bre = new BufferedReader ( inp ) ; int n ; for ( int i = 0 ; i < 10 ; i ++ ) { String num = bre . readLine ( ) ; n = Integer . parseInt ( num ) ; hills [ i ] = n ; } sort ( hills ) ; print_hill ( hills ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { int i , m = 0 , n = 0 , p = 0 , x ; Scanner s = new Scanner ( System . in ) ; for ( i = 0 ; i < 10 ; i ++ ) { x = s . nextInt ( ) ; if ( m < x ) { p = n ; n = m ; m = x ; } else if ( n < x ) { p = n ; n = x ; } else if ( p < x ) p = x ; } System . out . println ( m ) ; System . out . println ( n ) ; System . out . println ( p ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int t = sc . nextInt ( ) ; l . add ( t ) ; } Collections . sort ( l ) ; Collections . reverse ( l ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( l . get ( i ) ) ; } } } ;",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . * ; public class Main { Main ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] str ; while ( sc . hasNext ( ) ) { str = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) str [ i ] = sc . nextInt ( ) ; Arrays . sort ( str ) ; for ( int i = 1 , l = str . length ; i <= 3 ; i ++ ) System . out . println ( Integer . toString ( str [ l - i ] ) ) ; } } public static void main ( String [ ] args ) { new Main ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Comparator ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Queue < Integer > q = new PriorityQueue < Integer > ( 10 , new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ) ; for ( int i = 0 ; i < 10 ; i ++ ) q . add ( sc . nextInt ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( q . poll ( ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] a = new int [ 10 ] ; BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = r . readLine ( ) ; a [ i ] = Integer . parseInt ( s ) ; } Arrays . sort ( a ) ; System . out . printf ( \" %d \\n \" , a [ 9 ] ) ; System . out . printf ( \" %d \\n \" , a [ 8 ] ) ; System . out . printf ( \" %d \\n \" , a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . * ; public class Main { Main ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] str ; while ( sc . hasNext ( ) ) { str = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) str [ i ] = sc . nextInt ( ) ; Arrays . sort ( str ) ; for ( int i = 1 , l = str . length ; i <= 3 ; i ++ ) System . out . println ( Integer . toString ( str [ l - i ] ) ) ; } } public static void main ( String [ ] args ) { new Main ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; int num = 0 ; while ( num < 10 ) { String line = reader . readLine ( ) ; mountains [ num ] = Integer . parseInt ( line ) ; num ++ ; } Arrays . sort ( mountains ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } int max = 0 ; int [ ] top = { - 1 , - 1 , - 1 } ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( j != top [ 0 ] && j != top [ 1 ] && j != top [ 2 ] ) { if ( max < height [ j ] ) { top [ i ] = j ; max = height [ j ] ; } } } max = 0 ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ top [ i ] ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { private static void solve ( int n ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] heights = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { heights [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( heights ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights [ heights . length - i - 1 ] ) ; } } public static void main ( String ... args ) { solve ( 10 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { List < Integer > ls = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! sc . hasNextInt ( ) ) { break ; } int n = sc . nextInt ( ) ; ls . add ( Integer . valueOf ( n ) ) ; } Collections . sort ( ls ) ; Collections . reverse ( ls ) ; for ( int height : ls . subList ( 0 , Math . min ( ls . size ( ) , 3 ) ) ) { System . out . println ( height ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = s . nextInt ( ) ; Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String s ; int i , j , t ; int [ ] c = new int [ 10 ] ; try { for ( i = 0 ; i < 10 ; i ++ ) { s = r . readLine ( ) ; c [ i ] = Integer . parseInt ( s ) ; } for ( i = 0 ; i < 9 ; i ++ ) { for ( j = 0 ; j < 9 - i ; j ++ ) { if ( c [ j ] < c [ j + 1 ] ) { t = c [ j ] ; c [ j ] = c [ j + 1 ] ; c [ j + 1 ] = t ; } } } for ( i = 0 ; i < 3 ; i ++ ) System . out . println ( c [ i ] ) ; } catch ( NoSuchElementException e ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int max , i , j , h ; int a [ ] = new int [ 10 ] ; for ( i = 0 ; i < 10 ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( i = 0 ; i < 10 ; i ++ ) { max = i ; for ( j = i ; j < 10 ; j ++ ) { if ( a [ max ] < a [ j ] ) max = j ; } h = a [ max ] ; a [ max ] = a [ i ] ; a [ i ] = h ; } for ( i = 0 ; i < 3 ; i ++ ) System . out . println ( a [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) { ArrayList < Integer > mountain = new ArrayList < Integer > ( ) ; try { BufferedReader stdReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int line ; for ( int i = 0 ; i < 10 ; i ++ ) { line = Integer . parseInt ( stdReader . readLine ( ) ) ; mountain . add ( line ) ; } Collections . sort ( mountain ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( mountain . get ( i ) ) ; } } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] hills = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = sc . nextInt ( ) ; } int max = 0 ; int maxi = 0 ; ; for ( int j = 0 ; j < 3 ; j ++ ) { max = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hills [ i ] > max ) { max = hills [ i ] ; maxi = i ; } } System . out . println ( max ) ; hills [ maxi ] = 0 ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { private static int [ ] hills = new int [ 10 ] ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < hills . length ; i ++ ) { hills [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hills , 0 , hills . length ) ; for ( int i = ( hills . length - 1 ) ; i > 6 ; i -- ) { System . out . println ( hills [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public void doIt ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array ) ; for ( int i = 10 - 1 ; i > 10 - 1 - 3 ; i -- ) { System . out . println ( array [ i ] ) ; } } public static void main ( String [ ] args ) { Main obj = new Main ( ) ; obj . doIt ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } Arrays . sort ( h ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] t = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { t [ i ] = sc . nextInt ( ) ; } Arrays . sort ( t ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] rank = new int [ 3 ] ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = br . readLine ( ) ; int v = Integer . parseInt ( s , 10 ) ; for ( int j = 0 ; j < rank . length ; j ++ ) { if ( v > rank [ j ] ) { int pre = rank [ j ] ; rank [ j ] = v ; v = pre ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( rank [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { int [ ] rank = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int v = readInt ( ) ; for ( int j = 0 ; j < rank . length ; j ++ ) { if ( v > rank [ j ] ) { int pre = rank [ j ] ; rank [ j ] = v ; v = pre ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( rank [ i ] ) ; } } private final static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; private static int readInt ( ) throws IOException { return Integer . parseInt ( br . readLine ( ) , 10 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int [ ] res = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int now = sc . nextInt ( ) ; if ( now >= res [ 0 ] ) { int x = res [ 0 ] ; int y = res [ 1 ] ; res [ 0 ] = now ; res [ 1 ] = x ; res [ 2 ] = y ; } else { if ( now >= res [ 1 ] ) { int x = res [ 1 ] ; res [ 1 ] = now ; res [ 2 ] = x ; } else { if ( now >= res [ 2 ] ) { res [ 2 ] = now ; } } } } for ( int j = 0 ; j < res . length ; j ++ ) { System . out . println ( res [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = stdIn . nextInt ( ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { int temp ; for ( int j = i ; j < 10 ; j ++ ) { temp = x [ i ] ; if ( x [ j ] > x [ i ] ) { x [ i ] = x [ j ] ; x [ j ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { try { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = Integer . parseInt ( in . readLine ( ) ) ; } Arrays . sort ( h ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( h [ 10 - 1 - i ] ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import static java . lang . Math . * ; import static java . lang . System . out ; public class Main { Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) . AOJ0001 ( ) ; } void AOJ0001 ( ) { int [ ] m = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) m [ i ] = sc . nextInt ( ) ; Arrays . sort ( m ) ; for ( int i = 9 ; i >= 7 ; i -- ) out . println ( m [ i ] ) ; } void AOJ10029 ( ) { int n = sc . nextInt ( ) ; int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = sc . nextInt ( ) ; Arrays . sort ( ans ) ; out . print ( ans [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) out . print ( \" \" + ans [ i ] ) ; out . println ( ) ; } int [ ] [ ] p26 = new int [ 10 ] [ 10 ] ; int c26 = 100 ; void AOJ0026 ( ) { int ans = 0 ; while ( sc . hasNext ( ) ) { Scanner sc2 = new Scanner ( sc . nextLine ( ) ) . useDelimiter ( \" , \" ) ; int x = sc2 . nextInt ( ) , y = sc2 . nextInt ( ) , s = sc2 . nextInt ( ) ; ans = max ( solve26 ( x , y ) , ans ) ; ans = max ( solve26 ( x - 1 , y ) , ans ) ; ans = max ( solve26 ( x + 1 , y ) , ans ) ; ans = max ( solve26 ( x , y - 1 ) , ans ) ; ans = max ( solve26 ( x , y + 1 ) , ans ) ; if ( s >= 2 ) { ans = max ( solve26 ( x - 1 , y - 1 ) , ans ) ; ans = max ( solve26 ( x - 1 , y + 1 ) , ans ) ; ans = max ( solve26 ( x + 1 , y - 1 ) , ans ) ; ans = max ( solve26 ( x + 1 , y + 1 ) , ans ) ; } if ( s >= 3 ) { ans = max ( solve26 ( x - 2 , y ) , ans ) ; ans = max ( solve26 ( x + 2 , y ) , ans ) ; ans = max ( solve26 ( x , y - 2 ) , ans ) ; ans = max ( solve26 ( x , y + 2 ) , ans ) ; } } out . println ( c26 ) ; out . println ( ans ) ; } int solve26 ( int x , int y ) { int r = - 1 ; if ( 0 <= x && x <= 9 && 0 <= y && y <= 9 ) { c26 -= p26 [ x ] [ y ] == 0 ? 1 : 0 ; p26 [ x ] [ y ] ++ ; r = p26 [ x ] [ y ] ; } return r ; } void AOJ0008 ( ) { while ( sc . hasNext ( ) ) { int ans = 0 , n = sc . nextInt ( ) ; for ( int a = 0 ; a < 10 ; a ++ ) { for ( int b = 0 ; b < 10 ; b ++ ) { for ( int c = 0 ; c < 10 ; c ++ ) { for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( a + b + c + d ) == n ) ans ++ ; } } } } out . println ( ans ) ; } } void AOJ0055 ( ) { while ( sc . hasNext ( ) ) { double last = sc . nextDouble ( ) , ans = last ; for ( int i = 2 ; i <= 10 ; i ++ ) { ans += i % 2 == 0 ? last * 2 : last / 3 ; last = i % 2 == 0 ? last * 2 : last / 3 ; } out . println ( ans ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . awt . event . MouseAdapter ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . LinkedList ; import java . util . Stack ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { try { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; LinkedList < String > list = new LinkedList < String > ( ) ; list . clear ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String s = in . readLine ( ) ; if ( s != null && ! s . equals ( \" (`*)\")) { l i s . dd(s ) ; } e l s bre k } } L n e List<Integ e r> moun t ins = new L nke List<Integ e r>(); f o r ( i t i = 0 1 ; i +) mo u t ins.add(I n teg e r.value O f(list. g et(i ) )); } C o l e tions.sort( m ount a ins); for ( i t i = 0 3 + ) in t h = m u t ins.remov e Last(); Sy s t e .out.p r int l n(h); } } c t h Excep t ion e) { . p i t S tackTrace(); } } p i a e stati void oWor (Linke d List<Strin g > orde r ist) { in t n m = Int g r.value O f(order L ist.getFi r st()); o r d e r ist.remov e First(); @S u p p e ssWarnings(\"unch e c ked\") Sta c k Strin g >[] st a c k = new S ack num]; for ( i t i = 0 s a k .lengt h ; i++) st a k [i] = n e w S ack Strin g >(); } f o r i t c = 0 o d r ist.size( ) ; c+ + ) St r n order = ord r ist.get(c ) ; i f ( o r er . equal s (\"push \" ) ) { i n t s = nt g r.value O f(order L ist.get(+ + c)) - 1 ; t i n pushS ring = ord r ist.get(+ + c); st a c k [sa].p u sh ( p ushS t ring); } e l s f(or er . equal s (\"pop\" ) ) { i n t s = nt g r.value O f(order L ist.get(+ + c)) - 1 ; t i n poped = sta k [sa].p o p( ) ; Sy s t e .out.p r int l n(poped ) ; } i f ( r er . equal s (\"move \" ) ) { i n t s = nt g r.value O f(order L ist.get(+ + c)) - 1 ; n s = nt g r.value O f(order L ist.get(+ + c)) - 1 ; t i n poped = sta k [sa].p o p( ) ; st a c k [sb].p u sh ( p oped ) ; } } } p i a e stati int g tPo nt(Strin g strin 1, Stri n strin 2) { if ( t in g 1.equal s (strin g 2)) { r e t r 1; } i n e List<Strin g > list new L nke List<Strin g >(); l i s t . lear ( ); li s t . dd(s t rin g 1); lis t . dd(s t rin g 2); Col l e tions.sort( l ist) ; if( l i t. g et(0 ) .eq u a l s (strin g 1)) { r e t r 0; } l s ret r 3; } p i a e stati Strin [] get S p itStrings(Strin g s) { i n e List<Strin g > reli s = new L nke List<Strin g >(); r e l i s .clear ( ); St r i n Tokenizer sz = ew S rin Tokenizer(s); w h i l e sz.ha s Mo r eTokens()) { r e l s .add(s z .ne x tT o ken()); } S t r n [] res u l = rel s .toArr a y(new S t rin [relis t .size( ) ]); r e t u r resul ; } pr i a e stati doubl getDe ideChild(doubl e [] sco r e , doub l avera e) { do u l resul = 0D; f r( i t i = 0 s o e .lengt h ; i++) re s l += Ma h. ow(( s cor e s [i] - a v e a e), 2D) ; r e t r resul ; } pr i a e stati doubl getAv rage(doubl e [] sco r e ) { do u l resul = 0D; f r( i t i = 0 s o e .lengt h ; i++) re s l += sc re [i]; } r e t r (resu t /= sc re .lengt h ); } p r i a e stati doubl getDi tance(doubl e [] poi n t ) { do u l dx0 = poi t [0]; d o u b l dy0 = poi t [1]; d o u b l dx1 = poi t [2]; d o u b l dy1 = poi t [3]; d o u b l dx = x1 - dx0 oub l dy = y1 - dy0 etu r Math. qrt( d x*dx + dy * dy ) ; } p r i a e stati doubl [] get P a sedDoublea(Strin g s) { t r n Tokenizer sz = ew S rin Tokenizer(s); A r r a y ist<Doubl e > resl i t = new A ray ist<Doubl e >(); w h i l e sz.ha s Mo r eTokens()) { r e s i t.add(D o ubl e .value O f(sz.ne x tT o ken())); } d o u l [] res u l = new d ubl [resli s t.size( ) ]; f o r ( i t i = 0 r s l .lengt h ; i++) re s l [i] = r e s i t.get(i ) ; } r e t r resul ; } pr i a e stati Strin shuff e(Strin g reg, nt i { y s e .out.p r int l n(reg+\" to \" + reg. s u bst r ing(i, re g . l ngt h ()) + r e g s bst r ing(0, i) ) ; e t u r reg.s bst r ing(i, re g . l ngt h ()) + r e g s bst r ing(0, i) ; } p r i a e stati int[] get C h rCounts(Strin g s) { n t ] res u l = new i t[' '-' a '+1 ] ; f o r ( i t i = 0 s l n t h (); i+ + ) Ch a a ter c = s c a A t (i); i f ( C h ra c ter.isLet t er(c)) { c = C a a ter.toLow e rCase(c); i n t n m = (in ) - ' a ' esu l [num]+ + ; } } r t r resul ; } pr i a e stati int g tCo nt(Strin g s) { n t r sul = 0; o ( i t i = 0 s l n t h (); i+ + ) re s l += In eg r.value O f(s.sub s t r ing(i, i+ 1 ) ) } r e t r resul ; } pr i a e stati Strin getPa sedString(Strin g s) { t r n resul = \"\"; f r ( i t i = 0 s l n t h (); i+ + ) ch a = s c a A t (i); i f ( C h ra c ter.isLow e rCase(c)) { c = C a a ter.toUpp e rCase(c); } e l s f(Ch ra c ter.isUpp e rCase(c)) { c = C a a ter.toLow e rCase(c); } r e s l += c; } e t r resul ; } pr i a e stati int g tCo nt(int n u m, nt m x) in t r sul = 0; i k e List<Strin g > buff e = new L nke List<Strin g >(); b u f f e .clear ( ); fo r ( i t i = 1 = u ; ++) fo r i t j = 1 = u ; ++) fo r i t k = 1 = u ; ++) if ( j + k = a & nE (i j, k ) { i n t ] res = get o ted(i, j, k ) S r i n s = S r n .value O f(res[0 ] +\", \" + r e s [ 1 ] +\", \" + r e s [ 2 ] ); i f ( ! b ff e r .conta i ns(s)) { b u f e .add(s ) ; r e s u l ++; } } } } } r t r resul ; } pr i a e stati boole n nEq(i t i , in j in k { e t r i != & = & = ; } r i a e stati int[] get S o ted(int . . . p ram { fo r i t i = 0 p r m lengt h - 1; + ) fo r i t j = 0 p r m lengt h - 1 - i + ) if ( a am [ j] > p a r m j+1]) { p a r m = swa ( aram . clone ( ), j, j + ) ; } } } r t r param } pr i a e stati int[] swa p ( nt[] par a m int i in j { n t t p = par m i]; p a r a m i] = p a r m j]; p a r a m j] = t m p etu r param } pu b i stati int[] get S p itIntegers(Strin g s) th o w Excep ion { Arr y ist<Integ e r> list new A ray ist<Integ e r>(); l i s t . lear ( ); St r i n Tokenizer sz = ew S rin Tokenizer(s); w h i l e sz.ha s Mo r eTokens()) { l i s . dd(I n teg e r.value O f(sz.ne x tT o ken())); } i n t ] res u l = new i t[l st. s ize( ) ]; f o r ( i t i = 0 l s . ize( ) ; i+ + ) re s l [i] = l i s . et(i ) ; } r e t r resul ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int h [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) h [ i ] = s . nextInt ( ) ; Arrays . sort ( h ) ; System . out . println ( h [ 9 ] ) ; System . out . println ( h [ 8 ] ) ; System . out . println ( h [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] args ) throws IOException { int [ ] data = new int [ 10 ] ; int max1 , max2 , max3 ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String buf = br . readLine ( ) ; data [ i ] = Integer . parseInt ( buf ) ; } java . util . Arrays . sort ( data ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] a ) { int [ ] mt = new int [ 10 ] ; int i ; Scanner scan = new Scanner ( System . in ) ; for ( i = 0 ; i < 10 ; i ++ ) { mt [ i ] = scan . nextInt ( ) ; } Arrays . sort ( mt ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( mt [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Random ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] heights = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { heights [ i ] = in . nextInt ( ) ; } quicksort ( heights , 0 , heights . length - 1 ) ; for ( int i = heights . length - 1 ; i >= heights . length - 3 ; i -- ) { System . out . println ( heights [ i ] ) ; } } private static void quicksort ( int [ ] data , int start , int end ) { if ( start > end ) { return ; } int index = partition ( data , start , end ) ; quicksort ( data , start , index - 1 ) ; quicksort ( data , index + 1 , end ) ; } private static int partition ( int [ ] data , int start , int end ) { int index = - 1 ; Random rd = new Random ( ) ; while ( index < start || index > end ) { index = rd . nextInt ( end + 1 ) ; } swap ( data , index , end ) ; int pivot = data [ end ] ; int i = - 1 , j = 0 ; for ( ; j < end ; j ++ ) { if ( data [ j ] <= pivot ) { swap ( data , ++ i , j ) ; } } swap ( data , ++ i , end ) ; return i ; } private static void swap ( int [ ] data , int i , int j ) { int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = s . nextInt ( ) ; Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = 10 , m = 3 ; int alt [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { alt [ i ] = sc . nextInt ( ) ; } Arrays . sort ( alt ) ; for ( int i = 0 ; i < m ; i ++ ) { System . out . println ( alt [ n - i - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] hight ; hight = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { hight [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hight ) ; System . out . println ( hight [ 9 ] ) ; System . out . println ( hight [ 8 ] ) ; System . out . println ( hight [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int data [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( data ) ; for ( int i = 9 ; i >= 7 ; i -- ) System . out . printf ( \" %d \\n \" , data [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < h . length ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = i ; j < h . length ; j ++ ) { if ( h [ j ] > h [ i ] ) { int max = h [ j ] ; h [ j ] = h [ i ] ; h [ i ] = max ; } } System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { Scanner scan = new Scanner ( System . in ) ; int [ ] delta = new int [ 10 ] ; for ( int j = 0 ; j < 10 ; j ++ ) { delta [ j ] = scan . nextInt ( ) ; } Arrays . sort ( delta ) ; for ( int i = delta . length - 1 ; i > delta . length - 4 ; i -- ) { System . out . println ( delta [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . ArrayList ; public class Main { public static void main ( String [ ] a ) { ArrayList < Integer > inputs = new ArrayList < Integer > ( ) ; String line ; try { int count = 0 ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( ( line = br . readLine ( ) ) != null && line . length ( ) > 0 ) { inputs . add ( Integer . parseInt ( line ) ) ; count ++ ; if ( count > 9 ) { break ; } } } catch ( Exception e ) { } int sub = 0 ; for ( int k = 0 ; k < inputs . size ( ) - 1 ; k ++ ) { for ( int i = k + 1 ; i < inputs . size ( ) ; i ++ ) { try { int num1 = inputs . get ( k ) ; int num2 = inputs . get ( i ) ; if ( num1 < num2 ) { sub = num2 ; inputs . set ( i , num1 ) ; inputs . set ( k , sub ) ; } } catch ( Exception e ) { } } } for ( int i = 0 ; i < 3 ; i ++ ) { if ( i < inputs . size ( ) ) { System . out . println ( inputs . get ( i ) ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; ArrayList < Integer > lst = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) lst . add ( in . nextInt ( ) ) ; Collections . sort ( lst ) ; System . out . println ( lst . get ( 9 ) ) ; System . out . println ( lst . get ( 8 ) ) ; System . out . println ( lst . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; ++ i ) a [ i ] = in . nextInt ( ) ; Arrays . sort ( a ) ; System . out . println ( a [ 9 ] + \" \\n \" + a [ 8 ] + \" \\n \" + a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { int [ ] mountains = new int [ 10 ] ; int [ ] big = new int [ 4 ] ; int cursor = 0 ; BufferedReader d = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . valueOf ( d . readLine ( ) ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( big [ j ] <= mountains [ i ] ) { for ( int k = 2 ; k > j ; k -- ) { big [ k ] = big [ k - 1 ] ; } big [ j ] = mountains [ i ] ; mountains [ i ] = 0 ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( big [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int first = 0 ; int second = 0 ; int third = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { int mount = sc . nextInt ( ) ; if ( mount >= first ) { third = second ; second = first ; first = mount ; } else if ( mount >= second ) { third = second ; second = mount ; } else if ( mount > third ) { third = mount ; } } System . out . printf ( \" %d \\n %d \\n %d \\n \" , first , second , third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; List < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { l . add ( Integer . valueOf ( r . readLine ( ) ) ) ; } Collections . sort ( l ) ; for ( int i = l . size ( ) - 1 ; i >= l . size ( ) - 3 ; i -- ) { System . out . println ( l . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; int [ ] b = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { b [ i ] = s . nextInt ( ) ; } Arrays . sort ( b ) ; System . out . println ( b [ 9 ] ) ; System . out . println ( b [ 8 ] ) ; System . out . println ( b [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; int [ ] b = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { b [ i ] = s . nextInt ( ) ; } Arrays . sort ( b ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( b [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int [ ] d ; d = new int [ 10 ] ; int a = 0 , b = 0 , c = 0 ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { d [ i ] = sc . nextInt ( ) ; if ( d [ i ] > a ) { c = b ; b = a ; a = d [ i ] ; } else if ( d [ i ] > b ) { c = b ; b = d [ i ] ; } else if ( d [ i ] > c ) { c = d [ i ] ; } } System . out . println ( a + \" \\n \" + b + \" \\n \" + c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { static int [ ] height ; final static int size = 10 ; public static void main ( String [ ] args ) { printAns ( ) ; } public static void init ( ) { height = new int [ size ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < size ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } } public static void sort ( ) { int max ; for ( int i = 0 ; i < size ; i ++ ) { max = i ; for ( int j = i + 1 ; j < size ; j ++ ) if ( height [ max ] < height [ j ] ) max = j ; swap ( i , max ) ; } } public static void swap ( int i , int j ) { int tmp = height [ i ] ; height [ i ] = height [ j ] ; height [ j ] = tmp ; } public static void printAns ( ) { init ( ) ; sort ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( height [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; class Main { Scanner sc = new Scanner ( System . in ) ; public void run ( ) { int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = sc . nextInt ( ) ; } Arrays . sort ( data ) ; for ( int i = data . length - 1 ; i >= data . length - 3 ; i -- ) { ln ( data [ i ] ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } public static void pr ( Object o ) { System . out . print ( o ) ; } public static void ln ( Object o ) { System . out . println ( o ) ; } public static void ln ( ) { System . out . println ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String arg [ ] ) { int a [ ] = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = scan . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( a [ 10 - i - 1 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scanner = new Scanner ( System . in ) ; int height [ ] = new int [ 10 ] ; int first = - 1 , second = - 1 , third = - 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = scanner . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( first == - 1 || height [ first ] < height [ i ] ) { third = second ; second = first ; first = i ; } } for ( int i = 0 ; i < 10 ; i ++ ) { if ( ( i != first ) && ( second == - 1 || height [ second ] < height [ i ] ) ) { third = second ; second = i ; } } for ( int i = 0 ; i < 10 ; i ++ ) { if ( ( i != first ) && ( i != second ) && ( third == - 1 || height [ third ] < height [ i ] ) ) { third = i ; } } System . out . println ( height [ first ] ) ; System . out . println ( height [ second ] ) ; System . out . println ( height [ third ] ) ; } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String [ ] args ) { java . util . Queue < Integer > lis = new java . util . PriorityQueue < Integer > ( 16 , new java . util . Comparator < Integer > ( ) { public int compare ( Integer a , Integer b ) { return ( b - a ) ; } } ) ; java . util . Scanner cin = new java . util . Scanner ( System . in ) ; int i ; for ( i = 0 ; i < 10 ; ++ i ) { lis . add ( new Integer ( cin . nextInt ( ) ) ) ; } for ( i = 0 ; i < 3 ; ++ i ) { System . out . println ( lis . poll ( ) ) ; } return ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { solve0001 ( ) ; } public static void solve0001 ( ) { Integer [ ] array = new Integer [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = new Integer ( sc . nextInt ( ) ) ; } Arrays . sort ( array , new MyComparator ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( array [ i ] ) ; } } } class MyComparator implements Comparator < Integer > { public int compare ( Integer o1 , Integer o2 ) { return o1 . intValue ( ) < o2 . intValue ( ) ? 1 : - 1 ; } }",
    "label": 1
  },
  {
    "code": "import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . io . IOException ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int top1 = 0 , top2 = 0 , top3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int input = Integer . parseInt ( br . readLine ( ) ) ; int w ; if ( input > top1 ) { top3 = top2 ; top2 = top1 ; top1 = input ; } else if ( input > top2 ) { top3 = top2 ; top2 = input ; } else if ( input > top3 ) { top3 = input ; } } System . out . println ( top1 + \" \\n \" + top2 + \" \\n \" + top3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n1 = 0 ; int n2 = 0 ; int n3 = 0 ; int num = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { num = scan . nextInt ( ) ; if ( num >= n1 ) { n3 = n2 ; n2 = n1 ; n1 = num ; } else if ( num >= n2 ) { n3 = n2 ; n2 = num ; } else if ( num >= n3 ) { n3 = num ; } } System . out . println ( n1 + \" \\n \" + n2 + \" \\n \" + n3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] array = new int [ 10 ] ; Scanner stdIn = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = stdIn . nextInt ( ) ; } array = arraySort ( array ) ; System . out . println ( array [ 0 ] + \" \\n \" + array [ 1 ] + \" \\n \" + array [ 2 ] ) ; } public static int [ ] arraySort ( int [ ] array ) { for ( int i = 0 ; i < array . length - 1 ; i ++ ) { for ( int j = array . length - 1 ; j > i ; j -- ) { if ( array [ j ] > array [ j - 1 ] ) { int t = array [ j ] ; array [ j ] = array [ j - 1 ] ; array [ j - 1 ] = t ; } } } return array ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { static void run ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { int mountain [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountain ) ; System . out . println ( mountain [ 9 ] + \" \\n \" + mountain [ 8 ] + \" \\n \" + mountain [ 7 ] ) ; } } public static void main ( String [ ] args ) { run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int a [ ] = new int [ 10 ] ; int b [ ] = new int [ 3 ] ; b [ 0 ] = b [ 1 ] = b [ 2 ] = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) { String s = br . readLine ( ) ; a [ i ] = Integer . parseInt ( s ) ; } java . util . Arrays . sort ( a ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( a [ i ] ) ; } System . exit ( 0 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int a [ ] = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { String s = br . readLine ( ) ; a [ i ] = Integer . parseInt ( s ) ; } java . util . Arrays . sort ( a ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( a [ i ] ) ; } System . exit ( 0 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; int [ ] b = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( a [ i ] > b [ 0 ] ) { b [ 2 ] = b [ 1 ] ; b [ 1 ] = b [ 0 ] ; b [ 0 ] = a [ i ] ; } else if ( a [ i ] > b [ 1 ] ) { b [ 2 ] = b [ 1 ] ; b [ 1 ] = a [ i ] ; } else if ( a [ i ] > b [ 2 ] ) b [ 2 ] = a [ i ] ; } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( b [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] arg ) { Scanner cin = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; int [ ] c = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = cin . nextInt ( ) ; c [ i ] = a [ i ] ; } int count = 1 ; while ( count == 1 ) { count = 0 ; for ( int k = 0 ; k < 9 ; k ++ ) { if ( a [ k ] < a [ k + 1 ] ) { c [ k ] = a [ k + 1 ] ; c [ k + 1 ] = a [ k ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = c [ i ] ; } count = 1 ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] arg ) { Scanner cin = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; int [ ] c = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = cin . nextInt ( ) ; c [ i ] = a [ i ] ; } Arrays . sort ( a ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( a [ a . length - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = scan . nextInt ( ) ; Arrays . sort ( a ) ; for ( int i = 9 ; i >= 7 ; i -- ) System . out . println ( a [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] ans = new int [ 10 ] ; int len = ans . length ; for ( int i = 0 ; i < len ; i ++ ) { ans [ i ] = sc . nextInt ( ) ; } Arrays . sort ( ans ) ; len -- ; for ( int i = len ; i > len - 3 ; i -- ) { System . out . println ( ans [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . PrintStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { doit ( args , new Scanner ( System . in ) , System . out ) ; } static void doit ( String [ ] args , Scanner scanner , PrintStream out ) { List < Integer > heights = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = scanner . nextInt ( ) ; heights . add ( h ) ; } Collections . sort ( heights , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 . compareTo ( o1 ) ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int first = 0 ; int second = 0 ; int third = 0 ; int input ; while ( cin . hasNextInt ( ) ) { input = cin . nextInt ( ) ; if ( input > third ) { if ( input > second ) { if ( input > first ) { third = second ; second = first ; first = input ; } else { third = second ; second = input ; } } else { third = input ; } } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { List < Integer > inputs = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! sc . hasNextInt ( ) ) { break ; } int input = sc . nextInt ( ) ; inputs . add ( Integer . valueOf ( input ) ) ; } Collections . sort ( inputs , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ) ; for ( int height : inputs . subList ( 0 , Math . min ( inputs . size ( ) , 3 ) ) ) { System . out . println ( height ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { List < Integer > inputs = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! sc . hasNextInt ( ) ) { break ; } int input = sc . nextInt ( ) ; inputs . add ( Integer . valueOf ( input ) ) ; } Collections . sort ( inputs , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ) ; for ( int height : inputs . subList ( 0 , Math . min ( inputs . size ( ) , 3 ) ) ) { System . out . println ( height ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] mountains ; public static void main ( String [ ] args ) { while ( read ( ) ) { solve ( ) ; } } static boolean read ( ) { if ( ! sc . hasNext ( ) ) return false ; mountains = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = sc . nextInt ( ) ; } return true ; } static void solve ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i ; j < 10 ; j ++ ) { if ( mountains [ j ] < mountains [ i ] ) { int swap = mountains [ i ] ; mountains [ i ] = mountains [ j ] ; mountains [ j ] = swap ; } } } System . out . println ( mountains [ 9 ] ) ; System . out . println ( mountains [ 8 ] ) ; System . out . println ( mountains [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) list [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( list ) ; System . out . println ( list [ list . length - 1 ] ) ; System . out . println ( list [ list . length - 2 ] ) ; System . out . println ( list [ list . length - 3 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Scanner ; import java . util . Collections ; class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int i = 0 ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; while ( sc . hasNextInt ( ) ) { int num = sc . nextInt ( ) ; list . add ( num ) ; i ++ ; if ( i > 9 ) { break ; } } if ( sc . ioException ( ) != null ) { throw sc . ioException ( ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( 9 ) ) ; System . out . println ( list . get ( 8 ) ) ; System . out . println ( list . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { int a = stdIn . nextInt ( ) ; list . add ( a ) ; } Collections . sort ( list ) ; for ( int i = 9 ; i > 6 ; -- i ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; import java . util . Vector ; public class Main { public static void main ( String [ ] args ) { int [ ] box = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { box [ i ] = sc . nextInt ( ) ; } Arrays . sort ( box ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( box [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) x [ i ] = sc . nextInt ( ) ; Arrays . sort ( x ) ; System . out . printf ( \" %d \\n %d \\n %d \\n \" , x [ 9 ] , x [ 8 ] , x [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } Arrays . sort ( h ) ; for ( int i = h . length - 1 ; i >= 7 ; i -- ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . IOException ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] moun = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) moun [ i ] = Integer . parseInt ( br . readLine ( ) ) ; Arrays . sort ( moun ) ; System . out . println ( moun [ 9 ] ) ; System . out . println ( moun [ 8 ] ) ; System . out . println ( moun [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader var = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int vec [ ] = new int [ 10 ] ; for ( int c = 0 ; c < 10 ; c ++ ) { vec [ c ] = Integer . parseInt ( var . readLine ( ) ) ; } Arrays . sort ( vec ) ; System . out . println ( vec [ 9 ] ) ; System . out . println ( vec [ 8 ] ) ; System . out . println ( vec [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader t = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Vector < Integer > vector = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= 10 ; i ++ ) { vector . add ( Integer . parseInt ( t . readLine ( ) ) ) ; } Collections . sort ( vector ) ; Collections . reverse ( vector ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( vector . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader entrada = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 * 8 ) ; int A [ ] = new int [ 10 ] ; int numero , i ; for ( i = 0 ; i < 10 ; i ++ ) { numero = Integer . parseInt ( entrada . readLine ( ) ) ; A [ i ] = numero ; } Arrays . sort ( A ) ; System . out . println ( \" \" + A [ 9 ] + \" \\n \" + A [ 8 ] + \" \\n \" + A [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] a ) { int [ ] arr = new int [ ] { 0 , 0 , 0 } ; String str ; BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { while ( null != ( str = bf . readLine ( ) ) ) { int tmp = Integer . parseInt ( str ) ; if ( arr [ 0 ] < tmp ) { arr [ 0 ] = tmp ; Arrays . sort ( arr ) ; } } for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( arr [ 3 - i ] ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int [ ] vec = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) vec [ i ] = in . nextInt ( ) ; Arrays . sort ( vec ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( vec [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; import java . lang . * ; class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; List < Integer > vec = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int val ; val = in . nextInt ( ) ; vec . add ( val ) ; } Collections . sort ( vec , new Comparator < Integer > ( ) { @ Override public int compare ( Integer a , Integer b ) { return b . compareTo ( a ) ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( vec . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { int [ ] m = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < m . length ; i ++ ) { m [ i ] = sc . nextInt ( ) ; } Arrays . sort ( m ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( m [ 10 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public int a [ ] = new int [ 10 ] ; public void topThree ( ) { } public void order ( ) { int temp ; int i , j ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = i ; j < 10 ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } } public void display ( ) { int i ; for ( i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Main m = new Main ( ) ; int i = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { m . a [ i ] = sc . nextInt ( ) ; } m . order ( ) ; m . display ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; import java . math . BigInteger ; public class Main { public static void main ( String [ ] args ) { try { final int INF = Integer . MAX_VALUE , MINF = Integer . MIN_VALUE ; SpecialComparator scomparator = new SpecialComparator ( ) ; Scanner s = new Scanner ( System . in ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) in [ i ] = s . nextInt ( ) ; Arrays . sort ( in ) ; for ( int i = 0 ; i < 3 ; i ++ ) debugl ( in [ 9 - i ] ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private static void debugl ( Object obj ) { System . out . println ( obj ) ; } private static void debug ( Object obj ) { System . out . print ( obj ) ; } private static String toStrmd ( Object [ ] obj ) { return Arrays . deepToString ( obj ) ; } } class SpecialComparator implements Comparator { private int index = 0 ; public void setIndex ( int index ) { this . index = index ; } public int compare ( Object a , Object b ) { String [ ] sa = ( String [ ] ) a ; String [ ] sb = ( String [ ] ) b ; return ( sa [ index ] . compareTo ( sb [ index ] ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int first = 0 , second = 0 , third = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int temp = scan . nextInt ( ) ; if ( first < temp ) { third = second ; second = first ; first = temp ; } else if ( second < temp ) { third = second ; second = temp ; } else if ( third < temp ) { third = temp ; } } System . out . println ( first + \" \\n \" + second + \" \\n \" + third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int first = 0 , second = 0 , third = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int temp = scan . nextInt ( ) ; if ( first <= temp ) { third = second ; second = first ; first = temp ; } else if ( second <= temp ) { third = second ; second = temp ; } else if ( third < temp ) { third = temp ; } } System . out . println ( first + \" \\n \" + second + \" \\n \" + third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { Scanner input = new Scanner ( System . in ) ; int [ ] m_height = new int [ 10 ] ; for ( int i = 0 ; i < m_height . length ; i ++ ) { m_height [ i ] = input . nextInt ( ) ; } Arrays . sort ( m_height ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( m_height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = in . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; in . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] kekka = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { kekka [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( kekka ) ; System . out . println ( kekka [ 9 ] ) ; System . out . println ( kekka [ 8 ] ) ; System . out . println ( kekka [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { int i = 0 , j = 0 ; int a [ ] = new int [ 10 ] ; Scanner scan = new Scanner ( System . in ) ; for ( i = 0 ; i <= 9 ; i ++ ) a [ i ] = scan . nextInt ( ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < 3 ; i ++ ) System . out . println ( a [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner reader = new Scanner ( System . in ) ; int [ ] bil ; bil = new int [ 11 ] ; for ( int i = 1 ; i <= 10 ; i ++ ) { bil [ i ] = reader . nextInt ( ) ; } for ( int i = 1 ; i <= 3 ; i ++ ) { int max = bil [ 0 ] ; int nomor = 0 ; for ( int j = 1 ; j <= 10 ; j ++ ) { if ( max < bil [ j ] ) { max = bil [ j ] ; nomor = j ; } } bil [ nomor ] = 0 ; System . out . println ( max ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( array ) ; for ( int i = 9 ; 6 < i ; i -- ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; public class Main { public static void main ( String [ ] args ) throws IOException { java . io . BufferedReader in = new java . io . BufferedReader ( new java . io . InputStreamReader ( System . in ) ) ; { int data [ ] = new int [ 4 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int p = Integer . parseInt ( in . readLine ( ) ) ; int k = 2 ; while ( k >= 0 && data [ k ] < p ) { data [ k + 1 ] = data [ k ] ; k -- ; } data [ k + 1 ] = p ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( data [ i ] ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lc = 0 ; short [ ] heights = new short [ 10 ] ; while ( lc < 10 ) { try { heights [ lc ] = Short . parseShort ( reader . readLine ( ) ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } lc ++ ; } Arrays . sort ( heights ) ; for ( int i = heights . length - 1 ; i > heights . length - 4 ; i -- ) { System . out . println ( heights [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m_count = 10 , ans_count = 3 ; int [ ] m = new int [ m_count ] ; int i ; for ( i = 0 ; i < m_count ; i ++ ) { m [ i ] = sc . nextInt ( ) ; } Arrays . sort ( m ) ; int t = 0 ; for ( i = 0 ; i < m_count / 2 ; i ++ ) { t = m [ i ] ; m [ i ] = m [ m_count - i - 1 ] ; m [ m_count - i - 1 ] = t ; } for ( i = 0 ; i < ans_count ; i ++ ) { System . out . println ( m [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] hill = new int [ 10 ] ; int len ; for ( int i = 0 ; i < ( len = hill . length ) ; i ++ ) hill [ i ] = sc . nextInt ( ) ; Arrays . sort ( hill ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( hill [ len - 1 - i ] ) ; sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . lang . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { int top = 0 ; int second = 0 ; int third = 0 ; int wk = 0 ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { int height = sc . nextInt ( ) ; if ( ! ( 0 <= height && height <= 10000 ) ) { continue ; } if ( top < height ) { wk = top ; top = height ; height = wk ; } if ( second < height ) { wk = second ; second = height ; height = wk ; } if ( third < height ) { wk = third ; third = height ; height = wk ; } } System . out . println ( top ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) list . add ( sc . nextInt ( ) ) ; Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( list . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { static int n ; static void swap ( int [ ] array , int i , int j ) { int temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } static void quick_sort ( int [ ] array , int left , int right ) { int pivot = array [ ( left + right ) / 2 ] ; int i = left ; int j = right ; while ( true ) { while ( pivot > array [ i ] ) i ++ ; while ( pivot < array [ j ] ) j -- ; if ( i >= j ) break ; swap ( array , i , j ) ; i ++ ; j -- ; } if ( left < i - 1 ) quick_sort ( array , left , i - 1 ) ; if ( j + 1 < right ) quick_sort ( array , j + 1 , right ) ; } static void display ( int [ ] array , int m , int n ) { for ( int i = n - 1 ; i > m - 1 ; i -- ) { System . out . print ( array [ i ] + \" \\n \" ) ; } } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int array [ ] = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { String s = br . readLine ( ) ; array [ i ] = Integer . parseInt ( s ) ; } n = array . length ; quick_sort ( array , n - n , n - 1 ) ; display ( array , 7 , 9 + 1 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { int [ ] hills = new int [ 3 ] ; hills [ 0 ] = 0 ; hills [ 1 ] = 0 ; hills [ 2 ] = 0 ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int hill = scan . nextInt ( ) ; if ( hills [ 2 ] < hill ) { if ( hills [ 1 ] < hill ) { if ( hills [ 0 ] < hill ) { hills [ 2 ] = hills [ 1 ] ; hills [ 1 ] = hills [ 0 ] ; hills [ 0 ] = hill ; } else { hills [ 2 ] = hills [ 1 ] ; hills [ 1 ] = hill ; } } else { hills [ 2 ] = hill ; } } } for ( int topThree : hills ) { System . out . println ( topThree ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] inputData = new String [ 10 ] ; try { for ( int i = 0 ; i < 10 ; i ++ ) { inputData [ i ] = in . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } finally { try { in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } } int firstHill = 0 ; int secondHill = 0 ; int thirdHill = 0 ; int nowHill = 0 ; for ( String nowHillStr : inputData ) { nowHill = Integer . parseInt ( nowHillStr ) ; if ( nowHill > firstHill ) { thirdHill = secondHill ; secondHill = firstHill ; firstHill = nowHill ; } else if ( nowHill > secondHill ) { thirdHill = secondHill ; secondHill = nowHill ; } else if ( nowHill > thirdHill ) { thirdHill = nowHill ; } } System . out . println ( firstHill ) ; System . out . println ( secondHill ) ; System . out . println ( thirdHill ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { x [ i ] = scan . nextInt ( ) ; } Arrays . sort ( x ) ; System . out . println ( x [ 9 ] ) ; System . out . println ( x [ 8 ] ) ; System . out . println ( x [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) throws IOException { Scanner scan = new Scanner ( System . in ) ; int array [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = scan . nextInt ( ) ; } Arrays . sort ( array ) ; for ( int i = array . length - 1 ; i > array . length - 4 ; i -- ) System . out . println ( array [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] in = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { in [ i ] = sc . nextInt ( ) ; } Arrays . sort ( in ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( in [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mt ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mt [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int [ ] data = new int [ 10 ] , top3 = new int [ 3 ] ; Scanner stdIn = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) data [ i ] = stdIn . nextInt ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int max = data [ 0 ] , idx = 0 ; for ( int j = 1 ; j < 10 - i ; j ++ ) if ( max < data [ j ] ) max = data [ idx = j ] ; top3 [ i ] = max ; for ( int j = idx ; j < 9 - i ; j ++ ) data [ j ] = data [ j + 1 ] ; } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( top3 [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) ; } Main ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] in = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { in [ i ] = sc . nextInt ( ) ; } Arrays . sort ( in ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( in [ 9 - i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { static Scanner kbd = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int max1 = 0 , max2 = 0 , max3 = 0 ; while ( kbd . hasNext ( ) ) { int m = kbd . nextInt ( ) ; if ( m > max1 ) { max3 = max2 ; max2 = max1 ; max1 = m ; } else if ( m > max2 ) { max3 = max2 ; max2 = m ; } else if ( m > max3 ) { max3 = m ; } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) { String [ ] sl = new String [ 10 ] ; InputStreamReader in = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { try { sl [ i ] = br . readLine ( ) ; if ( i == 9 ) { br . close ( ) ; } } catch ( Exception e ) { } } int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = Integer . parseInt ( sl [ i ] ) ; } Arrays . sort ( height ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String s ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; try { while ( null != ( s = br . readLine ( ) ) ) { if ( isNumber ( s ) ) list . add ( Integer . valueOf ( s ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } Integer [ ] array = list . toArray ( new Integer [ 0 ] ) ; Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } private static boolean isNumber ( String s ) { try { int n = Integer . parseInt ( s ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] max = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { max [ i ] = 0 ; } Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int val = scan . nextInt ( ) ; int tmp , tmp2 ; if ( max [ 0 ] < val ) { if ( max [ 1 ] < val ) { if ( max [ 2 ] < val ) { tmp = max [ 2 ] ; tmp2 = max [ 1 ] ; max [ 2 ] = val ; max [ 1 ] = tmp ; max [ 0 ] = tmp2 ; } else { tmp = max [ 1 ] ; max [ 1 ] = val ; max [ 0 ] = tmp ; } } else { max [ 0 ] = val ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( max [ 2 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] mtHeight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mtHeight [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( mtHeight ) ; for ( int i = mtHeight . length - 1 ; i >= 7 ; i -- ) { System . out . println ( mtHeight [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int x = sc . nextInt ( ) ; data [ i ] = x ; } Arrays . sort ( data ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static Scanner sc = new Scanner ( System . in ) ; void run ( ) { List < Integer > list = new ArrayList < Integer > ( ) ; while ( sc . hasNextInt ( ) ) { list . add ( sc . nextInt ( ) ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( list . size ( ) - 1 ) ) ; System . out . println ( list . get ( list . size ( ) - 2 ) ) ; System . out . println ( list . get ( list . size ( ) - 3 ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; int arrIn [ ] = new int [ 10 ] ; for ( int nLoop = 0 ; nLoop < arrIn . length ; nLoop ++ ) { arrIn [ nLoop ] = stdin . nextInt ( ) ; } Arrays . sort ( arrIn ) ; for ( int nLoop = 0 ; nLoop < 3 ; nLoop ++ ) { System . out . println ( arrIn [ arrIn . length - nLoop - 1 ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private int [ ] mt = new int [ 10 ] ; public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } private void run ( ) { Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = scan . nextInt ( ) ; } Arrays . sort ( mt ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( mt [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String [ ] args ) throws IOException { int [ ] data = new int [ 10 ] ; BufferedReader buf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = buf . readLine ( ) ; data [ i ] = Integer . parseInt ( str ) ; } for ( int i = 0 ; i < data . length - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ min ] > data [ j ] ) { min = j ; } } if ( min != i ) { int tmp = data [ min ] ; data [ min ] = data [ i ] ; data [ i ] = tmp ; } } System . out . println ( data [ 9 ] ) ; System . out . println ( data [ 8 ] ) ; System . out . println ( data [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountain = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountain ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountain [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; ArrayList < Integer > h = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { h . add ( s . nextInt ( ) ) ; } Collections . sort ( h ) ; Collections . reverse ( h ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( h . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] height = new Integer [ 10 ] ; for ( int i = 0 ; i < height . length ; i ++ ) { try { height [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } catch ( NumberFormatException e ) { System . out . println ( \" \"); } catch (IOExcepti o n ) { e.p i ntStackTrac ( ) } Arrays.sort(he i g h , C llecti o ns.r e verseO r er()); for( i nt i = 0; i < 3 ; i++ ) { S s e . o t p i n l n( h e ght[i] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; ArrayList < Integer > h = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { h . add ( s . nextInt ( ) ) ; } Collections . sort ( h ) ; Collections . reverse ( h ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( h . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] aH = new int [ 10 ] ; int temp ; for ( int i = 0 ; i < 10 ; i ++ ) { aH [ i ] = s . nextInt ( ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = i ; j > 0 ; j -- ) { if ( aH [ j - 1 ] < aH [ j ] ) { temp = aH [ j - 1 ] ; aH [ j - 1 ] = aH [ j ] ; aH [ j ] = temp ; } else { break ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( aH [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; public class Main { public static void main ( String [ ] a ) throws IOException { java . io . BufferedReader in = new java . io . BufferedReader ( new java . io . InputStreamReader ( System . in ) ) ; int change ; int [ ] Hill = new int [ ] { 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { Hill [ 3 ] = Integer . parseInt ( in . readLine ( ) ) ; for ( int j = 2 ; j >= 0 ; j -- ) { if ( Hill [ j + 1 ] > Hill [ j ] ) { change = Hill [ j + 1 ] ; Hill [ j + 1 ] = Hill [ j ] ; Hill [ j ] = change ; } else { break ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( Hill [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) data [ i ] = stdIn . nextInt ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int max = i ; for ( int j = 9 ; j > i ; j -- ) if ( data [ max ] < data [ j ] ) max = j ; int tmp = data [ i ] ; System . out . println ( data [ i ] = data [ max ] ) ; data [ max ] = tmp ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { ArrayList < Integer > mt = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mt . add ( sc . nextInt ( ) ) ; } Collections . sort ( mt , new Comparator < Integer > ( ) { @ Override public int compare ( Integer a , Integer b ) { return b - a ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mt . get ( i ) ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 10 ; i -- > 0 ; data [ i ] = stdIn . nextInt ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int max = i ; for ( int j = 9 ; j > i ; j -- ) if ( data [ max ] < data [ j ] ) max = j ; int tmp = data [ i ] ; System . out . println ( data [ i ] = data [ max ] ) ; data [ max ] = tmp ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) a . add ( sc . nextInt ( ) ) ; Collections . sort ( a ) ; for ( int i = 9 ; i >= 7 ; -- i ) System . out . println ( a . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner buf = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = buf . nextInt ( ) ; Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static Scanner sc ; public static void main ( String [ ] args ) { int [ ] hight = new int [ 10 ] ; sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { hight [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hight ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( hight [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static Scanner sc ; public static void main ( String [ ] args ) { int [ ] height = new int [ 10 ] ; sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { static public void main ( String [ ] argv ) { try { BufferedReader d = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] res = new int [ 3 ] ; res [ 0 ] = 0 ; res [ 1 ] = 0 ; res [ 2 ] = 0 ; while ( true ) { String str = d . readLine ( ) ; if ( str == null ) break ; res = compare ( Integer . valueOf ( str ) , res ) ; } printResult ( res ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } static int [ ] compare ( int input , int [ ] array ) { if ( input > array [ 0 ] ) { array [ 2 ] = array [ 1 ] ; array [ 1 ] = array [ 0 ] ; array [ 0 ] = input ; } else if ( input > array [ 1 ] ) { array [ 2 ] = array [ 1 ] ; array [ 1 ] = input ; } else if ( input > array [ 2 ] ) { array [ 2 ] = input ; } return array ; } static void printResult ( int [ ] res ) { System . out . println ( res [ 0 ] ) ; System . out . println ( res [ 1 ] ) ; System . out . println ( res [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = Integer . parseInt ( sc . nextLine ( ) ) ; data [ i ] = h ; } Arrays . sort ( data ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] ms = new int [ 10 ] ; for ( int ii = 0 ; ii < 10 ; ii ++ ) { ms [ ii ] = scanner . nextInt ( ) ; } java . util . Arrays . sort ( ms ) ; System . out . println ( ms [ 9 ] ) ; System . out . println ( ms [ 8 ] ) ; System . out . println ( ms [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] memo = new int [ 10 ] ; for ( int s = 0 ; s < 10 ; s ++ ) memo [ s ] = in . nextInt ( ) ; Arrays . sort ( memo ) ; for ( int i = 9 ; i >= 7 ; i -- ) System . out . println ( memo [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner keyboad = new Scanner ( System . in ) ; int yama [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { yama [ i ] = keyboad . nextInt ( ) ; } int mob = 0 ; int ans [ ] = new int [ 3 ] ; int mem [ ] = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) { mob = yama [ i ] ; } else { if ( mob < yama [ i ] ) { mob = yama [ i ] ; mem [ j ] = i ; } } ans [ j ] = mob ; } yama [ mem [ j ] ] = - 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( ans [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { static BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static List < Integer > list = new ArrayList < Integer > ( ) ; public static void main ( String [ ] a ) throws IOException { Integer num = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { try { num = Integer . parseInt ( input . readLine ( ) ) ; } catch ( NumberFormatException e ) { System . exit ( 0 ) ; } if ( num < 0 || 10000 < num ) { System . exit ( 0 ) ; } list . add ( num ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( 9 ) + \" \\n \" + list . get ( 8 ) + \" \\n \" + list . get ( 7 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { int [ ] mountains = new int [ 10 ] ; Scanner scanner = new Scanner ( System . in ) ; for ( int i = 0 ; i < mountains . length ; i ++ ) { int value = scanner . nextInt ( ) ; mountains [ i ] = value ; } Arrays . sort ( mountains ) ; int [ ] top3 = new int [ 3 ] ; int j = 0 ; for ( int i = mountains . length - 1 ; j < 3 ; i -- ) { top3 [ j ] = mountains [ i ] ; j ++ ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( top3 [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String [ ] args ) { java . util . Scanner in = new java . util . Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int n = 0 ; n < 10 ; n ++ ) { a [ n ] = in . nextInt ( ) ; } java . util . Arrays . sort ( a ) ; for ( int n = 0 ; n < 3 ; n ++ ) { System . out . println ( a [ 9 - n ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { final static int SIZE = 10 ; final static int OUT = 3 ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] heights = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { heights [ i ] = in . nextInt ( ) ; } Arrays . sort ( heights ) ; for ( int i = 0 ; i < OUT ; i ++ ) { System . out . println ( \" \" + heights [ SIZE - 1 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = input . nextInt ( ) ; int j = i ; while ( j > 0 && h [ j ] > h [ j - 1 ] ) { int t = h [ j ] ; h [ j ] = h [ j - 1 ] ; h [ j - 1 ] = t ; j -- ; } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( h [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] top = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { top [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 9 ; j > i ; j -- ) { if ( top [ j ] > top [ j - 1 ] ) { int multi = top [ j ] ; top [ j ] = top [ j - 1 ] ; top [ j - 1 ] = multi ; } } } System . out . println ( top [ 0 ] ) ; System . out . println ( top [ 1 ] ) ; System . out . println ( top [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int data = 0 ; int top [ ] = new int [ 3 ] ; top [ 0 ] = 0 ; top [ 1 ] = 0 ; top [ 2 ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { data = scan . nextInt ( ) ; if ( data > top [ 2 ] ) { if ( data > top [ 1 ] ) { if ( data > top [ 0 ] ) { top [ 2 ] = top [ 1 ] ; top [ 1 ] = top [ 0 ] ; top [ 0 ] = data ; continue ; } top [ 2 ] = top [ 1 ] ; top [ 1 ] = data ; continue ; } top [ 2 ] = data ; continue ; } } System . out . println ( top [ 0 ] + \" \\n \" + top [ 1 ] + \" \\n \" + top [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner angi = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; for ( int cont = 0 ; cont < 10 ; cont ++ ) { a [ cont ] = angi . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] rank = new int [ 10 ] ; int space ; for ( int i = 0 ; i < rank . length ; i ++ ) { rank [ i ] = scan . nextInt ( ) ; } for ( int k = 0 ; k < rank . length ; k ++ ) { for ( int j = 0 ; j < rank . length ; j ++ ) { if ( rank [ k ] > rank [ j ] ) { space = rank [ k ] ; rank [ k ] = rank [ j ] ; rank [ j ] = space ; } } } for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( rank [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] args ) { java . io . BufferedReader reader = null ; try { reader = new java . io . BufferedReader ( new java . io . InputStreamReader ( System . in ) ) ; int rank1 = 0 ; int rank2 = 0 ; int rank3 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int x = Integer . parseInt ( reader . readLine ( ) ) ; if ( x > rank1 ) { rank3 = rank2 ; rank2 = rank1 ; rank1 = x ; } else if ( x > rank2 ) { rank3 = rank2 ; rank2 = x ; } else if ( x > rank3 ) { rank3 = x ; } } System . out . println ( rank1 ) ; System . out . println ( rank2 ) ; System . out . println ( rank3 ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mt = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mt [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mt ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mt [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { int in ; int [ ] max = new int [ 3 ] ; Scanner s = new Scanner ( System . in ) ; for ( int i = 0 ; i < 3 ; i ++ ) { max [ i ] = 0 ; } for ( int i = 0 ; i < 10 ; i ++ ) { in = s . nextInt ( ) ; if ( max [ 0 ] < in ) { max [ 2 ] = max [ 1 ] ; max [ 1 ] = max [ 0 ] ; max [ 0 ] = in ; } else if ( max [ 0 ] == in ) { max [ 2 ] = max [ 1 ] ; max [ 1 ] = in ; } else if ( max [ 1 ] < in ) { max [ 2 ] = max [ 1 ] ; max [ 1 ] = in ; } else if ( max [ 1 ] == in ) { max [ 2 ] = max [ 1 ] ; max [ 1 ] = in ; } else if ( max [ 2 ] < in ) { max [ 2 ] = in ; } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( max [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int list_max = 10 ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < list_max ; i ++ ) { list . add ( scan . nextInt ( ) ) ; } Collections . sort ( list ) ; System . out . println ( list . get ( list . size ( ) - 1 ) ) ; System . out . println ( list . get ( list . size ( ) - 2 ) ) ; System . out . println ( list . get ( list . size ( ) - 3 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { int a = stdIn . nextInt ( ) ; list . add ( a ) ; } Collections . sort ( list , new MyComparator ( ) ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( list . get ( i ) ) ; } } } class MyComparator implements java . util . Comparator < Integer > { public int compare ( Integer object1 , Integer object2 ) { return ( ( object1 ) . compareTo ( object2 ) * - 1 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Comparator ; class Main { private static final int MOUNTAIN_COUNT = 10 ; public static void main ( final String [ ] args ) throws IOException , NumberFormatException { Integer [ ] mountainHeights = new Integer [ 10 ] ; BufferedReader input = null ; try { input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < MOUNTAIN_COUNT ; i ++ ) { mountainHeights [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } } finally { if ( input != null ) { input . close ( ) ; } } Arrays . sort ( mountainHeights , new Comparator < Integer > ( ) { @ Override public int compare ( final Integer lhs , final Integer rhs ) { return rhs . compareTo ( lhs ) ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountainHeights [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int [ ] intheight = new int [ 10 ] ; int [ ] intTopheight = new int [ 3 ] ; Scanner scan = new Scanner ( System . in ) ; scan . useDelimiter ( \" \\n \" ) ; for ( int i = 0 ; i < 10 ; i ++ ) { intheight [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( intTopheight [ j ] <= intheight [ i ] ) { if ( j == 0 ) { intTopheight [ 2 ] = intTopheight [ 1 ] ; intTopheight [ 1 ] = intTopheight [ 0 ] ; intTopheight [ 0 ] = intheight [ i ] ; } if ( j == 1 ) { intTopheight [ 2 ] = intTopheight [ 1 ] ; intTopheight [ 1 ] = intheight [ i ] ; } if ( j == 2 ) { intTopheight [ 2 ] = intheight [ i ] ; } break ; } } } for ( int k = 0 ; k < 3 ; k ++ ) { System . out . println ( intTopheight [ k ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; class Main { public static void main ( String args [ ] ) { try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int a [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = Integer . parseInt ( reader . readLine ( ) ) ; int t = a [ i ] ; int j = i ; while ( j > 0 && a [ j - 1 ] < t ) { a [ j ] = a [ j - 1 ] ; j -- ; } a [ j ] = t ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } catch ( IOException e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner scan = new Scanner ( System . in ) ; public static void main ( String [ ] a ) { int [ ] list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; ++ i ) { list [ i ] = Integer . parseInt ( scan . nextLine ( ) ) ; } Arrays . sort ( list ) ; print ( list [ 9 ] ) ; print ( list [ 8 ] ) ; print ( list [ 7 ] ) ; } public static void print ( Object out ) { System . out . println ( out ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner k = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; for ( int i = 0 ; i < x . length ; i ++ ) { x [ i ] = k . nextInt ( ) ; } Arrays . sort ( x ) ; for ( int i = x . length - 1 ; i > 6 ; i -- ) { System . out . println ( x [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] hills = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) hills [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( hills [ j ] > hills [ i ] ) { int tmp ; tmp = hills [ i ] ; hills [ i ] = hills [ j ] ; hills [ j ] = tmp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( hills [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; Integer [ ] hills = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) hills [ i ] = in . nextInt ( ) ; Arrays . sort ( hills , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( hills [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] hills = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) hills [ i ] = Integer . parseInt ( in . readLine ( ) ) ; Arrays . sort ( hills , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( hills [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] data = new int [ 10 ] ; for ( int i = 0 ; i < data . length ; i ++ ) data [ i ] = sc . nextInt ( ) ; Arrays . sort ( data ) ; System . out . println ( data [ data . length - 1 ] ) ; System . out . println ( data [ data . length - 2 ] ) ; System . out . println ( data [ data . length - 3 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = 10 ; int array [ ] = new int [ N ] ; for ( int i = 0 ; i < 10 ; i ++ ) { String line = br . readLine ( ) ; array [ i ] = Integer . parseInt ( line ) ; } quickSort ( 0 , N - 1 , array ) ; for ( int j = N - 1 ; j > 6 ; j -- ) { System . out . println ( array [ j ] ) ; } } private static void quickSort ( int bottom , int top , int [ ] data ) { int lower , upper ; if ( bottom >= top ) return ; int div = data [ bottom ] ; for ( lower = bottom , upper = top ; lower < upper ; ) { while ( lower <= upper && data [ lower ] <= div ) lower ++ ; while ( lower <= upper && data [ upper ] > div ) upper -- ; if ( lower < upper ) { int temp = data [ lower ] ; data [ lower ] = data [ upper ] ; data [ upper ] = temp ; } } int temp = data [ bottom ] ; data [ bottom ] = data [ upper ] ; data [ upper ] = temp ; quickSort ( bottom , upper - 1 , data ) ; quickSort ( upper + 1 , top , data ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] mountains = new int [ 10 ] ; int i = 0 ; while ( true ) { String s = r . readLine ( ) ; mountains [ i ++ ] = Integer . valueOf ( s ) ; if ( i >= 10 ) break ; } Arrays . sort ( mountains ) ; for ( i = 9 ; i > 6 ; i -- ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String args [ ] ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } java . util . Arrays . sort ( h ) ; for ( int i = h . length - 1 ; i >= 7 ; i -- ) { System . out . println ( h [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int first = 0 ; int second = 0 ; int third = 0 ; while ( sc . hasNext ( ) ) { int m = sc . nextInt ( ) ; if ( m > first ) { third = second ; second = first ; first = m ; } else if ( m > second ) { third = second ; second = m ; } else if ( m > third ) { third = m ; } } System . out . println ( first ) ; System . out . println ( second ) ; System . out . println ( third ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Collections ; import java . util . ArrayList ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int max = Integer . MIN_VALUE ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String input = br . readLine ( ) ; if ( ! input . equals ( \" \" ) ) { int inputAngka = Integer . parseInt ( input ) ; arr . add ( inputAngka ) ; } } int [ ] arrayResult = new int [ arr . size ( ) ] ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { arrayResult [ i ] = arr . get ( i ) ; } Arrays . sort ( arrayResult ) ; int max1 = arrayResult [ arrayResult . length - 1 ] ; int max2 = arrayResult [ arrayResult . length - 2 ] ; int max3 = arrayResult [ arrayResult . length - 3 ] ; System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; for ( int i = 0 ; i < a . length ; ++ i ) a [ i ] = cin . nextInt ( ) ; Arrays . sort ( a ) ; for ( int i = a . length - 1 ; i > a . length - 4 ; -- i ) System . out . println ( a [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { List < Integer > inputs = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! sc . hasNextInt ( ) ) { break ; } int input = sc . nextInt ( ) ; inputs . add ( Integer . valueOf ( input ) ) ; } Collections . sort ( inputs , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } } ) ; for ( int height : inputs . subList ( 0 , Math . min ( inputs . size ( ) , 3 ) ) ) { System . out . println ( height ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = 0 , b = 0 , c = 0 ; while ( sc . hasNext ( ) ) { String line = sc . nextLine ( ) ; Scanner s = new Scanner ( line ) ; int h = s . nextInt ( ) ; if ( a < h ) { c = b ; b = a ; a = h ; } else if ( b < h ) { c = b ; b = h ; } else if ( c < h ) { c = h ; } } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = 0 , b = 0 , c = 0 ; while ( sc . hasNext ( ) ) { String line = sc . nextLine ( ) ; Scanner s = new Scanner ( line ) ; int h = s . nextInt ( ) ; if ( a < h ) { c = b ; b = a ; a = h ; } else if ( b < h ) { c = b ; b = h ; } else if ( c < h ) { c = h ; } } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = 0 , b = 0 , c = 0 ; while ( sc . hasNext ( ) ) { String line = sc . nextLine ( ) ; Scanner s = new Scanner ( line ) ; int h = s . nextInt ( ) ; if ( a < h ) { c = b ; b = a ; a = h ; } else if ( b < h ) { c = b ; b = h ; } else if ( c < h ) { c = h ; } } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner date = new Scanner ( System . in ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = date . nextInt ( ) ; } java . util . Arrays . sort ( num ) ; for ( int i = num . length - 1 ; i > num . length - 4 ; i -- ) { System . out . println ( num [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner date = new Scanner ( System . in ) ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = date . nextInt ( ) ; } java . util . Arrays . sort ( num ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( num [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input1 = new Scanner ( System . in ) ; int largest = 0 ; int secondlargest = 0 ; int thirdlargest = 0 ; int largestindex = 0 ; int secondlargestindex = 0 ; int [ ] number = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { number [ i ] = input1 . nextInt ( ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( number [ i ] > largest ) { largest = number [ i ] ; largestindex = i ; } } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( number [ i ] > secondlargest && i != largestindex ) { secondlargest = number [ i ] ; secondlargestindex = i ; } } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( number [ i ] > thirdlargest && i != largestindex && i != secondlargestindex ) { thirdlargest = number [ i ] ; } } System . out . println ( largest ) ; System . out . println ( secondlargest ) ; System . out . println ( thirdlargest ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner stdIn = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; int [ ] max = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = stdIn . nextInt ( ) ; if ( i == 0 ) { max [ 0 ] = height [ i ] ; } else { for ( int j = 0 ; j < 3 ; j ++ ) { if ( max [ j ] < height [ i ] ) { for ( int k = 2 ; k > j ; k -- ) { max [ k ] = max [ k - 1 ] ; } max [ j ] = height [ i ] ; break ; } } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( max [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int i , j ; int [ ] mountain = new int [ 10 ] ; for ( i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mountain ) ; System . out . println ( mountain [ 9 ] ) ; System . out . println ( mountain [ 8 ] ) ; System . out . println ( mountain [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = scan . nextInt ( ) ; } for ( int j = 1 ; j < 10 ; j ++ ) { int k = j ; { while ( k >= 1 && a [ k ] > a [ k - 1 ] ) { int temp = a [ k - 1 ] ; a [ k - 1 ] = a [ k ] ; a [ k ] = temp ; k -- ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m_count = 10 , ans_count = 3 ; int [ ] m = new int [ m_count ] ; int i ; for ( i = 0 ; i < m_count ; i ++ ) { m [ i ] = sc . nextInt ( ) ; } Arrays . sort ( m ) ; int t = 0 ; for ( i = 0 ; i < m_count / 2 ; i ++ ) { t = m [ i ] ; m [ i ] = m [ m_count - i - 1 ] ; m [ m_count - i - 1 ] = t ; } for ( i = 0 ; i < ans_count ; i ++ ) { System . out . println ( m [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { private static int [ ] x ; private static int [ ] top = { 0 , 0 , 0 } ; public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; x = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { x [ i ] = Integer . parseInt ( br . readLine ( ) ) ; if ( x [ i ] > top [ 0 ] ) { top [ 2 ] = top [ 1 ] ; top [ 1 ] = top [ 0 ] ; top [ 0 ] = x [ i ] ; } else if ( x [ i ] > top [ 1 ] ) { top [ 2 ] = top [ 1 ] ; top [ 1 ] = x [ i ] ; } else if ( x [ i ] > top [ 2 ] ) { top [ 2 ] = x [ i ] ; } } System . out . println ( top [ 0 ] ) ; System . out . println ( top [ 1 ] ) ; System . out . println ( top [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { int [ ] is = new int [ 10 ] ; BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; ++ i ) { String c = r . readLine ( ) ; is [ i ] = Integer . parseInt ( c ) ; } java . util . Arrays . sort ( is ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( is [ is . length - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; for ( int i = 0 ; i <= 2 ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { private static int top3 [ ] ; public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; top3 = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int h = Integer . parseInt ( br . readLine ( ) ) ; if ( top3 [ 0 ] < h ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = top3 [ 0 ] ; top3 [ 0 ] = h ; } else if ( top3 [ 1 ] < h ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = h ; } else if ( top3 [ 2 ] < h ) { top3 [ 2 ] = h ; } } for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( top3 [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { private static int [ ] data = new int [ 10 ] ; public static void main ( String ... args ) { BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { for ( int i = 0 ; i < 10 ; i ++ ) { data [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } } catch ( IOException e ) { } Arrays . sort ( data ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( data [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int i , k ; int a [ ] ; a = new int [ 10 ] ; a [ 0 ] = in . nextInt ( ) ; for ( i = 1 ; i < 10 ; i ++ ) { a [ i ] = in . nextInt ( ) ; if ( a [ 0 ] < a [ i ] ) { k = a [ i ] ; a [ i ] = a [ 0 ] ; a [ 0 ] = k ; } } System . out . println ( a [ 0 ] ) ; for ( i = 1 ; i < 10 ; i ++ ) { if ( a [ 1 ] < a [ i ] ) { k = a [ i ] ; a [ i ] = a [ 1 ] ; a [ 1 ] = k ; } } System . out . println ( a [ 1 ] ) ; for ( i = 2 ; i < 10 ; i ++ ) { if ( a [ 2 ] < a [ i ] ) { k = a [ i ] ; a [ i ] = a [ 2 ] ; a [ 2 ] = k ; } } System . out . println ( a [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] values = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { values [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( values ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( values [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > heights = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { heights . add ( sc . nextInt ( ) ) ; } Collections . sort ( heights ) ; Collections . reverse ( heights ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class aoj0001 { public void solve ( ) { int [ ] list = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) list [ i ] = sc . nextInt ( ) ; Arrays . sort ( list ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( list [ 9 - i ] ) ; } } class Main { public static void main ( String ... args ) { new aoj0001 ( ) . solve ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n [ ] = new int [ 10 ] ; int a = 0 ; int b = 0 ; int c = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { n [ i ] = sc . nextInt ( ) ; if ( a <= n [ i ] ) { c = b ; b = a ; a = n [ i ] ; } else if ( b <= n [ i ] ) { c = b ; b = n [ i ] ; } else if ( c <= n [ i ] ) { c = n [ i ] ; } } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanf = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; int x , i , k , j ; for ( i = 0 ; i < 10 ; i ++ ) a [ i ] = scanf . nextInt ( ) ; for ( j = 9 ; j > 0 ; j -- ) for ( k = 0 ; k < j ; k ++ ) if ( a [ k ] > a [ k + 1 ] ) { x = a [ k ] ; a [ k ] = a [ k + 1 ] ; a [ k + 1 ] = x ; } System . out . println ( a [ 9 ] + \" \\n \" + a [ 8 ] + \" \\n \" + a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; class Main { public static void main ( String args [ ] ) { try { int [ ] mountain = new int [ 10 ] ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { mountain [ i ] = Integer . parseInt ( br . readLine ( ) ) ; } Arrays . sort ( mountain ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( mountain [ i ] ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } finally { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int max = 10 , temp ; int mountain [ ] = new int [ max ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < max ; i ++ ) mountain [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < max ; i ++ ) { for ( int j = max - 1 ; j > i ; j -- ) { if ( mountain [ j - 1 ] > mountain [ j ] ) { temp = mountain [ j - 1 ] ; mountain [ j - 1 ] = mountain [ j ] ; mountain [ j ] = temp ; } } } for ( int i = max - 1 ; i >= max - 3 ; i -- ) System . out . println ( mountain [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int [ ] top3 = new int [ 3 ] ; while ( ( line = r . readLine ( ) ) != null ) { int val = Integer . parseInt ( line ) ; if ( top3 [ 0 ] <= val ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = top3 [ 0 ] ; top3 [ 0 ] = val ; } else if ( top3 [ 1 ] <= val ) { top3 [ 2 ] = top3 [ 1 ] ; top3 [ 1 ] = val ; } else if ( top3 [ 2 ] <= val ) { top3 [ 2 ] = val ; } } for ( int t : top3 ) { System . out . println ( t ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; class Main { public static void main ( String [ ] args ) throws IOException { java . io . BufferedReader in = new java . io . BufferedReader ( new java . io . InputStreamReader ( System . in ) ) ; int top3 [ ] = new int [ ] { 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { int height = Integer . parseInt ( in . readLine ( ) ) ; for ( int j = 2 ; j >= 0 ; j -- ) { if ( height > top3 [ j ] ) { top3 [ j + 1 ] = top3 [ j ] ; top3 [ j ] = height ; } else { break ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( top3 [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] t = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { t [ i ] = sc . nextInt ( ) ; } Arrays . sort ( t ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] hills = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 9 ; j > i ; j -- ) { if ( hills [ j ] < hills [ j - 1 ] ) { int box = hills [ j ] ; hills [ j ] = hills [ j - 1 ] ; hills [ j - 1 ] = box ; } } } for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( hills [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] n = new int [ 10 ] ; for ( int i = 0 ; i < n . length ; i ++ ) { n [ i ] = sc . nextInt ( ) ; } Arrays . sort ( n ) ; for ( int j = 9 ; j > 6 ; j -- ) { System . out . println ( n [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] inputs = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { inputs [ i ] = s . nextInt ( ) ; } Arrays . sort ( inputs ) ; System . out . println ( inputs [ 9 ] ) ; System . out . println ( inputs [ 8 ] ) ; System . out . println ( inputs [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; System . out . println ( a [ 9 ] ) ; System . out . println ( a [ 8 ] ) ; System . out . println ( a [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; short temp [ ] = new short [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { short num = scan . nextShort ( ) ; if ( temp [ 0 ] < num ) { temp [ 2 ] = temp [ 1 ] ; temp [ 1 ] = temp [ 0 ] ; temp [ 0 ] = num ; continue ; } if ( temp [ 1 ] < num ) { temp [ 2 ] = temp [ 1 ] ; temp [ 1 ] = num ; continue ; } if ( temp [ 2 ] < num ) { temp [ 2 ] = num ; continue ; } } for ( short i = 0 ; i < 3 ; i ++ ) { System . out . println ( temp [ i ] ) ; } scan . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int N = in . nextInt ( ) ; a [ i ] = N ; } Arrays . sort ( a ) ; for ( int i = a . length - 1 ; i > a . length - 4 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] x = new int [ 10 ] ; int temp ; for ( int i = 0 ; i < x . length ; i ++ ) { x [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < x . length ; i ++ ) { for ( int j = 0 ; j < x . length ; j ++ ) { if ( x [ i ] > x [ j ] ) { temp = x [ i ] ; x [ i ] = x [ j ] ; x [ j ] = temp ; } } } System . out . println ( x [ 0 ] ) ; System . out . println ( x [ 1 ] ) ; System . out . println ( x [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] hight_list = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hight_list [ i ] = sc . nextInt ( ) ; } Arrays . sort ( hight_list ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( hight_list [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { static void swap ( int [ ] a , int idx1 , int idx2 ) { int t = a [ idx1 ] ; a [ idx1 ] = a [ idx2 ] ; a [ idx2 ] = t ; } static void quickSort ( int [ ] a , int left , int right ) { int pl = left ; int pr = right ; int x = a [ ( pl + pr ) / 2 ] ; do { while ( a [ pl ] < x ) { pl ++ ; } while ( a [ pr ] > x ) { pr -- ; } if ( pl <= pr ) { swap ( a , pl ++ , pr -- ) ; } } while ( pl <= pr ) ; if ( left < pr ) { quickSort ( a , left , pr ) ; } if ( pl < right ) { quickSort ( a , pl , right ) ; } } public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] hill = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hill [ i ] = scan . nextInt ( ) ; } quickSort ( hill , 0 , 9 ) ; System . out . println ( hill [ 9 ] ) ; System . out . println ( hill [ 8 ] ) ; System . out . println ( hill [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Integer [ ] ary = new Integer [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < ary . length ; ++ i ) { ary [ i ] = sc . nextInt ( ) ; } Arrays . sort ( ary ) ; System . out . println ( ary [ 9 ] ) ; System . out . println ( ary [ 8 ] ) ; System . out . println ( ary [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; Integer [ ] ary = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { ary [ i ] = scan . nextInt ( ) ; } int max1 = 0 , max2 = 0 , max3 = 0 , temp = 0 ; for ( int height : ary ) { if ( max3 < height ) { if ( max2 < height ) { if ( max1 < height ) { max3 = max2 ; max2 = max1 ; max1 = height ; } else { max3 = max2 ; max2 = height ; } } else { max3 = height ; } } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; Integer [ ] ary = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { ary [ i ] = scan . nextInt ( ) ; } int max1 = 0 , max2 = 0 , max3 = 0 , temp = 0 ; for ( int height : ary ) { if ( max3 < height ) { if ( max2 < height ) { if ( max1 < height ) { max3 = max2 ; max2 = max1 ; max1 = height ; } else { max3 = max2 ; max2 = height ; } } else { max3 = height ; } } } System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] s = new String [ 10 ] ; int [ ] n = new int [ 10 ] ; try { for ( int i = 0 ; i < 10 ; i ++ ) { s [ i ] = reader . readLine ( ) ; n [ i ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( n ) ; System . out . println ( n [ 9 ] ) ; System . out . println ( n [ 8 ] ) ; System . out . println ( n [ 7 ] ) ; } catch ( IOException e ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = br . readLine ( ) ; int input = Integer . parseInt ( str ) ; if ( input > a ) { c = b ; b = a ; a = input ; continue ; } if ( input > b ) { c = b ; b = input ; continue ; } if ( input > c ) { c = input ; continue ; } } System . out . println ( a ) ; System . out . println ( b ) ; System . out . println ( c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int [ ] hills = new int [ 10 ] ; Scanner scanner = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { hills [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( hills ) ; printListOfTop3Hills ( hills ) ; } public static void printListOfTop3Hills ( int [ ] hills ) { for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( hills [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner scanner = new Scanner ( System . in ) ; int hei [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { hei [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( hei ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hei [ 9 - i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { List < Integer > values = new ArrayList < > ( ) ; Scanner scanner = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { values . add ( Integer . parseInt ( scanner . nextLine ( ) ) ) ; } values . sort ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( values . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = s . nextInt ( ) ; Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; List < String > list = new ArrayList < > ( ) ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { list . add ( line ) ; } list . stream ( ) . map ( Integer :: parseInt ) . sorted ( Comparator . reverseOrder ( ) ) . limit ( 3 ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int mount [ ] = new int [ 10 ] ; for ( int i = 0 ; i < mount . length ; i ++ ) mount [ i ] = input . nextInt ( ) ; Arrays . sort ( mount ) ; int max1 = mount [ mount . length - 1 ] ; int max2 = mount [ mount . length - 2 ] ; int max3 = mount [ mount . length - 3 ] ; System . out . println ( max1 ) ; System . out . println ( max2 ) ; System . out . println ( max3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ 9 ] ) ; System . out . println ( arr [ 8 ] ) ; System . out . println ( arr [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Integer M [ ] = new Integer [ 10 ] ; for ( int i = 0 ; i < M . length ; i ++ ) { M [ i ] = sc . nextInt ( ) ; } Arrays . sort ( M , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( M [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; int array [ ] = new int [ 10 ] ; int cnt = 0 ; while ( cnt < 10 ) { int num = scanner . nextInt ( ) ; array [ cnt ] = num ; cnt ++ ; } scanner . close ( ) ; for ( int i = 0 ; i < array . length - 1 ; i ++ ) { for ( int j = 0 ; j < array . length - 1 ; j ++ ) { if ( array [ j ] < array [ j + 1 ] ) { int max = array [ j ] ; array [ j ] = array [ j + 1 ] ; array [ j + 1 ] = max ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( array [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int kari ; Scanner scan = new Scanner ( System . in ) ; int [ ] taller = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { taller [ i ] = 0 ; } for ( int i = 0 ; i < 10 ; i ++ ) { int tall = scan . nextInt ( ) ; if ( taller [ 2 ] <= tall ) { taller [ 2 ] = tall ; if ( taller [ 1 ] <= taller [ 2 ] ) { kari = taller [ 2 ] ; taller [ 2 ] = taller [ 1 ] ; taller [ 1 ] = kari ; if ( taller [ 0 ] <= taller [ 1 ] ) { kari = taller [ 1 ] ; taller [ 1 ] = taller [ 0 ] ; taller [ 0 ] = kari ; } } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( taller [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mtHight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mtHight [ i ] = sc . nextInt ( ) ; } Arrays . sort ( mtHight ) ; System . out . println ( mtHight [ 9 ] ) ; System . out . println ( mtHight [ 8 ] ) ; System . out . println ( mtHight [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int [ ] n = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { n [ i ] = sc . nextInt ( ) ; } Arrays . sort ( n ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( n [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int x [ ] = new int [ 10 ] ; int n ; for ( int i = 0 ; i < 10 ; i ++ ) x [ i ] = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = i ; j < 10 ; j ++ ) { if ( x [ i ] < x [ j ] ) { n = x [ i ] ; x [ i ] = x [ j ] ; x [ j ] = n ; } } } for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( x [ i ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { new Main ( ) . mainrun ( ) ; } private Scanner scan ; private int height [ ] ; private void mainrun ( ) { scan = new Scanner ( System . in ) ; height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = scan . nextInt ( ) ; } Arrays . sort ( height ) ; ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ height . length - i - 1 ] ) ; } scan . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] A = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; Arrays . sort ( A ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( A [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { List < Integer > heights = new ArrayList < > ( ) ; try ( Scanner sc = new Scanner ( System . in ) ; ) { for ( int i = 0 ; i < 10 ; i ++ ) { heights . add ( sc . nextInt ( ) ) ; } } heights . sort ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( heights . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner scanner = new Scanner ( System . in ) ; int N = 10 ; int M = 3 ; int height [ ] = new int [ N ] ; int ans [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { height [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int i = 1 ; i <= M ; i ++ ) { System . out . println ( height [ N - i ] ) ; } scanner . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int no1 = 0 ; int no2 = 0 ; int no3 = 0 ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String line = sc . nextLine ( ) ; int h = Integer . parseInt ( line ) ; if ( h > no1 ) { int a = no1 ; int b = no2 ; no2 = a ; no3 = b ; no1 = h ; continue ; } else if ( h > no2 ) { no3 = no2 ; no2 = h ; continue ; } else if ( h > no3 ) { no3 = h ; continue ; } } System . out . println ( no1 ) ; System . out . println ( no2 ) ; System . out . println ( no3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { static Scanner input = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = 10 ; PriorityQueue < Integer > pq = new PriorityQueue < > ( ( a , b ) -> ( b - a ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = input . nextInt ( ) ; pq . add ( x ) ; } input . close ( ) ; for ( int i = n - 1 ; i > 6 ; i -- ) { System . out . println ( pq . poll ( ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String args [ ] ) { ArrayList < Integer > HeightMountain = new ArrayList < > ( ) ; int height = 0 ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = null ; try { while ( ( line = input . readLine ( ) ) != null ) { height = Integer . valueOf ( line ) ; HeightMountain . add ( height ) ; } } catch ( NumberFormatException e ) { System . out . println ( line + \" \"); } catch ( I O x eptio e) { System o u . rintln ( \"  \"); } C ollections.sort ( H e g tMountain, C olle c tions.reverseO r er()); for( i nt i = 0; i < 3 ; i++ ) { y t m . u . r i t ln ( e ghtMou n tai n .get(i) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] a ) { Scanner sc = new Scanner ( System . in ) ; int [ ] mountainsHight = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountainsHight [ i ] = Integer . parseInt ( sc . next ( ) ) ; } Arrays . sort ( mountainsHight ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( mountainsHight [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Integer [ ] height = new Integer [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 20 ] ; int first = 15 , second = 15 , third = 15 ; height [ 15 ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; if ( height [ first ] < height [ i ] ) { third = second ; second = first ; first = i ; } else if ( height [ second ] < height [ i ] ) { third = second ; second = i ; } else if ( height [ third ] < height [ i ] ) third = i ; } System . out . println ( height [ first ] ) ; System . out . println ( height [ second ] ) ; System . out . println ( height [ third ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; public class Main { void solve ( FastScanner in , PrintWriter out , Methods ms ) { int [ ] a = in . nextIntArray ( 10 ) ; Arrays . sort ( a ) ; out . println ( a [ 9 ] ) ; out . println ( a [ 8 ] ) ; out . println ( a [ 7 ] ) ; } public static void main ( String [ ] args ) { Main main = new Main ( ) ; FastScanner in = new FastScanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; Methods ms = new Methods ( ) ; main . solve ( in , out , ms ) ; in . close ( ) ; out . close ( ) ; } static class Methods { public void print ( Object ... ar ) { System . out . println ( Arrays . deepToString ( ar ) ) ; } public void yesno ( PrintWriter out , boolean b ) { out . println ( b ? \" Yes \" : \" No \" ) ; } public void YESNO ( PrintWriter out , boolean b ) { out . println ( b ? \" YES \" : \" NO \" ) ; } public int max ( int ... ar ) { Arrays . sort ( ar ) ; return ar [ ar . length - 1 ] ; } public int min ( int ... ar ) { Arrays . sort ( ar ) ; return ar [ 0 ] ; } public long gcd ( long a , long b ) { return b > 0 ? gcd ( b , a % b ) : a ; } public long lcm ( long a , long b ) { return a / gcd ( a , b ) * b ; } public boolean isPrime ( int n ) { if ( n == 2 ) return true ; if ( n < 2 || n % 2 == 0 ) return false ; double d = Math . sqrt ( n ) ; for ( int i = 3 ; i <= d ; i += 2 ) if ( n % i == 0 ) { return false ; } return true ; } } static class FastScanner { private InputStream in ; private byte [ ] buffer = new byte [ 1024 ] ; private int length = 0 , p = 0 ; public FastScanner ( InputStream stream ) { in = stream ; } public boolean hasNextByte ( ) { if ( p < length ) return true ; else { p = 0 ; try { length = in . read ( buffer ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( length <= 0 ) return false ; } return true ; } public int readByte ( ) { if ( hasNextByte ( ) == true ) return buffer [ p ++ ] ; return - 1 ; } public boolean isPrintable ( int n ) { return 33 <= n && n <= 126 ; } public void skip ( ) { while ( hasNextByte ( ) && ! isPrintable ( buffer [ p ] ) ) p ++ ; } public boolean hasNext ( ) { skip ( ) ; return hasNextByte ( ) ; } public String next ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; StringBuilder sb = new StringBuilder ( ) ; int t = readByte ( ) ; while ( isPrintable ( t ) ) { sb . appendCodePoint ( t ) ; t = readByte ( ) ; } return sb . toString ( ) ; } public String [ ] nextArray ( int n ) { String [ ] ar = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ar [ i ] = next ( ) ; return ar ; } public int nextInt ( ) { return Math . toIntExact ( nextLong ( ) ) ; } public int [ ] nextIntArray ( int n ) { int [ ] ar = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ar [ i ] = nextInt ( ) ; return ar ; } public long nextLong ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; boolean minus = false ; int temp = readByte ( ) ; if ( temp == '-' ) { minus = true ; temp = readByte ( ) ; } if ( temp < '0' || '9' < temp ) throw new NumberFormatException ( ) ; long n = 0 ; while ( isPrintable ( temp ) ) { if ( '0' <= temp && temp <= '9' ) { n *= 10 ; n += temp - '0' ; } else throw new NumberFormatException ( ) ; temp = readByte ( ) ; } return minus ? - n : n ; } public long [ ] nextLongArray ( int n ) { long [ ] ar = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ar [ i ] = nextLong ( ) ; return ar ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public double [ ] nextDoubleArray ( int n ) { double [ ] ar = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ar [ i ] = nextDouble ( ) ; return ar ; } public void close ( ) { try { in . close ( ) ; } catch ( Exception e ) { } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Long > height = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { String str = br . readLine ( ) ; height . add ( Long . valueOf ( str ) ) ; } Collections . sort ( height , new Comparator < Long > ( ) { @ Override public int compare ( Long o1 , Long o2 ) { int ret = 0 ; if ( o1 > o2 ) { ret = - 1 ; } else if ( o1 < 02 ) { ret = 1 ; } return ret ; } } ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( height . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void run ( ) { Scanner scan = new Scanner ( System . in ) ; int [ ] inputArray = new int [ 10 ] ; int [ ] outputArray = new int [ 3 ] ; for ( int i = 0 ; i < 10 ; i ++ ) inputArray [ i ] = scan . nextInt ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int max = 0 ; int max_j = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { int tmp = inputArray [ j ] ; if ( max < tmp ) { max = tmp ; max_j = j ; } } outputArray [ i ] = max ; inputArray [ max_j ] = 0 ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( outputArray [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Integer [ ] ary = new Integer [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < ary . length ; ++ i ) { ary [ i ] = sc . nextInt ( ) ; } Arrays . sort ( ary ) ; System . out . println ( ary [ 9 ] ) ; System . out . println ( ary [ 8 ] ) ; System . out . println ( ary [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner a = new Scanner ( System . in ) ; int [ ] lst = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { lst [ i ] = a . nextInt ( ) ; } Arrays . sort ( lst ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . println ( lst [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int i ; int [ ] mountain ; int escape = 0 ; mountain = new int [ 10 ] ; for ( i = 0 ; i < 10 ; i ++ ) mountain [ i ] = Integer . parseInt ( br . readLine ( ) ) ; for ( int a = 0 ; a < 9 ; a ++ ) { for ( int b = a + 1 ; b < 10 ; b ++ ) { if ( mountain [ a ] < mountain [ b ] ) { escape = mountain [ b ] ; mountain [ b ] = mountain [ a ] ; mountain [ a ] = escape ; } } } System . out . println ( mountain [ 0 ] ) ; System . out . println ( mountain [ 1 ] ) ; System . out . println ( mountain [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] height = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = sc . nextInt ( ) ; } Arrays . sort ( height ) ; for ( int i = 9 ; i >= 7 ; i -- ) { System . out . println ( height [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int height [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = stdIn . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; stdIn . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( System . in ) ; int [ ] list = new int [ 3 ] ; int x ; for ( int i = 0 ; i < 10 ; i ++ ) { x = s . nextInt ( ) ; fun ( x , list ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( list [ i ] ) ; } } static int [ ] fun ( int x , int [ ] z ) { if ( z [ 0 ] < x ) { z [ 2 ] = z [ 1 ] ; z [ 1 ] = z [ 0 ] ; z [ 0 ] = x ; } else if ( z [ 1 ] < x ) { z [ 2 ] = z [ 1 ] ; z [ 1 ] = x ; } else if ( z [ 2 ] < x ) { z [ 2 ] = x ; } return z ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int a [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i >= 7 ; i -- ) System . out . println ( a [ i ] ) ; in . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int top1 = 0 ; int top2 = 0 ; int top3 = 0 ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( a [ i ] > top1 ) { top1 = a [ i ] ; num1 = i ; } } for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == num1 ) { continue ; } else if ( a [ i ] > top2 ) { top2 = a [ i ] ; num2 = i ; } } for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == num1 || i == num2 ) { continue ; } else if ( a [ i ] > top3 ) { top3 = a [ i ] ; } } System . out . println ( top1 ) ; System . out . println ( top2 ) ; System . out . println ( top3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] = sc . nextInt ( ) ; array = mergeSort ( array ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( array [ i ] ) ; } public static int [ ] mergeSort ( int [ ] array ) { if ( array . length <= 1 ) return array ; int [ ] head = split ( array , 0 , array . length / 2 ) ; int [ ] tail = split ( array , array . length / 2 , array . length ) ; return merge ( mergeSort ( head ) , mergeSort ( tail ) ) ; } private static int [ ] split ( int [ ] array , int start , int end ) { int [ ] newArray = new int [ end - start ] ; for ( int i = start , j = 0 ; i < end ; i ++ , j ++ ) newArray [ j ] = array [ i ] ; return newArray ; } private static int [ ] merge ( int [ ] a , int [ ] b ) { int [ ] merged = new int [ a . length + b . length ] ; for ( int i = 0 , j = 0 , k = 0 ; i < a . length + b . length ; i ++ ) { if ( j == a . length || k == b . length ) merged [ i ] = ( j == a . length ? b [ k ++ ] : a [ j ++ ] ) ; else merged [ i ] = ( a [ j ] > b [ k ] ? a [ j ++ ] : b [ k ++ ] ) ; } return merged ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int [ ] array ; public static void main ( String [ ] args ) { read ( ) ; solve ( ) ; } static void read ( ) { array = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } } static void solve ( ) { Arrays . sort ( array ) ; System . out . println ( array [ 9 ] ) ; System . out . println ( array [ 8 ] ) ; System . out . println ( array [ 7 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Toi junbi = new Junbi2 ( ) ; junbi . solve ( ) ; } } interface Toi { public void solve ( ) ; } class Junbi1 implements Toi { public void solve ( ) { for ( int i = 1 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 9 ; j ++ ) { System . out . println ( i + \" x \" + j + \" = \" + i * j ) ; } } } } class Junbi2 implements Toi { public void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } Arrays . sort ( array ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( array [ array . length - ( i + 1 ) ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Integer [ ] h = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; ++ i ) { h [ i ] = sc . nextInt ( ) ; } Arrays . sort ( h , Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( h [ i ] ) ; } sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; List < Integer > A = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) A . add ( in . nextInt ( ) ) ; Collections . sort ( A , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . println ( A . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int mountainArray [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountainArray [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( mountainArray [ i ] < mountainArray [ j ] ) { int temp = mountainArray [ i ] ; mountainArray [ i ] = mountainArray [ j ] ; mountainArray [ j ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountainArray [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { int [ ] a = new int [ 10 ] ; Scanner sc = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = Integer . parseInt ( sc . next ( ) ) ; } Arrays . sort ( a ) ; for ( int i = 9 ; i > 6 ; i -- ) { System . out . printf ( \" %d \\n \" , a [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int temp ; int [ ] height = new int [ 10 ] ; Scanner cin = new Scanner ( System . in ) ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = cin . nextInt ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { if ( height [ i ] < height [ j ] ) { temp = height [ i ] ; height [ i ] = height [ j ] ; height [ j ] = temp ; } } } System . out . println ( height [ 0 ] ) ; System . out . println ( height [ 1 ] ) ; System . out . println ( height [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t [ ] = new int [ 10 ] ; t [ 0 ] = scan . nextInt ( ) ; t [ 1 ] = scan . nextInt ( ) ; t [ 2 ] = scan . nextInt ( ) ; t [ 3 ] = scan . nextInt ( ) ; t [ 4 ] = scan . nextInt ( ) ; t [ 5 ] = scan . nextInt ( ) ; t [ 6 ] = scan . nextInt ( ) ; t [ 7 ] = scan . nextInt ( ) ; t [ 8 ] = scan . nextInt ( ) ; t [ 9 ] = scan . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 - i ; j ++ ) { if ( t [ j ] < t [ j + 1 ] ) { int temp = t [ j ] ; t [ j ] = t [ j + 1 ] ; t [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t [ ] = new int [ 10 ] ; t [ 0 ] = scan . nextInt ( ) ; t [ 1 ] = scan . nextInt ( ) ; t [ 2 ] = scan . nextInt ( ) ; t [ 3 ] = scan . nextInt ( ) ; t [ 4 ] = scan . nextInt ( ) ; t [ 5 ] = scan . nextInt ( ) ; t [ 6 ] = scan . nextInt ( ) ; t [ 7 ] = scan . nextInt ( ) ; t [ 8 ] = scan . nextInt ( ) ; t [ 9 ] = scan . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 - i ; j ++ ) { if ( t [ j ] < t [ j + 1 ] ) { int temp = t [ j ] ; t [ j ] = t [ j + 1 ] ; t [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { t [ i ] = scanner . nextInt ( ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 - i ; j ++ ) { if ( t [ j ] < t [ j + 1 ] ) { int temp = t [ j ] ; t [ j ] = t [ j + 1 ] ; t [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t [ ] = new int [ 10 ] ; t [ 0 ] = scan . nextInt ( ) ; t [ 1 ] = scan . nextInt ( ) ; t [ 2 ] = scan . nextInt ( ) ; t [ 3 ] = scan . nextInt ( ) ; t [ 4 ] = scan . nextInt ( ) ; t [ 5 ] = scan . nextInt ( ) ; t [ 6 ] = scan . nextInt ( ) ; t [ 7 ] = scan . nextInt ( ) ; t [ 8 ] = scan . nextInt ( ) ; t [ 9 ] = scan . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 - i ; j ++ ) { if ( t [ j ] < t [ j + 1 ] ) { int temp = t [ j ] ; t [ j ] = t [ j + 1 ] ; t [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t [ ] = new int [ 10 ] ; t [ 0 ] = scan . nextInt ( ) ; t [ 1 ] = scan . nextInt ( ) ; t [ 2 ] = scan . nextInt ( ) ; t [ 3 ] = scan . nextInt ( ) ; t [ 4 ] = scan . nextInt ( ) ; t [ 5 ] = scan . nextInt ( ) ; t [ 6 ] = scan . nextInt ( ) ; t [ 7 ] = scan . nextInt ( ) ; t [ 8 ] = scan . nextInt ( ) ; t [ 9 ] = scan . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 - i ; j ++ ) { if ( t [ j ] < t [ j + 1 ] ) { int temp = t [ j ] ; t [ j ] = t [ j + 1 ] ; t [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t [ ] = new int [ 10 ] ; t [ 0 ] = scanner . nextInt ( ) ; t [ 1 ] = scanner . nextInt ( ) ; t [ 2 ] = scanner . nextInt ( ) ; t [ 3 ] = scanner . nextInt ( ) ; t [ 4 ] = scanner . nextInt ( ) ; t [ 5 ] = scanner . nextInt ( ) ; t [ 6 ] = scanner . nextInt ( ) ; t [ 7 ] = scanner . nextInt ( ) ; t [ 8 ] = scanner . nextInt ( ) ; t [ 9 ] = scanner . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 - i ; j ++ ) { if ( t [ j ] < t [ j + 1 ] ) { int temp = t [ j ] ; t [ j ] = t [ j + 1 ] ; t [ j + 1 ] = temp ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( t [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { new Main ( ) . compute ( ) ; } void compute ( ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > heights = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { heights . add ( sc . nextInt ( ) ) ; } heights . sort ( ( o1 , o2 ) -> o2 - o1 ) ; System . out . println ( heights . get ( 0 ) ) ; System . out . println ( heights . get ( 1 ) ) ; System . out . println ( heights . get ( 2 ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; import java . util . Collections ; class Main { public static void main ( String [ ] a ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer [ ] mountains = new Integer [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { mountains [ i ] = Integer . valueOf ( br . readLine ( ) ) ; } Arrays . sort ( mountains , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( mountains [ i ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; List < Integer > al = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int a = sc . nextInt ( ) ; al . add ( a ) ; } Collections . sort ( al ) ; for ( int j = 0 ; j < 3 ; j ++ ) { System . out . println ( al . get ( 9 - j ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String a [ ] ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; System . out . println ( isRightTriangle ( b , c , d ) ) ; } sc . close ( ) ; } public static String isRightTriangle ( int a , int b , int c ) { if ( a > b ) { int k = a ; a = b ; b = k ; } if ( b > c ) { int k = b ; b = c ; c = k ; } if ( c * c == a * a + b * b ) return \" YES \" ; else return \" NO \" ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String lineCountStr = br . readLine ( ) ; for ( int lineCount = 0 ; lineCount < Integer . parseInt ( lineCountStr ) ; lineCount ++ ) { String [ ] dataSetStr = br . readLine ( ) . split ( \" \" ) ; int [ ] dataSet = new int [ dataSetStr . length ] ; for ( int i = 0 ; i < dataSetStr . length ; i ++ ) { dataSet [ i ] = Integer . parseInt ( dataSetStr [ i ] ) ; } if ( dataSet [ 0 ] > dataSet [ 1 ] ) { int tmp = dataSet [ 0 ] ; dataSet [ 0 ] = dataSet [ 1 ] ; dataSet [ 1 ] = tmp ; } if ( dataSet [ 1 ] > dataSet [ 2 ] ) { int tmp = dataSet [ 1 ] ; dataSet [ 1 ] = dataSet [ 2 ] ; dataSet [ 2 ] = tmp ; } if ( Math . pow ( dataSet [ 0 ] , 2 ) + Math . pow ( dataSet [ 1 ] , 2 ) == Math . pow ( dataSet [ 2 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int num = scan . nextInt ( ) ; int i , maxSide ; int [ ] side = new int [ 3 ] ; for ( i = 0 ; i < num ; i ++ ) { side [ 0 ] = scan . nextInt ( ) ; side [ 1 ] = scan . nextInt ( ) ; side [ 2 ] = scan . nextInt ( ) ; maxSide = Math . max ( side [ 0 ] , side [ 1 ] ) ; maxSide = Math . max ( maxSide , side [ 2 ] ) ; if ( maxSide == side [ 0 ] ) { if ( side [ 0 ] * side [ 0 ] == side [ 1 ] * side [ 1 ] + side [ 2 ] * side [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( maxSide == side [ 1 ] ) { if ( side [ 1 ] * side [ 1 ] == side [ 0 ] * side [ 0 ] + side [ 2 ] * side [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else { if ( side [ 2 ] * side [ 2 ] == side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; int i , a , b , c ; for ( i = 0 ; i < num ; i ++ ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; c = sc . nextInt ( ) ; if ( a * a == ( ( b * b ) + ( c * c ) ) || b * b == ( ( a * a ) + ( c * c ) ) || c * c == ( ( a * a ) + ( b * b ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String s = reader . readLine ( ) ; int n = Integer . parseInt ( s ) ; for ( int j = 0 ; j < n ; j ++ ) { s = reader . readLine ( ) ; String t [ ] = s . split ( \" \" ) ; int [ ] in = new int [ t . length ] ; for ( int i = 0 ; i < t . length ; i ++ ) in [ i ] = Integer . parseInt ( t [ i ] ) ; Arrays . sort ( in ) ; String ans ; if ( in [ 0 ] * in [ 0 ] + in [ 1 ] * in [ 1 ] == in [ 2 ] * in [ 2 ] ) ans = \" YES \" ; else ans = \" NO \" ; System . out . println ( ans ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String args [ ] ) throws IOException { String str ; String [ ] dataSet ; int dataSet_Number ; double a , b , c , i ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; dataSet_Number = Integer . parseInt ( input . readLine ( ) ) ; for ( i = 0 ; i < dataSet_Number ; i ++ ) { str = input . readLine ( ) ; dataSet = str . split ( \" \" ) ; a = Math . pow ( Double . parseDouble ( dataSet [ 0 ] ) , 2 ) ; b = Math . pow ( Double . parseDouble ( dataSet [ 1 ] ) , 2 ) ; c = Math . pow ( Double . parseDouble ( dataSet [ 2 ] ) , 2 ) ; if ( ( a + b ) == c || ( b + c ) == a || ( a + c ) == b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = \" \" ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { int N = Integer . parseInt ( line ) ; next : for ( int i = 0 ; i < N ; i ++ ) { int [ ] num = new int [ 3 ] ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; num [ 0 ] = Integer . parseInt ( st . nextToken ( ) ) ; num [ 1 ] = Integer . parseInt ( st . nextToken ( ) ) ; num [ 2 ] = Integer . parseInt ( st . nextToken ( ) ) ; num [ 0 ] *= num [ 0 ] ; num [ 1 ] *= num [ 1 ] ; num [ 2 ] *= num [ 2 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( num [ j % 3 ] == num [ ( j + 1 ) % 3 ] + num [ ( j + 2 ) % 3 ] ) { System . out . println ( \" YES \" ) ; continue next ; } } System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; while ( num -- > 0 ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) , c = sc . nextInt ( ) ; if ( a == 0 && b == 0 && c == 0 ) break ; double [ ] set = new double [ 3 ] ; set [ 0 ] = a ; set [ 1 ] = b ; set [ 2 ] = c ; Arrays . sort ( set ) ; boolean boo = false ; if ( set [ 0 ] == set [ 1 ] && set [ 0 ] * Math . sqrt ( 2 ) == set [ 2 ] ) boo = true ; if ( set [ 0 ] * Math . sqrt ( 3 ) == set [ 1 ] && set [ 0 ] * 2 == set [ 2 ] ) boo = true ; for ( int i = 1 ; i <= set [ 2 ] ; i ++ ) { if ( set [ 0 ] / i == 3 && set [ 1 ] / i == 4 && set [ 2 ] / i == 5 ) boo = true ; if ( set [ 0 ] / i == 5 && set [ 1 ] / i == 12 && set [ 2 ] / i == 13 ) boo = true ; } if ( boo ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; boolean yes = false ; for ( int i = 0 ; i < n ; i ++ ) { yes = false ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; if ( ( ( x * x ) + ( y * y ) ) == ( z * z ) ) yes = true ; else if ( ( ( z * z ) + ( y * y ) ) == ( x * x ) ) yes = true ; else if ( ( ( x * x ) + ( z * z ) ) == ( y * y ) ) yes = true ; if ( yes ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } Scanner sc = new Scanner ( System . in ) ; int a , b , c ; void run ( ) { int n = sc . nextInt ( ) ; while ( n -- > 0 ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; c = sc . nextInt ( ) ; a = a * a ; b = b * b ; c = c * c ; if ( a == ( b + c ) || b == ( a + c ) || c == ( a + b ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; for ( int i = sc . nextInt ( ) ; i > 0 ; i -- ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a * a == ( b * b + c * c ) || b * b == ( a * a + c * c ) || c * c == ( a * a + b * b ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; for ( int i = sc . nextInt ( ) ; i > 0 ; i -- ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a * a == ( b * b + c * c ) || b * b == ( a * a + c * c ) || c * c == ( a * a + b * b ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . IOException ; import java . lang . Exception ; import java . lang . Integer ; import java . lang . String ; import java . lang . System ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] a ) throws IOException { java . io . BufferedReader r = new java . io . BufferedReader ( new java . io . InputStreamReader ( System . in ) ) ; try { int count = Integer . parseInt ( r . readLine ( ) ) ; String [ ] ans = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { String s = r . readLine ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; int num [ ] = new int [ 4 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { num [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; if ( num [ 0 ] < num [ j ] ) { int tmp = num [ 0 ] ; num [ 0 ] = num [ j ] ; num [ j ] = tmp ; } } if ( num [ 0 ] * num [ 0 ] == num [ 1 ] * num [ 1 ] + num [ 2 ] * num [ 2 ] ) { ans [ i ] = \" YES \" ; } else { ans [ i ] = \" NO \" ; } } for ( int i = 0 ; i < count ; i ++ ) { System . out . println ( ans [ i ] ) ; } } catch ( Exception ex ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; System . out . println ( isRightTriangle ( a , b , c ) ? \" YES \" : \" NO \" ) ; } } public static boolean isRightTriangle ( int a , int b , int c ) { int [ ] x = new int [ 3 ] ; x [ 0 ] = a ; x [ 1 ] = b ; x [ 2 ] = c ; Arrays . sort ( x ) ; return x [ 0 ] * x [ 0 ] + x [ 1 ] * x [ 1 ] == x [ 2 ] * x [ 2 ] ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . lang . Exception ; import java . lang . Integer ; import java . lang . System ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] a ) { try { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( r . readLine ( ) ) ; StringTokenizer st ; int side [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { st = new StringTokenizer ( r . readLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { side [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } Arrays . sort ( side ) ; if ( ( side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) == side [ 2 ] * side [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( Exception ex ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . Exception ; import java . lang . Integer ; import java . lang . System ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( r . readLine ( ) ) ; StringTokenizer st ; int side [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { st = new StringTokenizer ( r . readLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { side [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } Arrays . sort ( side ) ; if ( ( side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) == side [ 2 ] * side [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int j = 0 ; j < n ; j ++ ) { int tri [ ] = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { tri [ i ] = sc . nextInt ( ) ; tri [ i ] *= tri [ i ] ; } Arrays . sort ( tri ) ; if ( tri [ 0 ] + tri [ 1 ] == tri [ 2 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int dataset ; int [ ] data = new int [ 3 ] ; Scanner scanner = new Scanner ( System . in ) ; dataset = scanner . nextInt ( ) ; for ( int i = 0 ; i < dataset ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { data [ j ] = scanner . nextInt ( ) ; } Arrays . sort ( data ) ; if ( data [ 2 ] * data [ 2 ] == ( data [ 0 ] * data [ 0 ] + data [ 1 ] * data [ 1 ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import static java . lang . Math . pow ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int numOfDataset = Integer . parseInt ( reader . readLine ( ) ) ; for ( int i = 0 ; i < numOfDataset ; i ++ ) { String [ ] sideLengths_Str = reader . readLine ( ) . split ( \" \" ) ; int [ ] sideLengths = new int [ sideLengths_Str . length ] ; for ( int j = 0 ; j < sideLengths_Str . length ; j ++ ) sideLengths [ j ] = Integer . parseInt ( sideLengths_Str [ j ] ) ; Arrays . sort ( sideLengths ) ; if ( pow ( sideLengths [ 2 ] , 2 ) == pow ( sideLengths [ 1 ] , 2 ) + pow ( sideLengths [ 0 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] tri = new int [ 3 ] ; for ( ; n > 0 ; n -- ) { for ( int i = 0 ; i < 3 ; i ++ ) tri [ i ] = sc . nextInt ( ) ; Arrays . sort ( tri ) ; if ( tri [ 2 ] * tri [ 2 ] == tri [ 0 ] * tri [ 0 ] + tri [ 1 ] * tri [ 1 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = s . nextInt ( ) ; int b = s . nextInt ( ) ; int c = s . nextInt ( ) ; if ( ( a * a + b * b ) == c * c ) { System . out . println ( \" YES \" ) ; } else if ( ( b * b + c * c ) == a * a ) { System . out . println ( \" YES \" ) ; } else if ( ( c * c + a * a ) == b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] es = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) es [ j ] = in . nextInt ( ) ; Arrays . sort ( es ) ; if ( sq ( es [ 0 ] ) + sq ( es [ 1 ] ) == sq ( es [ 2 ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } static int sq ( int x ) { return x * x ; } ; }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] a ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int [ ] inputs = new int [ 3 ] ; String result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int m = s . nextInt ( ) ; inputs [ j ] = m * m ; } Arrays . sort ( inputs ) ; result = inputs [ 0 ] + inputs [ 1 ] == inputs [ 2 ] ? \" YES \" : \" NO \" ; System . out . println ( result ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n , s = 0 ; String [ ] str ; long [ ] hen = new long [ 3 ] ; n = Integer . parseInt ( br . readLine ( ) ) ; StringBuilder out = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { str = br . readLine ( ) . split ( \" \" ) ; long max = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { hen [ j ] = Integer . parseInt ( str [ j ] ) ; if ( max < hen [ j ] ) { max = hen [ j ] ; s = j ; } } hen [ s ] = 0 ; if ( max * max == hen [ 0 ] * hen [ 0 ] + hen [ 1 ] * hen [ 1 ] + hen [ 2 ] * hen [ 2 ] ) { out . append ( \" YES \" + \" \\n \" ) ; } else out . append ( \" NO \" + \" \\n \" ) ; } out . delete ( out . length ( ) - 1 , out . length ( ) ) ; System . out . println ( out ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] data = new int [ 3 ] ; while ( scan . hasNext ( ) ) { int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { data [ j ] = scan . nextInt ( ) ; } for ( int j = 0 ; j < 2 ; j ++ ) { for ( int k = j + 1 ; k < 3 ; k ++ ) { if ( data [ j ] < data [ k ] ) { int tmp ; tmp = data [ j ] ; data [ j ] = data [ k ] ; data [ k ] = tmp ; } } } if ( data [ 0 ] * data [ 0 ] == data [ 1 ] * data [ 1 ] + data [ 2 ] * data [ 2 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] array = sc . nextLine ( ) . split ( \" [ \\\\ s] \" ) ; int n1 = Integer . parseInt ( array [ 0 ] ) ; int n2 = Integer . parseInt ( array [ 1 ] ) ; int n3 = Integer . parseInt ( array [ 2 ] ) ; int swap = n3 ; if ( n1 < n2 && n3 < n2 ) { n3 = n2 ; n2 = swap ; } else if ( n2 < n1 && n3 < n1 ) { n3 = n1 ; n1 = swap ; } if ( ( n1 * n1 ) + ( n2 * n2 ) == ( n3 * n3 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int n = stdIn . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = stdIn . nextInt ( ) ; int b = stdIn . nextInt ( ) ; int c = stdIn . nextInt ( ) ; if ( a < b ) { if ( b < c ) { func ( c , a , b ) ; } else { func ( b , a , c ) ; } } else { if ( a < c ) { func ( c , a , b ) ; } else { func ( a , b , c ) ; } } } } static void func ( int a , int b , int c ) { if ( Math . pow ( a , 2 ) == ( Math . pow ( b , 2 ) + Math . pow ( c , 2 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . Stack ; import java . util . Scanner ; import java . util . Queue ; class Main { static final boolean DEBUG = false ; static Scanner sc = new Scanner ( new InputStreamReader ( System . in ) ) ; static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public static void main ( String args [ ] ) throws Exception { int n = parseInt ( readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int t [ ] = parseInt ( readLine ( ) . split ( \" \" ) ) ; Arrays . sort ( t ) ; t [ 0 ] *= t [ 0 ] ; t [ 1 ] *= t [ 1 ] ; t [ 2 ] *= t [ 2 ] ; if ( t [ 0 ] + t [ 1 ] == t [ 2 ] ) { p ( \" YES \" ) ; } else { p ( \" NO \" ) ; } } } public static String readLine ( ) throws IOException { return br . readLine ( ) ; } public static int readInt ( ) { return sc . nextInt ( ) ; } public static void pa ( Object [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void pa ( int [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void pa ( double [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void pa ( boolean [ ] arr ) { System . out . println ( Arrays . toString ( arr ) ) ; } public static void p ( Object o ) { System . out . println ( o . toString ( ) ) ; } public static void d ( Object o ) { if ( DEBUG ) System . out . println ( o . toString ( ) ) ; } public static void da ( int [ ] arr ) { if ( DEBUG ) System . out . println ( Arrays . toString ( arr ) ) ; } public static void sort ( int [ ] a ) { Arrays . sort ( a ) ; } public static int [ ] parseInt ( String [ ] arr ) { int [ ] res = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) res [ i ] = Integer . parseInt ( arr [ i ] ) ; return res ; } public static int parseInt ( Object o ) { return Integer . parseInt ( o . toString ( ) ) ; } public static int digit ( int n ) { return String . valueOf ( n ) . length ( ) ; } } class MyHashMap < E > extends HashMap < E , Integer > { ArrayList < E > keyArray = new ArrayList < E > ( ) ; public void add ( E key ) { add ( key , 1 ) ; } public void add ( E key , Integer value ) { if ( containsKey ( key ) ) { value += get ( key ) ; } else { keyArray . add ( key ) ; } put ( key , value ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( int T = sc . nextInt ( ) ; 0 < T ; T -- ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; a *= a ; b *= b ; c *= c ; if ( a + b == c || a + c == b || b + c == a ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; a = a * a ; b = b * b ; c = c * c ; if ( a == b + c || b == a + c || c == a + b ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int a , b , c ; for ( int i = 0 ; i < N ; i ++ ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; c = sc . nextInt ( ) ; a = a * a ; b = b * b ; c = c * c ; if ( a + b == c ) { System . out . println ( \" YES \" ) ; } else if ( b + c == a ) { System . out . println ( \" YES \" ) ; } else if ( a + c == b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { Integer dataNum = Integer . valueOf ( in . readLine ( ) ) ; for ( int i = 0 ; i < dataNum . intValue ( ) ; i ++ ) { String [ ] problemData = in . readLine ( ) . split ( \" \\\\ s \" ) ; int max = 0 ; int other1 = 0 ; int other2 = 0 ; for ( String data : problemData ) { int dataInt = Integer . valueOf ( data ) ; other2 = other1 ; if ( dataInt > max ) { other1 = max ; max = dataInt ; } else { other1 = dataInt ; } } if ( ( max * max ) == ( other1 * other1 + other2 * other2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String args [ ] ) { int dataSet ; Scanner in = new Scanner ( System . in ) ; dataSet = in . nextInt ( ) ; for ( int i = 0 ; i < dataSet ; i ++ ) { int [ ] e = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { e [ j ] = in . nextInt ( ) ; } Arrays . sort ( e ) ; if ( e [ 0 ] * e [ 0 ] + e [ 1 ] * e [ 1 ] == e [ 2 ] * e [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int x = input . nextInt ( ) ; for ( int i = 0 ; i < x ; i ++ ) { ArrayList < Integer > out = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { out . add ( input . nextInt ( ) ) ; } Collections . sort ( out ) ; System . out . println ( Math . pow ( out . get ( out . size ( ) - 1 ) , 2 ) == Math . pow ( out . get ( 0 ) , 2 ) + Math . pow ( out . get ( 1 ) , 2 ) ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int tmp = sc . nextInt ( ) ; for ( int i = 0 ; i < tmp ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( ( a * a == ( b * b ) + ( c * c ) ) || ( b * b == ( c * c ) + ( a * a ) ) || ( c * c == ( a * a ) + ( b * b ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String ... args ) { final Scanner scanner = new Scanner ( System . in ) ; final int set = scanner . nextInt ( ) ; for ( int i = 0 ; i < set ; i ++ ) { final List < Integer > integers = Arrays . asList ( scanner . nextInt ( ) , scanner . nextInt ( ) , scanner . nextInt ( ) ) ; Collections . sort ( integers ) ; final double a = Math . pow ( integers . get ( 0 ) , 2 ) ; final double b = Math . pow ( integers . get ( 1 ) , 2 ) ; final double c = Math . pow ( integers . get ( 2 ) , 2 ) ; System . out . println ( c == a + b ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] ia = new int [ 3 ] ; ia [ 0 ] = scanner . nextInt ( ) ; ia [ 1 ] = scanner . nextInt ( ) ; ia [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( ia ) ; if ( ia [ 0 ] * ia [ 0 ] + ia [ 1 ] * ia [ 1 ] == ia [ 2 ] * ia [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int set = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < set ; i ++ ) { line = br . readLine ( ) ; String [ ] numbers = line . split ( \" \" ) ; int [ ] numSet = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { numSet [ j ] = Integer . parseInt ( numbers [ j ] ) ; } Arrays . sort ( numSet ) ; if ( numSet [ 2 ] * numSet [ 2 ] == numSet [ 1 ] * numSet [ 1 ] + numSet [ 0 ] * numSet [ 0 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { final String SPACE = \" \" ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; final int cntData = Integer . parseInt ( br . readLine ( ) ) ; int a ; int b ; int c ; String data [ ] = new String [ 3 ] ; String lineString ; for ( int i = 0 ; i < cntData ; i ++ ) { lineString = br . readLine ( ) ; data = lineString . split ( SPACE ) ; a = Integer . parseInt ( data [ 0 ] ) ; b = Integer . parseInt ( data [ 1 ] ) ; c = Integer . parseInt ( data [ 2 ] ) ; if ( a * a + b * b == c * c ) { sb . append ( \" YES \\r \\n \" ) ; } else if ( a * a + c * c == b * b ) { sb . append ( \" YES \\r \\n \" ) ; } else if ( b * b + c * c == a * a ) { sb . append ( \" YES \\r \\n \" ) ; } else { sb . append ( \" NO \\r \\n \" ) ; } } System . out . print ( sb ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private StringTokenizer st ; private BufferedReader bf ; private int w ; Main ( ) { readData ( ) ; } private void readData ( ) { try { bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; st = new StringTokenizer ( bf . readLine ( ) ) ; int n = nextInt ( ) ; int [ ] a ; for ( int i = 0 ; i < n ; i ++ ) { a = new int [ 3 ] ; a [ 0 ] = nextInt ( ) ; a [ 1 ] = nextInt ( ) ; a [ 2 ] = nextInt ( ) ; Arrays . sort ( a ) ; if ( ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] ) == a [ 2 ] * a [ 2 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } private String next ( ) throws IOException { if ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( bf . readLine ( ) ) ; return st . nextToken ( ) ; } public static void main ( String [ ] args ) { Main m = new Main ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Vector ; import java . util . Collections ; class Main { public static void main ( String [ ] av ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; Vector < Boolean > bools = new Vector < Boolean > ( ) ; for ( int i = 0 ; i < num ; ++ i ) { Vector < Integer > ps = new Vector < Integer > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { ps . add ( sc . nextInt ( ) ) ; } Collections . sort ( ps ) ; if ( ps . get ( 0 ) * ps . get ( 0 ) + ps . get ( 1 ) * ps . get ( 1 ) == ps . get ( 2 ) * ps . get ( 2 ) ) { bools . add ( true ) ; } else { bools . add ( false ) ; } } for ( Boolean bool : bools ) { if ( bool ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader buf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( buf . readLine ( ) ) ; String [ ] list ; String [ ] check = new String [ N ] ; int i , j , l ; for ( int k = 0 ; k < N ; k ++ ) { list = buf . readLine ( ) . split ( \" \" ) ; i = Integer . parseInt ( list [ 0 ] ) ; j = Integer . parseInt ( list [ 1 ] ) ; l = Integer . parseInt ( list [ 2 ] ) ; check [ k ] = Check ( i , j , l ) ; } for ( int k = 0 ; k < N ; k ++ ) { System . out . println ( check [ k ] ) ; } } public static String Check ( int a , int b , int c ) { if ( a - b > 0 && a - c > 0 ) { if ( a * a == b * b + c * c ) { return \" YES \" ; } else { return \" NO \" ; } } else if ( b - a > 0 && b - c > 0 ) { if ( b * b == a * a + c * c ) { return \" YES \" ; } else { return \" NO \" ; } } else { if ( c * c == b * b + a * a ) { return \" YES \" ; } else { return \" NO \" ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; import java . math . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int count = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < count ; i ++ ) { String [ ] line = br . readLine ( ) . split ( \" \" ) ; List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( new Integer ( line [ 0 ] ) ) ; list . add ( new Integer ( line [ 1 ] ) ) ; list . add ( new Integer ( line [ 2 ] ) ) ; Collections . sort ( list ) ; double cor = Math . sqrt ( Math . pow ( list . get ( 0 ) . doubleValue ( ) , 2 ) + Math . pow ( list . get ( 1 ) . doubleValue ( ) , 2 ) ) ; double ex = list . get ( 2 ) . doubleValue ( ) ; if ( cor == ex ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder builder = new StringBuilder ( ) ; int a = Integer . parseInt ( reader . readLine ( ) ) ; for ( int i = 0 ; i < a ; i ++ ) { String [ ] line = reader . readLine ( ) . split ( \" \" ) ; int [ ] nums = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { nums [ j ] = Integer . parseInt ( line [ j ] ) ; } Arrays . sort ( nums ) ; if ( Math . pow ( nums [ 0 ] , 2 ) + Math . pow ( nums [ 1 ] , 2 ) == Math . pow ( nums [ 2 ] , 2 ) ) builder . append ( \" YES \\n \" ) ; else builder . append ( \" NO \\n \" ) ; } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder builder = new StringBuilder ( ) ; StringTokenizer to ; int [ ] nums = new int [ 3 ] ; int a = Integer . parseInt ( reader . readLine ( ) ) ; for ( int i = 0 ; i < a ; i ++ ) { to = new StringTokenizer ( reader . readLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { nums [ j ] = Integer . parseInt ( to . nextToken ( ) ) ; } Arrays . sort ( nums ) ; if ( Math . pow ( nums [ 0 ] , 2 ) + Math . pow ( nums [ 1 ] , 2 ) == Math . pow ( nums [ 2 ] , 2 ) ) builder . append ( \" YES \\n \" ) ; else builder . append ( \" NO \\n \" ) ; } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int loop = Integer . parseInt ( readLine ( reader ) ) ; for ( int i = 0 ; i < loop ; i ++ ) { String [ ] sideArray = readLine ( reader ) . split ( \" \" ) ; int [ ] sideNumArray = new int [ sideArray . length ] ; for ( int j = 0 ; j < sideNumArray . length ; j ++ ) { sideNumArray [ j ] = Integer . parseInt ( sideArray [ j ] ) ; } Arrays . sort ( sideNumArray ) ; int smallTwo = sideNumArray [ 0 ] * sideNumArray [ 0 ] + sideNumArray [ 1 ] * sideNumArray [ 1 ] ; int largeOne = sideNumArray [ 2 ] * sideNumArray [ 2 ] ; if ( smallTwo == largeOne ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static String readLine ( BufferedReader reader ) { String line = null ; try { line = reader . readLine ( ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } return line ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static int [ ] a = new int [ 3 ] ; public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int n = cin . nextInt ( ) ; while ( 0 != n -- ) { for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = cin . nextInt ( ) ; } solve ( ) ; } } public static void solve ( ) { Arrays . sort ( a ) ; System . out . println ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ? \" YES \" : \" NO \" ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; String str = \" \" ; StringTokenizer st ; int num [ ] = new int [ 3 ] ; int index [ ] = new int [ 2 ] ; int max = 0 , i , j , k ; str = br . readLine ( ) ; int datasets = Integer . parseInt ( str ) ; for ( i = 0 ; i < datasets ; i ++ ) { str = br . readLine ( ) ; st = new StringTokenizer ( str , \" \" ) ; num [ 0 ] = Integer . parseInt ( st . nextToken ( ) ) ; num [ 1 ] = Integer . parseInt ( st . nextToken ( ) ) ; num [ 2 ] = Integer . parseInt ( st . nextToken ( ) ) ; for ( j = 0 ; j < 3 ; j ++ ) if ( num [ max ] < num [ j ] ) max = j ; k = 0 ; for ( j = 0 ; j < 3 ; j ++ ) if ( num [ j ] != num [ max ] ) index [ k ++ ] = j ; if ( ( num [ max ] * num [ max ] ) == ( num [ index [ 0 ] ] * num [ index [ 0 ] ] + num [ index [ 1 ] ] * num [ index [ 1 ] ] ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . StringTokenizer ; import java . util . Collections ; import java . util . ArrayList ; class Main { public static void main ( String args [ ] ) { InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; try { int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String buf = br . readLine ( ) ; StringTokenizer st = new StringTokenizer ( buf ) ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; a . add ( Integer . parseInt ( st . nextToken ( ) ) ) ; a . add ( Integer . parseInt ( st . nextToken ( ) ) ) ; a . add ( Integer . parseInt ( st . nextToken ( ) ) ) ; Collections . sort ( a ) ; if ( Math . pow ( a . get ( 0 ) , 2 ) + Math . pow ( a . get ( 1 ) , 2 ) == Math . pow ( a . get ( 2 ) , 2 ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } catch ( IOException e ) { System . out . println ( \" IOException! \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int count = scanner . nextInt ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; a *= a ; b *= b ; c *= c ; if ( a + b == c || b + c == a || c + a == b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; try { line = br . readLine ( ) ; int n = Integer . parseInt ( line . trim ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { line = br . readLine ( ) ; String [ ] numbers = line . trim ( ) . split ( \" \" ) ; int [ ] sides = { Integer . parseInt ( numbers [ 0 ] ) , Integer . parseInt ( numbers [ 1 ] ) , Integer . parseInt ( numbers [ 2 ] ) } ; int maxSide = sides [ 0 ] > sides [ 1 ] && sides [ 0 ] > sides [ 2 ] ? 0 : sides [ 1 ] > sides [ 2 ] ? 1 : 2 ; int sum = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( j != maxSide ) { sum += sides [ j ] * sides [ j ] ; } } System . out . println ( sides [ maxSide ] * sides [ maxSide ] == sum ? \" YES \" : \" NO \" ) ; } } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] arg ) { int [ ] a = new int [ 3 ] ; int n = 0 ; Scanner scan = new Scanner ( System . in ) ; n = scan . nextInt ( ) ; for ( int j = 0 ; j < n ; j ++ ) { a [ 0 ] = scan . nextInt ( ) ; a [ 1 ] = scan . nextInt ( ) ; a [ 2 ] = scan . nextInt ( ) ; Arrays . sort ( a ) ; if ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int x = scanner . nextInt ( ) ; for ( int i = 0 ; i < x ; i ++ ) { int [ ] a = new int [ 3 ] ; a [ 0 ] = scanner . nextInt ( ) ; a [ 1 ] = scanner . nextInt ( ) ; a [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( a ) ; if ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; try { int t = scan . nextInt ( ) ; while ( t -- != 0 ) { int x , y , z ; x = scan . nextInt ( ) ; y = scan . nextInt ( ) ; z = scan . nextInt ( ) ; int a = x * x ; int b = y * y ; int c = z * z ; if ( a + b == c ) System . out . println ( \" YES \" ) ; else if ( b + c == a ) System . out . println ( \" YES \" ) ; else if ( c + a == b ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } catch ( Exception e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String s ; int input = Integer . parseInt ( br . readLine ( ) ) ; List < String > rightAngleList = new ArrayList < String > ( ) ; for ( int i = 1 ; i <= input ; i ++ ) { s = br . readLine ( ) ; String [ ] num = s . split ( \" \" ) ; Integer [ ] side = convertArray ( num ) ; if ( 1 <= side [ 0 ] && side [ 0 ] <= 1000 && 1 <= side [ 1 ] && side [ 1 ] <= 1000 && 1 <= side [ 2 ] && side [ 2 ] <= 1000 ) { Arrays . sort ( side ) ; if ( side [ 2 ] * side [ 2 ] == side [ 1 ] * side [ 1 ] + side [ 0 ] * side [ 0 ] ) { rightAngleList . add ( \" YES \" ) ; } else { rightAngleList . add ( \" NO \" ) ; } } else { break ; } } String [ ] rightAngles = rightAngleList . toArray ( new String [ 0 ] ) ; for ( String rightAngle : rightAngles ) { System . out . println ( rightAngle ) ; } } finally { br . close ( ) ; } } public static Integer [ ] convertArray ( String [ ] str ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( String num : str ) { list . add ( Integer . parseInt ( num ) ) ; } return list . toArray ( new Integer [ 0 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String s ; int input = Integer . parseInt ( br . readLine ( ) ) ; List < String > rightAngleList = new ArrayList < String > ( ) ; for ( int i = 1 ; i <= input ; i ++ ) { s = br . readLine ( ) ; String [ ] num = s . split ( \" \" ) ; Integer [ ] side = convertArray ( num ) ; Arrays . sort ( side ) ; if ( side [ 2 ] * side [ 2 ] == side [ 1 ] * side [ 1 ] + side [ 0 ] * side [ 0 ] ) { rightAngleList . add ( \" YES \" ) ; } else { rightAngleList . add ( \" NO \" ) ; } } String [ ] rightAngles = rightAngleList . toArray ( new String [ 0 ] ) ; for ( String rightAngle : rightAngles ) { System . out . println ( rightAngle ) ; } } finally { br . close ( ) ; } } public static Integer [ ] convertArray ( String [ ] str ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( String num : str ) { list . add ( Integer . parseInt ( num ) ) ; } return list . toArray ( new Integer [ 0 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = br . readLine ( ) ; int N = Integer . parseInt ( line ) ; for ( int i = 0 ; i < N ; i ++ ) { String l = br . readLine ( ) ; Scanner sc = new Scanner ( l ) ; int a [ ] ; a = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; if ( ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] ) == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = br . readLine ( ) ; int N = Integer . parseInt ( line ) ; for ( int i = 0 ; i < N ; i ++ ) { String l = br . readLine ( ) ; Scanner sc = new Scanner ( l ) ; int a [ ] ; a = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; if ( ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] ) == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { @ SuppressWarnings ( \" resource \" ) Scanner sc = new Scanner ( System . in ) ; String ans [ ] = new String [ 1000 ] ; int set = sc . nextInt ( ) ; int i = 0 ; for ( ; i < set ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a * a == b * b + c * c || a * a + b * b == c * c || a * a + c * c == b * b ) { ans [ i ] = \" YES \" ; } else { ans [ i ] = \" NO \" ; } } for ( int j = 0 ; j < i ; j ++ ) { System . out . println ( ans [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a [ ] = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; if ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] arg ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int DATE_QUANTITY = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < DATE_QUANTITY ; i ++ ) { String [ ] splitedLine = br . readLine ( ) . split ( \" \" ) ; int [ ] val = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { int tmp = Integer . parseInt ( splitedLine [ j ] ) ; val [ j ] = ( int ) Math . pow ( tmp , 2 ) ; } Arrays . sort ( val ) ; if ( ( val [ 0 ] + val [ 1 ] ) == val [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; public class Main { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final String LINE_SPR = System . getProperty ( \" line.separator \" ) ; final int BIG_MOD = 1000000007 ; void run ( ) throws Exception { int nt = ni ( ) ; for ( int t = 0 ; t < nt ; t ++ ) { String [ ] nums = ns ( ) . split ( \" \" ) ; int a = Integer . parseInt ( nums [ 0 ] ) ; int b = Integer . parseInt ( nums [ 1 ] ) ; int c = Integer . parseInt ( nums [ 2 ] ) ; if ( a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } void dumpObjArr ( Object [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] ) ; if ( i < n - 1 ) System . out . print ( \" \" ) ; } System . out . println ( \" \" ) ; } void dumpObjArr2 ( Object [ ] [ ] arr , int m , int n ) { for ( int j = 0 ; j < m ; j ++ ) dumpObjArr ( arr [ j ] , n ) ; } int ni ( ) throws Exception { return Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; } long nl ( ) throws Exception { return Long . parseLong ( br . readLine ( ) . trim ( ) ) ; } String ns ( ) throws Exception { return br . readLine ( ) ; } boolean isPrime ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int getPrime ( int n ) { List < Integer > primes = new ArrayList < Integer > ( ) ; primes . add ( 2 ) ; int count = 1 ; int x = 1 ; while ( primes . size ( ) < n ) { x += 2 ; int m = ( int ) Math . sqrt ( x ) ; for ( int p : primes ) { if ( p > m ) { primes . add ( x ) ; break ; } if ( x % p == 0 ) break ; } } return primes . get ( primes . size ( ) - 1 ) ; } void gcjPrint ( String str , int t ) { System . out . println ( \" Case # \" + t + \" : \" + str ) ; } public static void main ( String [ ] args ) throws Exception { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int b , x , max , SH ; SH = 0 ; while ( s . hasNextInt ( ) ) { x = s . nextInt ( ) ; int [ ] [ ] a = new int [ x ] [ 3 ] ; for ( b = 0 ; b < x ; b ++ ) { a [ b ] [ 0 ] = s . nextInt ( ) ; a [ b ] [ 1 ] = s . nextInt ( ) ; a [ b ] [ 2 ] = s . nextInt ( ) ; } for ( b = 0 ; b < x ; b ++ ) { max = a [ b ] [ 0 ] ; if ( a [ b ] [ 1 ] > max ) max = a [ b ] [ 1 ] ; if ( a [ b ] [ 2 ] > max ) max = a [ b ] [ 2 ] ; if ( max == a [ b ] [ 0 ] ) { SH = a [ b ] [ 1 ] * a [ b ] [ 1 ] + a [ b ] [ 2 ] * a [ b ] [ 2 ] ; } else if ( max == a [ b ] [ 1 ] ) { SH = a [ b ] [ 0 ] * a [ b ] [ 0 ] + a [ b ] [ 2 ] * a [ b ] [ 2 ] ; } else if ( max == a [ b ] [ 2 ] ) { SH = a [ b ] [ 0 ] * a [ b ] [ 0 ] + a [ b ] [ 1 ] * a [ b ] [ 1 ] ; } max = max * max ; if ( SH == max ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . lang . Math . * ; import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ 0 ] = sc . nextInt ( ) ; a [ 1 ] = sc . nextInt ( ) ; a [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( a ) ; if ( Math . pow ( a [ 2 ] , 2 ) == Math . pow ( a [ 0 ] , 2 ) + Math . pow ( a [ 1 ] , 2 ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int dataSize = Integer . parseInt ( sc . nextLine ( ) ) ; int [ ] [ ] data = new int [ dataSize ] [ 3 ] ; for ( int i = 0 ; i < dataSize ; ++ i ) { String [ ] splitted = sc . nextLine ( ) . split ( \" \\\\ s+ \" ) ; data [ i ] [ 0 ] = Integer . parseInt ( splitted [ 0 ] ) ; data [ i ] [ 1 ] = Integer . parseInt ( splitted [ 1 ] ) ; data [ i ] [ 2 ] = Integer . parseInt ( splitted [ 2 ] ) ; } for ( int i = 0 ; i < dataSize ; ++ i ) { if ( IsRight ( data [ i ] [ 0 ] , data [ i ] [ 1 ] , data [ i ] [ 2 ] ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } public static boolean IsRight ( int a , int b , int c ) { if ( ( a * a == b * b + c * c ) || ( b * b == a * a + c * c ) || ( c * c == a * a + b * b ) ) return true ; else return false ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . Scanner ; import java . math . BigInteger ; public class Main { public static void main ( String [ ] args ) { int t , n1 , n2 , n3 ; int [ ] a = new int [ 3 ] ; Scanner sc = new Scanner ( System . in ) ; t = sc . nextInt ( ) ; while ( t > 0 ) { t -- ; n1 = sc . nextInt ( ) ; n2 = sc . nextInt ( ) ; n3 = sc . nextInt ( ) ; a [ 0 ] = n1 ; a [ 1 ] = n2 ; a [ 2 ] = n3 ; Arrays . sort ( a ) ; System . out . println ( ( a [ 2 ] * a [ 2 ] == a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] ) ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > intArr = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) intArr . add ( in . nextInt ( ) ) ; Collections . sort ( intArr ) ; Collections . reverse ( intArr ) ; int c = intArr . get ( 0 ) ; int a = intArr . get ( 1 ) ; int b = intArr . get ( 2 ) ; if ( a * a + b * b == c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int ndata = Integer . parseInt ( br . readLine ( ) ) ; List < String > results = new ArrayList < String > ( ) ; while ( ndata > 0 ) { String line = br . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int a = Integer . parseInt ( st . nextToken ( ) ) ; int b = Integer . parseInt ( st . nextToken ( ) ) ; int c = Integer . parseInt ( st . nextToken ( ) ) ; if ( a * a + b * b == c * c || b * b + c * c == a * a || a * a + c * c == b * b ) { results . add ( \" YES \" ) ; } else { results . add ( \" NO \" ) ; } ndata -- ; } for ( String r : results ) { System . out . println ( r ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] t = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { t [ i ] [ j ] = sc . nextInt ( ) ; } if ( triangle ( i , t ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static boolean triangle ( int i , int [ ] [ ] t ) { double max = Math . max ( Math . max ( t [ i ] [ 0 ] , t [ i ] [ 1 ] ) , t [ i ] [ 2 ] ) ; double res = Math . min ( Math . min ( Math . hypot ( t [ i ] [ 0 ] , t [ i ] [ 1 ] ) , Math . hypot ( t [ i ] [ 0 ] , t [ i ] [ 2 ] ) ) , Math . hypot ( t [ i ] [ 2 ] , t [ i ] [ 1 ] ) ) ; if ( res == max ) { return true ; } else { return false ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int loopNum = scanner . nextInt ( ) ; for ( int i = 0 ; i < loopNum ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; if ( isTriangle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static boolean isTriangle ( int a , int b , int c ) { if ( a >= b && a >= c ) { return a * a == b * b + c * c ; } else { if ( b >= c ) { return b * b == a * a + c * c ; } else { return c * c == a * a + b * b ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { static int a = 0 ; static int b = 0 ; static int c = 0 ; public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int loopNum = scanner . nextInt ( ) ; for ( int i = 0 ; i < loopNum ; i ++ ) { a = scanner . nextInt ( ) ; b = scanner . nextInt ( ) ; c = scanner . nextInt ( ) ; if ( isTriangle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static boolean isTriangle ( int a , int b , int c ) { if ( a >= b && a >= c ) { return a * a == b * b + c * c ; } else { if ( b >= c ) { return b * b == a * a + c * c ; } else { return c * c == a * a + b * b ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int loopNum = scanner . nextInt ( ) ; for ( int i = 0 ; i < loopNum ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; if ( isTriangle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static boolean isTriangle ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 && ( a + b + c ) % 12 != 0 ) { return false ; } if ( a >= b && a >= c ) { return a * a == b * b + c * c ; } else { if ( b >= c ) { return b * b == a * a + c * c ; } else { return c * c == a * a + b * b ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 512 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; int productAB ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( ( ( productAB = sides [ 0 ] * sides [ 1 ] ) % 12 ) != 0 ) { builder . append ( NEGATIVE ) ; } else if ( productAB * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEG = \" NO \\n \" ; private final static String AFF = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEG ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEG ) ; } else { builder . append ( AFF ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEG = \" NO \\n \" ; private final static String AFF = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEG ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEG ) ; } else { builder . append ( AFF ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEG = \" NO \\n \" ; private final static String AFF = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 1 ] % 2 != 0 ) { builder . append ( NEG ) ; } else if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEG ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEG ) ; } else { builder . append ( AFF ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEG = \" NO \\n \" ; private final static String AFF = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 1 ] % 2 != 0 ) { builder . append ( NEG ) ; } else if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEG ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEG ) ; } else { builder . append ( AFF ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEG = \" NO \\n \" ; private final static String AFF = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 1 ] % 2 != 0 ) { builder . append ( NEG ) ; } else if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEG ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEG ) ; } else { builder . append ( AFF ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; public class Main { private static final int NUMBER_OF_ELEMENT = 3 ; private static final int INDEX_X = 0 ; private static final int INDEX_Y = 1 ; private static final int INDEX_Z = 2 ; private static final Map < Boolean , String > printMap = new HashMap < Boolean , String > ( ) ; ; static { printMap . put ( true , \" YES \" ) ; printMap . put ( false , \" NO \" ) ; } public static void main ( String [ ] args ) throws IOException { int [ ] [ ] triangleList = readTriangleList ( ) ; for ( int i = 0 ; i < triangleList . length ; i ++ ) { boolean isTriangle = isRightTriangle ( triangleList [ i ] ) ; System . out . println ( printMap . get ( isTriangle ) ) ; } } protected static int [ ] [ ] readTriangleList ( ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int numberOfLine = Integer . parseInt ( reader . readLine ( ) ) ; int [ ] [ ] triangleList = new int [ numberOfLine ] [ NUMBER_OF_ELEMENT ] ; for ( int i = 0 ; i < triangleList . length ; i ++ ) { String [ ] lengthArray = reader . readLine ( ) . split ( \" \" ) ; for ( int j = 0 ; j < lengthArray . length ; j ++ ) { triangleList [ i ] [ j ] = Integer . parseInt ( lengthArray [ j ] ) ; } } if ( reader != null ) { reader . close ( ) ; } return triangleList ; } protected static boolean isRightTriangle ( int [ ] triangle ) { Arrays . sort ( triangle ) ; int xx = ( int ) Math . pow ( triangle [ INDEX_X ] , 2 ) ; int yy = ( int ) Math . pow ( triangle [ INDEX_Y ] , 2 ) ; int zz = ( int ) Math . pow ( triangle [ INDEX_Z ] , 2 ) ; return ( ( xx + yy ) == zz ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { private static final String RIGHT_TRIANGLE = \" YES \" ; private static final String NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws IOException { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int numsOfDataSets = Integer . parseInt ( bufferedReader . readLine ( ) ) ; for ( int i = 0 ; i < numsOfDataSets ; i ++ ) { String [ ] triangle = bufferedReader . readLine ( ) . split ( \" \\\\ s \" ) ; int [ ] sides = getIntArray ( triangle ) ; if ( isRightTriangle ( sides ) ) { System . out . println ( RIGHT_TRIANGLE ) ; } else { System . out . println ( NOT_RIGHT_TRIANGLE ) ; } } bufferedReader . close ( ) ; } private static boolean isRightTriangle ( int [ ] sides ) { Arrays . sort ( sides ) ; if ( calcSumPower ( sides [ 0 ] , sides [ 1 ] ) == calcPower ( sides [ 2 ] ) ) { return true ; } return false ; } private static int [ ] getIntArray ( String [ ] strArray ) { int [ ] intArray = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { intArray [ i ] = Integer . parseInt ( strArray [ i ] ) ; } return intArray ; } private static int calcPower ( int n ) { return n * n ; } private static int calcSumPower ( int n , int m ) { return calcPower ( n ) + calcPower ( m ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String args [ ] ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String str = br . readLine ( ) ; int n [ ] = new int [ 3 ] ; while ( ( str = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( str ) ; for ( int i = 0 ; i <= 2 ; i ++ ) { n [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } Arrays . sort ( n ) ; int a = ( int ) Math . pow ( n [ 0 ] , 2 ) ; int b = ( int ) Math . pow ( n [ 1 ] , 2 ) ; int c = ( int ) Math . pow ( n [ 2 ] , 2 ) ; if ( a + b == c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( Exception ex ) { } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int i [ ] ; i = new int [ 3 ] ; for ( int count = 0 ; count < n ; count ++ ) { for ( int d = 0 ; d < 3 ; d ++ ) { i [ d ] = sc . nextInt ( ) ; } Arrays . sort ( i ) ; if ( ( i [ 2 ] * i [ 2 ] ) == ( i [ 0 ] * i [ 0 ] ) + ( i [ 1 ] * i [ 1 ] ) ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lineCount = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { String line = br . readLine ( ) ; List < Integer > sideList = new ArrayList < Integer > ( ) ; String [ ] input = line . split ( \" \" ) ; sideList . add ( Integer . parseInt ( input [ 0 ] ) ) ; sideList . add ( Integer . parseInt ( input [ 1 ] ) ) ; sideList . add ( Integer . parseInt ( input [ 2 ] ) ) ; Collections . sort ( sideList ) ; if ( isRightTriangle ( sideList . get ( 2 ) , sideList . get ( 1 ) , sideList . get ( 0 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static boolean isRightTriangle ( int side1 , int side2 , int side3 ) { return ( side1 * side1 == side2 * side2 + side3 * side3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lineCount = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \" ) ; int side1 = Integer . parseInt ( input [ 0 ] ) ; int side2 = Integer . parseInt ( input [ 1 ] ) ; int side3 = Integer . parseInt ( input [ 2 ] ) ; if ( isRightTriangle ( side1 , side2 , side3 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static boolean isRightTriangle ( int side1 , int side2 , int side3 ) { boolean isRightTriangle = false ; if ( side1 >= side2 && side1 >= side3 ) { isRightTriangle = ( side1 * side1 == side2 * side2 + side3 * side3 ) ; } else if ( side2 >= side1 && side2 >= side3 ) { isRightTriangle = ( side2 * side2 == side1 * side1 + side3 * side3 ) ; } else { isRightTriangle = ( side3 * side3 == side1 * side1 + side2 * side2 ) ; } return isRightTriangle ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { private static final String RIGHT_TRIANGLE = \" YES \" ; private static final String NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lineCount = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \" ) ; int [ ] side = { Integer . parseInt ( input [ 0 ] ) , Integer . parseInt ( input [ 1 ] ) , Integer . parseInt ( input [ 2 ] ) } ; Arrays . sort ( side ) ; if ( isRightTriangle ( side [ 2 ] , side [ 0 ] , side [ 1 ] ) ) { System . out . println ( RIGHT_TRIANGLE ) ; } else { System . out . println ( NOT_RIGHT_TRIANGLE ) ; } } } private static boolean isRightTriangle ( int side1 , int side2 , int side3 ) { return ( side1 * side1 == side2 * side2 + side3 * side3 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { private static final String RIGHT_TRIANGLE = \" YES \" ; private static final String NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lineCount = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \" ) ; int [ ] side = { Integer . parseInt ( input [ 0 ] ) , Integer . parseInt ( input [ 1 ] ) , Integer . parseInt ( input [ 2 ] ) } ; Arrays . sort ( side ) ; if ( side [ 2 ] * side [ 2 ] == side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) { System . out . println ( RIGHT_TRIANGLE ) ; } else { System . out . println ( NOT_RIGHT_TRIANGLE ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { private static final String RIGHT_TRIANGLE = \" YES \" ; private static final String NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lineCount = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \" ) ; int [ ] side = { Integer . parseInt ( input [ 0 ] ) , Integer . parseInt ( input [ 1 ] ) , Integer . parseInt ( input [ 2 ] ) } ; Arrays . sort ( side ) ; if ( Math . pow ( side [ 2 ] , 2 ) == Math . pow ( side [ 0 ] , 2 ) + Math . pow ( side [ 1 ] , 2 ) ) { System . out . println ( RIGHT_TRIANGLE ) ; } else { System . out . println ( NOT_RIGHT_TRIANGLE ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { private static final String RIGHT_TRIANGLE = \" YES \" ; private static final String NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int lineCount = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \" ) ; int [ ] side = { Integer . parseInt ( input [ 0 ] ) , Integer . parseInt ( input [ 1 ] ) , Integer . parseInt ( input [ 2 ] ) } ; Arrays . sort ( side ) ; if ( side [ 2 ] * side [ 2 ] == side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) { System . out . println ( RIGHT_TRIANGLE ) ; } else { System . out . println ( NOT_RIGHT_TRIANGLE ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int a ; int b ; int c ; int N = stdIn . nextInt ( ) ; int count = 0 ; int box ; while ( true ) { if ( N <= 0 ) { break ; } a = stdIn . nextInt ( ) ; b = stdIn . nextInt ( ) ; c = stdIn . nextInt ( ) ; if ( a < b ) { box = a ; a = b ; b = box ; } if ( a < c ) { box = a ; a = c ; c = box ; } a = a * a ; b = b * b ; c = c * c ; if ( a == b + c ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; count = count + 1 ; if ( count == N ) { break ; } } } }",
    "label": 1
  },
  {
    "code": "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int N , i , j ; int [ ] [ ] a ; N = sc . nextInt ( ) ; a = new int [ N ] [ 3 ] ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; } } sc . close ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( a [ i ] [ 0 ] * a [ i ] [ 0 ] + a [ i ] [ 1 ] * a [ i ] [ 1 ] == a [ i ] [ 2 ] * a [ i ] [ 2 ] ) { System . out . println ( \" YES \" ) ; } else if ( a [ i ] [ 0 ] * a [ i ] [ 0 ] + a [ i ] [ 2 ] * a [ i ] [ 2 ] == a [ i ] [ 1 ] * a [ i ] [ 1 ] ) { System . out . println ( \" YES \" ) ; } else if ( a [ i ] [ 2 ] * a [ i ] [ 2 ] + a [ i ] [ 1 ] * a [ i ] [ 1 ] == a [ i ] [ 0 ] * a [ i ] [ 0 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int number = sc . nextInt ( ) ; for ( int i = 0 ; i < number ; i ++ ) { int [ ] a = new int [ 3 ] ; a [ 0 ] = sc . nextInt ( ) ; a [ 1 ] = sc . nextInt ( ) ; a [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( a ) ; if ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . * ; public class Main { static InputStream is ; static PrintWriter out ; static String INPUT = \" \" ; final int INF = Integer . MAX_VALUE ; final int MIN = Integer . MIN_VALUE ; static void solve ( ) { int n = ni ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = ni ( ) ; int b = ni ( ) ; int c = ni ( ) ; boolean res = a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b ; System . out . println ( res ? \" YES \" : \" NO \" ) ; } } public static void main ( String [ ] args ) throws Exception { long S = System . currentTimeMillis ( ) ; is = INPUT . isEmpty ( ) ? System . in : new ByteArrayInputStream ( INPUT . getBytes ( ) ) ; out = new PrintWriter ( System . out ) ; solve ( ) ; out . flush ( ) ; long G = System . currentTimeMillis ( ) ; tr ( G - S + \" ms \" ) ; } private static boolean eof ( ) { if ( lenbuf == - 1 ) return true ; int lptr = ptrbuf ; while ( lptr < lenbuf ) if ( ! isSpaceChar ( inbuf [ lptr ++ ] ) ) return false ; try { is . mark ( 1000 ) ; while ( true ) { int b = is . read ( ) ; if ( b == - 1 ) { is . reset ( ) ; return true ; } else if ( ! isSpaceChar ( b ) ) { is . reset ( ) ; return false ; } } } catch ( IOException e ) { return true ; } } private static byte [ ] inbuf = new byte [ 1024 ] ; static int lenbuf = 0 , ptrbuf = 0 ; private static int readByte ( ) { if ( lenbuf == - 1 ) throw new InputMismatchException ( ) ; if ( ptrbuf >= lenbuf ) { ptrbuf = 0 ; try { lenbuf = is . read ( inbuf ) ; } catch ( IOException e ) { throw new InputMismatchException ( ) ; } if ( lenbuf <= 0 ) return - 1 ; } return inbuf [ ptrbuf ++ ] ; } private static boolean isSpaceChar ( int c ) { return ! ( c >= 33 && c <= 126 ) ; } private static int skip ( ) { int b ; while ( ( b = readByte ( ) ) != - 1 && isSpaceChar ( b ) ) ; return b ; } private static double nd ( ) { return Double . parseDouble ( ns ( ) ) ; } private static char nc ( ) { return ( char ) skip ( ) ; } private static String ns ( ) { int b = skip ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( ! ( isSpaceChar ( b ) ) ) { sb . appendCodePoint ( b ) ; b = readByte ( ) ; } return sb . toString ( ) ; } private static char [ ] ns ( int n ) { char [ ] buf = new char [ n ] ; int b = skip ( ) , p = 0 ; while ( p < n && ! ( isSpaceChar ( b ) ) ) { buf [ p ++ ] = ( char ) b ; b = readByte ( ) ; } return n == p ? buf : Arrays . copyOf ( buf , p ) ; } private static char [ ] [ ] nm ( int n , int m ) { char [ ] [ ] map = new char [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) map [ i ] = ns ( m ) ; return map ; } private static int [ ] na ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = ni ( ) ; return a ; } private static int ni ( ) { int num = 0 , b ; boolean minus = false ; while ( ( b = readByte ( ) ) != - 1 && ! ( ( b >= '0' && b <= '9' ) || b == '-' ) ) ; if ( b == '-' ) { minus = true ; b = readByte ( ) ; } while ( true ) { if ( b >= '0' && b <= '9' ) { num = num * 10 + ( b - '0' ) ; } else { return minus ? - num : num ; } b = readByte ( ) ; } } private static long nl ( ) { long num = 0 ; int b ; boolean minus = false ; while ( ( b = readByte ( ) ) != - 1 && ! ( ( b >= '0' && b <= '9' ) || b == '-' ) ) ; if ( b == '-' ) { minus = true ; b = readByte ( ) ; } while ( true ) { if ( b >= '0' && b <= '9' ) { num = num * 10 + ( b - '0' ) ; } else { return minus ? - num : num ; } b = readByte ( ) ; } } private static void tr ( Object ... o ) { if ( INPUT . length ( ) != 0 ) System . out . println ( Arrays . deepToString ( o ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; List < Integer > list = new ArrayList < Integer > ( ) ; int limit = Integer . parseInt ( scanner . next ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { list . add ( Integer . parseInt ( scanner . next ( ) ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list ) ; int a = list . get ( 0 ) ; int b = list . get ( 1 ) ; int c = list . get ( 2 ) ; double cosA = getCosA ( a , b , c ) ; if ( cosA == 0.0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } list . clear ( ) ; } } private static double getCosA ( int a , int b , int c ) { return ( Math . pow ( b , 2 ) + Math . pow ( c , 2 ) - Math . pow ( a , 2 ) ) / ( 2 * b * c ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { private static final String DELIMITER_SPACE = \" \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { List < String [ ] > dataSets = new ArrayList < String [ ] > ( ) ; int countOfDataSet = getInput ( dataSets ) ; for ( int i = 0 ; i < countOfDataSet ; ++ i ) { System . out . println ( getResult ( dataSets . get ( i ) ) ) ; } } private static String getResult ( String [ ] dataSets ) { int [ ] lengths = new int [ 3 ] ; toIntArray ( 3 , lengths , dataSets ) ; Arrays . sort ( lengths ) ; if ( isRightTriangle ( lengths ) ) { return \" YES \" ; } else { return \" NO \" ; } } private static boolean isRightTriangle ( int [ ] lengths ) { if ( lengths [ 2 ] * lengths [ 2 ] == lengths [ 0 ] * lengths [ 0 ] + lengths [ 1 ] * lengths [ 1 ] ) { return true ; } return false ; } private static void toIntArray ( int lengthOfArray , int [ ] intArray , String [ ] stringArray ) { for ( int i = 0 ; i < lengthOfArray ; ++ i ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } } private static int getInput ( List < String [ ] > target ) throws NumberFormatException , IOException { InputStreamReader streamReader = new InputStreamReader ( System . in ) ; BufferedReader bufferedReader = new BufferedReader ( streamReader ) ; String line = null ; boolean isFirst = true ; int numberOfDataSet = 0 ; try { while ( ( line = bufferedReader . readLine ( ) ) != null ) { if ( isFirst ) { numberOfDataSet = Integer . parseInt ( line ) ; isFirst = false ; } else { String [ ] lengths = line . split ( DELIMITER_SPACE ) ; target . add ( lengths ) ; } } return numberOfDataSet ; } finally { bufferedReader . close ( ) ; streamReader . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { private static final String DELIMITER_SPACE = \" \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { List < int [ ] > dataSets = new ArrayList < int [ ] > ( ) ; int countOfDataSet = getInput ( dataSets ) ; for ( int i = 0 ; i < countOfDataSet ; ++ i ) { System . out . println ( getResult ( dataSets . get ( i ) ) ) ; } } private static String getResult ( int [ ] dataSets ) { Arrays . sort ( dataSets ) ; if ( isRightTriangle ( dataSets ) ) { return \" YES \" ; } else { return \" NO \" ; } } private static boolean isRightTriangle ( int [ ] lengths ) { if ( lengths [ 2 ] * lengths [ 2 ] == lengths [ 0 ] * lengths [ 0 ] + lengths [ 1 ] * lengths [ 1 ] ) { return true ; } return false ; } private static int getInput ( List < int [ ] > target ) throws NumberFormatException , IOException { InputStreamReader streamReader = new InputStreamReader ( System . in ) ; BufferedReader bufferedReader = new BufferedReader ( streamReader ) ; String line = null ; boolean isFirst = true ; int numberOfDataSet = 0 ; try { while ( ( line = bufferedReader . readLine ( ) ) != null ) { if ( isFirst ) { numberOfDataSet = Integer . parseInt ( line ) ; isFirst = false ; } else { String [ ] strLengths = line . split ( DELIMITER_SPACE ) ; int [ ] intLengths = new int [ 3 ] ; intLengths [ 0 ] = Integer . parseInt ( strLengths [ 0 ] ) ; intLengths [ 1 ] = Integer . parseInt ( strLengths [ 1 ] ) ; intLengths [ 2 ] = Integer . parseInt ( strLengths [ 2 ] ) ; target . add ( intLengths ) ; } } return numberOfDataSet ; } finally { bufferedReader . close ( ) ; streamReader . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { private static final String DELIMITER_SPACE = \" \" ; private static final String RESULT_RIGHT_TRIANGLE = \" YES \" ; private static final String RESULT_NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { List < String [ ] > dataSets = getInput ( ) ; for ( int i = 0 ; i < dataSets . size ( ) ; ++ i ) { System . out . println ( getResult ( dataSets . get ( i ) ) ) ; } } private static String getResult ( String [ ] dataSet ) { int [ ] lengths = toIntArray ( dataSet ) ; Arrays . sort ( lengths ) ; boolean isRightTriangle = ( getSquare ( lengths [ 2 ] ) == getSquare ( lengths [ 0 ] ) + getSquare ( lengths [ 1 ] ) ) ; if ( isRightTriangle ) { return RESULT_RIGHT_TRIANGLE ; } else { return RESULT_NOT_RIGHT_TRIANGLE ; } } private static int [ ] toIntArray ( String [ ] stringArray ) { int [ ] intArray = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; ++ i ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } private static int getSquare ( int target ) { return target * target ; } private static List < String [ ] > getInput ( ) throws NumberFormatException , IOException { InputStreamReader streamReader = new InputStreamReader ( System . in ) ; BufferedReader bufferedReader = new BufferedReader ( streamReader ) ; List < String [ ] > dataSets = new ArrayList < String [ ] > ( ) ; try { int numberOfDataSets = Integer . parseInt ( bufferedReader . readLine ( ) ) ; for ( int i = 0 ; i < numberOfDataSets ; ++ i ) { String [ ] dataSet = bufferedReader . readLine ( ) . split ( DELIMITER_SPACE ) ; dataSets . add ( dataSet ) ; } return dataSets ; } finally { bufferedReader . close ( ) ; streamReader . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { private static final String DELIMITER_SPACE = \" \" ; private static final String RESULT_RIGHT_TRIANGLE = \" YES \" ; private static final String RESULT_NOT_RIGHT_TRIANGLE = \" NO \" ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { List < String [ ] > dataSets = getInput ( ) ; for ( int i = 0 ; i < dataSets . size ( ) ; ++ i ) { System . out . println ( getResult ( dataSets . get ( i ) ) ) ; } } private static String getResult ( String [ ] dataSet ) { int [ ] lengths = toIntArray ( dataSet ) ; Arrays . sort ( lengths ) ; boolean isRightTriangle = ( getSquare ( lengths [ 2 ] ) == getSquare ( lengths [ 0 ] ) + getSquare ( lengths [ 1 ] ) ) ; if ( isRightTriangle ) { return RESULT_RIGHT_TRIANGLE ; } else { return RESULT_NOT_RIGHT_TRIANGLE ; } } private static int [ ] toIntArray ( String [ ] stringArray ) { int [ ] intArray = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; ++ i ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } private static int getSquare ( int target ) { return target * target ; } private static List < String [ ] > getInput ( ) throws NumberFormatException , IOException { InputStreamReader streamReader = new InputStreamReader ( System . in ) ; BufferedReader bufferedReader = new BufferedReader ( streamReader ) ; List < String [ ] > dataSets = new ArrayList < String [ ] > ( ) ; try { int numberOfDataSets = Integer . parseInt ( bufferedReader . readLine ( ) ) ; for ( int i = 0 ; i < numberOfDataSets ; ++ i ) { String [ ] dataSet = bufferedReader . readLine ( ) . split ( DELIMITER_SPACE ) ; dataSets . add ( dataSet ) ; } return dataSets ; } finally { bufferedReader . close ( ) ; streamReader . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String f = br . readLine ( ) ; int [ ] a = new int [ 3 ] ; for ( int i = 0 ; i < Integer . parseInt ( f ) ; i ++ ) { String str = br . readLine ( ) ; String [ ] stra = str . split ( \" \" ) ; for ( int j = 0 ; j < 3 ; j ++ ) { a [ j ] = Integer . parseInt ( stra [ j ] ) ; } Arrays . sort ( a ) ; if ( Math . pow ( a [ 0 ] , 2 ) + Math . pow ( a [ 1 ] , 2 ) == Math . pow ( a [ 2 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { public static void main ( String args [ ] ) { String str ; try { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; String [ ] strary = new String [ 3 ] ; int [ ] len = new int [ 3 ] ; int temp ; str = br . readLine ( ) ; int count = Integer . parseInt ( str ) ; while ( ( count -- ) != 0 ) { str = br . readLine ( ) ; strary = str . split ( \" \" ) ; for ( int i = 0 ; i < 3 ; i ++ ) { len [ i ] = Integer . parseInt ( strary [ i ] ) ; } if ( len [ 0 ] > len [ 1 ] ) { temp = len [ 0 ] ; len [ 0 ] = len [ 1 ] ; len [ 1 ] = temp ; } if ( len [ 1 ] > len [ 2 ] ) { temp = len [ 1 ] ; len [ 1 ] = len [ 2 ] ; len [ 2 ] = temp ; } if ( ( len [ 0 ] * len [ 0 ] + len [ 1 ] * len [ 1 ] ) == ( len [ 2 ] * len [ 2 ] ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } catch ( Exception e ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; a = a * a ; b = b * b ; c = c * c ; if ( a + b == c || b + c == a || c + a == b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; for ( int i = 0 ; i < x ; i ++ ) { int [ ] a = { sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) } ; Arrays . sort ( a ) ; if ( a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; for ( int i = 0 ; i < num ; i ++ ) { int [ ] inputNumList = new int [ 3 ] ; inputNumList [ 0 ] = sc . nextInt ( ) ; inputNumList [ 1 ] = sc . nextInt ( ) ; inputNumList [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( inputNumList ) ; if ( inputNumList [ 0 ] * inputNumList [ 0 ] + inputNumList [ 1 ] * inputNumList [ 1 ] == inputNumList [ 2 ] * inputNumList [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int [ ] c = new int [ n ] ; for ( int d = 0 ; d < n ; d ++ ) { a [ d ] = scan . nextInt ( ) ; b [ d ] = scan . nextInt ( ) ; c [ d ] = scan . nextInt ( ) ; } for ( int e = 0 ; e < n ; e ++ ) { if ( ( a [ e ] * a [ e ] + b [ e ] * b [ e ] == c [ e ] * c [ e ] ) || ( b [ e ] * b [ e ] + c [ e ] * c [ e ] == a [ e ] * a [ e ] ) || ( c [ e ] * c [ e ] + a [ e ] * a [ e ] == b [ e ] * b [ e ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; List < String > list = new ArrayList < String > ( ) ; int number = stdIn . nextInt ( ) ; for ( int i = 0 ; i < number ; i ++ ) { int a = ( int ) Math . pow ( stdIn . nextInt ( ) , 2 ) ; int b = ( int ) Math . pow ( stdIn . nextInt ( ) , 2 ) ; int c = ( int ) Math . pow ( stdIn . nextInt ( ) , 2 ) ; if ( a + b == c || a + c == b || b + c == a ) { list . add ( \" YES \" ) ; } else { list . add ( \" NO \" ) ; } } for ( String str : list ) { System . out . println ( str ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int c = scan . nextInt ( ) ; if ( a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int dataset = sc . nextInt ( ) ; int a , b , c ; for ( int i = 0 ; i < dataset ; i ++ ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; c = sc . nextInt ( ) ; if ( judgeTriangle ( a , b , c ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } sc . close ( ) ; } static boolean judgeTriangle ( int a , int b , int c ) { int da = a * a ; int db = b * b ; int dc = c * c ; if ( da + db == dc ) return true ; else if ( db + dc == da ) return true ; else if ( dc + da == db ) return true ; else return false ; } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < String > ret = new ArrayList < String > ( ) ; int i , max = sc . nextInt ( ) ; for ( i = 0 ; i < max ; i ++ ) { double a = Math . pow ( sc . nextInt ( ) , 2 ) ; double b = Math . pow ( sc . nextInt ( ) , 2 ) ; double c = Math . pow ( sc . nextInt ( ) , 2 ) ; if ( a + b == c || b + c == a || a + c == b ) { ret . add ( \" YES \" ) ; } else { ret . add ( \" NO \" ) ; } } for ( String text : ret ) { System . out . println ( text ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; import static java . lang . Math . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int temp [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) temp [ j ] = sc . nextInt ( ) ; Arrays . sort ( temp ) ; if ( temp [ 0 ] * temp [ 0 ] + temp [ 1 ] * temp [ 1 ] == temp [ 2 ] * temp [ 2 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static void solve ( ) { int n = in . nextInt ( ) ; while ( n -- > 0 ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a < c ) { int t = a ; a = c ; c = t ; } out . println ( a * a == b * b + c * c ? \" YES \" : \" NO \" ) ; } } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; solve ( ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static void solve ( ) { int n = in . nextInt ( ) ; while ( n -- > 0 ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; if ( a * a == b * b + c * c || b * b == c * c + a * a || c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; solve ( ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader read = new BufferedReader ( new java . io . InputStreamReader ( System . in ) ) ; int x = Integer . parseInt ( read . readLine ( ) ) ; for ( int i = 0 ; i < x ; i ++ ) { String y = read . readLine ( ) ; String z [ ] = y . split ( \" \" ) ; int a = Integer . parseInt ( z [ 0 ] ) ; int b = Integer . parseInt ( z [ 1 ] ) ; int c = Integer . parseInt ( z [ 2 ] ) ; a = a * a ; b = b * b ; c = c * c ; if ( a == ( b + c ) ) { System . out . println ( \" YES \" ) ; } else if ( b == ( a + c ) ) { System . out . println ( \" YES \" ) ; } else if ( c == ( a + b ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { @ SuppressWarnings ( \" resource \" ) Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; for ( int i = 0 ; i < num ; i ++ ) { int [ ] inputNumList = new int [ 3 ] ; inputNumList [ 0 ] = sc . nextInt ( ) ; inputNumList [ 1 ] = sc . nextInt ( ) ; inputNumList [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( inputNumList ) ; if ( inputNumList [ 0 ] * inputNumList [ 0 ] + inputNumList [ 1 ] * inputNumList [ 1 ] == inputNumList [ 2 ] * inputNumList [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int dataSetOfNum = scan . nextInt ( ) ; int [ ] dataSet = new int [ 3 ] ; int side1 , side2 , side3 ; for ( int i = 0 ; i < dataSetOfNum ; i ++ ) { dataSet [ 0 ] = scan . nextInt ( ) ; dataSet [ 1 ] = scan . nextInt ( ) ; dataSet [ 2 ] = scan . nextInt ( ) ; Arrays . sort ( dataSet ) ; if ( ( Math . pow ( dataSet [ 0 ] , 2 ) + Math . pow ( dataSet [ 1 ] , 2 ) ) == Math . pow ( dataSet [ 2 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { @ SuppressWarnings ( \" resource \" ) Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; for ( int i = 0 ; i < num ; i ++ ) { int [ ] inputNumList = new int [ 3 ] ; inputNumList [ 0 ] = sc . nextInt ( ) ; inputNumList [ 1 ] = sc . nextInt ( ) ; inputNumList [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( inputNumList ) ; if ( inputNumList [ 0 ] * inputNumList [ 0 ] + inputNumList [ 1 ] * inputNumList [ 1 ] == inputNumList [ 2 ] * inputNumList [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] vals = br . readLine ( ) . split ( \" \" , 0 ) ; int [ ] int_vals = new int [ vals . length ] ; for ( int j = 0 ; j < int_vals . length ; j ++ ) { int_vals [ j ] = Integer . parseInt ( vals [ j ] ) ; } Arrays . sort ( int_vals ) ; int a2 = int_vals [ 2 ] * int_vals [ 2 ] ; int b2 = int_vals [ 1 ] * int_vals [ 1 ] ; int c2 = int_vals [ 0 ] * int_vals [ 0 ] ; if ( a2 == b2 + c2 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int a , b , c ; for ( int i = 0 ; i < n ; i ++ ) { a = input . nextInt ( ) ; b = input . nextInt ( ) ; c = input . nextInt ( ) ; if ( a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static Scanner scanner = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = input ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ArrayList < Integer > numList = new ArrayList < > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { numList . add ( input ( ) ) ; } Collections . sort ( numList ) ; if ( isRight ( numList . get ( 2 ) , numList . get ( 1 ) , numList . get ( 0 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } close ( ) ; } public static boolean isRight ( int longSide , int shortSideA , int shortSideB ) { return Math . pow ( longSide , 2 ) == Math . pow ( shortSideA , 2 ) + Math . pow ( shortSideB , 2 ) ; } public static int input ( ) { return scanner . nextInt ( ) ; } public static void close ( ) { if ( scanner != null ) { scanner . close ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { print ( ) ; } private static void print ( ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String str = br . readLine ( ) ; int numberOfReceivedDataset = Integer . parseInt ( str ) ; for ( int i = 1 ; i <= numberOfReceivedDataset ; i ++ ) { str = br . readLine ( ) ; String [ ] nums = str . split ( \" \" , 0 ) ; int x = Integer . parseInt ( nums [ 0 ] ) ; int y = Integer . parseInt ( nums [ 1 ] ) ; int z = Integer . parseInt ( nums [ 2 ] ) ; int xToSecondPower = x * x ; int yToSecondPower = y * y ; int zToSecondPower = z * z ; if ( xToSecondPower + yToSecondPower == zToSecondPower ) { System . out . println ( \" YES \" ) ; } else if ( zToSecondPower + yToSecondPower == xToSecondPower ) { System . out . println ( \" YES \" ) ; } else if ( zToSecondPower + xToSecondPower == yToSecondPower ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . StringTokenizer ; public class Main { static InputReader in ; static PrintWriter out ; static class Solution { void solve ( ) throws IOException { int N = in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; if ( a * a == b * b + c * c || b * b == c * c + a * a || c * c == a * a + b * b ) { out . println ( \" YES \" ) ; } else { out . println ( \" NO \" ) ; } } } } public static void main ( String [ ] args ) throws IOException { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out ) ; Solution solver = new Solution ( ) ; solver . solve ( ) ; out . close ( ) ; } static class InputReader { public BufferedReader br ; public StringTokenizer st ; public InputReader ( InputStream stream ) { br = new BufferedReader ( new InputStreamReader ( stream ) ) ; } public int nextInt ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return Integer . parseInt ( st . nextToken ( ) ) ; } public long nextLong ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return Long . parseLong ( st . nextToken ( ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } public double nextDouble ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return Double . parseDouble ( st . nextToken ( ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int count = Integer . valueOf ( sc . next ( ) ) ; for ( int i = 0 ; i < count ; i ++ ) { int [ ] nums = new int [ ] { Integer . valueOf ( sc . next ( ) ) , Integer . valueOf ( sc . next ( ) ) , Integer . valueOf ( sc . next ( ) ) } ; Arrays . sort ( nums ) ; System . out . println ( isRightTriangle ( nums ) ? \" YES \" : \" NO \" ) ; } } public static boolean isRightTriangle ( int [ ] nums ) { return ( nums [ 0 ] * nums [ 0 ] ) + ( nums [ 1 ] * nums [ 1 ] ) == ( nums [ 2 ] * nums [ 2 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder builder = new StringBuilder ( ) ; StringTokenizer to ; int [ ] nums = new int [ 3 ] ; int a = Integer . parseInt ( reader . readLine ( ) ) ; for ( int i = 0 ; i < a ; i ++ ) { to = new StringTokenizer ( reader . readLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { nums [ j ] = Integer . parseInt ( to . nextToken ( ) ) ; } Arrays . sort ( nums ) ; if ( Math . pow ( nums [ 0 ] , 2 ) + Math . pow ( nums [ 1 ] , 2 ) == Math . pow ( nums [ 2 ] , 2 ) ) builder . append ( \" YES \\n \" ) ; else builder . append ( \" NO \\n \" ) ; } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { private static boolean isTriangle ( int a , int b , int c ) { int [ ] edge = { a , b , c } ; Arrays . sort ( edge ) ; return edge [ 0 ] * edge [ 0 ] + edge [ 1 ] * edge [ 1 ] == edge [ 2 ] * edge [ 2 ] ; } public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int N = scan . nextInt ( ) ; int a , b , c ; for ( int i = 0 ; i < N ; i ++ ) { a = scan . nextInt ( ) ; b = scan . nextInt ( ) ; c = scan . nextInt ( ) ; if ( isTriangle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } scan . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static final Scanner scn = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { for ( int i = 0 , n = scn . nextInt ( ) ; i < n ; i ++ ) { int [ ] ary = { scn . nextInt ( ) , scn . nextInt ( ) , scn . nextInt ( ) } ; Arrays . sort ( ary ) ; boolean flg = ary [ 0 ] * ary [ 0 ] + ary [ 1 ] * ary [ 1 ] == ary [ 2 ] * ary [ 2 ] ; System . out . println ( flg ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int n , temp ; Scanner stdIn = new Scanner ( System . in ) ; n = stdIn . nextInt ( ) ; int [ ] [ ] side = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { side [ i ] [ j ] = stdIn . nextInt ( ) ; } if ( side [ i ] [ 0 ] < side [ i ] [ 1 ] ) { temp = side [ i ] [ 0 ] ; side [ i ] [ 0 ] = side [ i ] [ 1 ] ; side [ i ] [ 1 ] = temp ; } if ( side [ i ] [ 0 ] < side [ i ] [ 2 ] ) { temp = side [ i ] [ 0 ] ; side [ i ] [ 0 ] = side [ i ] [ 2 ] ; side [ i ] [ 2 ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( side [ i ] [ 0 ] * side [ i ] [ 0 ] == side [ i ] [ 1 ] * side [ i ] [ 1 ] + side [ i ] [ 2 ] * side [ i ] [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { int n , temp ; Scanner stdIn = new Scanner ( System . in ) ; n = stdIn . nextInt ( ) ; int [ ] [ ] side = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { side [ i ] [ j ] = stdIn . nextInt ( ) ; } if ( side [ i ] [ 0 ] < side [ i ] [ 1 ] ) { temp = side [ i ] [ 0 ] ; side [ i ] [ 0 ] = side [ i ] [ 1 ] ; side [ i ] [ 1 ] = temp ; } if ( side [ i ] [ 0 ] < side [ i ] [ 2 ] ) { temp = side [ i ] [ 0 ] ; side [ i ] [ 0 ] = side [ i ] [ 2 ] ; side [ i ] [ 2 ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( side [ i ] [ 0 ] * side [ i ] [ 0 ] == side [ i ] [ 1 ] * side [ i ] [ 1 ] + side [ i ] [ 2 ] * side [ i ] [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < String > ynJudge = new ArrayList < > ( ) ; int N = sc . nextInt ( ) ; int sideA , sideB , sideC ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sideA = sc . nextInt ( ) ; sideB = sc . nextInt ( ) ; sideC = sc . nextInt ( ) ; if ( sideA * sideA == sideB * sideB + sideC * sideC || sideB * sideB == sideA * sideA + sideC * sideC || sideC * sideC == sideA * sideA + sideB * sideB ) { ynJudge . add ( \" YES \" ) ; cnt ++ ; } else { ynJudge . add ( \" NO \" ) ; cnt ++ ; } } for ( int i = 0 ; i < cnt ; i ++ ) { System . out . println ( ynJudge . get ( i ) ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { String str ; int a , b , c ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; str = br . readLine ( ) ; int N = Integer . parseInt ( str ) ; for ( int i = 0 ; i < N ; i ++ ) { str = br . readLine ( ) ; String [ ] num = str . split ( \" \" , 0 ) ; a = Integer . parseInt ( num [ 0 ] ) ; b = Integer . parseInt ( num [ 1 ] ) ; c = Integer . parseInt ( num [ 2 ] ) ; if ( a >= b && a >= c ) { if ( a * a == b * b + c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else { if ( b >= a && b >= c ) { if ( b * b == a * a + c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else { if ( c >= a && c >= b ) { if ( c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; final int cnt = sc . nextInt ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { Integer side [ ] = new Integer [ 3 ] ; side [ 0 ] = sc . nextInt ( ) ; side [ 1 ] = sc . nextInt ( ) ; side [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( side ) ; if ( ( side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) == side [ 2 ] * side [ 2 ] ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; String line = br . readLine ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] lines = line . split ( \" \" ) ; int a = Integer . parseInt ( lines [ 0 ] ) ; int b = Integer . parseInt ( lines [ 1 ] ) ; int c = Integer . parseInt ( lines [ 2 ] ) ; if ( a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } line = br . readLine ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] strTemp ; int numberOfTriangle , data1 , data2 , data3 ; numberOfTriangle = Integer . parseInt ( in . readLine ( ) ) ; Triangle [ ] triangles = new Triangle [ numberOfTriangle ] ; for ( int i = 0 ; i < numberOfTriangle ; i ++ ) { strTemp = in . readLine ( ) . split ( \" \" ) ; data1 = Integer . parseInt ( strTemp [ 0 ] ) ; data2 = Integer . parseInt ( strTemp [ 1 ] ) ; data3 = Integer . parseInt ( strTemp [ 2 ] ) ; triangles [ i ] = new Triangle ( data1 , data2 , data3 ) ; } for ( int j = 0 ; j < triangles . length ; j ++ ) { if ( triangles [ j ] . check ( ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } class Triangle { private int id , data1 , data2 , data3 , count ; private Triangle [ ] triangles ; public Triangle ( int data1 , int data2 , int data3 ) { this . data1 = data1 ; this . data2 = data2 ; this . data3 = data3 ; } public boolean check ( ) { int temp1 , temp2 , temp3 ; temp1 = ( int ) Math . pow ( data1 , 2 ) ; temp2 = ( int ) Math . pow ( data2 , 2 ) ; temp3 = ( int ) Math . pow ( data3 , 2 ) ; if ( temp1 == temp2 + temp3 || temp2 == temp1 + temp3 || temp3 == temp1 + temp2 ) { return true ; } else { return false ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static int [ ] sort ( int [ ] nums ) { for ( int h = nums . length - 1 ; h > 0 ; h -- ) { for ( int i = 1 ; i <= h ; i ++ ) { if ( nums [ i ] > nums [ i - 1 ] ) { int tmp = nums [ i ] ; nums [ i ] = nums [ i - 1 ] ; nums [ i - 1 ] = tmp ; } } } return nums ; } public static void main ( String [ ] a ) { BufferedReader br ; br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str ; try { str = br . readLine ( ) ; int setNum = Integer . parseInt ( str ) ; for ( int h = 0 ; h < setNum ; h ++ ) { int [ ] num = new int [ 3 ] ; str = br . readLine ( ) ; String [ ] numbers = str . split ( \" \" ) ; for ( int i = 0 ; i < numbers . length ; i ++ ) { num [ i ] = Integer . parseInt ( numbers [ i ] ) ; } num = sort ( num ) ; int answer = ( int ) Math . pow ( num [ 1 ] , 2 ) + ( int ) Math . pow ( num [ 2 ] , 2 ) ; if ( answer == ( Math . pow ( num [ 0 ] , 2 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int firstNumber = scan . nextInt ( ) ; int i [ ] = new int [ 3 ] ; for ( int k = 0 ; k < firstNumber ; k ++ ) { for ( int j = 0 ; j < i . length ; j ++ ) { i [ j ] = scan . nextInt ( ) ; } Arrays . sort ( i ) ; if ( ( i [ 2 ] * i [ 2 ] ) == ( i [ 1 ] * i [ 1 ] ) + ( i [ 0 ] * i [ 0 ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a < b ) { int s = a ; a = b ; b = s ; } if ( a < c ) { int s = a ; a = c ; c = s ; } if ( ( a * a ) == ( ( b * b ) + ( c * c ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int N = scan . nextInt ( ) ; int a , b , c ; for ( int i = 0 ; i < N ; i ++ ) { a = scan . nextInt ( ) ; b = scan . nextInt ( ) ; c = scan . nextInt ( ) ; a = a * a ; b = b * b ; c = c * c ; if ( ( a == b + c ) || ( b == c + a ) || ( c == a + b ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; for ( int j = 0 ; j < N ; j ++ ) { String [ ] arr = br . readLine ( ) . split ( \" \" ) ; int [ ] lens = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { lens [ i ] = Integer . parseInt ( arr [ i ] ) ; } Arrays . sort ( lens ) ; if ( lens [ 2 ] * lens [ 2 ] == lens [ 0 ] * lens [ 0 ] + lens [ 1 ] * lens [ 1 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int a , b , c , n , temp ; Boolean is_changed = true ; n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a = in . nextInt ( ) ; b = in . nextInt ( ) ; c = in . nextInt ( ) ; while ( is_changed == true ) { is_changed = false ; if ( a > b ) { temp = a ; a = b ; b = temp ; is_changed = true ; } if ( b > c ) { temp = b ; b = c ; c = temp ; is_changed = true ; } } if ( a * a + b * b - c * c == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } is_changed = true ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( r . readLine ( ) ) ; StringTokenizer st ; int side [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { st = new StringTokenizer ( r . readLine ( ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { side [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } Arrays . sort ( side ) ; if ( ( side [ 0 ] * side [ 0 ] + side [ 1 ] * side [ 1 ] ) == side [ 2 ] * side [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = Integer . parseInt ( scan . nextLine ( ) ) ; String [ ] input ; int a , b , c ; for ( int i = 0 ; i < n ; i ++ ) { input = scan . nextLine ( ) . split ( \" \" ) ; a = Integer . parseInt ( input [ 0 ] ) ; b = Integer . parseInt ( input [ 1 ] ) ; c = Integer . parseInt ( input [ 2 ] ) ; if ( isRightTriangle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } static boolean isRightTriangle ( int a , int b , int c ) { int a2 = a * a , b2 = b * b , c2 = c * c ; if ( a2 + b2 == c2 || a2 + c2 == b2 || b2 + c2 == a2 ) { return true ; } return false ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { ArrayList < Integer > side ; String line = br . readLine ( ) ; int x = Integer . parseInt ( line ) ; StringTokenizer tokens ; for ( int i = 0 ; i < x ; i ++ ) { line = br . readLine ( ) ; tokens = new StringTokenizer ( line ) ; side = new ArrayList < > ( ) ; side . add ( Integer . parseInt ( tokens . nextToken ( ) ) ) ; side . add ( Integer . parseInt ( tokens . nextToken ( ) ) ) ; side . add ( Integer . parseInt ( tokens . nextToken ( ) ) ) ; Collections . sort ( side ) ; if ( side . get ( 0 ) * side . get ( 0 ) + side . get ( 1 ) * side . get ( 1 ) == side . get ( 2 ) * side . get ( 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( Exception e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { List < List < Integer > > userInputs = getUserInputs ( ) ; for ( List < Integer > triangleSides : userInputs ) { boolean isRightAngleTrangle = isRightAngleTraingle ( triangleSides ) ; if ( isRightAngleTrangle ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } private static boolean isRightAngleTraingle ( List < Integer > intList ) { if ( intList == null || intList . isEmpty ( ) || intList . size ( ) != 3 ) { return false ; } Collections . sort ( intList ) ; int aSide = intList . get ( 0 ) ; int bSide = intList . get ( 1 ) ; int cSide = intList . get ( 2 ) ; if ( ( cSide * cSide ) == ( ( aSide * aSide ) + ( bSide * bSide ) ) ) { return true ; } return false ; } private static List < List < Integer > > getUserInputs ( ) { int repetation = 0 ; List < List < Integer > > returnList = new ArrayList < > ( ) ; List < String > userList = new ArrayList < String > ( ) ; { Scanner in = new Scanner ( System . in ) ; String sNum = in . nextLine ( ) ; repetation = Integer . parseInt ( sNum ) ; for ( int i = 0 ; i < repetation ; i ++ ) { userList . add ( in . nextLine ( ) ) ; } } { for ( String input : userList ) { input = input . trim ( ) ; if ( input . length ( ) == 0 ) { continue ; } String array [ ] = input . split ( \" \\\\ s+ \" ) ; ArrayList < Integer > intList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { String num = array [ i ] ; intList . add ( Integer . parseInt ( num . trim ( ) ) ) ; } returnList . add ( intList ) ; } } return returnList ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] s = br . readLine ( ) . split ( \" \" ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) { list . add ( Integer . parseInt ( s [ j ] ) ) ; } Collections . sort ( list ) ; int a = list . get ( 0 ) ; int b = list . get ( 1 ) ; int c = list . get ( 2 ) ; if ( a * a + b * b == c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int count = sc . nextInt ( ) ; if ( count <= 1000 ) { String [ ] triangles = new String [ count ] ; for ( int j = 0 ; j < count ; j ++ ) { int side1 = sc . nextInt ( ) ; int side2 = sc . nextInt ( ) ; int side3 = sc . nextInt ( ) ; if ( side1 >= 1 && side1 <= 1000 ) { if ( side2 >= 1 && side2 <= 1000 ) { if ( side3 >= 1 && side3 <= 1000 ) { String result = isRightTriangle ( side1 , side2 , side3 ) ; triangles [ j ] = result ; } } } } for ( int k = 0 ; k < count ; k ++ ) { System . out . println ( triangles [ k ] ) ; } } } private static String isRightTriangle ( int s1 , int s2 , int s3 ) { String test = \" NO \" ; if ( ( s1 * s1 ) == ( s2 * s2 ) + ( s3 * s3 ) ) { test = \" YES \" ; } else if ( ( s2 * s2 ) == ( s1 * s1 ) + ( s3 * s3 ) ) { test = \" YES \" ; } else if ( ( s3 * s3 ) == ( s1 * s1 ) + ( s2 * s2 ) ) { test = \" YES \" ; } return test ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { StringBuffer sb = new StringBuffer ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; double a , b , c ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] str = ( br . readLine ( ) ) . split ( \" \" ) ; a = Math . pow ( Integer . parseInt ( str [ 0 ] ) , 2 ) ; b = Math . pow ( Integer . parseInt ( str [ 1 ] ) , 2 ) ; c = Math . pow ( Integer . parseInt ( str [ 2 ] ) , 2 ) ; if ( a + b == c || a + c == b || b + c == a ) { sb . append ( \" YES \\n \" ) ; } else { sb . append ( \" NO \\n \" ) ; } } System . out . print ( sb ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { StringBuilder sb = new StringBuilder ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; double a , b , c ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] str = ( br . readLine ( ) ) . split ( \" \" ) ; a = Math . pow ( Integer . parseInt ( str [ 0 ] ) , 2 ) ; b = Math . pow ( Integer . parseInt ( str [ 1 ] ) , 2 ) ; c = Math . pow ( Integer . parseInt ( str [ 2 ] ) , 2 ) ; if ( a + b == c || a + c == b || b + c == a ) { sb . append ( \" YES \\n \" ) ; } else { sb . append ( \" NO \\n \" ) ; } } System . out . print ( sb ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int z = sc . nextInt ( ) ; int [ ] num = new int [ 3 ] ; for ( int i = 0 ; i < z ; i ++ ) { for ( int j = 0 ; j < num . length ; j ++ ) { num [ j ] = sc . nextInt ( ) ; } Arrays . sort ( num ) ; if ( num [ 0 ] * num [ 0 ] + num [ 1 ] * num [ 1 ] == num [ 2 ] * num [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] sides = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { sides [ 0 ] = scanner . nextInt ( ) ; sides [ 1 ] = scanner . nextInt ( ) ; sides [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( sides ) ; System . out . println ( sides [ 0 ] * sides [ 0 ] + sides [ 1 ] * sides [ 1 ] == sides [ 2 ] * sides [ 2 ] ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int x ; int y ; int z ; String line = br . readLine ( ) ; line = br . readLine ( ) ; while ( line != null ) { String strArray [ ] = line . split ( \" \" ) ; x = Integer . valueOf ( strArray [ 0 ] ) ; y = Integer . valueOf ( strArray [ 1 ] ) ; z = Integer . valueOf ( strArray [ 2 ] ) ; String Anser = \" NO \" ; if ( x * x == ( y * y + z * z ) || ( y * y == ( x * x + z * z ) ) || ( z * z == ( y * y + x * x ) ) ) { Anser = \" YES \" ; } System . out . println ( Anser ) ; line = br . readLine ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int N = s . nextInt ( ) ; s . nextLine ( ) ; int [ ] [ ] a = new int [ N ] [ 3 ] ; String str ; String [ ] result ; for ( int i = 0 ; i < N ; i ++ ) { result = s . nextLine ( ) . split ( \" \" ) ; for ( int j = 0 ; j < a [ i ] . length ; j ++ ) { a [ i ] [ j ] = Integer . parseInt ( result [ j ] ) ; } Arrays . sort ( a [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] [ 1 ] * a [ i ] [ 1 ] + a [ i ] [ 0 ] * a [ i ] [ 0 ] - a [ i ] [ 2 ] * a [ i ] [ 2 ] == 0 ) { str = \" YES \" ; } else { str = \" NO \" ; } System . out . println ( str ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] ia = new int [ 3 ] ; ia [ 0 ] = scanner . nextInt ( ) ; ia [ 1 ] = scanner . nextInt ( ) ; ia [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( ia ) ; if ( ia [ 0 ] * ia [ 0 ] + ia [ 1 ] * ia [ 1 ] == ia [ 2 ] * ia [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] it = new int [ 3 ] ; it [ 0 ] = scanner . nextInt ( ) ; it [ 1 ] = scanner . nextInt ( ) ; it [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( it ) ; if ( it [ 0 ] * it [ 0 ] + it [ 1 ] * it [ 1 ] == it [ 2 ] * it [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] it = new int [ 3 ] ; it [ 0 ] = scanner . nextInt ( ) ; it [ 1 ] = scanner . nextInt ( ) ; it [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( it ) ; if ( it [ 0 ] * it [ 0 ] + it [ 1 ] * it [ 1 ] == it [ 2 ] * it [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] it = new int [ 3 ] ; it [ 0 ] = scanner . nextInt ( ) ; it [ 1 ] = scanner . nextInt ( ) ; it [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( it ) ; if ( it [ 0 ] * it [ 0 ] + it [ 1 ] * it [ 1 ] == it [ 2 ] * it [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] it = new int [ 3 ] ; it [ 0 ] = scanner . nextInt ( ) ; it [ 1 ] = scanner . nextInt ( ) ; it [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( it ) ; if ( it [ 0 ] * it [ 0 ] + it [ 1 ] * it [ 1 ] == it [ 2 ] * it [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { try { int a ; int b ; int c ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String s = new String ( reader . readLine ( ) ) ; int setsu = Integer . parseInt ( s ) ; for ( int i = 1 ; i <= setsu ; i ++ ) { String Tri = new String ( reader . readLine ( ) ) ; String [ ] result1 = Tri . split ( \" \" ) ; a = Integer . parseInt ( result1 [ 0 ] ) ; b = Integer . parseInt ( result1 [ 1 ] ) ; c = Integer . parseInt ( result1 [ 2 ] ) ; if ( ( ( a * a ) + ( b * b ) == ( c * c ) ) || ( ( c * c ) + ( b * b ) == ( a * a ) ) || ( ( a * a ) + ( c * c ) == ( b * b ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String line = br . readLine ( ) ; String [ ] str = line . split ( \" \" ) ; int [ ] m = new int [ 3 ] ; int max = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { m [ j ] = Integer . parseInt ( str [ j ] ) ; if ( m [ j ] > max ) max = m [ j ] ; } int tmp = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) if ( m [ j ] != max ) tmp += m [ j ] * m [ j ] ; if ( max * max == tmp ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; ArrayList < String > output = new ArrayList < String > ( ) ; String input ; int n ; try { n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { input = br . readLine ( ) ; int [ ] sides = new int [ 3 ] ; sides [ 0 ] = Integer . parseInt ( input . split ( \" \" ) [ 0 ] ) ; sides [ 1 ] = Integer . parseInt ( input . split ( \" \" ) [ 1 ] ) ; sides [ 2 ] = Integer . parseInt ( input . split ( \" \" ) [ 2 ] ) ; Arrays . sort ( sides ) ; if ( sides [ 2 ] * sides [ 2 ] - sides [ 1 ] * sides [ 1 ] - sides [ 0 ] * sides [ 0 ] == 0 ) { output . add ( \" YES \" ) ; } else { output . add ( \" NO \" ) ; } } for ( String i : output ) { System . out . println ( i ) ; } } catch ( IOException e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int noDataSet = sc . nextInt ( ) ; for ( int i = 0 ; i < noDataSet ; i ++ ) { ArrayList < Integer > nums = new ArrayList < Integer > ( ) ; nums . add ( sc . nextInt ( ) ) ; nums . add ( sc . nextInt ( ) ) ; nums . add ( sc . nextInt ( ) ) ; Collections . sort ( nums ) ; int a = nums . get ( 0 ) ; int b = nums . get ( 1 ) ; int c = nums . get ( 2 ) ; if ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) == Math . pow ( c , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int nDataSets = sc . nextInt ( ) ; for ( int i = 0 ; i < nDataSets ; i ++ ) { ArrayList < Integer > nums = new ArrayList < Integer > ( ) ; nums . add ( sc . nextInt ( ) ) ; nums . add ( sc . nextInt ( ) ) ; nums . add ( sc . nextInt ( ) ) ; Collections . sort ( nums ) ; int a = nums . get ( 0 ) ; int b = nums . get ( 1 ) ; int c = nums . get ( 2 ) ; if ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) == Math . pow ( c , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; import java . util . Stack ; class Main { public static void main ( String [ ] a ) throws IOException { Scanner scan = new Scanner ( System . in ) ; int times = scan . nextInt ( ) ; for ( int i = 0 ; i < times ; i ++ ) { int aa = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int c = scan . nextInt ( ) ; int twoa = aa * aa ; int twob = b * b ; int twoc = c * c ; if ( twoa == twoc + twob ) { System . out . println ( \" YES \" ) ; } else if ( twob == twoc + twoa ) { System . out . println ( \" YES \" ) ; } else if ( twoc == twob + twoa ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; boolean tri [ ] = new boolean [ N ] ; int a , b , c , x ; for ( int i = 0 ; i < N ; i ++ ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; c = sc . nextInt ( ) ; if ( a < b ) { x = a ; a = b ; b = x ; } if ( a < c ) { x = a ; a = c ; c = x ; } if ( a * a == ( b * b ) + ( c * c ) ) { tri [ i ] = true ; } else { tri [ i ] = false ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( tri [ i ] == true ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String args [ ] ) { int n ; int sides [ ] = new int [ 3 ] ; boolean judge = false ; String line ; String tmp [ ] ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { line = reader . readLine ( ) ; n = Integer . parseInt ( line ) ; for ( int i = 0 ; i < n ; i ++ ) { line = reader . readLine ( ) ; tmp = line . split ( \" \" ) ; for ( int j = 0 ; j < sides . length ; j ++ ) { sides [ j ] = Integer . parseInt ( tmp [ j ] ) ; sides [ j ] *= sides [ j ] ; } for ( int j = 0 ; j < sides . length ; j ++ ) { if ( sides [ j % 3 ] == sides [ ( j + 1 ) % 3 ] + sides [ ( j + 2 ) % 3 ] ) { judge = true ; break ; } else judge = false ; } Answer ( judge ) ; } } catch ( IOException e ) { System . exit ( 0 ) ; } } static void Answer ( boolean j ) { if ( j ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n , s = 0 ; String [ ] str ; long [ ] hen = new long [ 3 ] ; n = Integer . parseInt ( br . readLine ( ) ) ; StringBuilder out = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { str = br . readLine ( ) . split ( \" \" ) ; long max = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { hen [ j ] = Integer . parseInt ( str [ j ] ) ; if ( max < hen [ j ] ) { max = hen [ j ] ; s = j ; } } hen [ s ] = 0 ; if ( max * max == hen [ 0 ] * hen [ 0 ] + hen [ 1 ] * hen [ 1 ] + hen [ 2 ] * hen [ 2 ] ) { out . append ( \" YES \" + \" \\n \" ) ; } else out . append ( \" NO \" + \" \\n \" ) ; } out . delete ( out . length ( ) - 1 , out . length ( ) ) ; System . out . println ( out ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; public class Main { public static void main ( String [ ] args ) throws IOException { InputStreamReader isr = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( isr ) ; PrintWriter out = new PrintWriter ( System . out ) ; String line ; String [ ] numList = new String [ 2 ] ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { line = br . readLine ( ) ; numList = line . split ( \" \" ) ; double num0 = Math . pow ( Double . parseDouble ( numList [ 0 ] ) , 2 ) ; double num1 = Math . pow ( Double . parseDouble ( numList [ 1 ] ) , 2 ) ; double num2 = Math . pow ( Double . parseDouble ( numList [ 2 ] ) , 2 ) ; if ( ( num2 == num0 + num1 ) || ( num0 == num1 + num2 ) || ( num1 == num0 + num2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; boolean bo = isTriangle ( a , b , c ) || isTriangle ( b , c , a ) || isTriangle ( c , a , b ) ; if ( bo ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static boolean isTriangle ( int a , int b , int c ) { return Math . sqrt ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) == c ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str ; StringTokenizer st1 ; int [ ] tri = new int [ 3 ] ; str = br . readLine ( ) ; int count = Integer . parseInt ( str ) ; for ( int i = 0 ; i < count ; i ++ ) { st1 = new StringTokenizer ( br . readLine ( ) , \" \" ) ; tri [ 0 ] = Integer . parseInt ( st1 . nextToken ( ) ) ; tri [ 1 ] = Integer . parseInt ( st1 . nextToken ( ) ) ; tri [ 2 ] = Integer . parseInt ( st1 . nextToken ( ) ) ; sortTri ( tri ) ; if ( tri [ 0 ] * tri [ 0 ] + tri [ 1 ] * tri [ 1 ] == tri [ 2 ] * tri [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static void sortTri ( int [ ] num ) { int tmp ; for ( int i = 0 ; i < num . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < num . length ; j ++ ) { if ( num [ i ] > num [ j ] ) { tmp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = tmp ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . io . IOException ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = br . readLine ( ) ; double a = Math . pow ( Double . parseDouble ( s . split ( \" \" ) [ 0 ] ) , 2 ) ; double b = Math . pow ( Double . parseDouble ( s . split ( \" \" ) [ 1 ] ) , 2 ) ; double c = Math . pow ( Double . parseDouble ( s . split ( \" \" ) [ 2 ] ) , 2 ) ; if ( a + b == c ) { System . out . println ( \" YES \" ) ; } else if ( a + c == b ) { System . out . println ( \" YES \" ) ; } else if ( b + c == a ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; public class Main { public static void main ( String [ ] a ) { BufferedReader stdin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int numDS = - 1 ; int aSide = - 1 ; int bSide = - 1 ; int cSide = - 1 ; ArrayList < String > results = new ArrayList < String > ( ) ; try { while ( ( line = stdin . readLine ( ) ) != null && line . length ( ) != 0 ) { String [ ] checker = line . split ( \" \" ) ; if ( checker . length == 1 ) { numDS = Integer . parseInt ( checker [ 0 ] ) ; } else if ( checker . length == 3 ) { int temp1 = Integer . parseInt ( checker [ 0 ] ) ; int temp2 = Integer . parseInt ( checker [ 1 ] ) ; int temp3 = Integer . parseInt ( checker [ 2 ] ) ; if ( temp1 < 1 || temp1 > 1000 || temp2 < 1 || temp2 > 1000 || temp3 < 1 || temp3 > 1000 ) { results . add ( \" NO \" ) ; } else { if ( temp1 > temp2 && temp1 > temp3 ) { cSide = temp1 ; aSide = temp2 ; bSide = temp3 ; } else if ( temp2 > temp1 && temp2 > temp3 ) { cSide = temp2 ; aSide = temp1 ; bSide = temp3 ; } else { cSide = temp3 ; aSide = temp2 ; bSide = temp1 ; } if ( ( cSide * cSide ) == ( ( aSide * aSide ) + ( bSide * bSide ) ) ) { results . add ( \" YES \" ) ; } else { results . add ( \" NO \" ) ; } if ( results . size ( ) == numDS ) { break ; } } } } for ( String s : results ) { System . out . println ( s ) ; } } catch ( NumberFormatException e ) { } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; class Main { public static void main ( String [ ] a ) throws NumberFormatException , IOException { BufferedReader stdin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int numDS = - 1 ; int aSide = - 1 ; int bSide = - 1 ; int cSide = - 1 ; ArrayList < String > results = new ArrayList < String > ( ) ; while ( ( line = stdin . readLine ( ) ) != null && line . length ( ) != 0 ) { String [ ] checker = line . split ( \" \" ) ; if ( checker . length == 1 ) { numDS = Integer . parseInt ( checker [ 0 ] ) ; } else if ( checker . length == 3 ) { int temp1 = Integer . parseInt ( checker [ 0 ] ) ; int temp2 = Integer . parseInt ( checker [ 1 ] ) ; int temp3 = Integer . parseInt ( checker [ 2 ] ) ; if ( temp1 < 1 || temp1 > 1000 || temp2 < 1 || temp2 > 1000 || temp3 < 1 || temp3 > 1000 ) { results . add ( \" NO \" ) ; } else { if ( temp1 > temp2 && temp1 > temp3 ) { cSide = temp1 ; aSide = temp2 ; bSide = temp3 ; } else if ( temp2 > temp1 && temp2 > temp3 ) { cSide = temp2 ; aSide = temp1 ; bSide = temp3 ; } else { cSide = temp3 ; aSide = temp2 ; bSide = temp1 ; } if ( ( cSide * cSide ) == ( ( aSide * aSide ) + ( bSide * bSide ) ) ) { results . add ( \" YES \" ) ; } else { results . add ( \" NO \" ) ; } if ( results . size ( ) == numDS ) { break ; } } } } for ( String s : results ) { System . out . println ( s ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { private static final int subNum = 3 ; private static final int adge1 = 0 ; private static final int adge2 = 1 ; private static final int adge3 = 2 ; public static void main ( String [ ] a ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int num = Integer . parseInt ( br . readLine ( ) ) ; int [ ] [ ] tryangle = new int [ num ] [ subNum ] ; for ( int i = 0 ; i < num ; i ++ ) { String str = br . readLine ( ) ; String [ ] strBuf = str . split ( \" \" ) ; for ( int j = 0 ; j < subNum ; j ++ ) { tryangle [ i ] [ j ] = Integer . parseInt ( strBuf [ j ] ) ; } } int x , y , z ; for ( int i = 0 ; i < num ; i ++ ) { x = tryangle [ i ] [ adge1 ] * tryangle [ i ] [ adge1 ] ; y = tryangle [ i ] [ adge2 ] * tryangle [ i ] [ adge2 ] ; z = tryangle [ i ] [ adge3 ] * tryangle [ i ] [ adge3 ] ; if ( ( ( x + y ) == z ) || ( ( y + z ) == x ) || ( ( x + z ) == y ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] [ ] t = new int [ N ] [ 3 ] ; int tmp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { t [ i ] [ j ] = sc . nextInt ( ) ; if ( j == 1 && t [ i ] [ 0 ] > t [ i ] [ 1 ] ) { tmp = t [ i ] [ 0 ] ; t [ i ] [ 0 ] = t [ i ] [ 1 ] ; t [ i ] [ 1 ] = tmp ; } if ( j == 2 && t [ i ] [ 1 ] > t [ i ] [ 2 ] ) { tmp = t [ i ] [ 1 ] ; t [ i ] [ 1 ] = t [ i ] [ 2 ] ; t [ i ] [ 2 ] = tmp ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( t [ i ] [ 0 ] * t [ i ] [ 0 ] + t [ i ] [ 1 ] * t [ i ] [ 1 ] == t [ i ] [ 2 ] * t [ i ] [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . lang . reflect . Array ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { int num = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < num ; i ++ ) { String [ ] in = br . readLine ( ) . split ( \" \" , 0 ) ; int [ ] data = { Integer . parseInt ( in [ 0 ] ) , Integer . parseInt ( in [ 1 ] ) , Integer . parseInt ( in [ 2 ] ) } ; Arrays . sort ( data ) ; if ( data [ 2 ] * data [ 2 ] == data [ 1 ] * data [ 1 ] + data [ 0 ] * data [ 0 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( Exception e ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] x , y , z ; int swap ; int n = scan . nextInt ( ) ; x = new int [ n ] ; y = new int [ n ] ; z = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = scan . nextInt ( ) ; y [ i ] = scan . nextInt ( ) ; z [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] * x [ i ] + y [ i ] * y [ i ] == z [ i ] * z [ i ] || x [ i ] * x [ i ] + z [ i ] * z [ i ] == y [ i ] * y [ i ] || z [ i ] * z [ i ] + y [ i ] * y [ i ] == x [ i ] * x [ i ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . stream . Stream ; import static java . util . stream . Collectors . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( br . lines ( ) . skip ( 1 ) . map ( s -> Stream . of ( s . split ( \" \" ) ) . mapToInt ( Integer :: parseInt ) . sorted ( ) . toArray ( ) ) . map ( i -> Math . pow ( i [ 0 ] , 2 ) + Math . pow ( i [ 1 ] , 2 ) == Math . pow ( i [ 2 ] , 2 ) ) . map ( b -> b ? \" YES \" : \" NO \" ) . collect ( joining ( \" \\n \" ) ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; import java . util . stream . Stream ; import static java . util . stream . Collectors . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( br . lines ( ) . skip ( 1 ) . map ( s -> Stream . of ( s . split ( \" \" ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ) . map ( i -> { Arrays . sort ( i ) ; return i ; } ) . map ( i -> Math . pow ( i [ 0 ] , 2 ) + Math . pow ( i [ 1 ] , 2 ) == Math . pow ( i [ 2 ] , 2 ) ) . map ( b -> b ? \" YES \" : \" NO \" ) . collect ( joining ( \" \\n \" ) ) ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int a = 0 , b = 0 , c = 0 ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; if ( x > y ) { int t = x ; x = y ; y = t ; } int z = sc . nextInt ( ) ; if ( z < x ) { a = z ; b = x ; c = y ; } else if ( z < y ) { a = x ; b = z ; c = y ; } else { a = x ; b = y ; c = z ; } if ( a * a + b * b == c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int x , y , z ; int yn [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x = scan . nextInt ( ) ; y = scan . nextInt ( ) ; z = scan . nextInt ( ) ; if ( x * x + y * y == z * z || x * x + z * z == y * y || y * y + z * z == x * x ) yn [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( yn [ i ] == 1 ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; String [ ] s ; int a , b , c ; for ( int i = 0 ; i < n ; ++ i ) { s = br . readLine ( ) . split ( \" \" ) ; a = Integer . parseInt ( s [ 0 ] ) ; b = Integer . parseInt ( s [ 1 ] ) ; c = Integer . parseInt ( s [ 2 ] ) ; if ( a * a == b * b + c * c || b * b == c * c + a * a || c * c == a * a + b * b ) { sb . append ( \" YES \\n \" ) ; } else { sb . append ( \" NO \\n \" ) ; } } System . out . print ( sb ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] a = new int [ 1000 ] ; int [ ] b = new int [ 1000 ] ; int [ ] c = new int [ 1000 ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; c [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] * a [ i ] == ( b [ i ] * b [ i ] + c [ i ] * c [ i ] ) || b [ i ] * b [ i ] == ( a [ i ] * a [ i ] + c [ i ] * c [ i ] ) || c [ i ] * c [ i ] == ( b [ i ] * b [ i ] + a [ i ] * a [ i ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int [ ] x , y , z ; int n = scan . nextInt ( ) ; ; x = new int [ n ] ; y = new int [ n ] ; z = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = scan . nextInt ( ) ; y [ i ] = scan . nextInt ( ) ; z [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] * x [ i ] + y [ i ] * y [ i ] == z [ i ] * z [ i ] || x [ i ] * x [ i ] + z [ i ] * z [ i ] == y [ i ] * y [ i ] || z [ i ] * z [ i ] + y [ i ] * y [ i ] == x [ i ] * x [ i ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \" ) ; int array [ ] = new int [ 3 ] ; for ( int j = 0 ; j < array . length ; j ++ ) array [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; Arrays . sort ( array ) ; if ( Math . pow ( array [ 0 ] , 2 ) + Math . pow ( array [ 1 ] , 2 ) == Math . pow ( array [ 2 ] , 2 ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int x = Integer . parseInt ( br . readLine ( ) ) ; int i = 0 ; while ( i < x ) { String str = br . readLine ( ) ; String [ ] num = str . split ( \" \" , 0 ) ; ArrayList < Integer > al = new ArrayList < > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { al . add ( Integer . parseInt ( num [ j ] ) ) ; } Collections . sort ( al ) ; int a = al . get ( 0 ) ; int b = al . get ( 1 ) ; int c = al . get ( 2 ) ; if ( c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } i ++ ; } } catch ( IOException ex ) { System . out . println ( \" error \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] arg ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = br . readLine ( ) ; int count = Integer . parseInt ( str ) ; for ( int i = 0 ; i < count ; i ++ ) { str = br . readLine ( ) ; String [ ] datasetstr = str . split ( \" \" , 3 ) ; int [ ] datasetint = new int [ 3 ] ; for ( int j = 0 ; j <= 2 ; j ++ ) { datasetint [ j ] = Integer . parseInt ( datasetstr [ j ] ) ; } for ( int k = 0 ; k <= 1 ; k ++ ) { for ( int l = k + 1 ; l <= 2 ; l ++ ) { if ( datasetint [ k ] < datasetint [ l ] ) { int temporary = datasetint [ k ] ; datasetint [ k ] = datasetint [ l ] ; datasetint [ l ] = temporary ; } } } int cc = datasetint [ 0 ] * datasetint [ 0 ] ; int aa = datasetint [ 1 ] * datasetint [ 1 ] ; int bb = datasetint [ 2 ] * datasetint [ 2 ] ; Boolean isRight = cc == ( aa + bb ) ; if ( isRight ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int in0 = scan . nextInt ( ) ; for ( int i = 0 ; i < in0 ; i ++ ) { int x = scan . nextInt ( ) ; int y = scan . nextInt ( ) ; int z = scan . nextInt ( ) ; int x2 = ( int ) Math . pow ( x , 2 ) ; int y2 = ( int ) Math . pow ( y , 2 ) ; int z2 = ( int ) Math . pow ( z , 2 ) ; boolean sw = false ; if ( x2 == ( y2 + z2 ) ) sw = true ; if ( y2 == ( x2 + z2 ) ) sw = true ; if ( z2 == ( y2 + x2 ) ) sw = true ; if ( sw ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] a = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { a [ j ] = scanner . nextInt ( ) ; } for ( int j = 1 ; j < 3 ; j ++ ) { if ( a [ 0 ] < a [ j ] ) { int buf = a [ 0 ] ; a [ 0 ] = a [ j ] ; a [ j ] = buf ; } } System . out . println ( ( a [ 0 ] * a [ 0 ] == a [ 1 ] * a [ 1 ] + a [ 2 ] * a [ 2 ] ) ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int line = scan . nextInt ( ) ; int i = 1 ; while ( i <= line ) { int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int c = scan . nextInt ( ) ; if ( a * a + b * b == c * c || b * b + c * c == a * a || a * a + c * c == b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } i ++ ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int count = Integer . parseInt ( br . readLine ( ) ) ; int [ ] data = new int [ 3 ] ; for ( int i = 0 ; i < count ; i ++ ) { String [ ] str = br . readLine ( ) . split ( \" \" ) ; for ( int k = 0 ; k < 3 ; k ++ ) { data [ k ] = Integer . parseInt ( str [ k ] ) ; } int maxIndex = 0 ; for ( int k = 1 ; k < 3 ; k ++ ) { if ( data [ k ] > data [ maxIndex ] ) { maxIndex = k ; } } int tmp = data [ maxIndex ] ; data [ maxIndex ] = data [ 0 ] ; data [ 0 ] = tmp ; if ( data [ 1 ] * data [ 1 ] + data [ 2 ] * data [ 2 ] == data [ 0 ] * data [ 0 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static boolean isRTri ( int a , int b , int c ) { return a * a + b * b == c * c ; } public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; for ( int k = 1 ; k <= n ; k ++ ) { int a [ ] = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = input . nextInt ( ) ; } Arrays . sort ( a ) ; boolean r = isRTri ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) ; System . out . printf ( \" %s \\n \" , r ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String number = br . readLine ( ) ; String s = br . readLine ( ) ; StringTokenizer st ; int count = 0 ; ArrayList < String > list = new ArrayList < > ( ) ; while ( ! ( s == null || \" \" . equals ( s ) ) ) { st = new StringTokenizer ( s ) ; Integer [ ] tri = new Integer [ 3 ] ; tri [ 0 ] = Integer . parseInt ( st . nextToken ( ) ) ; tri [ 1 ] = Integer . parseInt ( st . nextToken ( ) ) ; tri [ 2 ] = Integer . parseInt ( st . nextToken ( ) ) ; Arrays . sort ( tri , Collections . reverseOrder ( ) ) ; String yesno = new String ( ) ; yesno = \" NO \" ; double compare = Math . pow ( tri [ 0 ] , 2 ) - Math . pow ( tri [ 1 ] , 2 ) - Math . pow ( tri [ 2 ] , 2 ) ; if ( compare == 0 ) { yesno = \" YES \" ; } list . add ( count ++ , yesno ) ; s = br . readLine ( ) ; } for ( String string : list ) { System . out . println ( string ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int lim = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < lim ; i ++ ) { String [ ] values = in . readLine ( ) . split ( \" \" ) ; int a = Integer . parseInt ( values [ 0 ] ) ; int b = Integer . parseInt ( values [ 1 ] ) ; int c = Integer . parseInt ( values [ 2 ] ) ; int x = a * a ; int y = b * b ; int z = c * c ; if ( ( ( x + y ) == z ) || ( ( y + z ) == x ) || ( ( z + x ) == y ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int lim = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < lim ; i ++ ) { String [ ] values = in . readLine ( ) . split ( \" \" ) ; int a = Integer . parseInt ( values [ 0 ] ) ; int b = Integer . parseInt ( values [ 1 ] ) ; int c = Integer . parseInt ( values [ 2 ] ) ; int x = a * a ; int y = b * b ; int z = c * c ; if ( ( ( x + y ) == z ) || ( ( y + z ) == x ) || ( ( z + x ) == y ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; boolean [ ] judge = new boolean [ n ] ; if ( n > 1000 ) n = 1000 ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) , c = sc . nextInt ( ) ; judge [ i ] = ( a * a + b * b == c * c ) || ( a * a + c * c == b * b ) || ( b * b + c * c == a * a ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( judge [ i ] ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static final Scanner scan = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = scan . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int c = scan . nextInt ( ) ; if ( a * a == b * b + c * c | b * b == a * a + c * c | c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static final Scanner scan = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; boolean flag = false ; int [ ] tri = new int [ 3 ] ; int N = scan . nextInt ( ) ; for ( int a = 0 ; a < N ; a ++ ) { for ( int i = 0 ; i < 3 ; i ++ ) { tri [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 3 - 1 ; i ++ ) { for ( int j = 3 - 1 ; j > i ; j -- ) { if ( tri [ i ] < tri [ j ] ) { int big = tri [ j ] ; tri [ j ] = tri [ i ] ; tri [ i ] = big ; } } } if ( Math . pow ( tri [ 0 ] , 2 ) == Math . pow ( tri [ 1 ] , 2 ) + Math . pow ( tri [ 2 ] , 2 ) ) { flag = true ; } else { flag = false ; } list . add ( flag ? \" YES \" : \" NO \" ) ; } for ( String s : list ) { System . out . println ( s ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { private static final Scanner scan = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; int [ ] tri = new int [ 3 ] ; boolean flag = false ; int N = scan . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { tri [ j ] = scan . nextInt ( ) ; } for ( int j = 0 ; j < tri . length - 1 ; j ++ ) { for ( int k = tri . length - 1 ; k > j ; k -- ) { if ( tri [ j ] < tri [ k ] ) { int big = tri [ k ] ; tri [ k ] = tri [ j ] ; tri [ j ] = big ; } } } if ( Math . pow ( tri [ 0 ] , 2 ) == Math . pow ( tri [ 1 ] , 2 ) + Math . pow ( tri [ 2 ] , 2 ) ) { flag = true ; } else { flag = false ; } list . add ( flag ? \" YES \" : \" NO \" ) ; } for ( String s : list ) { System . out . printf ( \" %s \\n \" , s ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; int [ ] edges = new int [ 3 ] ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] str = br . readLine ( ) . split ( \" \" ) ; for ( int j = 0 ; j < 3 ; j ++ ) { edges [ j ] = Integer . parseInt ( str [ j ] ) ; } Arrays . sort ( edges ) ; if ( Math . pow ( edges [ 2 ] , 2 ) == Math . pow ( edges [ 0 ] , 2 ) + Math . pow ( edges [ 1 ] , 2 ) ) { sb . append ( \" YES \" ) . append ( \" \\n \" ) ; } else { sb . append ( \" NO \" ) . append ( \" \\n \" ) ; } } System . out . print ( sb ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; class Main { public static void main ( String [ ] a ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; int [ ] hen = new int [ 3 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int x = 0 ; x < 3 ; x ++ ) { hen [ x ] = scanner . nextInt ( ) ; } Arrays . sort ( hen ) ; if ( ( hen [ 2 ] * hen [ 2 ] ) == ( hen [ 0 ] * hen [ 0 ] + hen [ 1 ] * hen [ 1 ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner kb = new Scanner ( System . in ) ; int i , N , x , y , z , longest ; N = kb . nextInt ( ) ; for ( i = 0 ; i < N ; i ++ ) { x = kb . nextInt ( ) ; y = kb . nextInt ( ) ; z = kb . nextInt ( ) ; longest = x ; if ( longest < y ) { longest = y ; } if ( longest < z ) { longest = z ; } if ( longest == x ) { if ( ( x * x ) == ( y * y + z * z ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( longest == y ) { if ( ( y * y ) == ( x * x + z * z ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( longest == z ) { if ( ( z * z ) == ( x * x + y * y ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String gyosu = scan . next ( ) ; int intgyosu = Integer . parseInt ( gyosu ) ; String [ ] yesno ; yesno = new String [ intgyosu ] ; for ( int i = 1 ; i <= intgyosu ; i ++ ) { String num1 = scan . next ( ) ; int int1 = Integer . parseInt ( num1 ) ; String num2 = scan . next ( ) ; int int2 = Integer . parseInt ( num2 ) ; String num3 = scan . next ( ) ; int int3 = Integer . parseInt ( num3 ) ; int maxnum = Math . max ( int1 , int2 ) ; int max_num = Math . max ( maxnum , int3 ) ; boolean hantei = false ; if ( max_num == int1 ) { hantei = ( int2 * int2 ) + ( int3 * int3 ) == ( int1 * int1 ) ; } else if ( max_num == int2 ) { hantei = ( int1 * int1 ) + ( int3 * int3 ) == ( int2 * int2 ) ; } else if ( max_num == int3 ) { hantei = ( int2 * int2 ) + ( int1 * int1 ) == ( int3 * int3 ) ; } if ( hantei ) { yesno [ i - 1 ] = \" YES \" ; } else { yesno [ i - 1 ] = \" NO \" ; } } scan . close ( ) ; for ( int j = 0 ; j < intgyosu ; j ++ ) { System . out . println ( yesno [ j ] ) ; } } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String [ ] args ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a >= b && a >= c ) { if ( a * a == b * b + c * c ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } else if ( b >= c && b >= a ) { if ( b * b == c * c + a * a ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } else { if ( c * c == a * a + b * b ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int num = scanner . nextInt ( ) ; for ( int i = 0 ; i < num ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; if ( isRightTriAngle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } static boolean isRightTriAngle ( int side_a , int side_b , int side_c ) { int [ ] sides = { side_a , side_b , side_c } ; Arrays . sort ( sides ) ; int a_2 = ( int ) Math . pow ( sides [ 0 ] , 2 ) ; int b_2 = ( int ) Math . pow ( sides [ 1 ] , 2 ) ; int c_2 = ( int ) Math . pow ( sides [ 2 ] , 2 ) ; return a_2 + b_2 == c_2 ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( System . in ) ) { solve ( in ) ; } } private static void solve ( Scanner in ) { int N = in . nextInt ( ) ; while ( N -- > 0 ) { int a = in . nextInt ( ) , b = in . nextInt ( ) , c = in . nextInt ( ) ; int A = a * a , B = b * b , C = c * c ; boolean isRight ; if ( A > B && A > C ) { isRight = A == B + C ; } else if ( B > A && B > C ) { isRight = B == A + C ; } else { isRight = C == A + B ; } System . out . println ( isRight ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String name = br . readLine ( ) ; int kaz = Integer . parseInt ( name ) ; int num ; int compare ; int [ ] a = new int [ 3 ] ; int big ; int i = 0 ; for ( int j = 0 ; j < kaz ; j ++ ) { name = br . readLine ( ) ; try { StringTokenizer st = new StringTokenizer ( name , \" \" ) ; while ( st . hasMoreTokens ( ) ) { a [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; i ++ ; } i = 0 ; a [ 0 ] *= a [ 0 ] ; a [ 1 ] *= a [ 1 ] ; a [ 2 ] *= a [ 2 ] ; big = Math . max ( ( Math . max ( a [ 0 ] , a [ 1 ] ) ) , ( Math . max ( a [ 0 ] , a [ 2 ] ) ) ) ; if ( big == a [ 0 ] ) { if ( a [ 0 ] == a [ 1 ] + a [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( big == a [ 1 ] ) { if ( a [ 1 ] == a [ 2 ] + a [ 0 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( big == a [ 2 ] ) { if ( a [ 2 ] == a [ 1 ] + a [ 0 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } a [ 0 ] = 0 ; a [ 1 ] = 0 ; a [ 2 ] = 0 ; } catch ( Exception e ) { System . exit ( 0 ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String num1 = br . readLine ( ) ; StringBuilder bf = new StringBuilder ( ) ; int [ ] num = new int [ 3 ] ; for ( int i = 0 ; i < Integer . parseInt ( num1 ) ; i ++ ) { String [ ] str = br . readLine ( ) . split ( \" \" ) ; for ( int k = 0 ; k < 3 ; k ++ ) { num [ k ] = Integer . parseInt ( str [ k ] ) ; } Arrays . sort ( num ) ; if ( num [ 2 ] * num [ 2 ] == ( num [ 1 ] * num [ 1 ] ) + ( num [ 0 ] * num [ 0 ] ) ) { bf . append ( \" YES \" ) . append ( \" \\n \" ) ; } else { bf . append ( \" NO \" ) . append ( \" \\n \" ) ; } } System . out . print ( bf ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int length = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < length ; i ++ ) { String [ ] num = br . readLine ( ) . split ( \" \" ) ; int a = Integer . parseInt ( num [ 0 ] ) ; int b = Integer . parseInt ( num [ 1 ] ) ; int c = Integer . parseInt ( num [ 2 ] ) ; int rightc = a * a + b * b ; int rightb = a * a + c * c ; int righta = b * b + c * c ; if ( c * c == rightc || b * b == rightb || a * a == righta ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a > b && a > c ) { if ( a * a == b * b + c * c ) { System . out . println ( \" YES \" ) ; continue ; } } else if ( b > a && b > c ) { if ( b * b == a * a + c * c ) { System . out . println ( \" YES \" ) ; continue ; } } else if ( c > a && c > b ) { if ( c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; continue ; } } System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] l = new int [ 3 ] ; l [ 0 ] = in . nextInt ( ) ; l [ 1 ] = in . nextInt ( ) ; l [ 2 ] = in . nextInt ( ) ; Arrays . sort ( l ) ; if ( l [ 0 ] * l [ 0 ] + l [ 1 ] * l [ 1 ] == l [ 2 ] * l [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] str = br . readLine ( ) . split ( \" \" ) ; int [ ] sides = new int [ str . length ] ; for ( int j = 0 ; j < str . length ; j ++ ) { sides [ j ] = Integer . parseInt ( str [ j ] ) ; } Arrays . sort ( sides ) ; if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) == Math . pow ( sides [ 2 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String st = br . readLine ( ) ; String [ ] s = st . split ( \" \" , 0 ) ; int [ ] k = new int [ 3 ] ; k [ 0 ] = Integer . parseInt ( s [ 0 ] ) ; k [ 1 ] = Integer . parseInt ( s [ 1 ] ) ; k [ 2 ] = Integer . parseInt ( s [ 2 ] ) ; Arrays . sort ( k ) ; if ( k [ 2 ] * k [ 2 ] == ( k [ 1 ] * k [ 1 ] ) + ( k [ 0 ] * k [ 0 ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } catch ( Exception ex ) { System . exit ( 0 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int N = Integer . valueOf ( scan . nextLine ( ) ) ; while ( N -- > 0 ) { String [ ] data = scan . nextLine ( ) . split ( \" \" , 0 ) ; int num [ ] = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { num [ i ] = Integer . parseInt ( data [ i ] ) ; } num = sortInteger ( num ) ; if ( Math . pow ( num [ 0 ] , 2 ) == Math . pow ( num [ 1 ] , 2 ) + Math . pow ( num [ 2 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static int [ ] sortInteger ( int [ ] num ) { int len = num . length ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { if ( num [ i ] < num [ j ] ) { int tmp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = tmp ; } } } return num ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner kb = new Scanner ( System . in ) ; int size = kb . nextInt ( ) ; int a [ ] [ ] = new int [ size ] [ 3 ] ; int x , y , z ; for ( int i = 0 ; i < size ; i ++ ) { a [ i ] [ 0 ] = kb . nextInt ( ) ; a [ i ] [ 1 ] = kb . nextInt ( ) ; a [ i ] [ 2 ] = kb . nextInt ( ) ; } for ( int i = 0 ; i < size ; i ++ ) { x = a [ i ] [ 0 ] ; y = a [ i ] [ 1 ] ; z = a [ i ] [ 2 ] ; if ( x * x + y * y == z * z || y * y + z * z == x * x || z * z + x * x == y * y ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; while ( scan . hasNext ( ) ) { int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int c = scan . nextInt ( ) ; if ( a * a == b * b + c * c || b * b == a * a + c * c || c * c == b * b + a * a ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int count = Integer . parseInt ( sc . nextLine ( ) ) ; int a = 0 ; int b = 0 ; int c = 0 ; String [ ] req ; for ( int i = 0 ; i < count ; i ++ ) { sc . hasNext ( ) ; String s = sc . nextLine ( ) ; req = s . split ( \" \" ) ; a = Integer . parseInt ( req [ 0 ] ) ; b = Integer . parseInt ( req [ 1 ] ) ; c = Integer . parseInt ( req [ 2 ] ) ; if ( a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner scanner = new Scanner ( System . in ) ; while ( scanner . hasNext ( ) ) { int count = scanner . nextInt ( ) ; for ( int i = 0 ; i < count ; i ++ ) { double a = scanner . nextInt ( ) ; double b = scanner . nextInt ( ) ; double c = scanner . nextInt ( ) ; double d = a * a ; double f = b * b ; double g = c * c ; if ( d == f + g || f == d + g || g == d + f ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . IntStream ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int data_num = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int i = 0 ; i < data_num ; i ++ ) { String [ ] line = sc . nextLine ( ) . split ( \" \" ) ; IntStream intLine = Arrays . stream ( line ) . mapToInt ( Integer :: parseInt ) . sorted ( ) ; int [ ] intAraay = intLine . toArray ( ) ; int a = intAraay [ 0 ] ; int b = intAraay [ 1 ] ; int c = intAraay [ 2 ] ; if ( c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String n = sc . nextLine ( ) ; int N = Integer . parseInt ( n ) ; for ( int i = 0 ; i < N ; i ++ ) { String a = sc . nextLine ( ) ; String [ ] array = a . split ( \" \" ) ; String b = array [ 0 ] ; String c = array [ 1 ] ; int x = Integer . parseInt ( array [ 0 ] ) ; int y = Integer . parseInt ( array [ 1 ] ) ; int z = Integer . parseInt ( array [ 2 ] ) ; if ( x * x + y * y == z * z ) { System . out . println ( \" YES \" ) ; } else if ( x * x + z * z == y * y ) { System . out . println ( \" YES \" ) ; } else if ( y * y + z * z == x * x ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; String M = sc . nextLine ( ) ; int N = Integer . parseInt ( M ) ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] array = sc . nextLine ( ) . split ( \" \" ) ; List < Integer > triangle = new ArrayList < Integer > ( ) ; triangle . add ( Integer . parseInt ( array [ 0 ] ) ) ; triangle . add ( Integer . parseInt ( array [ 1 ] ) ) ; triangle . add ( Integer . parseInt ( array [ 2 ] ) ) ; Collections . sort ( triangle ) ; int A = ( int ) triangle . get ( 0 ) ; int B = ( int ) triangle . get ( 1 ) ; int C = ( int ) triangle . get ( 2 ) ; if ( ( B * B + A * A ) == C * C ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "class Main { public static void main ( String [ ] args ) { java . util . Scanner sc = new java . util . Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n != 0 ) { n -- ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( check ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } static boolean check ( int a , int b , int c ) { if ( a * a == b * b + c * c ) return true ; if ( b * b == c * c + a * a ) return true ; if ( c * c == a * a + b * b ) return true ; return false ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int kosu = sc . nextInt ( ) ; int hen [ ] = new int [ 3 ] ; for ( int j = 0 ; j < kosu ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { int len = sc . nextInt ( ) ; hen [ k ] = len * len ; } Arrays . sort ( hen ) ; if ( ( hen [ 0 ] + hen [ 1 ] ) == hen [ 2 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \" ) ; int a = Integer . parseInt ( input [ 0 ] ) ; int b = Integer . parseInt ( input [ 1 ] ) ; int c = Integer . parseInt ( input [ 2 ] ) ; boolean isRight = false ; if ( a >= c && a >= b ) isRight = ( a * a == b * b + c * c ) ; else if ( b >= c && b >= a ) isRight = ( b * b == c * c + a * a ) ; else if ( c >= a && c >= b ) isRight = ( c * c == a * a + b * b ) ; if ( isRight ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int [ ] a = new int [ 3 ] ; int b = scan . nextInt ( ) ; for ( int j = 0 ; j < b ; j ++ ) { for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = scan . nextInt ( ) ; } Arrays . sort ( a ) ; if ( ( Math . pow ( a [ 0 ] , 2 ) + Math . pow ( a [ 1 ] , 2 ) ) == ( Math . pow ( a [ 2 ] , 2 ) ) ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String args [ ] ) throws NumberFormatException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int dataCount = Integer . parseInt ( reader . readLine ( ) ) ; String [ ] inputDataList = new String [ dataCount ] ; for ( int i = 0 ; i < dataCount ; i ++ ) { inputDataList [ i ] = reader . readLine ( ) ; } for ( int i = 0 ; i < dataCount ; i ++ ) { String [ ] data = inputDataList [ i ] . split ( \" \" ) ; int a = Integer . parseInt ( data [ 0 ] ) ; int b = Integer . parseInt ( data [ 1 ] ) ; int c = Integer . parseInt ( data [ 2 ] ) ; if ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) == Math . pow ( c , 2 ) ) { System . out . println ( \" YES \" ) ; } else if ( Math . pow ( b , 2 ) + Math . pow ( c , 2 ) == Math . pow ( a , 2 ) ) { System . out . println ( \" YES \" ) ; } else if ( Math . pow ( c , 2 ) + Math . pow ( a , 2 ) == Math . pow ( b , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) , c = sc . nextInt ( ) ; switch ( biggestLength ( a , b , c ) ) { case 'a' : if ( isRightTriangle ( a , b , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } break ; case 'b' : if ( isRightTriangle ( b , a , c ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } break ; case 'c' : if ( isRightTriangle ( c , a , b ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } break ; } } } static char biggestLength ( int a , int b , int c ) { if ( a <= b ) { if ( b <= c ) { return 'c' ; } else { return 'b' ; } } else if ( a <= c ) { return 'c' ; } else { return 'a' ; } } static boolean isRightTriangle ( int longest , int other1 , int other2 ) { int longestP = longest * longest ; int other1P = other1 * other1 ; int other2P = other2 * other2 ; return longestP == other2P + other1P ; } }",
    "label": 1
  },
  {
    "code": "import java . util . List ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { IsitATriangle ( ) ; } public static void IsitATriangle ( ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int [ ] triangle = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) triangle [ j ] = scan . nextInt ( ) ; Arrays . sort ( triangle ) ; if ( triangle [ 0 ] * triangle [ 0 ] + triangle [ 1 ] * triangle [ 1 ] == triangle [ 2 ] * triangle [ 2 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] a ) throws IOException { String strLine = \" \" ; BufferedReader stdReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int i = 0 ; int max = 1000 ; String [ ] result = new String [ max ] ; while ( i <= max && ( ( strLine = stdReader . readLine ( ) ) != null ) ) { if ( i == 0 ) { max = Integer . parseInt ( strLine ) ; } else { String [ ] temp = strLine . split ( \" \" , 0 ) ; int [ ] tempInt = new int [ 3 ] ; tempInt [ 0 ] = Integer . parseInt ( temp [ 0 ] ) ; tempInt [ 1 ] = Integer . parseInt ( temp [ 1 ] ) ; tempInt [ 2 ] = Integer . parseInt ( temp [ 2 ] ) ; result [ i - 1 ] = calc ( tempInt ) ; } i ++ ; } if ( i > 1 ) { for ( int j = 0 ; j < max ; j ++ ) { System . out . println ( result [ j ] ) ; } } } public static String calc ( int [ ] tempInt ) { java . util . Arrays . sort ( tempInt ) ; if ( ( tempInt [ 0 ] * tempInt [ 0 ] ) + ( tempInt [ 1 ] * tempInt [ 1 ] ) == ( tempInt [ 2 ] * tempInt [ 2 ] ) ) { return \" YES \" ; } else { return \" NO \" ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { static final Scanner s = new Scanner ( System . in ) ; public static void main ( String args [ ] ) { for ( int i = s . nextInt ( ) ; i > 0 ; i -- ) { int [ ] in = { s . nextInt ( ) , s . nextInt ( ) , s . nextInt ( ) } ; Arrays . sort ( in ) ; System . out . println ( in [ 2 ] * in [ 2 ] == ( in [ 1 ] * in [ 1 ] + in [ 0 ] * in [ 0 ] ) ? \" YES \" : \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import static java . lang . Integer . parseInt ; import static java . lang . Math . pow ; import static java . lang . System . out ; import java . io . File ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { new Main ( ) . right ( ) ; } public void right ( ) { try ( Scanner scan = new Scanner ( System . in ) ) { scanInData ( scan ) ; } catch ( Exception e ) { System . exit ( 0 ) ; } } public void right ( String inDataPath ) { try ( Scanner scan = new Scanner ( new File ( inDataPath ) ) ) { scanInData ( scan ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void scanInData ( Scanner scan ) { int dataCount = parseInt ( scan . nextLine ( ) ) ; for ( int i = 0 ; i < dataCount ; i ++ ) { String [ ] data = scan . nextLine ( ) . split ( \" \" ) ; printJudgeTriangle ( parseInt ( data [ 0 ] ) , parseInt ( data [ 1 ] ) , parseInt ( data [ 2 ] ) ) ; } } public void printJudgeTriangle ( int a , int b , int c ) { if ( judgeTriangle ( a , b , c ) || judgeTriangle ( b , c , a ) || judgeTriangle ( c , a , b ) ) { out . println ( \" YES \" ) ; } else { out . println ( \" NO \" ) ; } } public boolean judgeTriangle ( int x , int y , int z ) { return pow ( x , 2 ) + pow ( y , 2 ) == pow ( z , 2 ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; public class Main { public static int [ ] sort ( String s [ ] ) { int [ ] sides = new int [ s . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) { sides [ i ] = Integer . parseInt ( s [ i ] ) ; } for ( int j = 1 ; j < sides . length ; j ++ ) { if ( sides [ 0 ] < sides [ j ] ) { int n = sides [ 0 ] ; sides [ 0 ] = sides [ j ] ; sides [ j ] = n ; } } return sides ; } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = br . readLine ( ) ; int num = Integer . parseInt ( str ) ; while ( num <= 0 || num > 1000 ) { str = br . readLine ( ) ; num = Integer . parseInt ( str ) ; } String str1 ; String side [ ] [ ] ; side = new String [ num ] [ ] ; int sides [ ] [ ] ; sides = new int [ num ] [ ] ; int a = 0 ; while ( a != num ) { str1 = br . readLine ( ) ; side [ a ] = str1 . split ( \" \" , 3 ) ; sides [ a ] = sort ( side [ a ] ) ; a ++ ; } for ( int k = 0 ; k < num ; k ++ ) { if ( sides [ k ] [ 0 ] * sides [ k ] [ 0 ] == sides [ k ] [ 2 ] * sides [ k ] [ 2 ] + sides [ k ] [ 1 ] * sides [ k ] [ 1 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { final int n = sc . nextInt ( ) ; while ( sc . hasNext ( ) ) { int [ ] x = new int [ 3 ] ; x [ 0 ] = sc . nextInt ( ) ; x [ 1 ] = sc . nextInt ( ) ; x [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( x ) ; boolean isTriangle = ( x [ 0 ] * x [ 0 ] ) + ( x [ 1 ] * x [ 1 ] ) == ( x [ 2 ] * x [ 2 ] ) ; System . out . println ( isTriangle ? \" YES \" : \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = Integer . parseInt ( sc . next ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { int a = Integer . parseInt ( sc . next ( ) ) ; int b = Integer . parseInt ( sc . next ( ) ) ; int c = Integer . parseInt ( sc . next ( ) ) ; if ( a < b ) { a ^= b ; b ^= a ; a ^= b ; } if ( a < c ) { a ^= c ; c ^= a ; a ^= c ; } if ( Math . pow ( a , 2 ) == ( Math . pow ( b , 2 ) + Math . pow ( c , 2 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; br . lines ( ) . skip ( 1 ) . parallel ( ) . map ( line -> Stream . of ( line . split ( \" \" ) ) . mapToInt ( Integer :: parseInt ) . map ( n -> n * n ) . sorted ( ) . toArray ( ) ) . map ( ar -> ( ar [ 0 ] + ar [ 1 ] == ar [ 2 ] ) ? \" YES \" : \" NO \" ) . sequential ( ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; br . lines ( ) . skip ( 1 ) . parallel ( ) . map ( line -> Stream . of ( line . split ( \" \" ) ) . parallel ( ) . mapToInt ( Integer :: parseInt ) . map ( n -> n * n ) . sorted ( ) . toArray ( ) ) . map ( ar -> ( ar [ 0 ] + ar [ 1 ] == ar [ 2 ] ) ? \" YES \" : \" NO \" ) . sequential ( ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; import java . util . stream . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; br . lines ( ) . skip ( 1 ) . map ( line -> Stream . of ( line . split ( \" \" ) ) . mapToInt ( Integer :: parseInt ) . map ( n -> n * n ) . sorted ( ) . toArray ( ) ) . map ( ar -> ( ar [ 0 ] + ar [ 1 ] == ar [ 2 ] ) ? \" YES \" : \" NO \" ) . forEach ( System . out :: println ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { private static int loop_num ; static String rightTriangle ( int a , int b , int c ) { String judge = \" NO \" ; if ( ( a * a ) + ( b * b ) == ( c * c ) || ( c * c ) + ( a * a ) == ( b * b ) || ( c * c ) + ( b * b ) == ( a * a ) ) { judge = \" YES \" ; } return judge ; } public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; loop_num = stdIn . nextInt ( ) ; String [ ] result_triangle = new String [ loop_num ] ; for ( int i = 0 ; i < loop_num ; i ++ ) { result_triangle [ i ] = rightTriangle ( stdIn . nextInt ( ) , stdIn . nextInt ( ) , stdIn . nextInt ( ) ) ; } for ( String result : result_triangle ) { System . out . println ( result ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < String > strLst = new ArrayList < String > ( ) ; int cnt = 0 ; int max ; int other ; String inputLine = \" \" ; String [ ] lines ; br . readLine ( ) ; while ( cnt <= 1000 && ( inputLine = br . readLine ( ) ) != null ) { max = 0 ; other = 0 ; lines = inputLine . split ( \" \" ) ; for ( int i = 0 ; i < 3 ; ++ i ) { other += ( int ) Math . pow ( Integer . parseInt ( lines [ i ] ) , 2 ) ; if ( max < Integer . parseInt ( lines [ i ] ) ) { max = Integer . parseInt ( lines [ i ] ) ; } } other -= ( int ) Math . pow ( max , 2 ) ; if ( other == ( int ) Math . pow ( max , 2 ) ) strLst . add ( \" YES \" ) ; else strLst . add ( \" NO \" ) ; ++ cnt ; } for ( String result : strLst ) { System . out . println ( result ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int a , b , c , max_num1 , max_num2 ; int res_flg ; int n = Integer . parseInt ( s . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String line = s . nextLine ( ) ; String [ ] array = line . split ( \" \" , 0 ) ; a = Integer . parseInt ( array [ 0 ] ) ; b = Integer . parseInt ( array [ 1 ] ) ; c = Integer . parseInt ( array [ 2 ] ) ; if ( a >= b && a >= c ) { if ( a * a == b * b + c * c ) { res_flg = 1 ; } else { res_flg = 0 ; } } else if ( b >= a && b >= c ) { if ( b * b == a * a + c * c ) { res_flg = 1 ; } else { res_flg = 0 ; } } else if ( c >= a && c >= b ) { if ( c * c == b * b + a * a ) { res_flg = 1 ; } else { res_flg = 0 ; } } else { res_flg = 0 ; } if ( res_flg == 0 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] a ) throws IOException { try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { String line1 = br . readLine ( ) ; int N = Integer . parseInt ( line1 ) ; for ( int i = 0 ; i < N ; i ++ ) { String line = br . readLine ( ) ; String [ ] tmp = line . split ( \" \" ) ; int [ ] tri = { Integer . parseInt ( tmp [ 0 ] ) , Integer . parseInt ( tmp [ 1 ] ) , Integer . parseInt ( tmp [ 2 ] ) } ; if ( pitagoras ( tri [ 0 ] , tri [ 1 ] , tri [ 2 ] ) || pitagoras ( tri [ 1 ] , tri [ 2 ] , tri [ 0 ] ) || pitagoras ( tri [ 2 ] , tri [ 0 ] , tri [ 1 ] ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } } private static boolean pitagoras ( int a , int b , int c ) { return Math . pow ( a , 2 ) + Math . pow ( b , 2 ) == Math . pow ( c , 2 ) ? true : false ; } }",
    "label": 1
  },
  {
    "code": "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] lc = br . readLine ( ) . split ( \" \" ) ; int a = Integer . parseInt ( lc [ 0 ] ) ; int b = Integer . parseInt ( lc [ 1 ] ) ; int c = Integer . parseInt ( lc [ 2 ] ) ; if ( a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; class Main { static List < Integer > list = new ArrayList < Integer > ( ) ; public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; while ( n != 0 ) { list . clear ( ) ; Collections . addAll ( list , scan . nextInt ( ) , scan . nextInt ( ) , scan . nextInt ( ) ) ; list . sort ( Comparator . reverseOrder ( ) ) ; if ( ( list . get ( 0 ) * list . get ( 0 ) ) == ( ( list . get ( 1 ) * list . get ( 1 ) ) + ( list . get ( 2 ) * list . get ( 2 ) ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } n -- ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a < c && b < c ) { if ( c * c == a * a + b * b ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( a < b && c < b ) { if ( b * b == a * a + c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else { if ( a * a == b * b + c * c ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < String > strLst = new ArrayList < String > ( ) ; int cnt = 0 ; int max ; int other ; String inputLine = \" \" ; String [ ] lines ; br . readLine ( ) ; while ( cnt <= 1000 && ( inputLine = br . readLine ( ) ) != null ) { max = 0 ; other = 0 ; lines = inputLine . split ( \" \" ) ; for ( int i = 0 ; i < 3 ; ++ i ) { other += ( int ) Math . pow ( Integer . parseInt ( lines [ i ] ) , 2 ) ; if ( max < Integer . parseInt ( lines [ i ] ) ) { max = Integer . parseInt ( lines [ i ] ) ; } } other -= ( int ) Math . pow ( max , 2 ) ; if ( other == ( int ) Math . pow ( max , 2 ) ) strLst . add ( \" YES \" ) ; else strLst . add ( \" NO \" ) ; ++ cnt ; } for ( String result : strLst ) { System . out . println ( result ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] line = convertInt ( sc . nextLine ( ) . split ( \" \" ) ) ; sort ( line ) ; if ( ( line [ 2 ] * line [ 2 ] ) == ( ( line [ 0 ] * line [ 0 ] ) + ( line [ 1 ] * line [ 1 ] ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static void sort ( int [ ] array ) { int n = array . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( array [ j ] < array [ j - 1 ] ) { int box = array [ j - 1 ] ; array [ j - 1 ] = array [ j ] ; array [ j ] = box ; } } } } public static int [ ] convertInt ( String [ ] str ) { int n = str . length ; int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( str [ i ] ) ; } return array ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int dataset = Integer . parseInt ( br . readLine ( ) ) ; String str ; for ( int i = 0 ; i < dataset ; i ++ ) { str = br . readLine ( ) ; String strline [ ] = str . split ( \" \" , 0 ) ; int line [ ] = new int [ strline . length ] ; for ( int j = 0 ; j < 3 ; j ++ ) { line [ j ] = Integer . parseInt ( strline [ j ] ) ; } Arrays . sort ( line ) ; if ( Math . pow ( ( double ) line [ 2 ] , 2 ) == Math . pow ( ( double ) line [ 0 ] , 2 ) + Math . pow ( ( double ) line [ 1 ] , 2 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int i , j , k , a , b , c ; String [ ] data ; Scanner scan = new Scanner ( System . in ) ; k = scan . nextInt ( ) ; data = new String [ k ] ; i = 0 ; while ( i < k ) { a = scan . nextInt ( ) ; b = scan . nextInt ( ) ; c = scan . nextInt ( ) ; a = a * a ; b = b * b ; c = c * c ; if ( a > b && a > c ) { b = b + c ; if ( a == b ) { data [ i ] = \" YES \" ; } else { data [ i ] = \" NO \" ; } } else if ( b > a && b > c ) { a = a + c ; if ( b == a ) { data [ i ] = \" YES \" ; } else { data [ i ] = \" NO \" ; } } else if ( c > a && c > b ) { a = a + b ; if ( c == a ) { data [ i ] = \" YES \" ; } else { data [ i ] = \" NO \" ; } } else { data [ i ] = \" NO \" ; } i ++ ; } j = 0 ; while ( j < i ) { System . out . println ( data [ j ] ) ; j ++ ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( bf . readLine ( ) ) ; StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] str = bf . readLine ( ) . split ( \" \" ) ; double x = Math . pow ( Integer . parseInt ( str [ 0 ] ) , 2 ) ; double y = Math . pow ( Integer . parseInt ( str [ 1 ] ) , 2 ) ; double z = Math . pow ( Integer . parseInt ( str [ 2 ] ) , 2 ) ; if ( x + y == z || x + z == y || y + z == x ) ans . append ( \" YES \\n \" ) ; else ans . append ( \" NO \\n \" ) ; } System . out . print ( ans ) ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int roop = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int i = 0 ; i < roop ; i ++ ) { Triangle tri = new Triangle ( sc . nextLine ( ) . split ( \" \" ) ) ; tri . execute ( ) ; } } } class Triangle { private int a ; private int b ; private int c ; public Triangle ( String [ ] nums ) { a = Integer . parseInt ( nums [ 0 ] ) ; a *= a ; b = Integer . parseInt ( nums [ 1 ] ) ; b *= b ; c = Integer . parseInt ( nums [ 2 ] ) ; c *= c ; } public void execute ( ) { int biggest = biggest ( ) ; String result = \" \" ; if ( biggest == 0 ) { result = sumNum ( this . b , this . c , this . a ) ; } else if ( biggest == 1 ) { result = sumNum ( this . a , this . c , this . b ) ; } else if ( biggest == 2 ) { result = sumNum ( this . a , this . b , this . c ) ; } System . out . println ( result ) ; } private int biggest ( ) { int result = Math . max ( c , Math . max ( a , b ) ) ; if ( result == a ) { return 0 ; } else if ( result == b ) { return 1 ; } else if ( result == c ) { return 2 ; } else { return 3 ; } } private String sumNum ( int a , int b , int c ) { String result = \" \" ; if ( c == a + b ) { result = \" YES \" ; } else { result = \" NO \" ; } return result ; } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ 3 ] ; for ( int j = 0 ; j < n ; j ++ ) for ( int l = 0 ; l < 3 ; l ++ ) a [ j ] [ l ] = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . sort ( a [ i ] ) ; if ( a [ i ] [ 0 ] * a [ i ] [ 0 ] + a [ i ] [ 1 ] * a [ i ] [ 1 ] == a [ i ] [ 2 ] * a [ i ] [ 2 ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; while ( num != 0 ) { ArrayList < Integer > tri = new ArrayList < Integer > ( ) ; tri . add ( sc . nextInt ( ) ) ; tri . add ( sc . nextInt ( ) ) ; tri . add ( sc . nextInt ( ) ) ; Collections . sort ( tri ) ; if ( ( Math . pow ( tri . get ( 0 ) , 2 ) + Math . pow ( tri . get ( 1 ) , 2 ) ) != Math . pow ( tri . get ( 2 ) , 2 ) ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; } num -- ; } sc . close ( ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String argv [ ] ) throws IOException { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; String str ; String triangle_side_str [ ] = new String [ 3 ] ; int max = 0 ; int remain [ ] = new int [ 2 ] ; int triangle_side_int [ ] = new int [ 3 ] ; int N = Integer . parseInt ( br . readLine ( ) ) ; for ( int j = 0 ; j < N ; j ++ ) { str = br . readLine ( ) ; remain [ 0 ] = 0 ; remain [ 1 ] = 0 ; max = 0 ; triangle_side_str = str . split ( \" \" ) ; for ( int i = 0 ; i < 3 ; i ++ ) { triangle_side_int [ i ] = Integer . parseInt ( triangle_side_str [ i ] ) ; if ( max <= triangle_side_int [ i ] ) { if ( remain [ 1 ] == 0 ) remain [ 1 ] = max ; else if ( remain [ 0 ] == 0 ) remain [ 0 ] = max ; max = triangle_side_int [ i ] ; } else { if ( remain [ 1 ] == 0 ) remain [ 1 ] = triangle_side_int [ i ] ; else if ( remain [ 0 ] == 0 ) remain [ 0 ] = triangle_side_int [ i ] ; } } if ( Math . pow ( remain [ 0 ] , 2 ) + Math . pow ( remain [ 1 ] , 2 ) == Math . pow ( max , 2 ) ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] tmpStr = br . readLine ( ) . split ( \" \" ) ; int [ ] lineLength = new int [ 3 ] ; int max = 0 ; int maxIndex = - 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { lineLength [ j ] = Integer . parseInt ( tmpStr [ j ] ) ; if ( lineLength [ j ] > max ) { max = lineLength [ j ] ; maxIndex = j ; } } int sum = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { int sq = lineLength [ j ] * lineLength [ j ] ; if ( j == maxIndex ) { sum -= sq ; } else { sum += sq ; } } if ( sum == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int num = sc . nextInt ( ) ; while ( num -- != 0 ) { int [ ] side = new int [ 3 ] ; for ( int count = 0 ; count < 3 ; count ++ ) { side [ count ] = ( int ) Math . pow ( sc . nextInt ( ) , 2 ) ; } if ( side [ 0 ] == side [ 1 ] + side [ 2 ] || side [ 1 ] == side [ 0 ] + side [ 2 ] || side [ 2 ] == side [ 0 ] + side [ 1 ] ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "var input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) main ( ) } ) function main ( ) { input . sort ( function ( a , b ) { return ( parseInt ( a ) < parseInt ( b ) ) ? 1 : - 1 ; } ) ; console . log ( input [ 0 ] ) console . log ( input [ 1 ] ) console . log ( input [ 2 ] ) }",
    "label": 2
  },
  {
    "code": "var heights = [ ] ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( height ) { height . trim ( ) . split ( ' \\n ' ) . forEach ( function ( line ) { heights . push ( parseInt ( line ) ) ; } ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { heights . sort ( function ( a , b ) { if ( a > b ) { return - 1 ; } else if ( a == b ) { return 0 ; } else { return 1 ; } } ) ; for ( var i = 0 ; i < 3 ; i ++ ) { console . log ( heights [ i ] ) ; } ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr [ 0 ] ) ; console . log ( Arr [ 1 ] ) ; console . log ( Arr [ 2 ] ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var heights = input . trim ( ) . split ( ' \\n ' ) ; heights . sort ( function ( a , b ) { return b - a ; } ) ; for ( var i = 0 ; i < 3 ; i ++ ) { console . log ( heights [ i ] ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . split ( ' \\n ' ) ; var heights = p . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( heights . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) )",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) )",
    "label": 2
  },
  {
    "code": "' use strict ' ; ( function ( stdin ) { var inputs = stdin . toString ( ) . trim ( ) . split ( ' \\n ' ) ; var sorted = inputs . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) ; console . log ( sorted ) ; } ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; ( function ( stdin ) { var inputs = stdin . toString ( ) . trim ( ) . split ( ' \\n ' ) ; var sorted = inputs . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) ; console . log ( sorted ) ; } ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; ( function ( stdin ) { var inputs = stdin . toString ( ) . trim ( ) . split ( ' \\n ' ) ; var sorts = inputs . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) ; console . log ( sorts ) ; } ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; ( function ( stdin ) { var inputs = stdin . toString ( ) . trim ( ) . split ( ' \\n ' ) ; var sorted = inputs . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) ; console . log ( sorted ) ; } ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; ( function ( stdin ) { var inputs = stdin . toString ( ) . trim ( ) . split ( ' \\n ' ) ; var sorted = inputs . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . join ( ' \\n ' ) ; console . log ( sorted ) ; } ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ) ;",
    "label": 2
  },
  {
    "code": "var readline = require ( ' readline ' ) ; var rl = readline . createInterface ( { input : process . stdin , output : { } , } ) ; hs = [ ] ; rl . on ( ' line ' , function ( h ) { hs . push ( h | 0 ) ; } ) ; rl . on ( ' close ' , function ( ) { hs . sort ( function ( p , q ) { return p - q ; } ) ; for ( var i = 0 ; i < 3 ; ++ i ) console . log ( hs [ hs . length - i - 1 ] ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { input = input . split ( \" \\n \" ) ; for ( var i = 0 ; i < 10 ; i ++ ) { input [ i ] = parseInt ( input [ i ] , 10 ) ; } input . sort ( descendingOrder ) ; for ( i = 0 ; i < 3 ; i ++ ) { console . log ( input [ i ] ) ; } } function ascendingOrder ( val1 , val2 ) { return val1 - val2 ; } function descendingOrder ( val1 , val2 ) { return val2 - val1 ; } function debug ( ) { var input = document . getElementById ( \" input \" ) . value ; Main ( input ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var heigths = input . trim ( ) . split ( \" \\n \" ) ; var n = heigths . sort ( compareNumbers ) ; for ( i = 0 ; i != 3 ; i ++ ) { console . log ( n [ i ] ) ; } function compareNumbers ( a , b ) { return b - a ; }",
    "label": 2
  },
  {
    "code": "var readline = require ( ' readline ' ) ; var rl = readline . createInterface ( { input : process . stdin , output : process . stdout , terminal : false } ) ; var hills = [ ] ; rl . on ( ' line ' , function ( line ) { hills . push ( parseInt ( line . trim ( ) ) ) ; } ) . on ( ' close ' , function ( ) { var top3 = hills . sort ( function ( a , b ) { return a - b ; } ) . reverse ( ) . slice ( 0 , 3 ) ; for ( i = 0 ; i < top3 . length ; i ++ ) { console . log ( top3 [ i ] ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { x = [ ] ; rep ( 10 , function ( i ) { x [ i ] = scan ( ) ; } ) ; x . sort ( function ( a , b ) { return b - a ; } ) ; rep ( 3 , function ( i ) { print ( x [ i ] ) ; } ) ; } function rep ( a , b , c ) { if ( c == null ) { c = b ; b = a ; a = 0 ; } for ( var i = a ; i < b ; ++ i ) { c ( i ) ; } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; var input_index = 0 ; function scan ( type ) { if ( type === ' string ' ) { return input [ input_index ++ ] ; } else { return + input [ input_index ++ ] ; } } function print ( val ) { console . log ( val ) ; } process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( / \\s+ / ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . split ( \" \\n \" ) ; x . sort ( function ( a , b ) { return b - a ; } ) ; for ( i = 0 ; console . log ( x [ i ++ ] ) , i < 3 ; ) { } ;",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( arg ) { var mountains = arg . split ( ' \\n ' ) ; mountains = mountains . map ( function ( x ) { return parseInt ( x ) ; } ) var topMountains = [ ] ; iterateTopMountains ( function init ( i ) { topMountains [ i ] = 0 ; } ) for ( var i = 0 ; i < mountains . length ; i += 1 ) { var mountain = mountains [ i ] ; iterateTopMountains ( function displace ( rank ) { if ( mountain > topMountains [ rank ] ) { topMountains . splice ( rank , 0 , mountain ) ; return true ; } } ) } iterateTopMountains ( function show ( i ) { console . log ( topMountains [ i ] ) ; } ) } function iterateTopMountains ( func ) { var numTopMountains = 3 ; for ( var i = 0 ; i < numTopMountains ; i += 1 ) { var needBreak = func ( i ) ; if ( needBreak ) { break ; } } }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var number_of_hills_to_output = 3 ; lines . sort ( function ( a , b ) { return b - a ; } ) ; for ( var counter = 0 ; counter < number_of_hills_to_output ; counter ++ ) { console . log ( lines [ counter ] ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) ; var numbers = input . split ( \" \\n \" ) . map ( Number ) ; numbers = numbers . sort ( function ( a , b ) { return b - a } ) ; for ( var i = 0 ; i < 3 ; i ++ ) { if ( i < numbers . length ) { console . log ( numbers [ i ] ) ; } }",
    "label": 2
  },
  {
    "code": "function main ( input ) { input . split ( \" \\n \" ) . slice ( 0 , 10 ) . map ( function ( str ) { return parseInt ( str ) ; } ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . map ( function ( height ) { console . log ( height ) ; } ) ; } main ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var data = ( input . trim ( ) ) . split ( ' \\n ' ) ; function main ( input ) { var sorted = input . sort ( function ( a , b ) { return b - a ; } ) ; var topThreeMountains = sorted . slice ( 0 , 3 ) ; for ( var i = 0 ; i < topThreeMountains . length ; i ++ ) { console . log ( topThreeMountains [ i ] ) ; } } main ( data ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( \" data \" , function ( chunk ) { var line = chunk . trim ( ) . split ( \" \\n \" ) . map ( function ( e ) { return parseInt ( e ) } ) ; console . log ( line . sort ( function ( a , b ) { return b - a } ) . slice ( 0 , 3 ) . join ( \" \\n \" ) ) } )",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var heights = input . trim ( ) . split ( ' \\n ' ) ; heights . sort ( function ( a , b ) { return b - a ; } ) ; for ( var i = 0 ; i < 3 ; i ++ ) { console . log ( heights [ i ] ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var height = input . trim ( ) . split ( ' \\n ' ) ; height . sort ( function ( a , b ) { return parseInt ( b ) - parseInt ( a ) ; } ) ; console . log ( height . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "var Mountains = { mountain_input : function ( ) { var mountain = [ ] ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( line ) { mountain . push ( parseInt ( line ) ) ; } ) ; return mountain ; } , sort : function ( ) { var data = this . mountain_input ( ) ; data . sort ( function ( a , b ) { return a - b ; } ) ; for ( k = data . length - 1 ; k >= data . length - 3 ; k -- ) { console . log ( data [ k ] ) ; } return true ; } } Mountains . sort ( ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { var c = chunk . split ( \" \\n \" ) c . sort ( function ( aft , bef ) { return bef - aft } ) for ( var j = 0 ; j < 3 ; j ++ ) { console . log ( c [ j ] ) } } )",
    "label": 2
  },
  {
    "code": "var data = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var input = data . trim ( ) . split ( ' \\n ' ) ; function findHighestHills ( arr ) { if ( arr . length <= 1 ) { return arr ; } var pivot = parseInt ( arr . pop ( ) ) ; var left = [ ] ; var right = [ ] ; while ( arr . length ) { var elem = parseInt ( arr . pop ( ) ) ; if ( elem > pivot ) { left . push ( elem ) ; } else { right . push ( elem ) ; } } var sorted = [ ] . concat ( findHighestHills ( left ) , pivot , findHighestHills ( right ) ) ; return sorted . splice ( 0 , 3 ) ; } var output = findHighestHills ( input ) ; for ( var i = 0 ; i < output . length ; i ++ ) { console . log ( output [ i ] ) ; }",
    "label": 2
  },
  {
    "code": "function main ( input ) { var a = input . split ( \" \\n \" ) ; a . sort ( function ( a , b ) { return b - a } ) ; a . slice ( 0 , 3 ) . forEach ( function ( value ) { console . log ( value ) ; } ) ; } main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { var aaa = chunk . toString ( ) ; var line = aaa . split ( \" \\n \" ) for ( var i in line ) { line [ i ] = new Number ( line [ i ] ) } line . sort ( function ( a , b ) { if ( a > b ) return - 1 ; if ( a < b ) return 1 ; return 0 ; } ) ; for ( var i = 0 ; i < 3 ; i ++ ) { console . log ( line [ i ] . toString ( ) ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "var input = [ ] ; var max ; var maxIndex ; var temp ; var maxLength = 3 ; process . stdin . resume ( ) ; process . stdin . setEncoding ( \" utf8 \" ) ; process . stdin . on ( ' data ' , function ( chunk ) { input = chunk . toString ( \" utf8 \" ) . split ( \" \\n \" ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { for ( var m = 0 ; m < maxLength ; m ++ ) { temp = 0 ; for ( var i = 0 ; i < input . length ; i ++ ) { if ( i === 0 ) { temp = parseInt ( input [ i ] ) ; } else { if ( temp < parseInt ( input [ i ] ) ) { temp = input [ i ] ; maxIndex = i ; } } } input . splice ( maxIndex , 1 ) ; console . log ( temp ) } } ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var hills = ( sample_input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; hills . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( hills . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var mountains = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; mountains . sort ( sortNumber ) ; function sortNumber ( a , b ) { return b - a ; } for ( i = 0 ; i != 3 ; i ++ ) { console . log ( mountains [ i ] ) ; }",
    "label": 2
  },
  {
    "code": "config = { stdin : ' /dev/stdin ' , newline : ' \\n ' } ; line = require ( ' fs ' ) . readFileSync ( config . stdin , ' ascii ' ) . trim ( ) . split ( config . newline ) . map ( Number ) ; line . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( line . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var hills = ( sample_input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; hills . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( hills . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "( function main ( input ) { var lines = input . trim ( ) . split ( ' \\n ' ) . map ( Number ) ; lines . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( lines . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "( function main ( input ) { var lines = input . trim ( ) . split ( ' \\n ' ) ; lines . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) . slice ( 0 , 3 ) . forEach ( function ( v ) { console . log ( v ) ; } ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( stdin ) { var mountains = stdin . trim ( ) . split ( ' \\n ' ) . map ( Number ) ; mountains . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( mountains . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( ) { ' use strict ' ; ( function ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; stdin . on ( ' end ' , function ( ) { process . exit ( ) ; } ) ; this . fs = require ( ' fs ' ) ; } ) . call ( this ) ; ( function ( ) { ( function input ( next_func ) { var list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var input_data = ( function ( ) { chunk . replace ( / \\\\r / , ' ' ) ; return chunk . trim ( ) . split ( ' \\n ' ) ; } ) ( chunk ) ; input_data . forEach ( function ( line ) { list . push ( parseInt ( line . trim ( ) ) ) ; } ) ; if ( list . length >= 10 ) return next_func ( list ) ; } ) ; } ) . call ( this , function solve ( list ) { list . sort ( function ( a , b ) { return a < b ; } ) ; var result = list . slice ( 0 , 3 ) ; result . forEach ( function ( height ) { output ( height ) ; } ) ; process . exit ( ) ; } ) ; } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var h = input . split ( \" \\n \" ) ; h . sort ( function ( a , b ) { return Number ( b ) - Number ( a ) ; } ) ; console . log ( h . slice ( 0 , 3 ) . join ( \" \\n \" ) ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var param = input . split ( \" \\n \" ) ; var sorted = param . sort ( function ( x , y ) { return ( y - x ) } ) ; console . log ( sorted . slice ( 0 , 3 ) . join ( \" \\n \" ) ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . sort ( function ( a , b ) { return b - a } ) . slice ( 0 , 3 ) . forEach ( function ( a ) { console . log ( a ) } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "function Main ( i ) { i . split ( \" \\n \" ) . sort ( function ( a , b ) { return b - a } ) . splice ( 0 , 3 ) . forEach ( function ( x ) { console . log ( x ) } ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; lines . sort ( function ( a , b ) { return b - a ; } ) ; for ( var i = 0 ; i < 3 ; i ++ ) { console . log ( lines [ i ] ) ; }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { var lines = input . split ( ' \\n ' ) ; lines . sort ( function ( a , b ) { return b - a } ) lines . slice ( 0 , 3 ) . forEach ( function ( x ) { console . log ( x ) ; } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "let sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var hills = ( sample_input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; hills . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( hills . slice ( 0 , 3 ) . join ( \" \\n \" ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var hills = ( sample_input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; hills . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( hills . slice ( 0 , 3 ) . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { input . sort ( function ( a , b ) { return b - a } ) . slice ( 0 , 3 ) . forEach ( function ( c ) { console . log ( c ) } ) ; }",
    "label": 2
  },
  {
    "code": "\" use strict \" ; new Promise ( function ( resolve , reject ) { let content = \" \" ; process . stdin . on ( \" data \" , chunk => { content += chunk ; } ) process . stdin . on ( \" end \" , ( ) => { resolve ( [ content , process . stdout ] ) ; } ) ; } ) . then ( function ( [ cin , cout ] ) { const data = cin . split ( \" \\n \" ) . slice ( 0 , 10 ) . map ( elt => parseInt ( elt ) ) ; data . sort ( ( a , b ) => { if ( a > b ) return - 1 ; if ( b > a ) return 1 ; return 0 ; } ) ; for ( let i = 0 ; i < 3 ; ++ i ) { cout . write ( ` ${ data [ i ] } \\n ` ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "let input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( ' \\n ' ) main ( ) } ) function main ( ) { dataset_num = input [ 0 ] if ( dataset_num > 1000 ) { return } for ( i = 1 ; i < input . length ; i ++ ) { input_line = input [ i ] . split ( ' ' ) in put_line . sort ( compareNumbers ) if ( 0 > input_line [ 0 ] || input_line [ 0 ] > 1000 ) { return } if ( 0 > input_line [ 1 ] || input_line [ 1 ] > 1000 ) { return } if ( 0 > input_line [ 2 ] || input_line [ 2 ] > 1000 ) { return } if ( Math . pow ( input_line [ 0 ] , 2 ) === Math . pow ( input_line [ 1 ] , 2 ) + Math . pow ( input_line [ 2 ] , 2 ) ) { console . log ( ' YES ' ) } else { console . log ( ' NO ' ) } } } function compareNumbers ( a , b ) { return b - a ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . shift ( ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; arr . sort ( function ( a , b ) { return a - b ; } ) ; var a = arr [ 0 ] ; var b = arr [ 1 ] ; var c = arr [ 2 ] ; var str = \" \" ; str = ( c * c == a * a + b * b ) ? \" YES \" : \" NO \" ; console . log ( str ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = Number ( p . shift ( ) ) ; for ( var i = 0 ; i < p . length ; i ++ ) { var args = p [ i ] . split ( ' ' ) . map ( Number ) . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Math . pow ( args [ 0 ] , 2 ) === Math . pow ( args [ 1 ] , 2 ) + Math . pow ( args [ 2 ] , 2 ) ? ' YES ' : ' NO ' ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = new Int32Array ( input [ line ] . split ( \" \" ) ) ; var i0 = inputArray [ 0 ] ; var i1 = inputArray [ 1 ] ; var i2 = inputArray [ 2 ] ; console . log ( isTri ( i0 , i1 , i2 ) || isTri ( i1 , i2 , i0 ) || isTri ( i2 , i0 , i1 ) ? ' YES ' : ' NO ' ) ; } } function isTri ( a , b , c ) { return a * a + b * b == c * c ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = inputArray [ 2 ] ; var middle = inputArray [ 1 ] ; var shortest = inputArray [ 0 ] ; console . log ( ( longest * longest == middle * middle + shortest * shortest ) ? ' YES ' : ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = new Int32Array ( input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ) ; var longest = inputArray [ 2 ] ; var middle = inputArray [ 1 ] ; var shortest = inputArray [ 0 ] ; console . log ( ( longest * longest == middle * middle + shortest * shortest ) ? ' YES ' : ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = inputArray [ 2 ] ; var middle = inputArray [ 1 ] ; var shortest = inputArray [ 0 ] ; console . log ( ( longest * longest == middle * middle + shortest * shortest ) ? ' YES ' : ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = inputArray [ 2 ] ; var middle = inputArray [ 1 ] ; var shortest = inputArray [ 0 ] ; console . log ( ( longest * longest - middle * middle - shortest * shortest ) ? ' NO ' : ' YES ' ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = inputArray [ 2 ] ; var middle = inputArray [ 1 ] ; var shortest = inputArray [ 0 ] ; console . log ( ( longest * longest - middle * middle - shortest * shortest ) ? ' NO ' : ' YES ' ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = inputArray [ 2 ] ; var middle = inputArray [ 1 ] ; var shortest = inputArray [ 0 ] ; console . log ( ( longest * longest == middle * middle + shortest * shortest ) ? ' YES ' : ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = pow ( inputArray [ 2 ] ) ; var middle = pow ( inputArray [ 1 ] ) ; var shortest = pow ( inputArray [ 0 ] ) ; var isRightTriangle = longest == middle + shortest ; console . log ( isRightTriangle ? ' YES ' : ' NO ' ) ; } } function pow ( a ) { return a * a ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var line = 1 , maxLines = input [ 0 ] - 0 ; line <= maxLines ; line ++ ) { var inputArray = input [ line ] . split ( \" \" ) . sort ( function ( a , b ) { return a - b } ) ; var longest = pow ( inputArray [ 2 ] ) ; var middle = pow ( inputArray [ 1 ] ) ; var shortest = pow ( inputArray [ 0 ] ) ; var isRightTriangle = middle + shortest - longest ; console . log ( isRightTriangle ? ' NO ' : ' YES ' ) ; } } function pow ( a ) { return a * a ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var lineNum = + lines . shift ( ) ; for ( var i = 0 ; i < lineNum ; i ++ ) { var line = lines [ i ] ; var args = line . split ( ' ' ) ; args = args . map ( function ( k ) { return + k ; } ) args . sort ( function ( a , b ) { return b - a ; } ) ; if ( Math . pow ( args [ 0 ] , 2 ) == Math . pow ( args [ 1 ] , 2 ) + Math . pow ( args [ 2 ] , 2 ) ) { console . log ( ' YES ' ) ; } else { console . log ( ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var input = input . split ( \" \\n \" ) ; var N = Int ( input [ 0 ] ) ; for ( var i = 1 ; i <= N ; i ++ ) { var side = input [ i ] . split ( \" \" ) ; for ( var j = 0 ; j < 3 ; j ++ ) { side [ j ] = Int ( side [ j ] ) ; } side . sort ( descendingOrder ) ; if ( side [ 0 ] * side [ 0 ] == side [ 1 ] * side [ 1 ] + side [ 2 ] * side [ 2 ] ) { console . log ( \" YES \" ) ; } else { console . log ( \" NO \" ) ; } } } function ascendingOrder ( val1 , val2 ) { return val1 - val2 ; } function descendingOrder ( val1 , val2 ) { return val2 - val1 ; } function Int ( str ) { return parseInt ( str , 10 ) ; } function Str ( num ) { return num . toString ( 10 ) ; } function debug ( ) { var input = document . getElementById ( \" input \" ) . value ; Main ( input ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var input = input . split ( \" \\n \" ) ; var N = Int ( input [ 0 ] ) ; for ( var i = 1 ; i <= N ; i ++ ) { var side = input [ i ] . split ( \" \" ) ; for ( var j = 0 ; j < 3 ; j ++ ) { side [ j ] = Int ( side [ j ] ) ; } side . sort ( descendingOrder ) ; if ( side [ 0 ] * side [ 0 ] == side [ 1 ] * side [ 1 ] + side [ 2 ] * side [ 2 ] ) { output ( \" YES \" ) ; } else { output ( \" NO \" ) ; } } } function ascendingOrder ( val1 , val2 ) { return val1 - val2 ; } function descendingOrder ( val1 , val2 ) { return val2 - val1 ; } function Int ( str ) { return parseInt ( str , 10 ) ; } function Str ( num ) { return num . toString ( 10 ) ; } function output ( str ) { if ( _Isdebug ) { document . getElementById ( \" input \" ) . value += ( str + \" \\n \" ) ; } console . log ( str ) ; } var _Isdebug = false ; function debug ( ) { _Isdebug = true ; var input = document . getElementById ( \" input \" ) . value ; Main ( input ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . split ( / \\s / ) ; for ( i = 1 ; i < x [ 0 ] * 3 + 1 ; ) { a = x [ i ] * x [ i ++ ] , b = x [ i ] * x [ i ++ ] , c = x [ i ] * x [ i ++ ] ; if ( a + b == c || b + c == a || c + a == b ) { console . log ( \" YES \" ) ; } else { console . log ( \" NO \" ) ; } }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var args = input . trim ( ) . split ( ' \\n ' ) ; args = args . slice ( 1 , parseInt ( args [ 0 ] ) + 1 ) ; args . forEach ( function ( data ) { data = data . split ( ' ' ) . map ( function ( x ) { x = parseInt ( x ) ; return x * x ; } ) . sort ( function ( a , b ) { return a - b ; } ) ; var isRight = data [ 0 ] + data [ 1 ] === data [ 2 ] ; var res = isRight ? \" YES \" : \" NO \" ; console . log ( res ) ; } ) }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( \" \\n \" ) ; var number_of_datasets = lines . shift ( ) ; for ( var dataset = 0 ; dataset < number_of_datasets ; dataset ++ ) { var value = \" NO \" ; var values = lines [ dataset ] . split ( \" \" ) ; var a = parseInt ( values [ 0 ] ) ; var b = parseInt ( values [ 1 ] ) ; var c = parseInt ( values [ 2 ] ) ; if ( ( a * a ) + ( b * b ) === ( c * c ) ) { value = \" YES \" ; } if ( ( a * a ) + ( c * c ) === ( b * b ) ) { value = \" YES \" ; } if ( ( c * c ) + ( b * b ) === ( a * a ) ) { value = \" YES \" ; } console . log ( value ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; function is_right_abc ( a , b , c ) { return a * a + b * b === c * c ; } function is_right ( a , b , c ) { return is_right_abc ( a , b , c ) || is_right_abc ( b , c , a ) || is_right_abc ( c , a , b ) ; } var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) ; var lines = input . split ( \" \\n \" ) ; var count = parseInt ( lines . shift ( ) ) ; for ( var i = 0 ; i < count ; i ++ ) { var parts = lines [ i ] . split ( \" \" ) ; var a = parseInt ( parts . shift ( ) ) ; var b = parseInt ( parts . shift ( ) ) ; var c = parseInt ( parts . shift ( ) ) ; if ( ! isNaN ( a + b + c ) ) { console . log ( is_right ( a , b , c ) ? \" YES \" : \" NO \" ) ; } }",
    "label": 2
  },
  {
    "code": "function main ( input ) { var lines = input . split ( \" \\n \" ) ; var problemCount = parseInt ( lines . shift ( ) ) ; lines = lines . slice ( 0 , problemCount ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { var sides = lines [ i ] . split ( \" \" ) . slice ( 0 , 3 ) . map ( function ( value ) { return parseInt ( value ) ; } ) . sort ( function ( a , b ) { return a - b ; } ) ; if ( ! isNaN ( sides [ 0 ] && ! isNaN ( sides [ 1 ] ) && ! isNaN ( sides [ 2 ] ) ) ) { console . log ( ( Math . pow ( sides [ 2 ] , 2 ) === Math . pow ( sides [ 1 ] , 2 ) + Math . pow ( sides [ 0 ] , 2 ) ) ? ' YES ' : ' NO ' ) ; } } } main ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "function generateTrianglesFromInput ( input ) { var max = 1000 ; var lines = getInputAsLines ( input , \" \\n \" ) ; var vertices = lines . map ( processLineToVertices ) ; for ( var i = 0 ; i < vertices . length ; i ++ ) { var line = vertices [ i ] ; if ( i === 0 ) { if ( line [ 0 ] > max ) { break ; } } var tri = new Triangle ( { constraints : { min : 1 , max : 1000 } , vertices : { a : line [ 0 ] , b : line [ 1 ] , c : line [ 2 ] } } ) ; if ( tri . isValid ( ) ) { var isRightAngleTriangle = tri . isRightAngleTriangle ( ) ; var logValue = ( isRightAngleTriangle ) ? ' YES ' : ' NO ' ; console . log ( logValue ) ; } } } function getInputAsLines ( input , delimeter ) { return input . split ( delimeter ) ; } function processLineToVertices ( line ) { var vertices = line . split ( ' ' ) ; return vertices ; } function Triangle ( options ) { this . constraints = { } ; this . vertices = { } ; this . constraints . min = options . constraints . min || 1 ; this . constraints . max = options . constraints . max || 1000 ; this . vertices . a = ( this . vertexIsWithinConstraints ( options . vertices . a ) ) ? options . vertices . a : null ; this . vertices . b = ( this . vertexIsWithinConstraints ( options . vertices . b ) ) ? options . vertices . b : null ; this . vertices . c = ( this . vertexIsWithinConstraints ( options . vertices . c ) ) ? options . vertices . c : null ; } Triangle . prototype . vertexIsWithinConstraints = function ( vertex ) { return ( vertex >= this . constraints . min && vertex <= this . constraints . max ) ; } Triangle . prototype . isValid = function ( ) { return ( this . vertices . a && this . vertices . b && this . vertices . c ) ; } Triangle . prototype . isRightAngleTriangle = function ( ) { var value = false ; if ( this . isValid ) { var vertexArray = [ ] ; vertexArray . push ( this . vertices . a ) ; vertexArray . push ( this . vertices . b ) ; vertexArray . push ( this . vertices . c ) ; vertexArray . sort ( function ( a , b ) { return a - b } ) ; var squares = vertexArray . map ( function ( vertex ) { return Math . pow ( vertex , 2 ) } ) ; value = ( squares [ 2 ] === ( squares [ 0 ] + squares [ 1 ] ) ) ; } return value ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; generateTrianglesFromInput ( input ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { var array = ( chunk . trim ( ) ) . split ( \" \\n \" ) var hen = 3 for ( var i = 1 ; i < array . length ; i ++ ) { var x = array [ i ] . split ( \" \" ) ; x . sort ( function ( d , e ) { return e - d } ) if ( Math . pow ( x [ 0 ] , 2 ) == Math . pow ( x [ 1 ] , 2 ) + Math . pow ( x [ 2 ] , 2 ) ) { console . log ( \" YES \" ) ; } else console . log ( \" NO \" ) ; } } )",
    "label": 2
  },
  {
    "code": "var input = [ ] ; var dataCount ; var data ; process . stdin . resume ( ) ; process . stdin . setEncoding ( \" utf8 \" ) ; process . stdin . on ( ' data ' , function ( chunk ) { input = chunk . toString ( \" utf8 \" ) . split ( \" \\n \" ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { dataCount = parseInt ( input . shift ( ) ) ; for ( var i = 0 ; i < dataCount ; i ++ ) { data = input [ i ] . split ( \" \" ) . map ( Number ) . sort ( function ( a , b ) { if ( a < b ) return - 1 ; if ( a > b ) return 1 ; return 0 ; } ) ; if ( Math . pow ( data [ 0 ] , 2 ) + Math . pow ( data [ 1 ] , 2 ) == Math . pow ( data [ 2 ] , 2 ) ) { console . log ( \" YES \" ) } else { console . log ( \" NO \" ) } } } ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { input = input . split ( \" \\n \" ) ; var n = parseInt ( input [ 0 ] , 10 ) ; for ( var i = 0 ; i < n ; i ++ ) { input [ i + 1 ] = input [ i + 1 ] . split ( ' ' ) ; var a = parseInt ( input [ i + 1 ] [ 0 ] , 10 ) ; var b = parseInt ( input [ i + 1 ] [ 1 ] , 10 ) ; var c = parseInt ( input [ i + 1 ] [ 2 ] , 10 ) ; if ( a > b ) { var ex = a ; a = b ; b = ex ; } if ( b > c ) { var ex = b ; b = c ; c = ex ; } if ( a * a + b * b === c * c ) console . log ( \" YES \" ) ; else console . log ( \" NO \" ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var triangles = ( sample_input . trim ( ) ) . split ( \" \\n \" ) ; triangles . shift ( ) ; triangles . forEach ( function ( triangle ) { var sides = triangle . split ( \" \" ) . map ( Number ) ; sides . sort ( function ( a , b ) { return a - b ; } ) ; var is_right = \" \" ; is_right = ( sides [ 2 ] * sides [ 2 ] == sides [ 0 ] * sides [ 0 ] + sides [ 1 ] * sides [ 1 ] ) ? \" YES \" : \" NO \" ; console . log ( is_right ) ; } ) ;",
    "label": 2
  },
  {
    "code": "config = { stdin : ' /dev/stdin ' , newline : ' \\n ' } ; line = require ( ' fs ' ) . readFileSync ( config . stdin , ' ascii ' ) . trim ( ) . split ( config . newline ) ; line . shift ( ) ; line = line . map ( function ( line ) { var ary = line . split ( ' ' ) . map ( Number ) ; ary . sort ( function ( a , b ) { return b - a ; } ) ; if ( sqr ( ary [ 0 ] ) === sqr ( ary [ 1 ] ) + sqr ( ary [ 2 ] ) ) return ' YES ' ; else return ' NO ' ; } ) ; console . log ( line . join ( ' \\n ' ) ) ; function sqr ( x ) { return x * x ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { var array = ( chunk . trim ( ) ) . split ( \" \\n \" ) var hen = 3 for ( var i = 1 ; i < array . length ; i ++ ) { var x = array [ i ] . split ( \" \" ) ; x . sort ( function ( d , e ) { return e - d } ) if ( Math . pow ( x [ 0 ] , 2 ) == Math . pow ( x [ 1 ] , 2 ) + Math . pow ( x [ 2 ] , 2 ) ) { console . log ( \" YES \" ) ; } else console . log ( \" NO \" ) ; } } )",
    "label": 2
  },
  {
    "code": "( function Main ( ) { var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; input = input . split ( \" \\n \" ) ; var n = parseInt ( input [ 0 ] , 10 ) ; for ( var i = 1 ; i <= n ; i ++ ) { var tmp = input [ i ] . split ( \" \" ) ; var a = parseInt ( tmp [ 0 ] , 10 ) ; var b = parseInt ( tmp [ 1 ] , 10 ) ; var c = parseInt ( tmp [ 2 ] , 10 ) ; if ( a * a + b * b == c * c || a * a + c * c == b * b || a * a == b * b + c * c ) console . log ( \" YES \" ) ; else console . log ( \" NO \" ) ; } } ) ( ) ;",
    "label": 2
  },
  {
    "code": "( function ( undefined ) { ' use strict ' ; ( function init ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; this . input_list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( / \\d+ / g ) ; input_list = input_list . concat ( result ) ; } ) ; this . input_number = function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } ; } ) . call ( this ) ; ( function solver ( ) { function sq ( x ) { return x * x ; } function check ( v ) { return sq ( v . a ) + sq ( v . b ) === sq ( v . c ) || sq ( v . b ) + sq ( v . c ) === sq ( v . a ) || sq ( v . c ) + sq ( v . a ) === sq ( v . b ) ; } setTimeout ( function solve ( ) { var n = input_number ( ) ; var vertexes = [ ] ; while ( n -- ) vertexes . push ( { a : input_number ( ) , b : input_number ( ) , c : input_number ( ) } ) ; vertexes . forEach ( function ( vertex ) { output ( check ( vertex ) ? ' YES ' : ' NO ' ) ; } ) ; } , 0 ) ; } ) ( ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { lines = input . split ( \" \\n \" ) . slice ( 1 ) ; for ( var i in lines ) { if ( lines [ i ] == \" \" ) break ; len = lines [ i ] . split ( \" \" ) . map ( function ( x ) { return x - 0 ; } ) ; len . sort ( function ( a , b ) { return a - b ; } ) ; console . log ( len [ 0 ] * len [ 0 ] + len [ 1 ] * len [ 1 ] == len [ 2 ] * len [ 2 ] ? \" YES \" : \" NO \" ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . slice ( 1 ) . some ( function ( n ) { n = n . split ( \" \" ) . map ( function ( a ) { return + a } ) . sort ( function ( a , b ) { return b - a } ) ; console . log ( n [ 0 ] * n [ 0 ] === n [ 1 ] * n [ 1 ] + n [ 2 ] * n [ 2 ] ? \" YES \" : \" NO \" ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var Triangle ; ( function ( Triangle ) { var RightAngle = ( function ( ) { function RightAngle ( a , b , c ) { this . a = a ; this . b = b ; this . c = c ; } RightAngle . prototype . isRightAngle = function ( ) { var values = [ this . a , this . b , this . c ] . sort ( function ( a , b ) { return b - a ; } ) ; return Math . pow ( values [ 0 ] , 2.0 ) == ( Math . pow ( values [ 1 ] , 2.0 ) + Math . pow ( values [ 2 ] , 2.0 ) ) ; } ; return RightAngle ; } ) ( ) ; Triangle . RightAngle = RightAngle ; } ) ( Triangle || ( Triangle = { } ) ) ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { chunk . trim ( ) . split ( ' \\n ' ) . forEach ( function ( line ) { var items = line . trim ( ) . split ( ' ' ) ; if ( items . length == 3 ) { var r = new Triangle . RightAngle ( + items [ 0 ] , + items [ 1 ] , + items [ 2 ] ) ; if ( r . isRightAngle ( ) ) { console . log ( \" YES \" ) ; } else { console . log ( \" NO \" ) ; } } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . slice ( 1 ) . some ( function ( a ) { var n = a . split ( \" \" ) . map ( function ( x ) { return x * x } ) . sort ( function ( x , y ) { return x - y } ) ; console . log ( n [ 0 ] + n [ 1 ] === n [ 2 ] ? ' YES ' : ' NO ' ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var n = + lines . shift ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var nums = lines [ i ] . split ( ' ' ) . sort ( function ( a , b ) { return a - b ; } ) ; var a = nums [ 0 ] ; var b = nums [ 1 ] ; var c = nums [ 2 ] ; if ( c * c == a * a + b * b ) console . log ( ' YES ' ) ; else console . log ( ' NO ' ) ; }",
    "label": 2
  },
  {
    "code": "let input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( ' \\n ' ) main ( ) } ) function main ( ) { for ( i = 0 ; i < input . length ; i ++ ) { input_line = input [ i ] . split ( ' ' ) let sort_input_line = input_line . slice ( ) sort_input_line . sort ( compareNumbers ) if ( input_line [ 0 ] > 1000 || input_line [ 0 ] < - 1000 ) { return } let a = input_line [ 0 ] let b = input_line [ 1 ] let c = input_line [ 2 ] let d = input_line [ 3 ] let e = input_line [ 4 ] let f = input_line [ 5 ] let x = ( b * f - e * c ) / ( d * b - a * e ) let y = ( c - a * x ) / b console . log ( x . toFixed ( 3 ) , y . toFixed ( 3 ) ) } } function compareNumbers ( a , b ) { return b - a ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; var A = arr [ 0 ] * arr [ 4 ] - arr [ 3 ] * arr [ 1 ] ; var B = arr [ 2 ] * arr [ 4 ] - arr [ 5 ] * arr [ 1 ] ; var C = arr [ 0 ] * arr [ 5 ] - arr [ 3 ] * arr [ 2 ] ; var x = ( B / A ) . toFixed ( 3 ) ; var y = ( C / A ) . toFixed ( 3 ) ; console . log ( x + \" \" + y ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; for ( var i = 0 ; i < p . length ; i ++ ) { var args = p [ i ] . split ( ' ' ) . map ( Number ) ; var a = args [ 0 ] ; var b = args [ 1 ] ; var c = args [ 2 ] ; var d = args [ 3 ] ; var e = args [ 4 ] ; var f = args [ 5 ] ; var x = ( c * e - b * f ) / ( a * e - b * d ) ; var y = ( c * d - a * f ) / ( b * d - a * e ) ; x = x . toFixed ( 3 ) ; y = y . toFixed ( 3 ) ; console . log ( ' %s %s ' , x , y ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . forEach ( function ( z ) { i = z . split ( ' ' ) ; console . log ( x = ( ( i [ 2 ] * i [ 4 ] - i [ 1 ] * i [ 5 ] ) / ( i [ 0 ] * i [ 4 ] - i [ 1 ] * i [ 3 ] ) ) . toFixed ( 3 ) , ( ( i [ 2 ] - i [ 0 ] * x ) / i [ 1 ] ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( z ) { i = z . split ( ' ' ) ; if ( i [ 5 ] ) console . log ( x = ( ( i [ 2 ] * i [ 4 ] - i [ 1 ] * i [ 5 ] ) / ( i [ 0 ] * i [ 4 ] - i [ 1 ] * i [ 3 ] ) ) . toFixed ( 3 ) , ( ( i [ 2 ] - i [ 0 ] * x ) / i [ 1 ] ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( z ) { i = z . split ( ' ' ) ; console . log ( x = ( ( i [ 2 ] * i [ 4 ] - i [ 1 ] * i [ 5 ] ) / ( i [ 0 ] * i [ 4 ] - i [ 1 ] * i [ 3 ] ) ) . toFixed ( 3 ) , ( ( i [ 2 ] - i [ 0 ] * x ) / i [ 1 ] ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "z = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; for ( i = 0 ; i < z . length ; ) { a = z [ i ++ ] ; b = z [ i ++ ] ; c = z [ i ++ ] ; d = z [ i ++ ] ; e = z [ i ++ ] ; f = z [ i ++ ] ; y = ( c * d - a * f ) / ( b * d - a * e ) ; x = ( c - b * y ) / a ; console . log ( ( Math . round ( x *= 1000 ) / 1000 ) . toFixed ( 3 ) + \" \" + ( Math . round ( y *= 1000 ) / 1000 ) . toFixed ( 3 ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var args = input . trim ( ) . split ( ' \\n ' ) ; args . forEach ( function ( data ) { data = data . split ( ' ' ) . map ( Number ) ; solve ( data ) ; } ) } function solve ( numbers ) { var a = numbers [ 0 ] , b = numbers [ 1 ] , p = numbers [ 2 ] ; var c = numbers [ 3 ] , d = numbers [ 4 ] , q = numbers [ 5 ] ; var z = a * d - b * c ; var x = ( d * p - b * q ) / z ; var y = ( a * q - c * p ) / z ; console . log ( x . toFixed ( 3 ) + ' ' + y . toFixed ( 3 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; function det ( a , b , c , d ) { return a * d - b * c ; } function solve_xy ( a , b , c , d , e , f ) { var D = det ( a , b , d , e ) var x = det ( c , b , f , e ) / D ; var y = det ( a , c , d , f ) / D ; return { x : x , y : y } } var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) ; var lines = input . split ( \" \\n \" ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { var parts = lines [ i ] . split ( \" \" ) ; var a = parseInt ( parts . shift ( ) ) ; var b = parseInt ( parts . shift ( ) ) ; var c = parseInt ( parts . shift ( ) ) ; var d = parseInt ( parts . shift ( ) ) ; var e = parseInt ( parts . shift ( ) ) ; var f = parseInt ( parts . shift ( ) ) ; if ( ! isNaN ( a ) ) { var solution = solve_xy ( a , b , c , d , e , f ) ; console . log ( solution . x . toFixed ( 3 ) , solution . y . toFixed ( 3 ) ) ; } }",
    "label": 2
  },
  {
    "code": "var input = [ ] ; process . stdin . resume ( ) ; process . stdin . setEncoding ( \" utf8 \" ) ; process . stdin . on ( ' data ' , function ( chunk ) { input = chunk . toString ( \" utf8 \" ) . trim ( ) . split ( \" \\n \" ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { for ( var i = 0 ; i < input . length ; i ++ ) { var data = input [ i ] . split ( \" \" ) . map ( Number ) ; var a = data [ 0 ] , b = data [ 1 ] , c = data [ 2 ] , d = data [ 3 ] , e = data [ 4 ] , f = data [ 5 ] ; var x = ( ( c * e - b * f ) / ( a * e - b * d ) ) . toFixed ( 3 ) ; var y = ( ( f * a - c * d ) / ( a * e - d * b ) ) . toFixed ( 3 ) ; console . log ( x + \" \" + y ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var coefficient_sets = ( sample_input . trim ( ) ) . split ( \" \\n \" ) ; coefficient_sets . forEach ( function ( coefficient_set ) { var coefficients = coefficient_set . split ( \" \" ) . map ( Number ) ; var a = coefficients [ 0 ] ; var b = coefficients [ 1 ] ; var c = coefficients [ 2 ] ; var d = coefficients [ 3 ] ; var e = coefficients [ 4 ] ; var f = coefficients [ 5 ] ; var x ; var y ; var x = ( c * e - f * b ) / ( e * a - d * b ) ; var y = ( c - a * x ) / b ; console . log ( [ x . toFixed ( 3 ) , y . toFixed ( 3 ) ] . join ( \" \" ) ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var coefficient_sets = ( sample_input . trim ( ) ) . split ( \" \\n \" ) ; coefficient_sets . forEach ( function ( coefficient_set ) { var coefficients = coefficient_set . split ( \" \" ) . map ( Number ) ; var a = coefficients [ 0 ] ; var b = coefficients [ 1 ] ; var c = coefficients [ 2 ] ; var d = coefficients [ 3 ] ; var e = coefficients [ 4 ] ; var f = coefficients [ 5 ] ; var x ; var y ; var x = ( c * e - f * b ) / ( e * a - d * b ) ; var y = ( c - a * x ) / b ; console . log ( [ x . toFixed ( 3 ) , y . toFixed ( 3 ) ] . join ( \" \" ) ) ; } ) ;",
    "label": 2
  },
  {
    "code": "config = { stdin : ' /dev/stdin ' , newline : ' \\n ' } ; require ( ' fs ' ) . readFileSync ( config . stdin , ' ascii ' ) . trim ( ) . split ( config . newline ) . forEach ( function ( line ) { var ary = line . split ( ' ' ) . map ( Number ) ; var a = ary [ 0 ] , b = ary [ 1 ] , c = ary [ 2 ] , d = ary [ 3 ] , e = ary [ 4 ] , f = ary [ 5 ] ; var det = a * e - b * d ; var Ainv_c = ( e * c - b * f ) / det ; var Ainv_f = ( - d * c + a * f ) / det ; console . log ( ' %s %s ' , format ( Ainv_c ) , format ( Ainv_f ) ) ; } ) ; function format ( num ) { var s = num . toFixed ( 4 ) ; var point = s . indexOf ( ' . ' ) ; if ( point === - 1 ) return s + ' .000 ' ; return ( s + ' 000 ' ) . slice ( 0 , point + 4 ) ; }",
    "label": 2
  },
  {
    "code": "( function set_utils ( undefined ) { this . print_float = function print_float ( val , base , pad , prec ) { var p10 = Math . pow ( 10 , prec ) ; var ival = \" \" + Math . round ( val * p10 ) ; if ( ival === ' 0 ' ) return ' 0.000 ' ; var ilen = ival . length - prec ; if ( ilen === 0 ) return \" 0. \" + ival . substr ( ilen , prec ) ; return ival . substr ( 0 , ilen ) + \" . \" + ival . substr ( ilen , prec ) ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; ( function init ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; this . input_list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( / [-]?\\d+ / g ) ; input_list = input_list . concat ( result ) ; } ) ; stdin . on ( ' end ' , function ( ) { fire ( ) ; } ) ; this . input_number = function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } ; this . has_next = function ( ) { return ! input_list . length ; } ; } ) . call ( this ) ; ( function solver ( ) { function sq ( x ) { return x * x ; } function check ( v ) { } this . fire = function ( ) { setTimeout ( function solve ( ) { var a = input_number ( ) ; var b = input_number ( ) ; var c = input_number ( ) ; var d = input_number ( ) ; var e = input_number ( ) ; var f = input_number ( ) ; var delta = 1.0 / ( a * e - b * d ) ; var x = ( e * c - b * f ) * delta ; var y = ( a * f - d * c ) * delta ; output ( print_float ( x , 10 , 3 , 3 ) + ' ' + print_float ( y , 10 , 3 , 3 ) ) ; if ( ! has_next ( ) ) setTimeout ( solve , 0 , this ) ; } , 0 , this ) ; } ; } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "( function set_utils ( undefined ) { this . print_float = function print_float ( val , base , pad , prec ) { var p10 = Math . pow ( 10 , prec ) ; var ival = \" \" + Math . round ( val * p10 ) ; if ( ival === ' 0 ' ) return ' 0. ' + Array ( prec + 1 ) . join ( ' 0 ' ) ; var ilen = ival . length - prec ; if ( ilen === 0 ) return \" 0. \" + ival . substr ( ilen , prec ) ; return ival . substr ( 0 , ilen ) + \" . \" + ival . substr ( ilen , prec ) ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; ( function init ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; this . input_list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( / [-]?\\d+ / g ) ; input_list = input_list . concat ( result ) ; } ) ; stdin . on ( ' end ' , function ( ) { fire ( ) ; } ) ; this . input_number = function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } ; this . has_next = function ( ) { return ! input_list . length ; } ; } ) . call ( this ) ; ( function solver ( ) { function sq ( x ) { return x * x ; } function check ( v ) { } this . fire = function ( ) { setTimeout ( function solve ( ) { var a = input_number ( ) ; var b = input_number ( ) ; var c = input_number ( ) ; var d = input_number ( ) ; var e = input_number ( ) ; var f = input_number ( ) ; var delta = 1.0 / ( a * e - b * d ) ; var x = ( e * c - b * f ) * delta ; var y = ( a * f - d * c ) * delta ; output ( print_float ( x , 10 , 3 , 3 ) + ' ' + print_float ( y , 10 , 3 , 3 ) ) ; if ( ! has_next ( ) ) setTimeout ( solve , 0 , this ) ; } , 0 , this ) ; } ; } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n , x ) { n = n . split ( \" \" ) ; var a = + n [ 0 ] , b = + n [ 1 ] , c = + n [ 2 ] , d = + n [ 3 ] , e = + n [ 4 ] , f = + n [ 5 ] , x ; console . log ( ( x = ( ( c * e - b * f ) / ( a * e - b * d ) ) ) . toFixed ( 3 ) , ( ( c - a * x ) / b ) . toFixed ( 3 ) ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var vals = line . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; var a = vals [ 0 ] ; var b = vals [ 1 ] ; var c = vals [ 2 ] ; var d = vals [ 3 ] ; var e = vals [ 4 ] ; var f = vals [ 5 ] ; var D = a * e - b * d ; var x = ( e * c - b * f ) / D ; var y = ( a * f - d * c ) / D ; console . log ( x . toFixed ( 3 ) + ' ' + y . toFixed ( 3 ) ) ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( z ) { i = z . split ( ' ' ) ; console . log ( x = ( ( i [ 2 ] * i [ 4 ] - i [ 1 ] * i [ 5 ] ) / ( i [ 0 ] * i [ 4 ] - i [ 1 ] * i [ 3 ] ) ) . toFixed ( 3 ) , ( ( i [ 2 ] - i [ 0 ] * x ) / i [ 1 ] ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "let input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( ' \\n ' ) main ( ) } ) function main ( ) { for ( i = 0 ; i < input . length ; i ++ ) { input_line = input [ i ] . split ( ' ' ) in put_line . sort ( compareNumbers ) let a = input_line [ 0 ] let b = input_line [ 1 ] let r = input_line [ 0 ] % input_line [ 1 ] let x = a * b while ( r != 0 ) { a = b b = r r = a % b } console . log ( b , x / b ) } } function compareNumbers ( a , b ) { return b - a ; }",
    "label": 2
  },
  {
    "code": "function GCD ( a , b ) { var m = Math . max ( a , b ) ; var n = Math . min ( a , b ) ; while ( n != 0 ) { var N = n ; n = m % n ; m = N ; } return m ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; var gcd = GCD ( arr [ 0 ] , arr [ 1 ] ) ; var lcm = arr [ 0 ] * arr [ 1 ] / gcd ; console . log ( gcd + \" \" + lcm ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; for ( var i = 0 ; i < p . length ; i ++ ) { var args = p [ i ] . split ( ' ' ) . map ( Number ) ; var a = args [ 0 ] ; var b = args [ 1 ] ; var gcd = greatestCommonDivisor ( a , b ) ; var lcm = leastCommonMultiple ( a , b ) ; console . log ( ' %s %s ' , gcd , lcm ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function greatestCommonDivisor ( a , b ) { if ( b > a ) { var tmp = a ; a = b ; b = tmp ; } if ( b == 0 ) { return a ; } return greatestCommonDivisor ( a % b , b ) ; } function leastCommonMultiple ( a , b ) { return a * b / greatestCommonDivisor ( a , b ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var j = input [ i ] . split ( \" \" ) ; var a = j [ 0 ] - 0 ; var b = j [ 1 ] - 0 ; var g = gcd ( a , b ) ; var lcm = a * b / g ; console . log ( g + \" \" + lcm ) ; } } function gcd ( a , b ) { var x = max ( a , b ) ; var y = min ( a , b ) ; var mod while ( mod = x % y ) { x = y ; y = mod ; } return y ; } function max ( a , b ) { var t = a - b ; return a - ( t & ( t >> 31 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; a = j [ 0 ] , b = j [ 1 ] , c = a * b ; while ( m = a % b ) a = b , b = m ; console . log ( b , c / b ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { j = i . split ( ' ' ) ; a = j [ 0 ] , b = j [ 1 ] , c = a * b ; while ( m = a % b ) a = b , b = m ; if ( b ) console . log ( b , c / b ) } )",
    "label": 2
  },
  {
    "code": "for ( i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) , j = 0 ; a = i [ j ++ ] , b = i [ j ++ ] , c = a * b ; ) { while ( m = a % b ) a = b , b = m ; console . log ( b , c / b ) }",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . split ( / \\s / ) ; i = 0 ; for ( ; i < x . length - 2 ; ) { if ( x [ i ++ ] < x [ i ++ ] ) { tmp = x [ i - 2 ] ; x [ i - 2 ] = x [ i - 1 ] ; x [ i - 1 ] = tmp ; } l = x [ i - 2 ] * x [ i - 1 ] ; r = x [ i - 2 ] % x [ i - 1 ] ; while ( r !== 0 ) { x [ i - 2 ] = x [ i - 1 ] ; x [ i - 1 ] = r ; r = x [ i - 2 ] % x [ i - 1 ] ; } console . log ( x [ i - 1 ] , l / x [ i - 1 ] ) ; }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var args = input . trim ( ) . split ( ' \\n ' ) ; args . forEach ( function ( data ) { data = data . split ( ' ' ) . map ( Number ) ; solve ( data [ 0 ] , data [ 1 ] ) ; } ) } function solve ( a , b ) { if ( a < b ) { var tmp = b ; b = a ; a = tmp ; } var gcd = calcGcd ( a , b ) ; var lcm = a * b / gcd ; console . log ( gcd + ' ' + lcm ) ; } function calcGcd ( a , b ) { if ( b <= 0 ) { return a ; } return calcGcd ( b , a % b ) ; }",
    "label": 2
  },
  {
    "code": "function calcultateGCD ( a , b , res ) { if ( a == b ) return a * res ; else if ( ( a & 1 ) == 0 && ( b & 1 ) == 0 ) return calcultateGCD ( a >> 1 , b >> 1 , res << 1 ) ; else if ( ( a & 1 ) == 0 ) return calcultateGCD ( a >> 1 , b , res ) ; else if ( ( b & 1 ) == 0 ) return calcultateGCD ( a , b >> 1 , res ) ; else if ( a > b ) return calcultateGCD ( a - b , b , res ) ; else return calcultateGCD ( a , b - a , res ) ; } function calcultateLCM ( a , b , gcd ) { return a * b / gcd ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; if ( lines . length > 50 ) { console . log ( \" Invalid dataset size. Dataset size is \" + lines . length + \" but must be <= 50 \" ) ; } else { for ( var i = 0 ; i < lines . length ; i ++ ) { var line = lines [ i ] . trim ( ) ; if ( line == ' ' ) break ; var vals = line . split ( ' ' ) . map ( function ( i ) { return + i ; } ) ; if ( vals . length != 2 || isNaN ( vals [ 0 ] ) || isNaN ( vals [ 1 ] ) || vals [ 0 ] < 0 || vals [ 0 ] > 2000000000 || vals [ 1 ] < 0 || vals [ 1 ] > 2000000000 ) { console . log ( \" Invalid dataset: \" + line + \" . Use 0 <= a, b <= 2,000,000,000 \" ) ; } else { var gcd = calcultateGCD ( vals [ 0 ] , vals [ 1 ] , 1 ) ; var lcm = calcultateLCM ( vals [ 0 ] , vals [ 1 ] , gcd ) ; if ( lcm > 2000000000 ) console . log ( \" Invalid dataset: \" + line + \" . LCM is \" + lcm + \" but must be <= 2,000,000,000 \" ) ; else console . log ( gcd + \" \" + lcm ) ; } } }",
    "label": 2
  },
  {
    "code": "function calcultateGCD ( a , b , res ) { if ( a == b ) return a * res ; else if ( ( a & 1 ) == 0 && ( b & 1 ) == 0 ) return calcultateGCD ( a >> 1 , b >> 1 , res << 1 ) ; else if ( ( a & 1 ) == 0 ) return calcultateGCD ( a >> 1 , b , res ) ; else if ( ( b & 1 ) == 0 ) return calcultateGCD ( a , b >> 1 , res ) ; else if ( a > b ) return calcultateGCD ( a - b , b , res ) ; else return calcultateGCD ( a , b - a , res ) ; } function calcultateLCM ( a , b , gcd ) { return a * b / gcd ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; if ( lines . length > 50 ) { console . log ( \" Invalid dataset size. Dataset size is \" + lines . length + \" but must be <= 50 \" ) ; } else { for ( var i = 0 ; i < lines . length ; i ++ ) { var line = lines [ i ] . trim ( ) ; if ( line == ' ' ) break ; var vals = line . split ( ' ' ) . map ( function ( i ) { return + i ; } ) ; if ( vals . length != 2 || isNaN ( vals [ 0 ] ) || isNaN ( vals [ 1 ] ) || vals [ 0 ] < 0 || vals [ 0 ] > 2000000000 || vals [ 1 ] < 0 || vals [ 1 ] > 2000000000 ) { console . log ( \" Invalid dataset: \" + line + \" . Use 0 <= a, b <= 2,000,000,000 \" ) ; } else { var gcd = calcultateGCD ( vals [ 0 ] , vals [ 1 ] , 1 ) ; var lcm = calcultateLCM ( vals [ 0 ] , vals [ 1 ] , gcd ) ; if ( lcm > 2000000000 ) console . log ( \" Invalid dataset: \" + line + \" . LCM is \" + lcm + \" but must be <= 2,000,000,000 \" ) ; else console . log ( gcd + \" \" + lcm ) ; } } }",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; function gcd ( a , b ) { var t = a ; if ( b > a ) { a = b ; b = t ; } while ( b != 0 ) { t = b ; b = a % b ; a = t ; } return a ; } var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) ; var lines = input . split ( \" \\n \" ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { var parts = lines [ i ] . split ( \" \" ) ; var a = parseInt ( parts . shift ( ) ) ; var b = parseInt ( parts . shift ( ) ) ; if ( ! isNaN ( a + b ) ) { var g = gcd ( a , b ) ; var lcm = ( a * b ) / g ; console . log ( g , lcm ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var array = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < array . length ; i ++ ) { var splited = array [ i ] . split ( \" \" ) ; splited . sort ( function ( d , e ) { return e - d } ) test ( splited ) } function test ( data ) { var a = data [ 0 ] var b = data [ 1 ] var x = a ; var y = b ; var z ; while ( ( z = x % y ) != 0 ) { x = y y = z } var gcd = y var lcm = a * b / gcd console . log ( gcd + \" \" + lcm ) }",
    "label": 2
  },
  {
    "code": "var input = [ ] ; process . stdin . resume ( ) ; process . stdin . setEncoding ( \" utf8 \" ) ; process . stdin . on ( ' data ' , function ( chunk ) { input = chunk . toString ( \" utf8 \" ) . trim ( ) . split ( \" \\n \" ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { for ( var i = 0 ; i < input . length ; i ++ ) { var data = input [ i ] . split ( \" \" ) . map ( Number ) ; var a = data [ 0 ] , b = data [ 1 ] ; var GCD , LCM ; while ( b != 1 ) { if ( a === b ) break ; sortedData = [ a , b ] . sort ( function ( a , b ) { if ( a < b ) { return 1 } else if ( a > b ) { return - 1 } return 0 } ) ; b = sortedData [ 0 ] - sortedData [ 1 ] ; a = sortedData [ 1 ] } GCD = b ; LCM = data [ 0 ] * data [ 1 ] / GCD ; console . log ( GCD + \" \" + LCM ) } } ) ;",
    "label": 2
  },
  {
    "code": "const rl = require ( ' readline ' ) . createInterface ( { input : process . stdin , output : process . stdout } ) ; rl . on ( ' line ' , function ( line ) { var ary = line . split ( ' ' ) ; var a = Number ( ary [ 0 ] ) , b = Number ( ary [ 1 ] ) ; console . log ( ' %d %d ' , gcd ( a , b ) , lcm ( a , b ) ) ; } ) ; function gcd ( a , b ) { while ( a !== b ) { if ( a < b ) { var tmp = a ; a = b ; b = tmp ; } if ( a % b === 0 ) return b ; a -= b ; } return a ; } function lcm ( a , b ) { var g = gcd ( a , b ) ; return g * ( a / g ) * ( b / g ) ; }",
    "label": 2
  },
  {
    "code": "( function set_utils ( undefined ) { this . print_float = function print_float ( val , base , pad , prec ) { var p10 = Math . pow ( 10 , prec ) ; var ival = \" \" + Math . round ( val * p10 ) ; if ( ival === ' 0 ' ) return ' 0. ' + Array ( prec + 1 ) . join ( ' 0 ' ) ; var ilen = ival . length - prec ; if ( ilen === 0 ) return \" 0. \" + ival . substr ( ilen , prec ) ; return ival . substr ( 0 , ilen ) + \" . \" + ival . substr ( ilen , prec ) ; } ; this . gcd = function gcd ( a , b ) { return ! b ? a : gcd ( b , a % b ) ; } ; this . lcm = function lcm ( a , b ) { return a / gcd ( a , b ) * b ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; ( function init ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; this . input_list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( / [-]?\\d+ / g ) ; input_list = input_list . concat ( result ) ; } ) ; stdin . on ( ' end ' , function ( ) { fire ( ) ; } ) ; this . input_number = function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } ; this . has_next = function ( ) { return ! input_list . length ; } ; } ) . call ( this ) ; ( function solver ( ) { function sq ( x ) { return x * x ; } function check ( v ) { } this . fire = function ( ) { setTimeout ( solve , 0 , this ) ; } ; function solve ( ) { var args = [ input_number ( ) , input_number ( ) ] ; output ( gcd . apply ( this , args ) , lcm . apply ( this , args ) ) ; if ( ! has_next ( ) ) setTimeout ( solve , 0 , this ) ; } } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "( function utils ( undefined ) { this . print_float = function print_float ( val , base , pad , prec ) { var p10 = Math . pow ( 10 , prec ) ; var ival = \" \" + Math . round ( val * p10 ) ; if ( ival === ' 0 ' ) return ' 0. ' + Array ( prec + 1 ) . join ( ' 0 ' ) ; var ilen = ival . length - prec ; if ( ilen === 0 ) return \" 0. \" + ival . substr ( ilen , prec ) ; return ival . substr ( 0 , ilen ) + \" . \" + ival . substr ( ilen , prec ) ; } ; } ) . call ( global ) ; ( function math ( undefined ) { this . gcd = function gcd ( a , b ) { return ! b ? a : gcd ( b , a % b ) ; } ; this . lcm = function lcm ( a , b ) { return a / gcd ( a , b ) * b ; } ; this . sq = function sq ( x ) { return x * x ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; ( function init ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; this . input_list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( / [-]?\\d+ / g ) ; input_list = input_list . concat ( result ) ; } ) ; stdin . on ( ' end ' , function ( ) { fire ( ) ; } ) ; this . input_number = function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } ; this . has_next = function ( ) { return ! input_list . length ; } ; } ) . call ( this ) ; ( function solver ( ) { this . fire = function ( ) { setTimeout ( solve , 0 , this ) ; } ; function solve ( ) { var args = [ input_number ( ) , input_number ( ) ] ; output ( gcd . apply ( this , args ) , lcm . apply ( this , args ) ) ; if ( ! has_next ( ) ) setTimeout ( solve , 0 , this ) ; } } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n , m , h ) { n = n . split ( \" \" ) , m = + n [ 1 ] , n = + n [ 0 ] ; var g = function ( m , n , t ) { m < n && ( t = n , n = m , m = t ) ; while ( n = m % ( m = n ) ) ; return m ; } ; console . log ( h = g ( n , m ) , n * m / h ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "function gcd ( a , b ) { if ( b > a ) return gcd ( b , a ) ; if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var nums = line . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; var a = nums [ 0 ] ; var b = nums [ 1 ] ; var d = gcd ( a , b ) ; var m = a * b / d ; console . log ( d + ' ' + m ) ; }",
    "label": 2
  },
  {
    "code": "let input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( ' \\n ' ) main ( ) } ) function main ( ) { return console . log ( input [ 0 ] . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; console . log ( ( input . trim ( ) ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var str = input . replace ( / \\n$ / , ' ' ) ; console . log ( str . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var str = \" \" ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { str = input . split ( \" \\n \" ) [ 0 ] . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { console . log ( str ) ; } ) ;",
    "label": 2
  },
  {
    "code": "for ( i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) , j = i . length , k = ' ' ; j -- ; ) k += i [ j ] ; console . log ( k )",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) )",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var input = input . split ( \" \\n \" ) ; var str = input [ 0 ] . split ( \" \" ) ; var ans = \" \" ; for ( ; str . length != 0 ; ) { ans += str . pop ( ) ; } console . log ( ans ) ; } function ascendingOrder ( val1 , val2 ) { return val1 - val2 ; } function descendingOrder ( val1 , val2 ) { return val2 - val1 ; } function Int ( str ) { return parseInt ( str , 10 ) ; } function Str ( num ) { return num . toString ( 10 ) ; } function debug ( ) { var input = document . getElementById ( \" input \" ) . value ; Main ( input ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { print ( scan ( ' string ' ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) } function rep ( a , b , c ) { if ( c == null ) { c = b ; b = a ; a = 0 ; } for ( var i = a ; i < b ; ++ i ) { c ( i ) ; } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; var input_index = 0 ; function scan ( type ) { if ( type === ' string ' ) { return input [ input_index ++ ] ; } else { return + input [ input_index ++ ] ; } } function print ( val ) { console . log ( val ) ; } process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( / \\s+ / ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "console . log ( x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . replace ( / \\n / g , \" \" ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { console . log ( input . trim ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( \" \\n \" ) ; var line = lines [ 0 ] ; console . log ( line . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; function reverse ( s ) { return s . split ( ' ' ) . reverse ( ) . join ( ' ' ) ; } var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) . trim ( ) ; console . log ( reverse ( input ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; console . log ( input . trim ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . replace ( / \\n / g , ' ' ) ; function reverseSequence ( str ) { var output = ' ' ; var arr = str . split ( ' ' ) ; while ( arr . length ) { output += arr . pop ( ) ; } return output ; } console . log ( reverseSequence ( input ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var rSt = input . trim ( ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; console . log ( rSt ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( \" data \" , function ( chunk ) { console . log ( String ( chunk ) . trim ( ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) } )",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" ) . toString ( ) ; var reverse = input . substring ( 0 , 20 ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; console . log ( reverse ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; sample_str = sample_input . split ( \" \\n \" ) [ 0 ] ; console . log ( sample_str . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; console . log ( sample_input . split ( \" \\n \" ) [ 0 ] . trim ( ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; console . log ( sample_input . split ( \" \\n \" ) [ 0 ] . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var string = input . trim ( ) ; console . log ( reverse ( string ) ) ; function reverse ( s ) { return string . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; }",
    "label": 2
  },
  {
    "code": "config = { input : ' /dev/stdin ' , newline : ' \\n ' } ; ary = require ( ' fs ' ) . readFileSync ( config . input , ' ascii ' ) . trim ( ) . split ( ' ' ) ; ary . reverse ( ) ; console . log ( ary . join ( ' ' ) ) ;",
    "label": 2
  },
  {
    "code": "const fs = require ( ' fs ' ) function main ( input ) { console . log ( input . trim ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) } main ( fs . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) )",
    "label": 2
  },
  {
    "code": "( function ( ) { ' use strict ' ; var ArrayProto = Array . prototype , ObjProto = Object . prototype , FuncProto = Function . prototype ; var push = ArrayProto . push , slice = ArrayProto . slice , concat = ArrayProto . concat , toString = ObjProto . toString , hasOwnProperty = ObjProto . hasOwnProperty ; var nativeForEach = ArrayProto . forEach , nativeMap = ArrayProto . map , nativeReduce = ArrayProto . reduce , nativeReduceRight = ArrayProto . reduceRight , nativeFilter = ArrayProto . filter , nativeEvery = ArrayProto . every , nativeSome = ArrayProto . some , nativeIndexOf = ArrayProto . indexOf , nativeLastIndexOf = ArrayProto . lastIndexOf , nativeIsArray = Array . isArray , nativeKeys = Object . keys , nativeBind = FuncProto . bind ; this . _ = { } ; var each = _ . each = _ . forEach = function ( obj , iterator , context ) { if ( obj == null ) return ; if ( nativeForEach && obj . forEach === nativeForEach ) { obj . forEach ( iterator , context ) ; } else if ( obj . length === + obj . length ) { for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { if ( iterator . call ( context , obj [ i ] , i , obj ) === breaker ) return ; } } else { for ( var key in obj ) { if ( _ . has ( obj , key ) ) { if ( iterator . call ( context , obj [ key ] , key , obj ) === breaker ) return ; } } } } ; _ . extend = function ( obj ) { each ( slice . call ( arguments , 1 ) , function ( source ) { if ( source ) { for ( var prop in source ) { obj [ prop ] = source [ prop ] ; } } } ) ; return obj ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; var INPUT_TYPE = ' string ' ; var INPUT_REGEXP_LIST = { } ; INPUT_REGEXP_LIST [ ' string ' ] = / \\w* / g ; INPUT_REGEXP_LIST [ ' number ' ] = / [-]?\\d+ / g ; var INPUT_REGEXP = INPUT_REGEXP_LIST [ INPUT_TYPE ] ; ( function init ( ) { this . output = function ( ) { console . log . apply ( console , arguments ) ; } ; this . stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; this . input_list = [ ] ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( INPUT_REGEXP ) ; input_list = input_list . concat ( result . filter ( function ( line ) { return line . length ; } ) ) ; } ) ; stdin . on ( ' end ' , function ( ) { fire ( ) ; } ) ; _ . extend ( this , { input_number : function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } , input_text : function ( ) { return input_list . splice ( 0 , 1 ) [ 0 ] ; } , has_next : function ( ) { return ! input_list . length ; } } ) ; } ) . call ( this ) ; ( function solver ( ) { this . fire = function ( ) { setTimeout ( solve , 0 , this ) ; } ; function solve ( ) { output ( input_text ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) ; if ( ! has_next ( ) ) setTimeout ( solve , 0 , this ) ; } } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var s = input . split ( ' \\n ' ) [ 0 ] ; var i = s . length ; var ans = \" \" ; while ( i -- ) ans += s [ i ] ; console . log ( ans ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { console . log ( ( c + \" \" ) . trim ( ) . split ( \" \" ) . reverse ( ) . join ( \" \" ) ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; console . log ( input . trim ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ) ;",
    "label": 2
  },
  {
    "code": "let input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( ' \\n ' ) main ( ) } ) function main ( ) { let debt = 100000 for ( i = 0 ; i < input [ 0 ] ; i ++ ) { debt = Math . ceil ( ( debt + debt * 0.05 ) / 1000 ) * 1000 } console . log ( debt ) }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; input = input - 0 ; var m = 100000 ; for ( var i = 0 ; i < input ; i ++ ) { m = m * 1.05 ; m = Math . ceil ( m / 1000 ) * 1000 ; } console . log ( m ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var debt = 100000 ; for ( var i = 0 ; i < input [ 0 ] - 0 ; i ++ ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var debt = 100000 ; for ( var i = 0 ; i < input . trim ( ) - 0 ; i ++ ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "console . log ( \" 13530000 \" ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var debt = 100000 ; for ( var i = 0 ; i < input . trim ( ) - 0 ; i ++ ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var debt = 100000 ; for ( var i = 0 ; i < input . trim ( ) - 0 ; i ++ ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var debt = 100000 ; var wk = input . trim ( ) - 0 ; for ( ; wk > 0 ; wk -- ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var debt = 100000 ; var wk = input . trim ( ) - 0 ; for ( ; wk > 0 ; wk -- ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var debt = 100000 ; var wk = input - 0 ; for ( ; wk > 0 ; wk -- ) { debt = Math . ceil ( ( debt * 1.05 ) / 1000 ) * 1000 ; } console . log ( debt ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var debt = 100 ; var wk = input - 0 ; for ( ; wk > 0 ; wk -- ) { debt = Math . ceil ( debt * 1.05 ) ; } console . log ( debt * 1000 ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var n = Number ( input . replace ( / \\n$ / , ' ' ) ) ; var v = 100000 ; for ( var i = 1 ; i <= n ; i ++ ) { v = add ( v ) ; } console . log ( v ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function add ( v ) { v = v * 1.05 ; v = Math . ceil ( v / 1000 ) * 1000 ; return v ; }",
    "label": 2
  },
  {
    "code": "var debt = 100 ; var wk = parseInt ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; for ( ; wk -- ; ) { debt = Math . ceil ( debt * 1.05 ) ; } console . log ( debt * 1000 ) ;",
    "label": 2
  },
  {
    "code": "var debt = 100 ; var wk = ~ ~ ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; for ( ; wk -- ; ) { debt = Math . ceil ( debt * 1.05 ) ; } console . log ( debt * 1000 ) ;",
    "label": 2
  },
  {
    "code": "var debt = 100 ; var wk = ~ ~ ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; for ( ; wk -- ; ) { debt = Math . ceil ( debt * 1.05 ) ; } console . log ( debt * 1000 ) ;",
    "label": 2
  },
  {
    "code": "var debt = 100 ; var wk = ~ ~ ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; for ( ; wk -- ; ) { debt = Math . ceil ( debt * 1.05 ) ; } console . log ( debt * 1000 ) ;",
    "label": 2
  },
  {
    "code": "var debt = 100 ; var wk = ~ ~ ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; for ( ; wk -- ; ) { debt = Math . ceil ( debt * 1.05 ) ; } console . log ( debt * 1000 ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var n = scan ( ) ; var x = 100000 ; rep ( n , function ( ) { x += x / 20 ; if ( x % 1000 > 0 ) { x = ( Math . floor ( x / 1000 ) + 1 ) * 1000 ; } } ) ; print ( x ) ; } function rep ( a , b , c ) { if ( c == null ) { c = b ; b = a ; a = 0 ; } for ( var i = a ; i < b ; ++ i ) { c ( i ) ; } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; var input_index = 0 ; function scan ( type ) { if ( type === ' string ' ) { return input [ input_index ++ ] ; } else { return + input [ input_index ++ ] ; } } function print ( val ) { console . log ( val ) ; } process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( / \\s+ / ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; m = 100000 ; for ( i = 0 ; i < x ; i ++ ) { m *= 1.05 ; m = Math . ceil ( m / 1000 ) * 1000 ; } console . log ( m ) ;",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var n = parseInt ( input . trim ( ) ) ; var dept = 100000 ; for ( var i = 0 ; i < n ; i += 1 ) { dept = increaseDept ( dept ) ; } console . log ( dept ) ; } function increaseDept ( dept ) { dept *= 1.05 ; dept = Math . ceil ( dept / 1000 ) * 1000 ; return dept ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; function shark_week ( n ) { var loan = 100 ; for ( var i = 0 ; i < n ; i ++ ) { loan = Math . ceil ( loan * 1.05 ) ; } return loan * 1000 ; } var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) . trim ( ) ; console . log ( shark_week ( parseInt ( input ) ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var x = 100 for ( var i = 0 ; i < input ; i ++ ) { x = Math . ceil ( x * 1.05 ) } console . log ( x * 1000 )",
    "label": 2
  },
  {
    "code": "' use strict ' ; var readline = require ( ' readline ' ) ; var rl = readline . createInterface ( { input : process . stdin , output : process . stdout , terminal : false } ) ; rl . on ( ' line ' , function ( line ) { var n = Number ( line . trim ( ) ) var debt = calculateDebt ( n ) ; console . log ( debt ) ; } ) ; function calculateDebt ( n ) { var debtInThousands = 100 ; for ( var i = 1 ; i <= n ; i ++ ) { debtInThousands = Math . ceil ( debtInThousands * 1.05 ) ; } return debtInThousands * 1000 ; }",
    "label": 2
  },
  {
    "code": "var N , RISHI = 0.05 , MIN = 1000 , money = 100000 ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( \" data \" , function ( chunk ) { N = Number ( chunk ) ; for ( var i = 0 ; i < N ; i ++ ) { money = Math . ceil ( ( money + money * RISHI ) / MIN ) * MIN ; } console . log ( money ) } )",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var n = parseInt ( sample_input . split ( \" \\n \" ) [ 0 ] ) ; var init = 100000 ; for ( i = 1 ; i <= n ; i ++ ) { init = Math . ceil ( init * 1.05 / 1000 ) * 1000 ; } console . log ( init ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var n = parseInt ( sample_input . split ( \" \\n \" ) [ 0 ] ) ; var to_pay = 100000 ; for ( i = 0 ; i < n ; i ++ ) { to_pay = Math . ceil ( to_pay * 1.05 / 1000 ) * 1000 ; } console . log ( to_pay ) ;",
    "label": 2
  },
  {
    "code": "var weeks = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ; var startPercentage = 100 ; console . log ( calculateDebt ( startPercentage , weeks ) ) ; function calculateDebt ( number , weeks ) { for ( var i = 0 ; i < weeks ; i ++ ) { number = Math . ceil ( number * 1.05 ) ; } return number * 1000 ; }",
    "label": 2
  },
  {
    "code": "config = { input : ' /dev/stdin ' , newline : ' \\n ' } ; n = parseInt ( require ( ' fs ' ) . readFileSync ( config . input , ' ascii ' ) ) ; dept = 100 ; for ( i = 0 ; i < n ; i ++ ) dept = Math . ceil ( dept * 1.05 ) ; console . log ( dept + ' 000 ' ) ;",
    "label": 2
  },
  {
    "code": "( function underscore ( undefined ) { ' use strict ' ; var ArrayProto = Array . prototype , ObjProto = Object . prototype , FuncProto = Function . prototype ; var push = ArrayProto . push , slice = ArrayProto . slice , concat = ArrayProto . concat , toString = ObjProto . toString , hasOwnProperty = ObjProto . hasOwnProperty ; var nativeForEach = ArrayProto . forEach , nativeMap = ArrayProto . map , nativeReduce = ArrayProto . reduce , nativeReduceRight = ArrayProto . reduceRight , nativeFilter = ArrayProto . filter , nativeEvery = ArrayProto . every , nativeSome = ArrayProto . some , nativeIndexOf = ArrayProto . indexOf , nativeLastIndexOf = ArrayProto . lastIndexOf , nativeIsArray = Array . isArray , nativeKeys = Object . keys , nativeBind = FuncProto . bind ; this . _ = { } ; var each = _ . each = _ . forEach = function ( obj , iterator , context ) { if ( obj == null ) return ; if ( nativeForEach && obj . forEach === nativeForEach ) { obj . forEach ( iterator , context ) ; } else if ( obj . length === + obj . length ) { for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { if ( iterator . call ( context , obj [ i ] , i , obj ) === breaker ) return ; } } else { for ( var key in obj ) { if ( _ . has ( obj , key ) ) { if ( iterator . call ( context , obj [ key ] , key , obj ) === breaker ) return ; } } } } ; _ . extend = function ( obj ) { each ( slice . call ( arguments , 1 ) , function ( source ) { if ( source ) { for ( var prop in source ) { obj [ prop ] = source [ prop ] ; } } } ) ; return obj ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; var INPUT_TYPE = ' number ' ; var INPUT_REGEXP_LIST = { } ; INPUT_REGEXP_LIST [ ' string ' ] = / \\w* / g ; INPUT_REGEXP_LIST [ ' number ' ] = / [-]?\\d+ / g ; var INPUT_REGEXP = INPUT_REGEXP_LIST [ INPUT_TYPE ] ; var Solver = { fire : function ( ) { setTimeout ( Solver . solve , 0 , this ) ; } , solve : function solve ( ) { var n = input_number ( ) ; var m = 100000 ; for ( var i = 0 ; i < n ; ++ i ) { m = parseInt ( m * 1.05 ) ; if ( m % 1000 > 0 ) { m += 1000 ; } m = ( function ( m ) { return Math . floor ( m / 1000 ) * 1000 ; } ) ( m ) ; } output ( m ) ; if ( ! has_next ( ) ) setTimeout ( Solver . solve , 0 , this ) ; } } ; ( function init ( ) { _ . extend ( this , { output : function ( ) { console . log . apply ( console , arguments ) ; } , stdin : process . openStdin ( ) , input_list : [ ] , input_number : function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } , input_text : function ( ) { return input_list . splice ( 0 , 1 ) [ 0 ] ; } , has_next : function ( ) { return ! input_list . length ; } } ) ; stdin . setEncoding ( ' utf8 ' ) ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( INPUT_REGEXP ) ; input_list = input_list . concat ( result . filter ( function ( line ) { return line . length ; } ) ) ; } ) ; stdin . on ( ' end ' , function ( ) { Solver . fire . call ( this ) ; } ) ; } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var n = parseInt ( input . split ( ' \\n ' ) [ 0 ] ) , a = 100 ; while ( n -- ) a = Math . ceil ( a * 1.05 ) ; console . log ( a * 1000 ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c , s , n ) { s = + ( c + \" \" ) . trim ( ) , n = 100 ; while ( n = Math . ceil ( n * 1.05 ) , -- s ) ; console . log ( n * 1e3 ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var week = + input ; var amount = 100 ; for ( var i = 0 ; i < week ; i ++ ) { amount = Math . ceil ( amount * 1.05 ) ; } console . log ( amount * 1000 ) ;",
    "label": 2
  },
  {
    "code": "let input = ' ' process . stdin . resume ( ) process . stdin . setEncoding ( ' utf8 ' ) process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( ' \\n ' ) main ( ) } ) function main ( ) { for ( i = 0 ; i < input . length ; i ++ ) { let prime_count = 0 let num = parseInt ( input [ i ] ) + 1 for ( j = 0 ; j < num ; j ++ ) { if ( isPrime ( j ) === true ) { prime_count += 1 } } console . log ( prime_count ) prime_count = 0 } } function isPrime ( n ) { if ( false === Number . isInteger ( n ) ) { return false ; } if ( n <= 1 ) { return false ; } if ( 2 === n ) { return true ; } if ( 0 === n % 2 ) { return false ; } var square_root = Math . floor ( Math . sqrt ( n ) ) ; for ( var i = 3 ; i <= square_root ; i += 2 ) { if ( 0 === n % i ) { return false ; } } return true ; }",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var result = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) result . push ( arr [ i ] ) ; } return result ; } var p = prime ( 999999 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var a = Arr [ i ] ; for ( var j = 0 ; j < p . length ; j ++ ) { if ( p [ j ] > a ) break ; } console . log ( j ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) . map ( Number ) ; for ( var i = 0 ; i < p . length ; i ++ ) { var n = p [ i ] ; console . log ( count ( n ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function count ( n ) { var count = 0 ; for ( var i = 2 ; i <= n ; i ++ ) { if ( isPrimeNumber ( i ) ) { count ++ ; } } return count ; } function isPrimeNumber ( x ) { if ( x === 2 ) { return true ; } else if ( x % 2 === 0 ) { return false ; } var n = 3 ; while ( n <= Math . sqrt ( x ) ) { if ( x % n === 0 ) { return false ; } n += 2 ; } return true ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = new Int32Array ( 65535 ) ; var maxNum = 0 ; for ( var line = 0 , inputLength = input . length ; line < inputLength - 1 ; line ++ ) { var num = input [ line ] - 0 ; maxNum = maxNum < num ? num : maxNum ; } primeNumbers [ 0 ] = 2 ; var pcount = 1 ; for ( var i = 3 ; i <= maxNum ; i += 2 ) { var isPrime = true ; for ( var j = 3 , maxJ = ~ ~ Math . sqrt ( i ) ; j <= maxJ ; j += 2 ) { if ( ! ( i % j ) ) { isPrime = false ; break ; } } if ( isPrime ) { primeNumbers [ pcount ] = i ; pcount ++ ; } } MLOOP : for ( var line = 0 , inputLength = input . length ; line < inputLength - 1 ; line ++ ) { for ( var k = 0 ; k < pcount ; k ++ ) { var prime = primeNumbers [ k ] ; if ( prime > ( input [ line ] - 0 ) ) { console . log ( k ) ; continue MLOOP ; } } console . log ( pcount ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = new Int32Array ( 65535 ) ; var maxNum = 0 ; primeNumbers [ 0 ] = 2 ; var pcount = 1 ; for ( var i = 3 ; i <= 999999 ; i += 2 ) { var isPrime = true ; for ( var j = 3 , maxJ = ~ ~ Math . sqrt ( i ) ; j <= maxJ ; j += 2 ) { if ( ! ( i % j ) ) { isPrime = false ; break ; } } if ( isPrime ) { primeNumbers [ pcount ] = i ; pcount ++ ; } } MLOOP : for ( var line = 0 , inputLength = input . length ; line < inputLength - 1 ; line ++ ) { for ( var k = 0 ; k < pcount ; k ++ ) { var prime = primeNumbers [ k ] ; if ( prime > ( input [ line ] - 0 ) ) { console . log ( k ) ; continue MLOOP ; } } console . log ( pcount ) ; } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; var sum = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { primeNums [ i ] += sum + ( 1 - primeNumbers [ i ] ) ; sum = primeNums [ i ] ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; var sum = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { sum = primeNums [ i ] += sum + ( 1 - primeNumbers [ i ] ) ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; var sum = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { sum = primeNums [ i ] += sum + ( ! primeNumbers [ i ] ) ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; var sum = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { sum = primeNums [ i ] += sum + 1 - primeNumbers [ i ] ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; for ( var i = 1 ; i <= max ; i ++ ) { primeNums [ i ] += primeNums [ i - 1 ] + 1 - primeNumbers [ i ] ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int32Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 0 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } for ( var i = 2 ; i <= max ; i ++ ) { primeNumbers [ i ] = primeNumbers [ i - 1 ] - primeNumbers [ i ] + 1 ; } return primeNumbers ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var intInput = new Int32Array ( input ) ; var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ intInput [ i ] ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int32Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 0 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } for ( var i = 2 ; i <= max ; i ++ ) { primeNumbers [ i ] = primeNumbers [ i - 1 ] - primeNumbers [ i ] + 1 ; } return primeNumbers ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length ; i < len ; i ++ ) { console . log ( primeNumbers [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 ; i <= 1000 ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; for ( var i = 1 ; i <= max ; i ++ ) { primeNums [ i ] += primeNums [ i - 1 ] + 1 - primeNumbers [ i ] ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length ; i < len ; i ++ ) { console . log ( primeNumbers [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int32Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 0 ; for ( var i = 2 ; i <= 1000 ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } for ( var i = 2 ; i <= max ; i ++ ) { primeNumbers [ i ] = primeNumbers [ i - 1 ] + 1 - primeNumbers [ i ] ; } return primeNumbers ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length ; i < len ; i ++ ) { console . log ( primeNumbers [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int32Array ( max + 1 ) ; for ( var i = 2 ; i <= 1000 ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } for ( var i = 2 ; i <= max ; i ++ ) { primeNumbers [ i ] = primeNumbers [ i - 1 ] + 1 - primeNumbers [ i ] ; } return primeNumbers ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; for ( var i = 1 ; i <= max ; i ++ ) { primeNums [ i ] += primeNums [ i - 1 ] + 1 - primeNumbers [ i ] ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( primeNumbers [ input [ i ] - 0 ] ) ; } } function calcPrimeNumbers ( ) { var max = 999999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( max + 1 ) ; for ( var i = 1 ; i <= max ; i ++ ) { primeNums [ i ] += primeNums [ i - 1 ] + 1 - primeNumbers [ i ] ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var result = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) result . push ( arr [ i ] ) ; } return result ; } var p = prime ( 999999 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var a = Arr [ i ] ; for ( var j = 0 ; j < p . length ; j ++ ) { if ( p [ j ] > a ) break ; } console . log ( j ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; if ( N === 1 ) { console . log ( 0 ) ; } else if ( N === 2 ) { console . log ( 1 ) ; } else { var prime = new Array ( N ) ; var sq , i , j , found , cnt ; sq = Math . sqrt ( N ) ; cnt = 1 ; prime [ 0 ] = 2 ; for ( i = 3 ; i <= N ; ++ i ) { found = 1 ; for ( j = 0 ; prime [ j ] <= sq ; ++ j ) { if ( i % prime [ j ] === 0 ) { found = 0 ; break ; } } if ( found ) { prime [ cnt ++ ] = i ; } } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; if ( N === 1 ) { console . log ( 0 ) ; } else if ( N === 2 ) { console . log ( 1 ) ; } else { var prime = new Array ( N ) ; var sq , i , j , found , cnt ; sq = Math . sqrt ( N ) ; cnt = 1 ; prime [ 0 ] = 2 ; for ( i = 3 ; i <= N ; i += 2 ) { found = 1 ; for ( j = 0 ; prime [ j ] <= sq ; ++ j ) { if ( i % prime [ j ] === 0 ) { found = 0 ; break ; } } if ( found ) { prime [ cnt ++ ] = i ; } } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var primeNxt = new Array ( 1000000 ) ; function primeGenerator ( ) { var p , fact , m ; var maxN = 9999999 ; var primePrv = new Array ( 1000000 ) ; for ( p = 2 ; p <= maxN ; ++ p ) { primeNxt [ p ] = p + 1 ; primePrv [ p ] = p - 1 ; } primePrv [ 2 ] = 0 ; primeNxt [ maxN ] = 0 ; for ( p = 2 ; p * p <= maxN ; p = primeNxt [ p ] ) { for ( fact = p ; p * fact <= maxN ; fact = primeNxt [ fact ] ) { for ( m = p * fact ; m <= maxN ; m *= p ) { primeNxt [ primePrv [ m ] ] = primeNxt [ m ] ; primePrv [ primeNxt [ m ] ] = primePrv [ m ] ; } } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { primeGenerator ( ) ; input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; if ( N === 1 ) { console . log ( 0 ) ; } else if ( N === 2 ) { console . log ( 1 ) ; } else { var i , cnt ; cnt = 0 ; for ( i = 2 ; i <= N ; i = primeNxt [ i ] ) { ++ cnt ; } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var primeNxt = new Array ( 1000000 ) ; function primeGenerator ( ) { var p , fact , m ; var maxN = 9999999 ; var primePrv = new Array ( 1000000 ) ; for ( p = 2 ; p <= maxN ; ++ p ) { primeNxt [ p ] = p + 1 ; primePrv [ p ] = p - 1 ; } primePrv [ 2 ] = 0 ; primeNxt [ maxN ] = 0 ; for ( p = 2 ; p * p <= maxN ; p = primeNxt [ p ] ) { for ( fact = p ; p * fact <= maxN ; fact = primeNxt [ fact ] ) { for ( m = p * fact ; m <= maxN ; m *= p ) { primeNxt [ primePrv [ m ] ] = primeNxt [ m ] ; primePrv [ primeNxt [ m ] ] = primePrv [ m ] ; } } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { primeGenerator ( ) ; input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; var cnt = 1 ; if ( N == 1 ) { console . log ( 0 ) ; } else if ( N == 2 ) { console . log ( 1 ) ; } else { for ( var i = 3 ; i <= N ; i = primeNxt [ i ] ) { ++ cnt ; } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var primeNxt = new Array ( 1000000 ) ; function primeGenerator ( ) { var p , fact , m ; var maxN = 1002001 ; var primePrv = new Array ( 1000000 ) ; for ( p = 2 ; p <= maxN ; ++ p ) { primeNxt [ p ] = p + 1 ; primePrv [ p ] = p - 1 ; } primePrv [ 2 ] = 0 ; primeNxt [ maxN ] = 0 ; for ( p = 2 ; p * p <= maxN ; p = primeNxt [ p ] ) { for ( fact = p ; p * fact <= maxN ; fact = primeNxt [ fact ] ) { for ( m = p * fact ; m <= maxN ; m *= p ) { primeNxt [ primePrv [ m ] ] = primeNxt [ m ] ; primePrv [ primeNxt [ m ] ] = primePrv [ m ] ; } } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { primeGenerator ( ) ; input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; var cnt = 1 ; if ( N == 1 ) { console . log ( 0 ) ; } else if ( N == 2 ) { console . log ( 1 ) ; } else { for ( var i = 3 ; i <= N ; i = primeNxt [ i ] ) { ++ cnt ; } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var primeNxt = new Array ( 1000000 ) ; function primeGenerator ( ) { var p , fact , m ; var maxN = 9999999 ; var primePrv = new Array ( 1000000 ) ; for ( p = 2 ; p <= maxN ; ++ p ) { primeNxt [ p ] = p + 1 ; primePrv [ p ] = p - 1 ; } primePrv [ 2 ] = 0 ; primeNxt [ maxN ] = 0 ; for ( p = 2 ; p * p <= maxN ; p = primeNxt [ p ] ) { for ( fact = p ; p * fact <= maxN ; fact = primeNxt [ fact ] ) { for ( m = p * fact ; m <= maxN ; m *= p ) { primeNxt [ primePrv [ m ] ] = primeNxt [ m ] ; primePrv [ primeNxt [ m ] ] = primePrv [ m ] ; } } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { primeGenerator ( ) ; input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; var cnt = 1 ; if ( N == 1 ) { console . log ( 0 ) ; } else if ( N == 2 ) { console . log ( 1 ) ; } else { for ( var i = 3 ; i <= N ; i = primeNxt [ i ] ) { ++ cnt ; } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var primeNxt = new Array ( 1000000 ) ; function primeGenerator ( ) { var p , fact , m ; var maxN = 1002001 ; var primePrv = new Array ( 1000000 ) ; for ( p = 2 ; p <= maxN ; ++ p ) { primeNxt [ p ] = p + 1 ; primePrv [ p ] = p - 1 ; } primePrv [ 2 ] = 0 ; primeNxt [ maxN ] = 0 ; for ( p = 2 ; p * p <= maxN ; p = primeNxt [ p ] ) { for ( fact = p ; p * fact <= maxN ; fact = primeNxt [ fact ] ) { for ( m = p * fact ; m <= maxN ; m *= p ) { primeNxt [ primePrv [ m ] ] = primeNxt [ m ] ; primePrv [ primeNxt [ m ] ] = primePrv [ m ] ; } } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { primeGenerator ( ) ; input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( val ) { var N = parseInt ( val ) ; var cnt = 1 ; if ( N == 1 ) { console . log ( 0 ) ; } else if ( N == 2 ) { console . log ( 1 ) ; } else { for ( var i = 3 ; i <= N ; i = primeNxt [ i ] ) { ++ cnt ; } console . log ( cnt ) ; } } ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var primeNxt = new Array ( 1000000 ) ; function primeGenerator ( ) { var p , fact , m ; var maxN = 1002001 ; var primePrv = new Array ( 1000000 ) ; for ( p = 2 ; p <= maxN ; ++ p ) { primeNxt [ p ] = p + 1 ; primePrv [ p ] = p - 1 ; } primePrv [ 2 ] = 0 ; primeNxt [ maxN ] = 0 ; for ( p = 2 ; p * p <= maxN ; p = primeNxt [ p ] ) { for ( fact = p ; p * fact <= maxN ; fact = primeNxt [ fact ] ) { for ( m = p * fact ; m <= maxN ; m *= p ) { primeNxt [ primePrv [ m ] ] = primeNxt [ m ] ; primePrv [ primeNxt [ m ] ] = primePrv [ m ] ; } } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { primeGenerator ( ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var len = lines . length ; for ( var t = 0 ; t < len ; ++ t ) { var N = parseInt ( lines [ t ] ) ; var cnt = 1 ; if ( N == 1 ) { console . log ( 0 ) ; } else if ( N == 2 ) { console . log ( 1 ) ; } else { for ( var i = 3 ; i <= N ; i = primeNxt [ i ] ) { ++ cnt ; } console . log ( cnt ) ; } } } ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( \" fs \" ) ; var primes = [ 2 ] ; function scan_primes ( max ) { var min = primes [ primes . length - 1 ] ; if ( max <= min ) { return ; } for ( var n = min + 1 ; n <= max ; n ++ ) { var isPrime = true ; var limit = Math . sqrt ( n ) ; for ( var i = 0 ; i < primes . length ; i ++ ) { var p = primes [ i ] ; if ( p > limit ) { break ; } if ( n % p === 0 ) { isPrime = false ; break ; } } if ( isPrime ) { primes . push ( n ) ; } } } function count_primes_until ( m ) { for ( var i = 0 ; i < primes . length ; i ++ ) { if ( primes [ i ] > m ) { return i ; } } return primes . length ; } var input = fs . readFileSync ( ' /dev/stdin ' ) . toString ( ) ; var lines = input . split ( \" \\n \" ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { var n = parseInt ( lines [ i ] ) ; if ( ! isNaN ( n ) ) { scan_primes ( n + 1 ) ; console . log ( count_primes_until ( n ) ) ; } }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { main ( chunk . trim ( ) ) ; } ) ; function main ( chunk ) { var lines = chunk . split ( \" \\n \" ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { console . log ( calc ( Number ( lines [ i ] ) ) ) ; } } var arr = [ 2 ] ; function calc ( num ) { if ( arr [ arr . length - 1 ] > num ) { for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > num ) { return i ; } } } start : for ( var i = arr [ arr . length - 1 ] + ( arr [ arr . length - 1 ] % 2 == 0 ? 1 : 2 ) ; i <= num ; i += 2 ) { for ( var j = 0 ; j < arr . length ; j ++ ) { if ( i % arr [ j ] == 0 ) { continue start ; } if ( arr [ j ] >= Math . sqrt ( i ) ) { break ; } } arr . push ( i ) ; } return arr . length ; }",
    "label": 2
  },
  {
    "code": "config = { input : ' /dev/stdin ' , newline : ' \\n ' } ; p1000 = ( function ( ) { var ary = [ ] ; for ( var i = 2 ; i <= 1000 ; i ++ ) { var is_prime = true ; for ( var j in ary ) { if ( i % ary [ j ] === 0 ) { is_prime = false ; break ; } } if ( is_prime ) ary . push ( i ) ; } return ary ; } ) ( ) ; p1000000 = ( function ( ) { var ary = [ ] ; for ( var i = 1001 ; i <= 1000000 ; i ++ ) { var is_prime = true ; for ( var j in p1000 ) { if ( i % p1000 [ j ] === 0 ) { is_prime = false ; break ; } } if ( is_prime ) ary . push ( i ) ; } return ary ; } ) ( ) ; prime = p1000 . concat ( p1000000 ) ; require ( ' fs ' ) . readFileSync ( config . input , ' ascii ' ) . trim ( ) . split ( config . newline ) . forEach ( function ( line ) { var n = parseInt ( line ) ; console . log ( prime . filter ( function ( x ) { return x <= n ; } ) . length ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function underscore ( undefined ) { ' use strict ' ; var ArrayProto = Array . prototype , ObjProto = Object . prototype , FuncProto = Function . prototype ; var push = ArrayProto . push , slice = ArrayProto . slice , concat = ArrayProto . concat , toString = ObjProto . toString , hasOwnProperty = ObjProto . hasOwnProperty ; var nativeForEach = ArrayProto . forEach , nativeMap = ArrayProto . map , nativeReduce = ArrayProto . reduce , nativeReduceRight = ArrayProto . reduceRight , nativeFilter = ArrayProto . filter , nativeEvery = ArrayProto . every , nativeSome = ArrayProto . some , nativeIndexOf = ArrayProto . indexOf , nativeLastIndexOf = ArrayProto . lastIndexOf , nativeIsArray = Array . isArray , nativeKeys = Object . keys , nativeBind = FuncProto . bind ; this . _ = { } ; var each = _ . each = _ . forEach = function ( obj , iterator , context ) { if ( obj == null ) return ; if ( nativeForEach && obj . forEach === nativeForEach ) { obj . forEach ( iterator , context ) ; } else if ( obj . length === + obj . length ) { for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { if ( iterator . call ( context , obj [ i ] , i , obj ) === breaker ) return ; } } else { for ( var key in obj ) { if ( _ . has ( obj , key ) ) { if ( iterator . call ( context , obj [ key ] , key , obj ) === breaker ) return ; } } } } ; _ . extend = function ( obj ) { each ( slice . call ( arguments , 1 ) , function ( source ) { if ( source ) { for ( var prop in source ) { obj [ prop ] = source [ prop ] ; } } } ) ; return obj ; } ; } ) . call ( global ) ; ( function ( undefined ) { ' use strict ' ; var INPUT_TYPE = ' number ' ; var SIZE = 1000001 ; var Solver = { primes : [ ] , fire : function ( ) { setTimeout ( Solver . solve , 0 , this ) ; } , pre_calc : function ( ) { var primes = Solver . primes ; for ( var i = 0 ; i < SIZE ; ++ i ) primes [ i ] = false ; primes [ 2 ] = true ; for ( var i = 3 ; i < SIZE ; i += 2 ) primes [ i ] = true ; for ( var i = 3 ; i < SIZE ; i += 2 ) { if ( ! primes [ i ] ) continue ; for ( var j = i + i ; j < SIZE ; j += i ) primes [ j ] = false ; } } , solve : function solve ( ) { var primes = Solver . primes ; var n = input_number ( ) ; output ( primes . slice ( 0 , n + 1 ) . filter ( function ( element ) { return element ; } ) . length ) ; if ( ! has_next ( ) ) setTimeout ( Solver . solve , 0 , this ) ; } } ; if ( Solver . pre_calc instanceof Function ) Solver . pre_calc . call ( this ) ; ( function init ( ) { _ . extend ( this , { output : function ( ) { console . log . apply ( console , arguments ) ; } , stdin : process . openStdin ( ) , input_list : [ ] , input_number : function ( ) { return parseInt ( input_list . splice ( 0 , 1 ) [ 0 ] ) ; } , input_text : function ( ) { return input_list . splice ( 0 , 1 ) [ 0 ] ; } , has_next : function ( ) { return ! input_list . length ; } } ) ; var INPUT_REGEXP_LIST = { } ; INPUT_REGEXP_LIST [ ' string ' ] = / \\w* / g ; INPUT_REGEXP_LIST [ ' number ' ] = / [-]?\\d+ / g ; var INPUT_REGEXP = INPUT_REGEXP_LIST [ INPUT_TYPE ] ; stdin . setEncoding ( ' utf8 ' ) ; stdin . on ( ' data ' , function ( chunk ) { var result = chunk . match ( INPUT_REGEXP ) ; input_list = input_list . concat ( result . filter ( function ( line ) { return line . length ; } ) ) ; } ) ; stdin . on ( ' end ' , function ( ) { Solver . fire . call ( this ) ; } ) ; } ) . call ( this ) ; } ) . call ( global ) ;",
    "label": 2
  },
  {
    "code": "function sl ( n ) { if ( n % 2 === 0 ) { return 2 ; } for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i === 0 ) { return i ; } } return n ; } var a = [ 2 , 3 ] ; for ( var i = 1 , l = 1e6 ; i * 6 + 1 < l ; i ++ ) { var o = i * 6 - 1 , p = i * 6 + 1 ; sl ( o ) === o && a . push ( o ) ; sl ( p ) === p && a . push ( p ) ; } process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n ) { var i = 0 , n = + n , c = 0 ; while ( a [ i ++ ] <= n ) c ++ ; console . log ( c ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var num = + line ; if ( num == 2 ) { console . log ( 1 ) ; continue ; } else if ( num == 3 ) { console . log ( 2 ) ; continue ; } else if ( num < 2 ) { console . log ( 0 ) ; continue ; } var cnt = 2 ; for ( var i = 5 ; i <= num ; i ++ ) { if ( isPrime ( i ) ) { cnt ++ ; } } console . log ( cnt ) ; } function isPrime ( num ) { if ( num == 2 || num == 3 ) return true ; if ( num < 2 || num % 2 == 0 || num % 3 == 0 ) return false ; var limit = Math . round ( Math . sqrt ( num ) ) ; var i = 1 ; while ( i * 6 - 1 <= limit ) { if ( num % ( i * 6 - 1 ) == 0 || num % ( i * 6 + 1 ) == 0 ) return false ; i ++ ; } return true ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = Number ( p . shift ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var args = p [ i ] . split ( ' ' ) . map ( Number ) ; var x1 = args . shift ( ) ; var y1 = args . shift ( ) ; var x2 = args . shift ( ) ; var y2 = args . shift ( ) ; var x3 = args . shift ( ) ; var y3 = args . shift ( ) ; var x = ( ( Math . pow ( x3 , 2 ) - Math . pow ( x2 , 2 ) + Math . pow ( y3 , 2 ) - Math . pow ( y2 , 2 ) ) * ( y2 - y1 ) - ( Math . pow ( x2 , 2 ) - Math . pow ( x1 , 2 ) + Math . pow ( y2 , 2 ) - Math . pow ( y1 , 2 ) ) * ( y3 - y2 ) ) / 2 / ( ( y2 - y1 ) * ( x3 - x2 ) - ( x2 - x1 ) * ( y3 - y2 ) ) ; var y = ( ( Math . pow ( y3 , 2 ) - Math . pow ( y2 , 2 ) + Math . pow ( x3 , 2 ) - Math . pow ( x2 , 2 ) ) * ( x2 - x1 ) - ( Math . pow ( y2 , 2 ) - Math . pow ( y1 , 2 ) + Math . pow ( x2 , 2 ) - Math . pow ( x1 , 2 ) ) * ( x3 - x2 ) ) / 2 / ( ( x2 - x1 ) * ( y3 - y2 ) - ( y2 - y1 ) * ( x3 - x2 ) ) ; console . log ( x . toFixed ( 3 ) , y . toFixed ( 3 ) , Math . sqrt ( Math . pow ( x1 - x , 2 ) + Math . pow ( y1 - y , 2 ) ) . toFixed ( 3 ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( i = 0 ; i < n ; i ++ ) { var arr = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 ) { var d1 = x1 * x1 + y1 * y1 ; var d2 = x2 * x2 + y2 * y2 ; var d3 = x3 * x3 + y3 * y3 ; var u = 0.5 / ( x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3 ) ; var a = u * ( d1 * y2 - d2 * y1 + d2 * y3 - d3 * y2 + d3 * y1 - d1 * y3 ) ; var b = u * ( x1 * d2 - x2 * d1 + x2 * d3 - x3 * d2 + x3 * d1 - x1 * d3 ) ; var r = Math . sqrt ( ( a - x1 ) * ( a - x1 ) + ( b - y1 ) * ( b - y1 ) ) ; console . log ( a . toFixed ( 3 ) + \" \" + b . toFixed ( 3 ) + \" \" + r . toFixed ( 3 ) ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j . length == 6 ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , p = ( ( b - f ) * ( h - l + g - k ) - ( b - d ) * ( h - n + g - m ) ) / ( 2 * ( b - f ) * ( a - c ) - 2 * ( b - d ) * ( a - e ) ) , q = ( ( a - e ) * ( g - k + h - l ) - ( a - c ) * ( g - m + h - n ) ) / ( 2 * ( a - e ) * ( b - d ) - 2 * ( a - c ) * ( b - f ) ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , p = ( ( b - f ) * ( h - l + g - k ) - ( b - d ) * ( h - n + g - m ) ) / ( 2 * ( b - f ) * ( a - c ) - 2 * ( b - d ) * ( a - e ) ) , q = ( ( a - e ) * ( g - k + h - l ) - ( a - c ) * ( g - m + h - n ) ) / ( 2 * ( a - e ) * ( b - d ) - 2 * ( a - c ) * ( b - f ) ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { j = i . split ( ' ' ) ; if ( j [ 1 ] ) a = j [ 0 ] , b = j [ 1 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { j = i . split ( ' ' ) ; if ( b = j [ 1 ] ) a = j [ 0 ] , c = j [ 2 ] , d = j [ 3 ] , e = j [ 4 ] , f = j [ 5 ] , g = a * a , h = b * b , k = c * c , l = d * d , m = e * e , n = f * f , o = a - c , r = b - d , s = b - f , t = a - e , p = ( s * ( h - l + g - k ) - r * ( h - n + g - m ) ) / ( 2 * s * o - 2 * r * t ) , q = ( t * ( g - k + h - l ) - o * ( g - m + h - n ) ) / ( 2 * t * r - 2 * o * s ) , console . log ( p . toFixed ( 3 ) , q . toFixed ( 3 ) , Math . sqrt ( ( a - p ) * ( a - p ) + ( b - q ) * ( b - q ) ) . toFixed ( 3 ) ) } )",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . slice ( 1 ) . some ( function ( n ) { n = n . split ( \" \" ) ; var x1 = + n [ 0 ] , y1 = + n [ 1 ] , x2 = + n [ 2 ] , y2 = + n [ 3 ] , x3 = + n [ 4 ] , y3 = + n [ 5 ] , a = 2 * ( x1 - x2 ) , b = 2 * ( y1 - y2 ) , c = x1 * x1 + y1 * y1 - ( x2 * x2 + y2 * y2 ) , d = 2 * ( x1 - x3 ) , e = 2 * ( y1 - y3 ) , f = x1 * x1 + y1 * y1 - ( x3 * x3 + y3 * y3 ) , z = a * e - b * d , x = ( c * e - f * b ) / z , y = ( f * a - c * d ) / z ; console . log ( x . toFixed ( 3 ) , y . toFixed ( 3 ) , Math . sqrt ( Math . pow ( x - x1 , 2 ) + Math . pow ( y - y1 , 2 ) ) . toFixed ( 3 ) ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var w = Arr . shift ( ) ; var n = Arr . shift ( ) ; var arr = [ 0 ] ; for ( var i = 1 ; i <= w ; i ++ ) arr [ i ] = i ; for ( var i = 0 ; i < n ; i ++ ) { var ab = Arr [ i ] . split ( \" , \" ) . map ( Number ) ; var a = ab [ 0 ] ; var b = ab [ 1 ] ; var x = arr [ a ] ; arr [ a ] = arr [ b ] ; arr [ b ] = x ; } arr . shift ( ) ; console . log ( arr . join ( \" \\n \" ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var w = Number ( p . shift ( ) ) ; var n = Number ( p . shift ( ) ) ; var W = [ ] ; for ( var i = 0 ; i < w ; i ++ ) { W . push ( i ) ; } for ( var i = 0 ; i < n ; i ++ ) { var args = p [ i ] . split ( ' , ' ) . map ( Number ) ; var a = args [ 0 ] ; var b = args [ 1 ] ; var tmp = W [ a - 1 ] ; W [ a - 1 ] = W [ b - 1 ] ; W [ b - 1 ] = tmp ; } console . log ( W . map ( function ( e ) { return e + 1 ; } ) . join ( ' \\n ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var w = parseInt ( input [ 0 ] , 10 ) ; var n = parseInt ( input [ 1 ] , 10 ) ; var goto = new Int8Array ( w ) ; for ( var i = 0 , len = goto . length ; i < len ; i ++ ) { goto [ i ] = i ; } for ( var i = 2 ; i < n + 2 ; i ++ ) { var c = input [ i ] . split ( \" , \" ) ; var from = parseInt ( c [ 0 ] , 10 ) - 1 ; var to = parseInt ( c [ 1 ] , 10 ) - 1 ; goto [ from ] ^= goto [ to ] ; goto [ to ] ^= goto [ from ] ; goto [ from ] ^= goto [ to ] ; } for ( var i = 0 ; i < len ; i ++ ) { console . log ( goto [ i ] + 1 ) ; } }",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) , w = + i [ 0 ] , a = [ ] ; for ( ; a [ w ] = w -- ; ) ; i . map ( function ( j ) { k = j . split ( ' , ' ) , l = + k [ 0 ] , m = + k [ 1 ] ; if ( m ) t = a [ l ] , a [ l ] = a [ m ] , a [ m ] = t } ) ; console . log ( a . slice ( 1 ) . join ( ' \\n ' ) )",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var w = + lines . shift ( ) ; var n = + lines . shift ( ) ; var list = [ ] ; var line = null ; while ( line = lines . shift ( ) ) { var args = line . split ( ' , ' ) ; list . push ( args ) ; } var answers = [ ] ; for ( var i = 1 ; i <= w ; i ++ ) { var k = i ; list . forEach ( function ( args ) { if ( args [ 0 ] == k ) { k = args [ 1 ] ; } else if ( args [ 1 ] == k ) { k = args [ 0 ] ; } } ) ; answers [ k ] = i ; } answers . shift ( ) ; console . log ( answers . join ( ' \\n ' ) ) ;",
    "label": 2
  },
  {
    "code": "function main ( input ) { var n = + input . shift ( ) ; var m = + input . shift ( ) ; var x = [ ] ; rep ( n , function ( i ) { x . push ( i + 1 ) ; } ) ; rep ( m , function ( i ) { var t = input . shift ( ) . split ( ' , ' ) ; var a = t [ 0 ] - 1 ; var b = t [ 1 ] - 1 ; var tmp = x [ a ] ; x [ a ] = x [ b ] ; x [ b ] = tmp ; } ) ; rep ( n , function ( i ) { console . log ( x [ i ] ) ; } ) ; } function rep ( n , func ) { for ( var i = 0 ; i < n ; ++ i ) { func ( i ) ; } } ( function ( ) { process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input . split ( / \\s+ / ) ) ; } ) ; } ) ( ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { main ( chunk . trim ( ) ) ; } ) ; function main ( chunk ) { var lines = chunk . split ( \" \\n \" ) ; var w = Number ( lines [ 0 ] ) ; var n = Number ( lines [ 1 ] ) ; var ans = [ ] ; for ( var i = 1 ; i <= w ; i ++ ) { ans . push ( i ) ; } var index = 2 ; for ( var i = 0 ; i < n ; i ++ ) { var a = Number ( lines [ index ] . split ( \" , \" ) [ 0 ] ) - 1 ; var b = Number ( lines [ index ] . split ( \" , \" ) [ 1 ] ) - 1 ; var tmp = ans [ a ] ; ans [ a ] = ans [ b ] ; ans [ b ] = tmp ; index ++ ; } for ( var i = 0 ; i < w ; i ++ ) { console . log ( ans [ i ] ) ; } }",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { var x = ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) , n = + x [ 0 ] , a = [ ] ; while ( a [ n ] = n -- ) ; x . slice ( 2 ) . some ( function ( s , p ) { s = s . split ( \" , \" ) ; p = a [ + s [ 0 ] ] ; a [ + s [ 0 ] ] = a [ + s [ 1 ] ] ; a [ + s [ 1 ] ] = p ; } ) ; a . slice ( 1 ) . some ( function ( a ) { console . log ( a ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "function swap ( A , a , b ) { var tmp = A [ a - 1 ] ; A [ a - 1 ] = A [ b - 1 ] ; A [ b - 1 ] = tmp ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var w = lines . shift ( ) ; var arr = [ ] ; for ( var i = 0 ; i < w ; i ++ ) { arr . push ( i + 1 ) ; } var n = lines . shift ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var nums = lines . shift ( ) . split ( ' , ' ) . map ( function ( i ) { return + i ; } ) ; swap ( arr , nums [ 0 ] , nums [ 1 ] ) ; } arr . forEach ( function ( num ) { console . log ( num ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; var arr = [ ] ; Arr . forEach ( function ( v ) { if ( v == 0 ) { console . log ( arr . pop ( ) ) ; } else { arr . push ( v ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) . map ( Number ) ; var array = [ ] ; while ( p . length > 0 ) { var n = p . shift ( ) ; if ( n === 0 ) { console . log ( array . pop ( ) ) ; continue ; } array . push ( n ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var queue = [ ] ; for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var inp = input [ i ] - 0 ; if ( inp ) { queue . push ( inp ) ; } else { console . log ( queue . pop ( ) ) ; } } }",
    "label": 2
  },
  {
    "code": "q = [ ] ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { i != 0 ? q . push ( i ) : console . log ( q . pop ( ) ) } )",
    "label": 2
  },
  {
    "code": "q = [ ] ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { i != 0 ? q . push ( i ) : console . log ( q . pop ( ) ) } )",
    "label": 2
  },
  {
    "code": "q = [ ] ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { + i ? q . push ( i ) : console . log ( q . pop ( ) ) } )",
    "label": 2
  },
  {
    "code": "for ( q = [ ] , j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) + i ? q . push ( i ) : console . log ( q . pop ( ) )",
    "label": 2
  },
  {
    "code": "for ( q = [ ] , j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) + i ? q . push ( i ) : console . log ( q . pop ( ) )",
    "label": 2
  },
  {
    "code": "for ( q = [ ] , j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) + i ? q . push ( i ) : console . log ( q . pop ( ) )",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) ; } ) ; function main ( input ) { var stack = [ ] ; input = input . split ( ' \\n ' ) ; input . forEach ( function ( number ) { if ( number === ' 0 ' ) { console . log ( stack . pop ( ) ) ; } else { stack . push ( number ) ; } } ) ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var s = [ ] ; var x ; while ( ( x = scan ( ) ) , x === x ) { if ( x === 0 ) { print ( s . pop ( ) ) ; } else { s . push ( x ) ; } } } function rep ( a , b , c ) { if ( c === undefined ) { c = b ; b = a ; a = 0 ; } for ( var i = a ; i < b ; ++ i ) { if ( c ( i ) === false ) { break ; } } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; var input_index = 0 ; function scan ( type ) { if ( type === ' string ' ) { return input [ input_index ++ ] ; } else { return + input [ input_index ++ ] ; } } function print ( val ) { console . log ( val ) ; } process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . trim ( ) . split ( / \\s+ / ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { var a = [ ] ; ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n ) { + n === 0 ? console . log ( a . pop ( ) ) : a . push ( n ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; while ( n > 0 ) { var a = ( Arr . shift ( ) ) . split ( \" \" ) . reverse ( ) . map ( Number ) ; var b = ( Arr . shift ( ) ) . split ( \" \" ) . reverse ( ) . map ( Number ) ; var c = [ ] ; var max = Math . max ( a . length , b . length ) ; for ( var i = 0 ; i < max + 1 ; i ++ ) c [ i ] = 0 ; for ( var i = 0 ; i < max ; i ++ ) { var sum = 0 ; if ( a . length > i ) sum += a [ i ] ; if ( b . length > i ) sum += b [ i ] ; c [ i ] += sum ; } for ( var i = 0 ; i < max ; i ++ ) { if ( c [ i ] >= 10 ) { c [ i ] -= 10 ; c [ i + 1 ] ++ ; } } if ( c [ c . length - 1 ] == 0 ) c . pop ( ) ; var str = c . reverse ( ) . join ( \" \" ) ; if ( c . length > 80 ) str = \" overflow \" ; console . log ( str ) ; n -- ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var N = Number ( p . shift ( ) ) ; var count = 0 ; while ( count ++ < N ) { var n1 = p . shift ( ) ; var n2 = p . shift ( ) ; if ( n1 . length > 80 || n2 . length > 80 ) { console . log ( ' overflow ' ) ; continue ; } var n = sum ( n1 , n2 ) ; if ( n . length > 80 ) { console . log ( ' overflow ' ) ; continue ; } console . log ( ' %s ' , n ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function sum ( n1 , n2 ) { var a , b ; if ( n1 . length > n2 . length ) { a = n1 . split ( ' ' ) . map ( Number ) . reverse ( ) ; b = n2 . split ( ' ' ) . map ( Number ) . reverse ( ) ; } else { b = n1 . split ( ' ' ) . map ( Number ) . reverse ( ) ; a = n2 . split ( ' ' ) . map ( Number ) . reverse ( ) ; } for ( var i = 0 ; i < b . length ; i ++ ) { a [ i ] += b [ i ] ; } for ( var i = 0 ; i < a . length - 1 ; i ++ ) { if ( a [ i ] >= 10 ) { var m = Math . floor ( a [ i ] / 10 ) ; a [ i ] = a [ i ] % 10 ; a [ i + 1 ] += m ; } } return a . reverse ( ) . join ( ' ' ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 1 ; for ( var len = input [ 0 ] - 0 ; len -- ; ) { var x = input [ i ++ ] . split ( ' ' ) . reverse ( ) . join ( ' ' ) . trim ( ) ; var y = input [ i ++ ] . split ( ' ' ) . reverse ( ) . join ( ' ' ) . trim ( ) ; var loop = x . length > y . length ? x . length : y . length ; var results = new Int8Array ( loop + 1 ) ; for ( var j = 0 ; j < loop ; j ++ ) { var xj = x . length > j ? x [ j ] - 0 : 0 ; var yj = y . length > j ? y [ j ] - 0 : 0 ; var rj = results [ j ] - 0 ; var sum = xj + yj + rj ; if ( sum >= 10 ) { sum -= 10 ; results [ j + 1 ] ++ ; } results [ j ] = sum ; } var result = \" \" ; for ( loop ++ ; loop -- ; ) { result += results [ loop ] ; } result = result . replace ( / ^0 / g , \" \" ) ; console . log ( result . length > 80 ? ' overflow ' : result ) ; } }",
    "label": 2
  },
  {
    "code": "function bigAdd ( A , B ) { var m , n , mn , i , j , carry , tmp ; var buf , a1 , a2 ; if ( A . length > B . length ) { m = A . length ; n = B . length ; a1 = A . split ( \" \" ) ; a2 = B . split ( \" \" ) ; } else { m = B . length ; n = A . length ; a1 = B . split ( \" \" ) ; a2 = A . split ( \" \" ) ; } if ( m > 80 ) { console . log ( \" overflow \" ) ; return ; } mn = m + 1 ; buf = new Array ( mn ) ; for ( j = m - 1 , i = n - 1 , carry = 0 ; i >= 0 ; -- i , -- j ) { tmp = parseInt ( a1 [ j ] ) + parseInt ( a2 [ i ] ) + carry ; buf [ j + 1 ] = tmp % 10 ; carry = parseInt ( tmp / 10 ) ; } for ( ; j >= 0 ; -- j ) { tmp = parseInt ( a1 [ j ] ) + carry ; buf [ j + 1 ] = tmp % 10 ; carry = parseInt ( tmp / 10 ) ; } buf [ 0 ] = carry ; if ( carry > 0 ) { if ( m == 80 ) { console . log ( \" overflow \" ) ; } else { console . log ( buf . join ( \" \" ) ) ; } } else { console . log ( buf . slice ( 1 , mn ) . join ( \" \" ) ) ; } } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var line = input . trim ( ) . split ( \" \\n \" ) ; var i = 0 ; var N = parseInt ( line [ i ++ ] . trim ( ) ) ; { for ( ; N > 0 ; -- N ) { bigAdd ( line [ i ] , line [ i + 1 ] ) ; i = i + 2 ; } } } ) ;",
    "label": 2
  },
  {
    "code": "function pad ( n ) { while ( n . length < 7 ) { n = \" 0 \" + n } return n ; } function divide ( s ) { var a = [ ] , i = 0 , l = s . length , d = 7 ; for ( ; ( a [ i ] = s . slice ( ( i + 1 ) * - d , l + i * - d ) ) . length > d - 1 ; i ++ ) ; return a ; } function unite ( a ) { return a . concat ( ) . reverse ( ) . join ( \" \" ) . replace ( / ^0* / , \" \" ) ; } function largeSum ( n , m ) { for ( var h = 0 , o = [ ] , i = 0 , l = Math . max ( n . length , m . length ) ; i < l || h != 0 ; i ++ ) { var a = ( ( parseInt ( n [ i ] , 10 ) || 0 ) + ( parseInt ( m [ i ] , 10 ) || 0 ) + ( + h ) ) . toString ( 10 ) ; o [ i ] = a . length > 7 ? ( h = a . slice ( 0 , 1 ) , a . slice ( 1 ) ) : ( h = 0 , pad ( a ) ) ; } return o ; } process . stdin . on ( \" data \" , function ( c ) { var a = ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) ; for ( var i = 0 , l = + a . shift ( ) * 2 ; i < l ; i += 2 ) { var s = unite ( largeSum ( divide ( a [ i ] ) , divide ( a [ i + 1 ] ) ) ) ; console . log ( s == \" \" ? 0 : s . length > 80 ? \" overflow \" : s ) ; } } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var x = 0 ; var y = 0 ; var r = 0 ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == \" 0,0 \" ) break ; var arr = Arr [ i ] . split ( \" , \" ) . map ( Number ) ; x += arr [ 0 ] * Math . cos ( r * Math . PI / 180 ) ; y += arr [ 0 ] * Math . sin ( r * Math . PI / 180 ) ; r += arr [ 1 ] ; } console . log ( parseInt ( y , 10 ) ) ; console . log ( parseInt ( x , 10 ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var bt = 0 ; var x = 0 ; var y = 0 ; while ( true ) { var l = p . shift ( ) . split ( ' , ' ) . map ( Number ) ; var r = l [ 0 ] ; var t = l [ 1 ] ; if ( r === 0 && t === 0 ) { break ; } x += r * Math . cos ( Math . PI * bt / 180 ) ; y += r * Math . sin ( Math . PI * bt / 180 ) ; bt += t ; } console . log ( y > 0 ? Math . floor ( y ) : Math . ceil ( y ) ) ; console . log ( x > 0 ? Math . floor ( x ) : Math . ceil ( x ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var x = y = 0 ; var sumt = 0 ; for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var inp = input [ i ] . split ( ' , ' ) ; var r = inp [ 0 ] - 0 ; var t = inp [ 1 ] - 0 ; if ( ! r && ! t ) { break ; } x += r * Math . sin ( sumt * Math . PI / 180 ) ; y += r * Math . cos ( sumt * Math . PI / 180 ) ; sumt += t ; } console . log ( ~ ~ x ) ; console . log ( ~ ~ y ) ; }",
    "label": 2
  },
  {
    "code": "m = ' +=+j[0]*Math. ' , n = ' (s*Math.PI/180) ' , x = y = s = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' , ' ) , eval ( ' x ' + m + ' sin ' + n + ' ,y ' + m + ' cos ' + n ) , s += + j [ 1 ] } ) ; console . log ( ~ ~ x ) , console . log ( ~ ~ y )",
    "label": 2
  },
  {
    "code": "m = ' +=+j[0]*Math. ' , n = ' (s*Math.PI/180) ' , x = y = s = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' , ' ) , eval ( ' x ' + m + ' sin ' + n + ' ,y ' + m + ' cos ' + n ) , s += + j [ 1 ] } ) ; console . log ( ~ ~ x ) , console . log ( ~ ~ y )",
    "label": 2
  },
  {
    "code": "m = ' +=+j[0]*Math. ' , n = ' (s*Math.PI/180) ' , x = y = s = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { j = i . split ( ' , ' ) , eval ( ' x ' + m + ' sin ' + n + ' ,y ' + m + ' cos ' + n ) , s += + j [ 1 ] } ) ; console . log ( ~ ~ x + ' \\n ' + ~ ~ y )",
    "label": 2
  },
  {
    "code": "m = ' +=+j[0]*Math. ' , n = ' (s*Math.PI/180) ' , x = y = s = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { j = i . split ( ' , ' ) , eval ( ' x ' + m + ' sin ' + n + ' ,y ' + m + ' cos ' + n ) , s += + j [ 1 ] } ) ; console . log ( ~ ~ x + ' \\n ' + ~ ~ y )",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { var x = 0 , y = 0 , r = 0 , p = Math . PI / 180 ; ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n ) { n = n . split ( \" , \" ) ; x += + n [ 0 ] * Math . sin ( r * p ) ; y += + n [ 0 ] * Math . cos ( r * p ) ; r += + n [ 1 ] ; } ) ; console . log ( x | 0 ) ; console . log ( y | 0 ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' ' ) ; console . log ( p . sort ( function ( a , b ) { return b - a ; } ) . join ( ' ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . sort ( function ( a , b ) { return b - a } ) . join ( ' ' ) )",
    "label": 2
  },
  {
    "code": "Main ( function ( input ) { console . log ( input . trim ( ) . split ( ' ' ) . sort ( function ( a , b ) { return ( b - a ) ; } ) . join ( ' ' ) ) ; } ) ; function Main ( main ) { var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) ; } ) ; } ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( \" \" ) . sort ( function ( a , b ) { return b - a } ) . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = sample_input . split ( \" \" ) . map ( Number ) ; arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( arr . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { const splitedData = data . split ( \" \" ) ; const sortedData = splitedData . sort ( ( x , y ) => y - x ) ; let answerString = \" \" ; for ( let i = 0 ; i < sortedData . length ; i ++ ) { answerString += sortedData [ i ] ; if ( i < sortedData . length - 1 ) { answerString += \" \" ; } } console . log ( answerString ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { const splitedData = data . split ( \" \" ) ; const sortedData = splitedData . sort ( ( x , y ) => y - x ) ; let answerString = \" \" ; for ( let i = 0 ; i < sortedData . length ; i ++ ) { answerString += sortedData [ i ] ; if ( i < sortedData . length - 1 ) { answerString += \" \" ; } } console . log ( answerString ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { const input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { var Arr = ( data . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { const data = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; yourAnswerFunctionComesHere ( data ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { var Arr = ( data . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { const data = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; yourAnswerFunctionComesHere ( data ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { var Arr = ( data . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { const data = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; yourAnswerFunctionComesHere ( data ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { var Arr = ( data . trim ( ) ) . split ( \" \" ) . map ( Number ) ; Arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( Arr . join ( \" \" ) ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { const data = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; yourAnswerFunctionComesHere ( data ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "let fs = require ( ' fs ' ) ; const yourAnswerFunctionComesHere = data => { var splitedData = ( data . trim ( ) ) . split ( \" \" ) . map ( Number ) ; var sortedData = splitedData . sort ( ( x , y ) => y - x ) ; console . log ( sortedData . join ( \" \" ) ) ; } const readFile = path => { fs . readFile ( path , ' utf8 ' , ( err , data ) => { yourAnswerFunctionComesHere ( data ) ; } ) ; } const readFileWithoutArg = ( ) => { const data = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; yourAnswerFunctionComesHere ( data ) ; } let sampleInputPath = \" \" ; if ( process . argv . length > 2 ) { sampleInputPath = process . argv [ 2 ] ; readFile ( sampleInputPath ) ; } else { readFileWithoutArg ( ) ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var arr = input . split ( ' ' ) . map ( parseFloat ) ; arr . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( arr . join ( ' ' ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { console . log ( ( c + \" \" ) . trim ( ) . split ( \" \" ) . sort ( function ( a , b ) { return b - a } ) . join ( \" \" ) ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var nums = input . trim ( ) . split ( ' ' ) . map ( function ( num ) { return + num ; } ) ; nums . sort ( function ( a , b ) { return b - a ; } ) ; console . log ( nums . join ( ' ' ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; input = input . trim ( ) ; console . log ( input . toUpperCase ( ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var str = input . replace ( / \\n$ / , ' ' ) ; console . log ( str . toUpperCase ( ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . toUpperCase ( ) ) ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . toUpperCase ( ) )",
    "label": 2
  },
  {
    "code": "console . log ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . toUpperCase ( ) . trim ( ) ) ;",
    "label": 2
  },
  {
    "code": "var sample_input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; sample_str = sample_input . split ( \" \\n \" ) [ 0 ] ; console . log ( sample_str . toUpperCase ( ) ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { s = input . split ( ' \\n ' ) [ 0 ] ; console . log ( s . toUpperCase ( ) ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var sys = require ( ' sys ' ) ; function main ( ) { sys . print ( input . toUpperCase ( ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { console . log ( ( c + \" \" ) . trim ( ) . toUpperCase ( ) ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; console . log ( input . trim ( ) . toUpperCase ( ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = Number ( p . shift ( ) ) ; var i = 0 ; while ( i ++ < n ) { var args = p . shift ( ) . split ( ' ' ) . map ( Number ) ; var x1 = args . shift ( ) ; var y1 = args . shift ( ) ; var x2 = args . shift ( ) ; var y2 = args . shift ( ) ; var x3 = args . shift ( ) ; var y3 = args . shift ( ) ; var x4 = args . shift ( ) ; var y4 = args . shift ( ) ; console . log ( ( ( y2 - y1 ) / ( x2 - x1 ) ) . toFixed ( 6 ) === ( ( y4 - y3 ) / ( x4 - x3 ) ) . toFixed ( 6 ) ? ' YES ' : ' NO ' ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var k1 = ( x2 - x1 != 0 ) ? ( y2 - y1 ) / ( x2 - x1 ) : 1 ; var k2 = ( x4 - x3 != 0 ) ? ( y4 - y3 ) / ( x4 - x3 ) : 1 ; k1 = k1 . toFixed ( 6 ) ; k2 = k2 . toFixed ( 6 ) ; console . log ( ( k1 == k2 ) ? \" YES \" : \" NO \" ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var k1 = ( x2 - x1 != 0 ) ? ( y2 - y1 ) / ( x2 - x1 ) : Infinity ; var k2 = ( x4 - x3 != 0 ) ? ( y4 - y3 ) / ( x4 - x3 ) : Infinity ; k1 = k1 . toFixed ( 6 ) ; k2 = k2 . toFixed ( 6 ) ; console . log ( ( k1 == k2 ) ? \" YES \" : \" NO \" ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var k1 = ( y2 - y1 ) / ( x2 - x1 ) ; var k2 = ( y4 - y3 ) / ( x4 - x3 ) ; k1 = k1 . toFixed ( 6 ) ; k2 = k2 . toFixed ( 6 ) ; console . log ( ( k1 == k2 ) ? \" YES \" : \" NO \" ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 1 , len = input [ 0 ] - 0 ; i <= len ; i ++ ) { var c = input [ i ] . split ( ' ' ) ; var x1 = c [ 0 ] ; var y1 = c [ 1 ] ; var x2 = c [ 2 ] ; var y2 = c [ 3 ] ; var x3 = c [ 4 ] ; var y3 = c [ 5 ] ; var x4 = c [ 6 ] ; var y4 = c [ 7 ] ; console . log ( ( ( y2 - y1 ) / ( x2 - x1 ) ) . toFixed ( 6 ) == ( ( y4 - y3 ) / ( x4 - x3 ) ) . toFixed ( 6 ) ? ' YES ' : ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { c = i . split ( ' ' ) ; if ( c [ 2 ] ) console . log ( ( ( c [ 3 ] - c [ 1 ] ) / ( c [ 2 ] - c [ 0 ] ) ) . toFixed ( 6 ) == ( ( c [ 7 ] - c [ 5 ] ) / ( c [ 6 ] - c [ 4 ] ) ) . toFixed ( 6 ) ? ' YES ' : ' NO ' ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { c = i . split ( ' ' ) ; if ( c [ 2 ] ) console . log ( ( ( c [ 3 ] - c [ 1 ] ) / ( c [ 2 ] - c [ 0 ] ) ) . toFixed ( 6 ) == ( ( c [ 7 ] - c [ 5 ] ) / ( c [ 6 ] - c [ 4 ] ) ) . toFixed ( 6 ) ? ' YES ' : ' NO ' ) } )",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( \" \\n \" ) ; var numLines = parseInt ( lines [ 0 ] ) ; for ( var i = 1 ; i <= numLines ; i ++ ) { var xs = [ ] ; var ys = [ ] ; var coords = lines [ i ] . split ( \" \" ) ; for ( var j = 0 ; j < coords . length ; j ++ ) { if ( j % 2 === 0 ) { xs . push ( parseFloat ( coords [ j ] ) ) ; } else { ys . push ( parseFloat ( coords [ j ] ) ) ; } } var slope1 = ( ( ys [ 1 ] - ys [ 0 ] ) / ( xs [ 1 ] - xs [ 0 ] ) ) . toFixed ( 6 ) ; var slope2 = ( ( ys [ 3 ] - ys [ 2 ] ) / ( xs [ 3 ] - xs [ 2 ] ) ) . toFixed ( 6 ) ; if ( slope1 == slope2 ) { console . log ( \" YES \" ) ; } else { console . log ( \" NO \" ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var n = + lines . shift ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var nums = lines . shift ( ) . split ( ' ' ) ; var x1 = + nums [ 0 ] ; var y1 = + nums [ 1 ] ; var x2 = + nums [ 2 ] ; var y2 = + nums [ 3 ] ; var x3 = + nums [ 4 ] ; var y3 = + nums [ 5 ] ; var x4 = + nums [ 6 ] ; var y4 = + nums [ 7 ] ; if ( ( ( x2 - x1 ) * ( y4 - y3 ) ) . toFixed ( 12 ) == ( ( x4 - x3 ) * ( y2 - y1 ) ) . toFixed ( 12 ) ) { console . log ( ' YES ' ) ; } else { console . log ( ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr [ 0 ] ; Arr . shift ( ) ; for ( var i = 0 ; i < n ; ++ i ) { var nums = Arr [ i ] . split ( \" \" ) . map ( Number ) ; var k1 = ( nums [ 3 ] - nums [ 1 ] ) / ( nums [ 2 ] - nums [ 0 ] ) ; var k2 = ( nums [ 7 ] - nums [ 5 ] ) / ( nums [ 6 ] - nums [ 4 ] ) ; if ( k1 . toFixed ( 6 ) == k2 . toFixed ( 6 ) ) { console . log ( \" YES \" ) ; } else { console . log ( \" NO \" ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; ( function ( xa , ya , ra , xb , yb , rb ) { var ans ; var d = Math . sqrt ( Math . pow ( xa - xb , 2 ) + Math . pow ( ya - yb , 2 ) ) ; if ( d > ra + rb ) ans = 0 ; if ( d <= ra + rb ) { ans = 1 ; if ( d < ra - rb ) ans = 2 ; if ( d < rb - ra ) ans = - 2 ; } console . log ( ans ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = Number ( p . shift ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var args = p . shift ( ) . split ( ' ' ) . map ( Number ) ; var xa = args . shift ( ) ; var ya = args . shift ( ) ; var ra = args . shift ( ) ; var xb = args . shift ( ) ; var yb = args . shift ( ) ; var rb = args . shift ( ) ; var d = Math . sqrt ( Math . pow ( xb - xa , 2 ) + Math . pow ( yb - ya , 2 ) ) ; if ( d <= ra + rb ) { if ( d < rb - ra ) { console . log ( - 2 ) ; } else if ( d < ra - rb ) { console . log ( 2 ) ; } else { console . log ( 1 ) ; } } else { console . log ( 0 ) ; } } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 1 , len = input [ 0 ] - 0 ; i <= len ; i ++ ) { var c = input [ i ] . split ( ' ' ) ; var xa = + c [ 0 ] , ya = + c [ 1 ] , ra = + c [ 2 ] , xb = + c [ 3 ] , yb = + c [ 4 ] , rb = + c [ 5 ] ; var r = Math . sqrt ( ( xa - xb ) * ( xa - xb ) + ( ya - yb ) * ( ya - yb ) ) ; if ( r > ra + rb ) { console . log ( 0 ) ; } else if ( r < ra - rb ) { console . log ( 2 ) ; } else if ( r < rb - ra ) { console . log ( - 2 ) ; } else { console . log ( 1 ) ; } } }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { z = i . split ( ' ' ) , a = + z [ 0 ] , b = + z [ 1 ] , c = + z [ 2 ] , d = + z [ 3 ] , e = + z [ 4 ] , f = + z [ 5 ] , r = Math . sqrt ( ( a - d ) * ( a - d ) + ( b - e ) * ( b - e ) ) ; if ( c ) console . log ( r > c + f ? 0 : r < c - f ? 2 : r < f - c ? - 2 : 1 ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { z = i . split ( ' ' ) , a = z [ 0 ] , b = z [ 1 ] , c = + z [ 2 ] , d = z [ 3 ] , e = z [ 4 ] , f = + z [ 5 ] , r = Math . sqrt ( ( a - d ) * ( a - d ) + ( b - e ) * ( b - e ) ) ; c ? console . log ( r > c + f ? 0 : r < c - f ? 2 : r < f - c ? - 2 : 1 ) : 0 } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { z = i . split ( ' ' ) , a = z [ 0 ] - z [ 3 ] , b = z [ 1 ] - z [ 4 ] , c = + z [ 2 ] , f = + z [ 5 ] , r = Math . sqrt ( a * a + b * b ) ; c ? console . log ( r > c + f ? 0 : r < c - f ? 2 : r < f - c ? - 2 : 1 ) : 0 } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { z = i . split ( ' ' ) , a = z [ 0 ] - z [ 3 ] , b = z [ 1 ] - z [ 4 ] , c = + z [ 2 ] , f = + z [ 5 ] , r = Math . sqrt ( a * a + b * b ) ; c ? console . log ( r > c + f ? 0 : r < c - f ? 2 : r < f - c ? - 2 : 1 ) : 0 } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { z = i . split ( ' ' ) , a = z [ 0 ] - z [ 3 ] , b = z [ 1 ] - z [ 4 ] , c = z [ 2 ] , f = z [ 5 ] , r = Math . sqrt ( a * a + b * b ) ; c ? console . log ( r - c > f ? 0 : f < c - r ? 2 : r < f - c ? - 2 : 1 ) : 0 } )",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; Arr . forEach ( function ( v ) { var t = v / 9.8 ; var y = 4.9 * t * t ; var n = Math . ceil ( ( y + 5 ) / 5 ) ; console . log ( n ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) . map ( Number ) ; var n = p . length ; var G = 9.8 ; for ( var i = 0 ; i < n ; i ++ ) { var mv = p . shift ( ) ; var t = mv / G ; var N = ( G / 2 * t * t + 5 ) / 5 ; console . log ( Math . ceil ( N ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . some ( function ( i ) { for ( n = 0 ; + i > Math . sqrt ( 98 * n ) ; n ++ ) ; console . log ( ++ n ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { if ( i ) console . log ( ~ ~ ( i * i / 98 + 2 ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { i ? console . log ( ~ ~ ( i * i / 98 + 2 ) ) : 0 } )",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\n / ) [ j ++ ] ; ) console . log ( ~ ~ ( i * i / 98 + 2 ) )",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = + require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\n / ) [ j ++ ] ; ) console . log ( ~ ~ ( i * i / 98 + 2 ) )",
    "label": 2
  },
  {
    "code": "for ( j = 0 , k = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\n / ) ; i = + k [ j ++ ] ; ) console . log ( ~ ~ ( i * i / 98 + 2 ) )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { i ? console . log ( ~ ~ ( i * i / 98 + 2 ) ) : 0 } )",
    "label": 2
  },
  {
    "code": "' use strict ' ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var minvs = input . trim ( ) . split ( ' \\n ' ) ; var minv ; while ( minv = minvs . shift ( ) ) { var t = minv / 9.8 ; var y = 4.9 * t * t ; var f = Math . ceil ( ( y + 5 ) / 5 ) ; console . log ( f ) ; }",
    "label": 2
  },
  {
    "code": "var input = \" \" ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; for ( var i = 0 ; i < input . length - 1 ; i ++ ) { a = Math . pow ( input [ i ] / 9.8 , 2 ) * 4.9 ; for ( var j = 1 ; ; j ++ ) { if ( j * 5 - 5 >= a ) { console . log ( j ) ; break ; } } } } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var speed = + line ; for ( var f = 1 ; ; f ++ ) { var t = Math . sqrt ( ( f * 5 - 5 ) / 4.9 ) ; var v = 9.8 * t ; if ( v >= speed ) { console . log ( f ) ; break ; } } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i = i + 2 ) { var a = Arr [ i ] . split ( \" \" ) . map ( Number ) ; var b = Arr [ i + 1 ] . split ( \" \" ) . map ( Number ) ; var hit = 0 ; var blow = 0 ; for ( var j = 0 ; j < 4 ; j ++ ) { if ( a [ j ] === b [ j ] ) hit ++ ; else if ( a . indexOf ( b [ j ] ) != - 1 ) blow ++ ; } console . log ( hit + \" \" + blow ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var a , b ; var hit , blow ; while ( ( a = p . shift ( ) ) && ( b = p . shift ( ) ) ) { a = a . split ( ' ' ) . map ( Number ) ; b = b . split ( ' ' ) . map ( Number ) ; hit = blow = 0 ; for ( var i = 0 ; i < b . length ; i ++ ) { if ( a [ i ] === b [ i ] ) { hit ++ ; } else if ( a . indexOf ( b [ i ] ) >= 0 ) { blow ++ ; } } console . log ( ' %d %d ' , hit , blow ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i += 2 ) { var hit = brow = 0 ; var a = input [ i ] . trim ( ) . split ( ' ' ) ; var b = input [ i + 1 ] . trim ( ) . split ( ' ' ) ; for ( var j = 0 , lenj = a . length ; j < lenj ; j ++ ) { if ( ( c = b . indexOf ( a [ j ] ) ) != - 1 ) c != j ? brow ++ : hit ++ ; } console . log ( hit , brow ) ; } }",
    "label": 2
  },
  {
    "code": "var arr = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( / \\n / ) ; var length = arr . length ; var x = [ ] , y = [ ] ; var h , b ; for ( var i = 0 ; i < length ; i += 2 ) { h = 0 ; b = 0 ; x = arr [ i ] . trim ( ) . split ( / \\s / ) ; y = arr [ i + 1 ] . trim ( ) . split ( / \\s / ) ; for ( var j = 0 ; j < 4 ; j ++ ) { if ( x [ j ] == y [ j ] ) { h ++ ; } else { for ( var k = 0 ; k < 4 ; k ++ ) { if ( x [ j ] == y [ k ] ) b ++ ; } } } console . log ( h + ' ' + b ) ; }",
    "label": 2
  },
  {
    "code": "' use strict ' ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; while ( lines . length > 1 ) { var A = lines . shift ( ) . split ( ' ' ) ; var B = lines . shift ( ) . split ( ' ' ) ; var hit = 0 ; var blow = 0 ; for ( var i = 0 ; i < B . length ; ++ i ) { if ( B [ i ] === A [ i ] ) { hit += 1 ; } else { for ( var j = 0 ; j < A . length ; ++ j ) { if ( B [ i ] === A [ j ] ) { blow += 1 ; break ; } } } } console . log ( ' %d %d ' , hit , blow ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var imagine ; while ( imagine = lines . shift ( ) ) { var guess = lines . shift ( ) ; var a = imagine . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; var b = guess . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; var hit = 0 ; for ( var i = 0 ; i < 4 ; i ++ ) { if ( a [ i ] == b [ i ] ) { hit ++ ; } } var blow = 0 ; for ( var i = 0 ; i < 4 ; i ++ ) { if ( a . indexOf ( b [ i ] ) >= 0 ) { blow ++ ; } } blow -= hit ; console . log ( hit + ' ' + blow ) ; }",
    "label": 2
  },
  {
    "code": "function F1 ( x , y ) { xy [ x ] [ y - 1 ] += 1 ; xy [ x - 1 ] [ y ] += 1 ; xy [ x ] [ y ] += 1 ; xy [ x + 1 ] [ y ] += 1 ; xy [ x ] [ y + 1 ] += 1 ; } function F2 ( x , y ) { F1 ( x , y ) ; xy [ x - 1 ] [ y - 1 ] += 1 ; xy [ x + 1 ] [ y - 1 ] += 1 ; xy [ x - 1 ] [ y + 1 ] += 1 ; xy [ x + 1 ] [ y + 1 ] += 1 ; } function F3 ( x , y ) { F2 ( x , y ) ; xy [ x ] [ y - 2 ] += 1 ; xy [ x - 2 ] [ y ] += 1 ; xy [ x + 2 ] [ y ] += 1 ; xy [ x ] [ y + 2 ] += 1 ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var xy = [ ] ; for ( var i = 0 ; i < 10 + 4 ; i ++ ) { xy [ i ] = [ ] ; for ( var j = 0 ; j < 10 + 4 ; j ++ ) { xy [ i ] [ j ] = 0 ; } } for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" , \" ) . map ( Number ) ; var x = arr [ 0 ] + 2 ; var y = arr [ 1 ] + 2 ; if ( arr [ 2 ] == 1 ) F1 ( x , y ) ; if ( arr [ 2 ] == 2 ) F2 ( x , y ) ; if ( arr [ 2 ] == 3 ) F3 ( x , y ) ; } var sum = 0 ; var max = 0 ; for ( var i = 2 ; i < 10 + 2 ; i ++ ) { for ( var j = 2 ; j < 10 + 2 ; j ++ ) { if ( xy [ i ] [ j ] == 0 ) sum ++ ; max = Math . max ( max , xy [ i ] [ j ] ) ; } } console . log ( sum ) ; console . log ( max ) ;",
    "label": 2
  },
  {
    "code": "var f = [ ] ; function main ( ) { for ( var y = - 2 ; y < 12 ; y ++ ) { f [ y ] = [ ] ; for ( var x = - 2 ; x < 12 ; x ++ ) { f [ y ] [ x ] = 0 ; } } for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { var s = input [ i ] . split ( ' , ' ) ; eval ( \" d \" + s [ 2 ] + \" ( \" + s [ 0 ] + \" , \" + s [ 1 ] + \" ); \" ) ; } var nd = 0 ; var md = 0 ; for ( var y = 0 ; y < 10 ; y ++ ) { for ( var x = 0 ; x < 10 ; x ++ ) { if ( f [ y ] [ x ] == 0 ) nd ++ ; if ( f [ y ] [ x ] > md ) md = f [ y ] [ x ] ; } } console . log ( nd ) ; console . log ( md ) ; } function d1 ( x , y ) { f [ y + 1 ] [ x ] ++ ; f [ y ] [ x - 1 ] ++ ; f [ y ] [ x ] ++ ; f [ y ] [ x + 1 ] ++ ; f [ y - 1 ] [ x ] ++ ; } function d2 ( x , y ) { d1 ( x , y ) ; f [ y + 1 ] [ x - 1 ] ++ ; f [ y + 1 ] [ x + 1 ] ++ ; f [ y - 1 ] [ x - 1 ] ++ ; f [ y - 1 ] [ x + 1 ] ++ ; } function d3 ( x , y ) { d2 ( x , y ) ; f [ y + 2 ] [ x ] ++ ; f [ y - 2 ] [ x ] ++ ; f [ y ] [ x - 2 ] ++ ; f [ y ] [ x + 2 ] ++ ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var f = [ ] ; function main ( ) { for ( var y = - 2 ; y < 12 ; y ++ ) { f [ y ] = [ ] ; for ( var x = - 2 ; x < 12 ; x ++ ) { f [ y ] [ x ] = 0 ; } } for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { eval ( \" d \" + input [ i ] [ 4 ] + \" ( \" + input [ i ] [ 0 ] + \" , \" + input [ i ] [ 2 ] + \" ); \" ) ; } var nd = 0 ; var md = 0 ; for ( var y = 0 ; y < 10 ; y ++ ) { for ( var x = 0 ; x < 10 ; x ++ ) { if ( f [ y ] [ x ] == 0 ) nd ++ ; if ( f [ y ] [ x ] > md ) md = f [ y ] [ x ] ; } } console . log ( nd ) ; console . log ( md ) ; } function d1 ( x , y ) { f [ y + 1 ] [ x ] ++ ; f [ y ] [ x - 1 ] ++ ; f [ y ] [ x ] ++ ; f [ y ] [ x + 1 ] ++ ; f [ y - 1 ] [ x ] ++ ; } function d2 ( x , y ) { d1 ( x , y ) ; f [ y + 1 ] [ x - 1 ] ++ ; f [ y + 1 ] [ x + 1 ] ++ ; f [ y - 1 ] [ x - 1 ] ++ ; f [ y - 1 ] [ x + 1 ] ++ ; } function d3 ( x , y ) { d2 ( x , y ) ; f [ y + 2 ] [ x ] ++ ; f [ y - 2 ] [ x ] ++ ; f [ y ] [ x - 2 ] ++ ; f [ y ] [ x + 2 ] ++ ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { for ( var y = 0 ; y < 14 ; y ++ ) { for ( var x = 0 ; x < 14 ; x ++ ) { eval ( \" f \" + x + \" \" + y + \" = 0; \" ) ; } } for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { eval ( \" d \" + input [ i ] [ 4 ] + \" ( \" + ( input [ i ] [ 0 ] - 0 + 2 ) + \" , \" + ( input [ i ] [ 2 ] - 0 + 2 ) + \" ); \" ) ; } var nd = 0 ; var md = 0 ; for ( var y = 2 ; y < 12 ; y ++ ) { for ( var x = 2 ; x < 12 ; x ++ ) { if ( eval ( \" f \" + x + \" \" + y ) == 0 ) nd ++ ; if ( eval ( \" f \" + x + \" \" + y ) > md ) md = eval ( \" f \" + x + \" \" + y ) ; } } console . log ( nd ) ; console . log ( md ) ; } function d1 ( x , y ) { eval ( \" f \" + x + \" \" + y + \" ++; \" ) ; eval ( \" f \" + ( x - 0 + 1 ) + \" \" + y + \" ++; \" ) ; eval ( \" f \" + ( x - 1 ) + \" \" + y + \" ++; \" ) ; eval ( \" f \" + x + \" \" + ( y - 0 + 1 ) + \" ++; \" ) ; eval ( \" f \" + x + \" \" + ( y - 1 ) + \" ++; \" ) ; } function d2 ( x , y ) { d1 ( x , y ) ; eval ( \" f \" + ( x - 0 + 1 ) + \" \" + ( y - 0 + 1 ) + \" ++; \" ) ; eval ( \" f \" + ( x - 0 + 1 ) + \" \" + ( y - 1 ) + \" ++; \" ) ; eval ( \" f \" + ( x - 1 ) + \" \" + ( y - 0 + 1 ) + \" ++; \" ) ; eval ( \" f \" + ( x - 1 ) + \" \" + ( y - 1 ) + \" ++; \" ) ; } function d3 ( x , y ) { d2 ( x , y ) ; eval ( \" f \" + x + \" \" + ( y - 0 + 2 ) + \" ++; \" ) ; eval ( \" f \" + x + \" \" + ( y - 2 ) + \" ++; \" ) ; eval ( \" f \" + ( x - 0 + 2 ) + \" \" + y + \" ++; \" ) ; eval ( \" f \" + ( x - 2 ) + \" \" + y + \" ++; \" ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var f = [ ] ; function main ( ) { for ( var y = - 2 ; y < 12 ; y ++ ) { f [ y ] = [ ] ; for ( var x = - 2 ; x < 12 ; x ++ ) { f [ y ] [ x ] = 0 ; } } for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { var s = input [ i ] . split ( ' , ' ) ; eval ( \" d \" + s [ 2 ] + \" ( \" + s [ 0 ] + \" , \" + s [ 1 ] + \" ); \" ) ; } var nd = 0 ; var md = 0 ; for ( var y = 0 ; y < 10 ; y ++ ) { for ( var x = 0 ; x < 10 ; x ++ ) { nd += ! ( f [ y ] [ x ] ) ; md = mx ( f [ y ] [ x ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function d1 ( x , y ) { f [ y + 1 ] [ x ] ++ ; f [ y ] [ x - 1 ] ++ ; f [ y ] [ x ] ++ ; f [ y ] [ x + 1 ] ++ ; f [ y - 1 ] [ x ] ++ ; } function d2 ( x , y ) { d1 ( x , y ) ; f [ y + 1 ] [ x - 1 ] ++ ; f [ y + 1 ] [ x + 1 ] ++ ; f [ y - 1 ] [ x - 1 ] ++ ; f [ y - 1 ] [ x + 1 ] ++ ; } function d3 ( x , y ) { d2 ( x , y ) ; f [ y + 2 ] [ x ] ++ ; f [ y - 2 ] [ x ] ++ ; f [ y ] [ x - 2 ] ++ ; f [ y ] [ x + 2 ] ++ ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var f = [ ] ; function main ( ) { var localInput = input ; for ( var y = - 2 ; y < 12 ; y ++ ) { f [ y ] = [ ] ; for ( var x = - 2 ; x < 12 ; x ++ ) { f [ y ] [ x ] = 0 ; } } var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; eval ( \" d \" + localInput [ len ] [ 4 ] + \" ( \" + localInput [ len ] [ 0 ] + \" , \" + localInput [ len ] [ 2 ] + \" ); \" ) ; } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y ] [ x ] ) ; md = mx ( f [ y ] [ x ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function d1 ( x , y ) { f [ y + 1 ] [ x ] ++ ; f [ y ] [ x - 1 ] ++ ; f [ y ] [ x ] ++ ; f [ y ] [ x + 1 ] ++ ; f [ y - 1 ] [ x ] ++ ; } function d2 ( x , y ) { d1 ( x , y ) ; f [ y + 1 ] [ x - 1 ] ++ ; f [ y + 1 ] [ x + 1 ] ++ ; f [ y - 1 ] [ x - 1 ] ++ ; f [ y - 1 ] [ x + 1 ] ++ ; } function d3 ( x , y ) { d2 ( x , y ) ; f [ y + 2 ] [ x ] ++ ; f [ y - 2 ] [ x ] ++ ; f [ y ] [ x - 2 ] ++ ; f [ y ] [ x + 2 ] ++ ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ ] ; for ( var y = - 2 ; y < 12 ; y ++ ) { f [ y ] = [ ] ; for ( var x = - 2 ; x < 12 ; x ++ ) { f [ y ] [ x ] = 0 ; } } var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) ; var iy = parseInt ( l [ 2 ] ) ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y ] [ x ] ) ; md = mx ( f [ y ] [ x ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { return a - ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { return a - ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; for ( ; len -- ; ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; for ( ; y -- ; ) { var x = 10 ; for ( ; x -- ; ) { nd += ! ( f [ y + 2 ] [ x + 2 ] ) ; md = mx ( f [ y + 2 ] [ x + 2 ] , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { return a - ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var localInput = input ; var f = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; var len = localInput . length - 1 ; while ( len -- ) { var l = localInput [ len ] ; var ix = parseInt ( l [ 0 ] ) + 2 ; var iy = parseInt ( l [ 2 ] ) + 2 ; switch ( l [ 4 ] ) { case ' 3 ' : f [ iy + 2 ] [ ix ] ++ ; f [ iy - 2 ] [ ix ] ++ ; f [ iy ] [ ix - 2 ] ++ ; f [ iy ] [ ix + 2 ] ++ ; case ' 2 ' : f [ iy + 1 ] [ ix - 1 ] ++ ; f [ iy + 1 ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix - 1 ] ++ ; f [ iy - 1 ] [ ix + 1 ] ++ ; case ' 1 ' : f [ iy + 1 ] [ ix ] ++ ; f [ iy ] [ ix - 1 ] ++ ; f [ iy ] [ ix ] ++ ; f [ iy ] [ ix + 1 ] ++ ; f [ iy - 1 ] [ ix ] ++ ; break ; } } var nd = 0 ; var md = 0 ; var y = 10 ; while ( y -- ) { var x = 10 ; while ( x -- ) { var fyx = f [ y + 2 ] [ x + 2 ] ; nd += ! fyx ; md = mx ( fyx , md ) ; } } console . log ( nd ) ; console . log ( md ) ; } function mx ( a , b ) { return a - ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = p . length ; var m = new Array ( 10 ) ; for ( var i = 0 ; i < m . length ; i ++ ) { m [ i ] = ( new Array ( 11 ) ) . join ( ' 0 ' ) . split ( ' ' ) . map ( Number ) ; } for ( i = 0 ; i < n ; i ++ ) { var a = p . shift ( ) . split ( ' , ' ) . map ( Number ) ; var x = a . shift ( ) ; var y = a . shift ( ) ; var s = a . shift ( ) ; drop ( m , x , y , s ) ; } var max = 0 ; var space = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { for ( var j = 0 ; j < 10 ; j ++ ) { var c = m [ i ] [ j ] ; if ( c > max ) { max = c ; } if ( c === 0 ) { space ++ ; } } } console . log ( space ) ; console . log ( max ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function drop ( m , x , y , s ) { drop_ ( m , x , y ) ; drop_ ( m , x , y - 1 ) ; drop_ ( m , x - 1 , y ) ; drop_ ( m , x + 1 , y ) ; drop_ ( m , x , y + 1 ) ; if ( s >= 2 ) { drop_ ( m , x - 1 , y - 1 ) ; drop_ ( m , x + 1 , y - 1 ) ; drop_ ( m , x - 1 , y + 1 ) ; drop_ ( m , x + 1 , y + 1 ) ; } if ( s >= 3 ) { drop_ ( m , x , y - 2 ) ; drop_ ( m , x - 2 , y ) ; drop_ ( m , x + 2 , y ) ; drop_ ( m , x , y + 2 ) ; } } function drop_ ( m , x , y ) { if ( x < 0 || x > 9 || y < 0 || y > 9 ) { return ; } m [ x ] [ y ] ++ ; }",
    "label": 2
  },
  {
    "code": "' use strict ' ; var len = 10 ; var map = new Array ( len ) ; for ( var i = 0 ; i < map . length ; ++ i ) { map [ i ] = new Array ( len ) ; for ( var j = 0 ; j < map . length ; ++ j ) { map [ i ] [ j ] = 0 ; } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var inks = input . trim ( ) . split ( ' \\n ' ) ; for ( var i in inks ) { var ink = inks [ i ] . trim ( ) . split ( ' , ' ) ; ink [ 0 ] = parseInt ( ink [ 0 ] ) ; ink [ 1 ] = parseInt ( ink [ 1 ] ) ; ++ map [ ink [ 0 ] ] [ ink [ 1 ] ] ; switch ( ink [ 2 ] ) { case ' 3 ' : if ( ink [ 0 ] - 2 >= 0 ) { ++ map [ ink [ 0 ] - 2 ] [ ink [ 1 ] ] ; } if ( ink [ 0 ] + 2 < len ) { ++ map [ ink [ 0 ] + 2 ] [ ink [ 1 ] ] ; } if ( ink [ 1 ] - 2 >= 0 ) { ++ map [ ink [ 0 ] ] [ ink [ 1 ] - 2 ] ; } if ( ink [ 1 ] + 2 < len ) { ++ map [ ink [ 0 ] ] [ ink [ 1 ] + 2 ] ; } case ' 2 ' : if ( ink [ 0 ] - 1 >= 0 && ink [ 1 ] - 1 >= 0 ) { ++ map [ ink [ 0 ] - 1 ] [ ink [ 1 ] - 1 ] ; } if ( ink [ 0 ] - 1 >= 0 && ink [ 1 ] + 1 < len ) { ++ map [ ink [ 0 ] - 1 ] [ ink [ 1 ] + 1 ] ; } if ( ink [ 0 ] + 1 < len && ink [ 1 ] - 1 >= 0 ) { ++ map [ ink [ 0 ] + 1 ] [ ink [ 1 ] - 1 ] ; } if ( ink [ 0 ] + 1 < len && ink [ 1 ] + 1 < len ) { ++ map [ ink [ 0 ] + 1 ] [ ink [ 1 ] + 1 ] ; } case ' 1 ' : if ( ink [ 0 ] - 1 >= 0 ) { ++ map [ ink [ 0 ] - 1 ] [ ink [ 1 ] ] ; } if ( ink [ 0 ] + 1 < len ) { ++ map [ ink [ 0 ] + 1 ] [ ink [ 1 ] ] ; } if ( ink [ 1 ] - 1 >= 0 ) { ++ map [ ink [ 0 ] ] [ ink [ 1 ] - 1 ] ; } if ( ink [ 1 ] + 1 < len ) { ++ map [ ink [ 0 ] ] [ ink [ 1 ] + 1 ] ; } break ; } } var zeroden = 0 ; var maxden = 0 ; for ( var row in map ) { for ( var col in map [ row ] ) { if ( map [ row ] [ col ] === 0 ) { ++ zeroden ; } else if ( map [ row ] [ col ] > maxden ) { maxden = map [ row ] [ col ] ; } } } console . log ( zeroden ) ; console . log ( maxden ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var weekday = [ \" Sunday \" , \" Monday \" , \" Tuesday \" , \" Wednesday \" , \" Thursday \" , \" Friday \" , \" Saturday \" ] ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var v = Arr [ i ] ; if ( v == \" 0 0 \" ) break ; var str = \" 2004/ \" + v . replace ( / \\s / , \" / \" ) ; var today = new Date ( str ) ; console . log ( weekday [ today . getDay ( ) ] ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; while ( true ) { var a = p . shift ( ) . split ( ' ' ) . map ( Number ) ; var m = a . shift ( ) ; var d = a . shift ( ) ; if ( m === 0 && d === 0 ) { return ; } var date = new Date ( 2004 , m - 1 , d ) ; console . log ( getWeekDay ( date . getDay ( ) ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function getWeekDay ( d ) { var week = [ ' Sunday ' , ' Monday ' , ' Tuesday ' , ' Wednesday ' , ' Thursday ' , ' Friday ' , ' Saturday ' ] ; return week [ d ] ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var c = input [ i ] . split ( ' ' ) ; if ( + c [ 1 ] && + c [ 0 ] ) { var date = new Date ( 2004 , c [ 0 ] - 1 , + c [ 1 ] ) ; console . log ( [ ' Sunday ' , ' Monday ' , ' Tuesday ' , ' Wednesday ' , ' Thursday ' , ' Friday ' , ' Saturday ' ] [ date . getDay ( ) ] ) ; } } }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { c = i . split ( ' ' ) ; m = c [ 0 ] , d = c [ 1 ] ; if ( m != 0 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 2004 , m - 1 , d ) . getDay ( ) ] + ' day ' ) } )",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) ; for ( a = 0 ; + i [ a ] ; a += 2 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 2004 , i [ a ] - 1 , i [ a + 1 ] ) . getDay ( ) ] + ' day ' )",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) ; for ( a = 0 ; + i [ a ] ; a += 2 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 1604 , i [ a ] - 1 , i [ a + 1 ] ) . getDay ( ) ] + ' day ' )",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) ; for ( a = 0 ; + i [ a ] ; a += 2 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 804 , i [ a ] - 1 , i [ a + 1 ] ) . getDay ( ) ] + ' day ' )",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) ; for ( a = 0 ; + i [ a ] ; a += 2 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 404 , i [ a ] - 1 , i [ a + 1 ] ) . getDay ( ) ] + ' day ' )",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) ; for ( a = 0 ; b = + i [ a ] ; a += 2 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 404 , b - 1 , i [ a + 1 ] ) . getDay ( ) ] + ' day ' )",
    "label": 2
  },
  {
    "code": "i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) ; for ( a = 0 ; b = + i [ a ] ; a += 2 ) console . log ( [ ' Sun ' , ' Mon ' , ' Tues ' , ' Wednes ' , ' Thurs ' , ' Fri ' , ' Satur ' ] [ new Date ( 76 , b - 1 , i [ a + 1 ] ) . getDay ( ) ] + ' day ' )",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var week = [ \" Sunday \" , \" Monday \" , \" Tuesday \" , \" Wednesday \" , \" Thursday \" , \" Friday \" , \" Saturday \" ] ; inputLine = input . split ( \" \\n \" ) ; for ( var i = 0 ; ; i ++ ) { var time = new Date ( ) ; time . setFullYear ( 2004 ) ; var date = inputLine [ i ] . split ( \" \" ) ; var month = Int ( date [ 0 ] ) ; var day = Int ( date [ 1 ] ) ; if ( month == 0 ) break ; time . setMonth ( month - 1 ) ; time . setDate ( day ) ; output ( week [ time . getDay ( ) ] ) ; } } function ascendingOrder ( val1 , val2 ) { return val1 - val2 ; } function descendingOrder ( val1 , val2 ) { return val2 - val1 ; } function Int ( str ) { return parseInt ( str , 10 ) ; } function Str ( num ) { return num . toString ( 10 ) ; } function output ( str ) { if ( _Isdebug ) { document . getElementById ( \" Console \" ) . value += ( str + \" \\n \" ) ; } console . log ( str ) ; } var _Isdebug = false ; function debug ( ) { _Isdebug = true ; var input = document . getElementById ( \" Console \" ) . value ; document . getElementById ( \" Console \" ) . value += \" \\n \" ; Main ( input ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { var week = [ \" Sunday \" , \" Monday \" , \" Tuesday \" , \" Wednesday \" , \" Thursday \" , \" Friday \" , \" Saturday \" ] ; inputLine = input . split ( \" \\n \" ) ; for ( var i = 0 ; ; i ++ ) { var dateObj = new Date ( ) ; dateObj . setFullYear ( 2004 ) ; var date = inputLine [ i ] . split ( \" \" ) ; var month = int ( date [ 0 ] ) ; var day = int ( date [ 1 ] ) ; if ( month === 0 ) break ; dateObj . setMonth ( month - 1 ) ; dateObj . setDate ( day ) ; output ( week [ dateObj . getDay ( ) ] ) ; dateObj = null ; } } function ascendingOrder ( val1 , val2 ) { return val1 - val2 ; } function descendingOrder ( val1 , val2 ) { return val2 - val1 ; } function int ( str ) { return parseInt ( str , 10 ) ; } function str ( num ) { return num . toString ( 10 ) ; } function output ( str ) { if ( _Isdebug ) { document . getElementById ( \" Console \" ) . value += ( str + \" \\n \" ) ; } console . log ( str ) ; } var _Isdebug = false ; function debug ( ) { _Isdebug = true ; var input = document . getElementById ( \" Console \" ) . value ; document . getElementById ( \" Console \" ) . value += \" \\n \" ; Main ( input ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; yobi = new Array ( \" Sunday \" , \" Monday \" , \" Tuesday \" , \" Wednesday \" , \" Thursday \" , \" Friday \" , \" Saturday \" ) ; for ( i = 0 ; i < x . length - 1 ; ) { if ( x [ i ] == 0 ) break ; console . log ( yobi [ new Date ( ' 2004/0 ' + x [ i ++ ] + ' /0 ' + x [ i ++ ] ) . getDay ( ) ] ) ; }",
    "label": 2
  },
  {
    "code": "' use strict ' ; var DateToDay = function ( year , month , date ) { if ( month == 1 || month == 2 ) { month += 12 ; -- year ; } var j = Math . floor ( year / 100 ) ; var k = year % 100 ; var h = ( date + Math . floor ( 26 * ( month + 1 ) / 10 ) + k + Math . floor ( k / 4 ) + Math . floor ( j / 4 ) + 5 * j ) % 7 ; var day ; switch ( h ) { case 0 : day = ' Saturday ' ; break ; case 1 : day = ' Sunday ' ; break ; case 2 : day = ' Monday ' ; break ; case 3 : day = ' Tuesday ' ; break ; case 4 : day = ' Wednesday ' ; break ; case 5 : day = ' Thursday ' ; break ; case 6 : day = ' Friday ' ; break ; } return day ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var dates = input . trim ( ) . split ( ' \\n ' ) ; var year = 2004 ; while ( true ) { var date = dates . shift ( ) . split ( ' ' ) ; if ( date [ 0 ] === ' 0 ' || date [ 1 ] === ' 0 ' ) { break ; } console . log ( DateToDay ( year , parseInt ( date [ 0 ] ) , parseInt ( date [ 1 ] ) ) ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { var t = [ \" Sun \" , \" Mon \" , \" Tues \" , \" Wednes \" , \" Thurs \" , \" Fri \" , \" Satur \" ] , d = new Date ; d . setYear ( 2004 ) ; ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n ) { n = n . split ( \" \" ) ; if ( ! + n [ 0 ] ) { return 1 ; } d . setMonth ( + n [ 0 ] - 1 , + n [ 1 ] ) ; console . log ( t [ d . getDay ( ) ] + \" day \" ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var DAY = [ ' Sunday ' , ' Monday ' , ' Tuesday ' , ' Wednesday ' , ' Thursday ' , ' Friday ' , ' Saturday ' ] ; var line ; while ( line = lines . shift ( ) ) { var arr = line . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; if ( arr [ 0 ] == 0 && arr [ 1 ] == 0 ) { break ; } var d = new Date ( 2004 , arr [ 0 ] - 1 , arr [ 1 ] ) ; console . log ( DAY [ d . getDay ( ) ] ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; var arr = [ ] ; for ( var i = 0 ; i <= 100 ; i ++ ) arr [ i ] = 0 ; var cnt = 0 ; Arr . forEach ( function ( v ) { arr [ v ] ++ ; if ( arr [ v ] > cnt ) cnt = arr [ v ] ; } ) ; arr . forEach ( function ( v , i ) { if ( v == cnt ) console . log ( i ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = p . length ; var r = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var x = p . shift ( ) ; if ( x in r ) { r [ x ] ++ ; } else { r [ x ] = 0 ; } } var a = [ ] ; for ( i = 0 ; i < r . length ; i ++ ) { var m = r [ i ] ; if ( isNaN ( m ) ) { m = 0 ; } if ( m in a ) { a [ m ] . push ( i ) ; } else { a [ m ] = [ i ] ; } } console . log ( a [ a . length - 1 ] . join ( ' \\n ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "for ( a = [ ] , b = 100 ; b -- ; ) c = a [ b ] = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { if ( + i ) a [ + i ] ++ , c = a [ + i ] > c ? a [ + i ] : c } ) ; a . some ( function ( i , j ) { if ( i == c ) console . log ( j ) } )",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( mode = [ ] , cnt = 0 , i = 0 ; i < x . length ; i ++ ) { temp_cnt = 1 ; for ( j = i + 1 ; j < x . length ; j ++ ) { if ( x [ i ] == x [ j ] ) { temp_cnt ++ ; } } mode . push ( temp_cnt ) ; } max = Math . max . apply ( null , mode ) ; k = 1 ; while ( max == Math . max . apply ( null , mode ) ) { console . log ( x [ mode . indexOf ( Math . max . apply ( null , mode ) ) + k ++ ] ) ; mode . splice ( mode . indexOf ( Math . max . apply ( null , mode ) ) , 1 ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { var k = [ ] , m = 1 , t = 0 , p ; ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . sort ( function ( a , b ) { return a - b ; } ) . map ( function ( n ) { p == n ? t ++ : ( ( t > m ? ( k = [ p ] , m = t ) : t == m ? ( k . push ( p ) , m = t ) : 0 ) , ( t = 0 ) ) ; p = n ; } ) ; console . log ( k . join ( \" \\n \" ) ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var nums = input . trim ( ) . split ( ' \\n ' ) ; var f = [ ] ; nums . forEach ( function ( num ) { var o = f [ num ] ; if ( ! o ) { o = { id : + num , cnt : 0 } ; f [ num ] = o ; } o . cnt ++ ; } ) ; f . sort ( function ( a , b ) { return b . cnt - a . cnt ; } ) ; var maxCnt = f [ 0 ] . cnt ; f = f . filter ( function ( o ) { return o . cnt == maxCnt } ) ; f . sort ( function ( a , b ) { return a . id - b . id ; } ) ; f . forEach ( function ( o ) { console . log ( o . id ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var arr = Arr [ 0 ] . split ( \" \" ) ; var a = \" \" ; var b = \" \" ; var obj = { } ; var cnt = 0 ; arr . forEach ( function ( v ) { if ( a . length <= v . length ) a = v ; ( v in obj ) ? obj [ v ] ++ : obj [ v ] = 1 ; if ( cnt <= obj [ v ] ) { b = v ; cnt = obj [ v ] ; } } ) ; console . log ( b + \" \" + a ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' ' ) ; var n = p . length ; var r = [ ] ; var max = ' ' ; for ( var i = 0 ; i < n ; i ++ ) { var x = p . shift ( ) ; if ( x . length > max . length ) { max = x ; } if ( x in r ) { r [ x ] ++ ; } else { r [ x ] = 0 ; } } var a = [ ] ; for ( i in r ) { var m = r [ i ] ; if ( isNaN ( m ) ) { m = 0 ; } if ( m in a ) { a [ m ] . push ( i ) ; } else { a [ m ] = [ i ] ; } } console . log ( ' %s %s ' , a [ a . length - 1 ] . join ( ' \\n ' ) , max ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var max = \" \" ; var map = { } ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { input = input . replace ( \" \\n \" , \" \" ) ; var arr = input . split ( \" \" ) ; for ( var i in arr ) { if ( map [ arr [ i ] ] === undefined || map [ arr [ i ] ] === null ) { map [ arr [ i ] ] = 0 ; } else { map [ arr [ i ] ] ++ ; } if ( max . length < arr [ i ] . length ) max = arr [ i ] ; } } ) ; process . stdin . on ( ' end ' , function ( ) { var keys = Object . keys ( map ) ; var m = keys . pop ( ) ; for ( var k in keys ) { k = keys [ k ] ; if ( map [ m ] < map [ k ] ) m = k ; } console . log ( m , max ) ; } ) ;",
    "label": 2
  },
  {
    "code": "a = [ ] , m = l = 0 , n = c = ' ' ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . some ( function ( i ) { a [ j = i . toLowerCase ( ) ] ? ( ++ a [ j ] > m ? m = a [ n = j ] : 0 ) : a [ j ] = 1 ; ( t = j . length ) > l ? ( c = j , l = t ) : 0 } ) ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "a = [ ] , m = l = 0 , n = c = ' ' ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . some ( function ( i ) { a [ i ] ? ( ++ a [ i ] > m ? m = a [ n = i ] : 0 ) : a [ i ] = 1 ; ( t = i . length ) > l ? ( c = i , l = t ) : 0 } ) ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "a = [ ] , m = l = 0 , n = c = ' ' ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . some ( function ( i ) { a [ i ] ? ++ a [ i ] > m ? m = a [ n = i ] : 0 : a [ i ] = 1 ; ( t = i . length ) > l ? ( c = i , l = t ) : 0 } ) ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "a = [ ] , m = l = 0 , n = c = ' ' ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . map ( function ( i ) { a [ i ] ? ++ a [ i ] > m ? m = a [ n = i ] : 0 : a [ i ] = 1 ; ( t = i . length ) > l ? ( c = i , l = t ) : 0 } ) ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "a = [ ] , m = l = n = c = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' ' ) . map ( function ( i ) { a [ i ] ? ++ a [ i ] > m ? m = a [ n = i ] : 0 : a [ i ] = 1 ; ( t = i . length ) > l ? ( c = i , l = t ) : 0 } ) ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "a = [ ] , m = l = n = c = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' ' ) . map ( function ( i ) { a [ i ] ? ++ a [ i ] > m ? m = a [ n = i ] : 0 : a [ i ] = 1 ; ( t = i . length ) > l ? ( c = i , l = t ) : 0 } ) ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "for ( c = a = [ ] , m = l = n = j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) a [ i ] ? ++ a [ i ] > m ? m = a [ n = i ] : 0 : a [ i ] = 1 , i . length > c . length ? c = i : 0 ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "for ( c = a = [ ] , m = l = n = j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) a [ i ] ? ++ a [ i ] > m ? m = a [ n = i ] : 0 : a [ i ] = 1 , i . length > c . length ? c = i : 0 ; console . log ( n + ' ' + c )",
    "label": 2
  },
  {
    "code": "' use strict ' ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var strlist = input . trim ( ) . split ( ' ' ) ; var strhash = { } ; var maxlen = 0 ; var lststr = ' ' ; for ( var i in strlist ) { if ( strlist [ i ] in strhash ) { strhash [ strlist [ i ] ] += 1 ; } else { strhash [ strlist [ i ] ] = 1 ; } if ( strlist [ i ] . length > maxlen ) { lststr = strlist [ i ] ; maxlen = strlist [ i ] . length ; } } var most = 0 ; var mststr = ' ' ; for ( var property in strhash ) { if ( strhash [ property ] > most ) { mststr = property ; most = strhash [ property ] ; } } console . log ( mststr + ' ' + lststr ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' ) . toString ( ) ; var inputArray = input . split ( \" \" ) ; var words = { } ; var mostAppearedValue = 0 ; var mostAppearedIndex = 0 ; var longestValue = 0 ; var longestIndex = 0 ; for ( var i = 0 ; i < inputArray . length ; i ++ ) { if ( words [ inputArray [ i ] ] ) { words [ inputArray [ i ] ] ++ ; } else { words [ inputArray [ i ] ] = 1 ; if ( inputArray [ i ] . length > longestValue ) { longestValue = inputArray [ i ] . length ; longestIndex = i ; } } if ( words [ inputArray [ i ] ] > mostAppearedValue ) { mostAppearedValue = words [ inputArray [ i ] ] ; mostAppearedIndex = i ; } } console . log ( inputArray [ mostAppearedIndex ] + \" \" + inputArray [ longestIndex ] ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i , word , longer , words , max , maxStr , words = input [ 0 ] . split ( ' ' ) , len = words . length , dict = { } ; for ( i = 0 ; i < len ; i ++ ) { word = words [ i ] . toLowerCase ( ) ; dict [ word ] = ( dict [ word ] || 0 ) + 1 ; } max = 0 ; longer = ' ' ; Object . keys ( dict ) . forEach ( function ( word ) { if ( dict [ word ] > max ) { max = dict [ word ] ; maxStr = word ; } if ( word . length > longer . length ) { longer = word ; } } ) ; console . log ( ' %s %s ' , maxStr , longer ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c , o , m ) { o = { } , n = 0 , s = \" \" ; ( c + \" \" ) . trim ( ) . split ( \" \" ) . some ( function ( a ) { n < ( o [ a = a . toLowerCase ( ) ] ? ++ o [ a ] : ( o [ a ] = 1 ) ) && ( n = o [ m = a ] ) ; s . length < a . length && ( s = a ) ; } ) ; console . log ( m + \" \" + s ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var words = input . trim ( ) . split ( ' ' ) ; var f = { } ; var maxCnt = 0 ; var maxWord ; words . forEach ( function ( word ) { var cnt = f [ word ] || 0 ; cnt ++ ; if ( cnt > maxCnt ) { maxCnt = cnt ; maxWord = word ; } f [ word ] = cnt ; } ) ; words . sort ( function ( a , b ) { return b . length - a . length ; } ) ; console . log ( maxWord + ' ' + words [ 0 ] ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; while ( true ) { var a = p . shift ( ) . split ( ' ' ) . map ( Number ) ; var n = a . shift ( ) ; var s = a . shift ( ) ; if ( n === 0 && s === 0 ) { return ; } console . log ( count ( n , s ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function count ( n , s ) { return loop ( 0 , n , s ) ; } function loop ( i , n , s ) { var c = 0 ; for ( var j = i ; j < 10 ; j ++ ) { var sm = s - j ; if ( n === 1 ) { if ( sm === 0 ) { c ++ ; } } else { c += loop ( j + 1 , n - 1 , sm ) ; } } return c ; }",
    "label": 2
  },
  {
    "code": "function bomb ( n , sum , str , before ) { if ( n == N && sum == S ) cnt ++ ; if ( n == N ) return ; var arr = str . split ( \" \" ) . map ( Number ) ; arr . forEach ( function ( v ) { if ( before < v ) bomb ( n + 1 , sum + v , str . replace ( v , \" \" ) , v ) ; } ) ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var NS = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var N = NS [ 0 ] ; var S = NS [ 1 ] ; if ( N == 0 && S == 0 ) break ; var cnt = 0 ; bomb ( 0 , 0 , \" 0123456789 \" , - 1 ) ; console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { if ( input [ i ] == ' 0 0 ' ) break ; var c = input [ i ] . split ( ' ' ) ; var n = c [ 0 ] , s = c [ 1 ] ; var pattern = 0 ; for ( var a = 9 ; a >= n - 1 ; a -- ) { pattern += conv ( a , s - a , n - 1 ) ; } console . log ( pattern ) ; } } function conv ( start , dist , limit ) { var result = 0 ; if ( limit == 0 && dist == 0 ) return 1 ; if ( start < 0 || dist < 0 || limit < 0 ) return result ; for ( var i = start - 1 ; i >= limit - 1 ; i -- ) { result += conv ( i , dist - i , limit - 1 ) ; } return result ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; arr . some ( function ( v ) { if ( v == \" 0 0 \" ) return true ; var ns = v . split ( \" \" ) . map ( Number ) ; var n = ns [ 0 ] ; var s = ns [ 1 ] ; var all = [ ] ; var loop = function ( start , ary ) { if ( ary . length == n ) all . push ( ary ) ; else { for ( var i = start ; i <= 9 ; i ++ ) loop ( i + 1 , ary . concat ( i ) ) ; } } ; loop ( 0 , [ ] ) ; var cnt = 0 ; all . forEach ( function ( v ) { var sum = v . reduce ( function ( a , b ) { return a + b ; } ) ; if ( sum == s ) cnt ++ ; } ) ; console . log ( cnt ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; arr . some ( function ( v ) { if ( v == \" 0 0 \" ) return true ; var ns = v . split ( \" \" ) . map ( Number ) ; var n = ns [ 0 ] ; var s = ns [ 1 ] ; var all = [ ] ; var loop = function ( start , sum , cnt ) { if ( cnt == n ) all . push ( sum ) ; else { for ( var i = start ; i <= 9 ; i ++ ) { loop ( i + 1 , sum + i , cnt + 1 ) ; } } } loop ( 0 , 0 , 0 ) ; var cnt = 0 ; all . forEach ( function ( v ) { if ( v == s ) cnt ++ ; } ) ; console . log ( cnt ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var all = [ \" \" ] ; for ( var i = 1 ; i <= 9 ; i ++ ) { all . push ( [ ] ) ; var loop = function ( start , sum , cnt ) { if ( cnt == i ) all [ i ] . push ( sum ) ; else { for ( var j = start ; j <= 9 ; j ++ ) loop ( j + 1 , sum + j , cnt + 1 ) ; } } ; loop ( 0 , 0 , 0 ) ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; arr . some ( function ( v ) { if ( v == \" 0 0 \" ) return true ; var ns = v . split ( \" \" ) . map ( Number ) ; var n = ns [ 0 ] ; var s = ns [ 1 ] ; var cnt = 0 ; all [ n ] . forEach ( function ( v ) { if ( v == s ) cnt ++ ; } ) ; console . log ( cnt ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function calc ( prev , _i , n , s , depth ) { if ( n - 1 === depth ) { if ( _i <= s - prev && s - prev <= 9 ) { return ( 1 ) ; } return ( 0 ) ; } var ans = 0 ; for ( var i = _i ; i <= 9 ; i ++ ) { if ( prev + i > s ) break ; ans += calc ( prev + i , i + 1 , n , s , depth + 1 ) ; } return ( ans ) ; } Main ( function ( input ) { input . trim ( ) . split ( ' \\n ' ) . forEach ( function ( line ) { var tmp = line . split ( ' ' ) ; var n = tmp [ 0 ] ; var s = tmp [ 1 ] ; if ( n === ' 0 ' && s === ' 0 ' ) { return ; } console . log ( calc ( 0 , 0 , + n , + s , 0 ) ) ; } ) ; } ) ; function Main ( main ) { var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) ; } ) ; } ;",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var args = input . trim ( ) . split ( ' \\n ' ) ; for ( var i = 0 ; i < args . length ; i += 1 ) { var set = args [ i ] . split ( ' ' ) . map ( Number ) ; var n = set [ 0 ] , s = set [ 1 ] ; if ( ! n && ! s ) { return ; } console . log ( solve ( n , s ) ) ; } } function solve ( n , s ) { return countRecursively ( s , - 1 , n ) ; } function countRecursively ( nowS , numPos , step ) { if ( step === 0 ) { var success = nowS === 0 ; return success ? 1 : 0 ; } var total = 0 ; for ( var i = numPos + 1 ; i <= 9 ; i += 1 ) { if ( nowS >= i ) { total += countRecursively ( nowS - i , i , step - 1 ) ; } } return total ; }",
    "label": 2
  },
  {
    "code": "function comb ( r ) { var c = [ ] ; c [ 0 ] = - 1 ; var k = 1 ; c [ 1 ] = 0 ; var ret = [ ] ; while ( k != 0 ) { for ( var i = k + 1 ; i <= r ; i ++ ) { c [ i ] = c [ i - 1 ] + 1 ; } var arr = [ ] for ( var i = 1 ; i <= r ; i ++ ) { arr . push ( c [ i ] ) ; } ret . push ( arr ) ; k = r ; while ( c [ k ] == 9 - r + k ) k = k - 1 ; c [ k ] = c [ k ] + 1 ; } return ret ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var nums = line . split ( ' ' ) ; var n = + nums [ 0 ] ; var s = + nums [ 1 ] ; if ( n + s == 0 ) break ; var c = comb ( n ) ; var cnt = 0 ; for ( var i = 0 ; i < c . length ; i ++ ) { var arr = c [ i ] ; if ( s == arr . reduce ( function ( prev , now ) { return prev + now ; } ) ) { cnt ++ ; } } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; var w = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] ; w . reverse ( ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var a = Arr [ i ] ; var arr = [ ] ; w . forEach ( function ( v ) { if ( a >= v ) { a = a - v ; arr . push ( v ) ; } } ) ; console . log ( arr . reverse ( ) . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) . map ( Number ) ; var n = p . length ; for ( var i = 0 ; i < n ; i ++ ) { var g = p . shift ( ) ; var s = [ ] ; g . toString ( 2 ) . split ( ' ' ) . reverse ( ) . map ( function ( e , i ) { if ( e == 1 ) { s . push ( Math . pow ( 2 , i ) ) ; } } ) ; console . log ( s . join ( ' ' ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { for ( a = [ ] , j = 0 ; j <= 9 ; j ++ ) if ( ( n = 1 << j ) & i ) a . push ( n ) ; if ( a [ 0 ] ) console . log ( a . join ( ' ' ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { for ( a = [ ] , j = 0 ; j <= 9 ; j ++ ) if ( ( n = 1 << j ) & i ) a . push ( n ) ; console . log ( a . join ( ' ' ) ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { for ( a = ' ' , j = 0 ; j <= 9 ; j ++ ) if ( ( n = 1 << j ) & i ) a += n + ' ' ; console . log ( a . trim ( ) ) } )",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; console . log ( a . trim ( ) ) ) for ( a = ' ' , k = 0 ; 10 - k ; k ++ ) ( n = 1 << k ) & i ? a += n + ' ' : 0",
    "label": 2
  },
  {
    "code": "function main ( ) { function search ( w , n , xs , sum ) { return n === ws . length ? ( sum === w ? xs : null ) : search ( w , n + 1 , xs . concat ( ws [ n ] ) , sum + ws [ n ] ) || search ( w , n + 1 , xs , sum ) ; } var ws = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] ; input . forEach ( function ( line ) { if ( line . trim ( ) === ' ' ) return ; console . log ( search ( parseInt ( line , 10 ) , 0 , [ ] , 0 ) . join ( ' ' ) ) ; } ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var g = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] ; process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n ) { var a = [ ] , l = 10 ; while ( l -- ) { ( n >= g [ l ] ) && ( n -= g [ l ] , a . unshift ( g [ l ] ) ) ; } console . log ( a . join ( \" \" ) ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var weights = [ ] ; for ( var i = 0 ; i < 10 ; i ++ ) { weights [ i ] = 1 << i ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var w = + line ; var result = [ ] ; for ( var i = 0 ; i < weights . length ; i ++ ) { if ( w & weights [ i ] ) result . push ( weights [ i ] ) ; } console . log ( result . length == 0 ? 0 : result . join ( ' ' ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var A = 0 ; var B = 0 ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" , \" ) . map ( Number ) ; var a = arr [ 0 ] ; var b = arr [ 1 ] ; var c = arr [ 2 ] ; if ( a * a + b * b == c * c ) A ++ ; if ( a == b ) B ++ ; } console . log ( A + \" \\n \" + B ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = p . length ; var r = [ 0 , 0 ] ; for ( var i = 0 ; i < n ; i ++ ) { var a = p . shift ( ) . split ( ' , ' ) . map ( Number ) ; var x1 = a . shift ( ) ; var x2 = a . shift ( ) ; var x3 = a . shift ( ) ; if ( x3 * x3 === x1 * x1 + x2 * x2 ) { r [ 0 ] ++ ; } else if ( x1 === x2 ) { r [ 1 ] ++ ; } } console . log ( ' %s \\n %s ' , r [ 0 ] , r [ 1 ] ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "a = b = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { c = i . split ( ' , ' ) ; x = c [ 0 ] , y = c [ 1 ] , z = c [ 2 ] ; z * z - y * y - x * x ? y - x ? 0 : b ++ : a ++ } ) ; console . log ( a + ' \\n ' + b )",
    "label": 2
  },
  {
    "code": "function main ( ) { var c1 = 0 , c2 = 0 ; input . forEach ( function ( line ) { if ( line . trim ( ) === ' ' ) return ; line = line . split ( ' , ' ) . map ( parseFloat ) ; if ( line [ 0 ] * line [ 0 ] + line [ 1 ] * line [ 1 ] === line [ 2 ] * line [ 2 ] ) { c1 ++ ; } else if ( line [ 0 ] === line [ 1 ] ) { c2 ++ ; } } ) ; console . log ( ' %d \\n %d ' , c1 , c2 ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; var rectangles = 0 ; var lozenges = 0 ; while ( line = lines . shift ( ) ) { var l = line . split ( ' , ' ) . map ( function ( n ) { return + n ; } ) ; var a = l [ 0 ] ; var b = l [ 1 ] ; var c = l [ 2 ] ; if ( a * a + b * b == c * c ) rectangles ++ ; else if ( a == b ) lozenges ++ ; } console . log ( rectangles ) ; console . log ( lozenges ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . shift ( ) ; Arr . forEach ( function ( V ) { var arr = V . split ( \" \" ) . map ( Number ) ; var a = 0 ; var b = 0 ; var flag = true ; for ( var i = 0 ; i < arr . length ; i ++ ) { var v = arr [ i ] ; if ( a < v ) { a = v ; continue ; } if ( b < v ) { b = v ; continue ; } flag = false ; } console . log ( flag ? \" YES \" : \" NO \" ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = Number ( p . shift ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var a = p . shift ( ) . split ( ' ' ) . map ( Number ) ; console . log ( order ( a ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function order ( a ) { var r = [ ] ; var x ; var c = a . shift ( ) ; while ( x = a . shift ( ) ) { if ( x > c ) { c = x ; continue ; } r . push ( x ) ; } var m = - Infinity ; while ( x = r . shift ( ) ) { if ( x > m ) { m = x ; continue ; } return ' NO ' ; } return ' YES ' ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input [ 0 ] - 0 ; i < len ; i ++ ) { var c = input [ i + 1 ] . split ( ' ' ) ; var a = b = 0 ; for ( var j = 0 , jlen = c . length ; j < jlen ; j ++ ) { if ( ( d = + c [ j ] ) > a ) a = d ; else if ( d > b ) b = d ; else a = b = 11 ; } console . log ( a == 11 ? ' NO ' : ' YES ' ) ; } }",
    "label": 2
  },
  {
    "code": "for ( i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) , j = 1 ; i [ 0 ] - j + 1 ; j ++ ) { for ( a = b = 0 , k = 10 ; k -- ; ) ( l = + i [ 10 * j - k ] ) > a ? a = l : l > b ? b = l : a = 11 ; console . log ( a == 11 ? ' NO ' : ' YES ' ) }",
    "label": 2
  },
  {
    "code": "for ( i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) , j = 1 ; i [ 0 ] - j + 1 ; j ++ ) { for ( a = b = 0 , k = 10 ; k -- ; ) ( l = + i [ 10 * j - k ] ) > a ? a = l : l > b ? b = l : a = 11 ; console . log ( a - 11 ? ' YES ' : ' NO ' ) }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var args = input . trim ( ) . split ( ' \\n ' ) ; var dataSetCount = parseInt ( args [ 0 ] ) ; args = args . slice ( 1 , dataSetCount + 1 ) ; args . forEach ( function ( set ) { set = set . split ( ' ' ) . map ( Number ) ; console . log ( solve ( set ) ) ; } ) } function solve ( set ) { var right = 0 ; var left = 0 ; for ( var i = 0 ; i < set . length ; i += 1 ) { var ball = set [ i ] ; if ( ball > right ) { right = ball ; } else if ( ball > left ) { left = ball ; } else return \" NO \" ; } return \" YES \" ; }",
    "label": 2
  },
  {
    "code": "var arr = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( / \\n / ) ; var caseCount = arr . length ; for ( var i = 1 ; i < caseCount ; i ++ ) { var balls = arr [ i ] . trim ( ) . split ( / \\s / ) ; var course = [ 0 , 0 ] ; for ( var j = 0 ; j < balls . length ; j ++ ) { var ballNum = parseInt ( balls [ j ] , 10 ) ; var courseDeff = [ ( ballNum - course [ 0 ] ) , ( ballNum - course [ 1 ] ) ] ; if ( ( courseDeff [ 0 ] < 0 ) && ( courseDeff [ 1 ] < 0 ) ) { console . log ( \" NO \" ) ; break ; } if ( ( courseDeff [ 0 ] <= courseDeff [ 1 ] ) && ( courseDeff [ 0 ] > 0 ) ) { course [ 0 ] = ballNum ; } else { course [ 1 ] = ballNum ; } if ( j == 9 ) { console . log ( \" YES \" ) ; } } }",
    "label": 2
  },
  {
    "code": "function main ( ) { function dfs ( n , l , r ) { if ( n . length === 0 ) return true ; return ( n [ 0 ] > l [ 0 ] && dfs ( n . slice ( 1 ) , [ n [ 0 ] ] . concat ( l ) , r ) ) || ( n [ 0 ] > r [ 0 ] && dfs ( n . slice ( 1 ) , l , [ n [ 0 ] ] . concat ( r ) ) ) ; } var i , n = parseInt ( input [ 0 ] , 10 ) , nums = input . slice ( 1 ) ; for ( i = 0 ; i < n ; i ++ ) { console . log ( dfs ( nums [ i ] . split ( ' ' ) . map ( parseFloat ) , [ 0 ] , [ 0 ] ) ? ' YES ' : ' NO ' ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . slice ( 1 ) . some ( function ( a ) { a = a . split ( \" \" ) ; var b = 0 , c = 0 ; console . log ( a . some ( function ( n ) { return b < ( n = + n ) ? ( b = n , 0 ) : c < n ? ( c = n , 0 ) : 1 ; } ) ? \" NO \" : \" YES \" ) ; } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" , \" ) . map ( Number ) ; var b = arr . pop ( ) ; var a = arr . pop ( ) ; var sum = arr . reduce ( function ( a , b ) { return a + b } ) ; var time = sum / ( a + b ) ; var d = a * time ; var D = 0 ; for ( var i = 0 ; i < arr . length ; i ++ ) { D += arr [ i ] ; if ( D >= d ) break ; } console . log ( i + 1 ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = p . length ; for ( var i = 0 ; i < n ; i ++ ) { var a = p . shift ( ) . split ( ' , ' ) . map ( Number ) ; var v2 = a . pop ( ) ; var v1 = a . pop ( ) ; console . log ( cross ( a , v1 , v2 ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function cross ( a , v1 , v2 ) { var l = [ ] ; for ( var i = 0 ; i < a . length ; i ++ ) { l [ i ] = a [ i ] ; if ( i > 0 ) { l [ i ] += l [ i - 1 ] ; } } var x = l [ l . length - 1 ] * v1 / ( v1 + v2 ) ; var c = 1 ; for ( i = 0 ; i < l . length ; i ++ ) { if ( x > l [ i ] ) { c = i + 2 ; continue ; } return c ; } }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , ' utf8 ' ) . trim ( ) . split ( / \\s / ) . map ( function ( i ) { j = i . split ( ' , ' ) ; for ( n = m = s = 0 ; m < 10 ; m ++ ) j [ m ] = s -= j [ m ] ; for ( s *= j [ 10 ] / ( - j [ 10 ] - j [ 11 ] ) ; j [ n ] > - s ; n ++ ) ; console . log ( ++ n ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , ' utf8 ' ) . trim ( ) . split ( / \\s / ) . map ( function ( i ) { j = i . split ( ' , ' ) ; for ( s = 0 , m = n = 10 ; m -- ; ) j [ m ] = s -= j [ m ] ; for ( s *= j [ 11 ] / ( - j [ 11 ] - j [ n ] ) ; j [ -- n ] >= - s ; ) ; console . log ( ++ n ) ; } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , ' utf8 ' ) . trim ( ) . split ( / \\s / ) . map ( function ( i ) { j = i . split ( ' , ' ) ; for ( s = 0 , m = n = 10 ; m -- ; ) j [ m ] = s -= j [ m ] ; for ( a = - j [ 11 ] , s *= a / ( a - j [ n ] ) ; j [ -- n ] >= s ; ) ; console . log ( ++ n ) ; } )",
    "label": 2
  },
  {
    "code": "function Vector ( x , y ) { this . x = x ; this . y = y ; } Vector . prototype . sub = function ( v ) { return new Vector ( this . x - v . x , this . y - v . y ) ; } ; Vector . prototype . product = function ( v ) { return this . x * v . y - this . y * v . x ; } ; ( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = p . length ; for ( var i = 0 ; i < n ; i ++ ) { var a = p . shift ( ) . split ( ' , ' ) . map ( Number ) ; console . log ( cross . apply ( null , a ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function cross ( xa , ya , xb , yb , xc , yc , xd , yd ) { var va = new Vector ( xa , ya ) ; var vb = new Vector ( xb , yb ) ; var vc = new Vector ( xc , yc ) ; var vd = new Vector ( xd , yd ) ; var vba = vb . sub ( va ) ; var vcb = vc . sub ( vb ) ; var vdc = vd . sub ( vc ) ; var vad = va . sub ( vd ) ; var c1 = vba . product ( vcb ) ; var c2 = vcb . product ( vdc ) ; var c3 = vdc . product ( vad ) ; var c4 = vad . product ( vba ) ; if ( ( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 ) || ( c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0 ) ) { return ' YES ' ; } return ' NO ' ; } function cross_ ( x1 , y1 , x2 , y2 ) { return x1 * y2 - x2 * y1 ; }",
    "label": 2
  },
  {
    "code": "function heron ( a , b , c ) { var s = ( a + b + c ) / 2 ; var S = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return S ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" , \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var d12 = Math . sqrt ( Math . pow ( x1 - x2 , 2 ) + Math . pow ( y1 - y2 , 2 ) ) ; var d23 = Math . sqrt ( Math . pow ( x2 - x3 , 2 ) + Math . pow ( y2 - y3 , 2 ) ) ; var d34 = Math . sqrt ( Math . pow ( x3 - x4 , 2 ) + Math . pow ( y3 - y4 , 2 ) ) ; var d41 = Math . sqrt ( Math . pow ( x4 - x1 , 2 ) + Math . pow ( y4 - y1 , 2 ) ) ; var d13 = Math . sqrt ( Math . pow ( x1 - x3 , 2 ) + Math . pow ( y1 - y3 , 2 ) ) ; var d24 = Math . sqrt ( Math . pow ( x2 - x4 , 2 ) + Math . pow ( y2 - y4 , 2 ) ) ; var A = heron ( d12 , d24 , d41 ) + heron ( d23 , d34 , d24 ) ; var B = heron ( d12 , d23 , d13 ) + heron ( d13 , d34 , d41 ) ; var ans = ( Math . abs ( A - B ) < 1.0e-5 ) ? \" YES \" : \" NO \" ; console . log ( ans ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var c = input [ i ] . split ( ' , ' ) ; console . log ( ! isInner ( c [ 0 ] , c [ 1 ] , c [ 2 ] , c [ 3 ] , c [ 4 ] , c [ 5 ] , c [ 6 ] , c [ 7 ] ) && ! isInner ( c [ 2 ] , c [ 3 ] , c [ 4 ] , c [ 5 ] , c [ 6 ] , c [ 7 ] , c [ 0 ] , c [ 1 ] ) && ! isInner ( c [ 4 ] , c [ 5 ] , c [ 6 ] , c [ 7 ] , c [ 0 ] , c [ 1 ] , c [ 2 ] , c [ 3 ] ) && ! isInner ( c [ 6 ] , c [ 7 ] , c [ 0 ] , c [ 1 ] , c [ 2 ] , c [ 3 ] , c [ 4 ] , c [ 5 ] ) ? ' YES ' : ' NO ' ) ; } } function isInner ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var v1 = new Vector2D ( x1 , y1 ) ; var v2 = new Vector2D ( x2 , y2 ) ; var v3 = new Vector2D ( x3 , y3 ) ; var vp = new Vector2D ( x4 , y4 ) ; var v12 = v2 . sub ( v1 ) ; var v2p = vp . sub ( v2 ) ; var v23 = v3 . sub ( v2 ) ; var v3p = vp . sub ( v3 ) ; var v31 = v1 . sub ( v3 ) ; var v1p = vp . sub ( v1 ) ; var c1 = v12 . cross ( v2p ) ; var c2 = v23 . cross ( v3p ) ; var c3 = v31 . cross ( v1p ) ; return ( c1 >= 0 && c2 >= 0 && c3 >= 0 ) || ( c1 < 0 && c2 < 0 && c3 < 0 ) ; } function Vector2D ( x , y ) { this . x = x - 0 , this . y = y - 0 ; this . sub = function ( v ) { return new Vector2D ( this . x - v . x , this . y - v . y ) ; } ; this . cross = function ( v ) { return this . x * v . y - this . y * v . x ; } ; }",
    "label": 2
  },
  {
    "code": "var COUNTER_CLOCKWISE = 1 ; var CLOCKWISE = - 1 ; var ONLINE_BACK = 2 ; var ONLINE_FRONT = - 2 ; var ON_SEGMENT = 0 ; var Vector2D = class Vector2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } Vector2D . prototype . Init = function ( x , y ) { this . x = x ; this . y = y ; } function rotateVector90 ( v ) { var r = new Vector2D ( ) ; r . x = - v . y ; r . y = v . x ; return r ; } function getDegreeToRadian ( degree ) { var pi = 3.14159265358979323846 ; return degree * pi / 180 ; } function getRotateVector ( vec , degree ) { var radian = getDegreeToRadian ( degree ) ; var sin = Math . sin ( radian ) ; var cos = Math . cos ( radian ) ; var r = new Vector2D ( ) ; r . x = vec . x * cos - vec . y * sin ; r . y = vec . x * sin + vec . y * cos ; return r ; } function getRotateVectorFromRad ( vec , radian ) { var sin = Math . sin ( radian ) ; var cos = Math . cos ( radian ) ; var r = new Vector2D ( ) ; r . x = vec . x * cos - vec . y * sin ; r . y = vec . x * sin + vec . y * cos ; return r ; } function isEqualVectors ( a , b ) { return equalFloats ( a . x - b . x , 0 ) && equalFloats ( a . y - b . y , 0 ) ; } function getUnitVector ( vec ) { var length = getVectorLength2D ( vec ) ; if ( length > 0 ) { return getDivideVector ( vec , length ) ; } return vec ; } function getVectorLength2D ( vec ) { return Math . sqrt ( ( vec . x * vec . x ) + ( vec . y * vec . y ) ) ; } function getNorm ( vec ) { return vec . x * vec . x + vec . y * vec . y ; } function getDivideVector ( vec2D , length ) { var vec = new Vector2D ( ) ; vec . x = vec2D . x / length ; vec . y = vec2D . y / length ; return vec ; } function equalFloats ( a , b ) { var threshold = 1 / 8192 ; return Math . abs ( a - b ) < threshold ; } function isParallelVector ( vectorA , vectorB ) { var na = rotateVector90 ( vectorA ) ; return equalFloats ( 0 , dotProduct2D ( na , vectorB ) ) ; } function isVerticalVector ( vectorA , vectorB ) { return equalFloats ( 0 , dotProduct2D ( vectorA , vectorB ) ) ; } function subtractVector ( vecA , vecB ) { var vec = new Vector2D ( ) ; vec . x = vecA . x - vecB . x ; vec . y = vecA . y - vecB . y ; return vec ; } function dotProduct2D ( vecA , vecB ) { var dot = vecA . x * vecB . x + vecA . y * vecB . y ; return vecA . x * vecB . x + vecA . y * vecB . y ; } function getCross ( vecA , vecB ) { return vecA . x * vecB . y - vecA . y * vecB . x ; } var LineSegment2D = class LineSegment2D { constructor ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } } LineSegment2D . prototype . Init = function ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } function onOneSide ( axis , segment ) { var d1 = new Vector2D ( ) ; d1 = subtractVector ( segment . point1 , axis . base ) ; var d2 = new Vector2D ( ) ; d2 = subtractVector ( segment . point2 , axis . base ) ; var n = new Vector2D ( ) ; n = rotateVector90 ( axis . direction ) ; return dotProduct2D ( n , d1 ) * dotProduct2D ( n , d2 ) > 0 ; } function overLapping ( minA , maxA , minB , maxB ) { return minB <= maxA && minA <= maxB ; } function isSegmentsCollide ( segment1 , segment2 ) { var axisA = new Line ( ) ; var axisB = new Line ( ) ; axisA . base = segment1 . point1 ; axisA . direction = subtractVector ( segment1 . point2 , segment1 . point1 ) ; if ( onOneSide ( axisA , segment2 ) ) { return false ; } axisB . base = segment2 . point1 ; axisB . direction = subtractVector ( segment2 . point2 , segment2 . point1 ) ; if ( onOneSide ( axisB , segment1 ) ) { return false ; } if ( isParallelVector ( axisA . direction , axisB . direction ) ) { var rangeA = getProjectSegment ( segment1 , axisA . direction ) ; var rangeB = getProjectSegment ( segment2 , axisA . direction ) ; return isOverLappingRanges ( rangeA , rangeB ) ; } else { return true ; } } function Line ( ) { this . base ; this . direction } Line . prototype . Init = function ( base , direction , color ) { this . base = base ; this . direction = direction ; } var Range = class Range { constructor ( min , max ) { this . min = min ; this . max = max ; } } function getMaxMinRange ( range1 , range2 ) { var range = new Range ( ) ; range . min = range1 . min < range2 . min ? range1 . min : range2 . min ; range . max = range1 . max < range2 . max ? range2 . max : range1 . max ; return range ; } function getSortRange ( range ) { var sorted = new Range ( range . min , range . max ) ; if ( range . min > range . max ) { sorted . min = range . max ; sorted . max = range . min ; } return sorted ; } function getNegateVector ( vector ) { vector . x = - vector . x ; vector . y = - vector . y ; return vector ; } function addVector ( vecA , vecB ) { return new Vector2D ( vecA . x + vecB . x , vecA . y + vecB . y ) ; } function getProjectSegment ( segment , onto ) { var ontoUnitVec = getUnitVector ( onto ) ; var range = new Range ( ) ; range . min = dotProduct2D ( ontoUnitVec , segment . point1 ) ; range . max = dotProduct2D ( ontoUnitVec , segment . point2 ) ; range = getSortRange ( range ) ; return range ; } function isOverLappingRanges ( range1 , range2 ) { return overLapping ( range1 . min , range1 . max , range2 . min , range2 . max ) ; } function projectVector ( project , onto ) { var d = dotProduct2D ( onto , onto ) ; if ( 0 < d ) { var dp = dotProduct2D ( project , onto ) ; return multiplyVector ( onto , dp / d ) ; } return onto ; } var Point2D = class Point2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } function addPoint ( point1 , point2 ) { return new Point2D ( point1 . x + point2 . x , point1 . y + point2 . y ) ; } function subtractPoint ( point1 , point2 ) { return new Point2D ( point1 . x - point2 . x , point1 . y - point2 . y ) ; } function multiplyPoint ( point , scalar ) { return new Point2D ( point . x * scalar , point . y * scalar ) ; } function getProjectPoint ( segment , point ) { var vec1 = new Vector2D ( segment . point2 . x - segment . point1 . x , segment . point2 . y - segment . point1 . y ) ; var vec2 = new Vector2D ( point . x - segment . point1 . x , point . y - segment . point1 . y ) ; var rate = dotProduct2D ( vec2 , vec1 ) / getNorm ( vec1 ) ; var vec3 = multiplyVector ( vec1 , rate ) ; var project = new Point2D ( segment . point1 . x + vec3 . x , segment . point1 . y + vec3 . y ) ; return project ; } function getReflectionPoint ( segment , point ) { var projection = getProjectPoint ( segment , point ) ; var vec = subtractPoint ( projection , point ) ; var refrectionPoint = multiplyPoint ( vec , 2 ) ; return addPoint ( refrectionPoint , point ) ; } function getCrossPoint ( segment1 , segment2 ) { var baseVector = new Vector2D ( segment2 . point2 . x - segment2 . point1 . x , segment2 . point2 . y - segment2 . point1 . y ) ; var d1Vec = new Vector2D ( segment1 . point1 . x - segment2 . point1 . x , segment1 . point1 . y - segment2 . point1 . y ) ; var d2Vec = new Vector2D ( segment1 . point2 . x - segment2 . point1 . x , segment1 . point2 . y - segment2 . point1 . y ) ; var d1 = Math . abs ( getCross ( baseVector , d1Vec ) ) ; var d2 = Math . abs ( getCross ( baseVector , d2Vec ) ) ; var t = d1 / ( d1 + d2 ) ; var x = segment1 . point1 . x + ( segment1 . point2 . x - segment1 . point1 . x ) * t ; var y = segment1 . point1 . y + ( segment1 . point2 . y - segment1 . point1 . y ) * t ; return new Point2D ( x , y ) ; } function multiplyVector ( vec , scalar ) { var temp = new Vector2D ( ) ; temp . x = vec . x * scalar ; temp . y = vec . y * scalar ; return temp ; } function clampOnRange ( x , min , max ) { if ( x < min ) { return min ; } else if ( x > max ) { return max ; } else { return x ; } } function getDistanceLinePoint ( line , point ) { var vec1 = new Vector2D ( line . point2 . x - line . point1 . x , line . point2 . y - line . point1 . y ) ; var vec2 = new Vector2D ( point . x - line . point1 . x , point . y - line . point1 . y ) ; return Math . abs ( getCross ( vec1 , vec2 ) / getVectorLength2D ( vec1 ) ) ; } function getDistanceSegmentPoint ( segment , point ) { if ( dotProduct2D ( subtractPoint ( segment . point2 , segment . point1 ) , subtractPoint ( point , segment . point1 ) ) < 0 ) { return getVectorLength2D ( subtractPoint ( point , segment . point1 ) ) ; } if ( dotProduct2D ( subtractPoint ( segment . point1 , segment . point2 ) , subtractPoint ( point , segment . point2 ) ) < 0 ) { return getVectorLength2D ( subtractPoint ( point , segment . point2 ) ) ; } return getDistanceLinePoint ( segment , point ) ; } function getSegmentDistance ( segment1 , segment2 ) { if ( isSegmentsCollide ( segment1 , segment2 ) ) { return 0 ; } return Math . min ( Math . min ( getDistanceSegmentPoint ( segment1 , segment2 . point1 ) , getDistanceSegmentPoint ( segment1 , segment2 . point2 ) ) , Math . min ( getDistanceSegmentPoint ( segment2 , segment1 . point1 ) , getDistanceSegmentPoint ( segment2 , segment1 . point2 ) ) ) ; } function ccw ( point1 , point2 , point3 ) { var vec1 = new Vector2D ( point2 . x - point1 . x , point2 . y - point1 . y ) ; var vec2 = new Vector2D ( point3 . x - point1 . x , point3 . y - point1 . y ) ; var cross = getCross ( vec1 , vec2 ) ; if ( cross > Number . EPSILON ) { return COUNTER_CLOCKWISE ; } if ( cross < - Number . EPSILON ) { return CLOCKWISE ; } if ( dotProduct2D ( vec1 , vec2 ) < - Number . EPSILON ) { return ONLINE_BACK ; } if ( getVectorLength2D ( vec1 ) < getVectorLength2D ( vec2 ) ) { return ONLINE_FRONT ; } return ON_SEGMENT ; } function getConvexHoll ( points ) { if ( points . length < 3 ) { return points ; } points . sort ( ( a , b ) => ( a . x > b . x ) ? 1 : ( a . x == b . x ) ? ( ( a . y > b . y ) ? 1 : - 1 ) : - 1 ) ; var u = [ ] ; u . push ( points [ 0 ] ) ; u . push ( points [ 1 ] ) ; var l = [ ] ; l . push ( points [ points . length - 1 ] ) ; l . push ( points [ points . length - 2 ] ) ; for ( var i = 2 ; i < points . length ; ++ i ) { for ( var j = u . length ; j >= 2 && ccw ( u [ j - 2 ] , u [ j - 1 ] , points [ i ] ) == COUNTER_CLOCKWISE ; -- j ) { u . pop ( ) ; } u . push ( points [ i ] ) ; } for ( var i = points . length - 3 ; i >= 0 ; -- i ) { for ( var j = l . length ; j >= 2 && ccw ( l [ j - 2 ] , l [ j - 1 ] , points [ i ] ) == COUNTER_CLOCKWISE ; -- j ) { l . pop ( ) ; ; } l . push ( points [ i ] ) ; } l . reverse ( ) ; for ( var i = u . length - 2 ; i >= 1 ; -- i ) { l . push ( u [ i ] ) ; } return l ; } function getConvexDiameter ( points ) { var is = 0 ; var js = 0 ; for ( var i = 1 ; i < points . length ; i ++ ) { if ( points [ i ] . y > points [ is ] . y ) is = i ; if ( points [ i ] . y < points [ js ] . y ) js = i ; } var distance = getNorm ( subtractVector ( points [ is ] , points [ js ] ) ) ; var maxi = is , i = js , maxj = js , j = js ; do { if ( getCross ( subtractVector ( points [ ( i + 1 ) % points . length ] , points [ i ] ) , subtractVector ( points [ ( j + 1 ) % points . length ] , points [ j ] ) ) >= 0 ) { j = ( j + 1 ) % points . length ; } else { i = ( i + 1 ) % points . length ; } if ( getNorm ( subtractVector ( points [ i ] , points [ j ] ) ) > distance ) { distance = getNorm ( subtractVector ( points [ i ] , points [ j ] ) ) ; maxi = i ; maxj = j ; } } while ( i != is || j != js ) ; return distance ; } function getArea ( points ) { var area = 0 ; for ( var i = 0 ; i < points . length ; ++ i ) { area += getCross ( points [ i ] , points [ ( i + 1 ) % points . length ] ) ; } return area / 2 ; } function getConvexCut ( points , point1 , point2 ) { var convex = [ ] ; for ( var i = 0 ; i < points . length ; ++ i ) { var nowPoint = points [ i ] ; var nextPoint = points [ ( i + 1 ) % points . length ] ; var nowPointCcw = ccw ( point1 , point2 , nowPoint ) ; if ( nowPointCcw != CLOCKWISE ) { convex . push ( nowPoint ) ; } if ( nowPointCcw * ccw ( point1 , point2 , nextPoint ) == CLOCKWISE ) { var crossPoint = getCrossPointFromPoints ( point1 , point2 , nowPoint , nextPoint ) ; convex . push ( crossPoint ) ; } } return convex ; } function getPointDistance ( point1 , point2 ) { var x = point1 . x - point2 . x ; var y = point1 . y - point2 . y ; return Math . sqrt ( x * x + y * y ) ; } function closestPair ( points , n ) { if ( n == 1 ) return Number . MAX_SAFE_INTEGER ; var d = Number . MAX_SAFE_INTEGER ; var m = Math . floor ( n / 2 ) ; d = Math . min ( closestPair ( points , m ) , closestPair ( points . slice ( m ) , n - m ) ) ; var mx = points [ m ] . x ; var arr = [ ] ; for ( var i = m ; i >= 0 ; -- i ) { var x = Math . abs ( points [ i ] . x - mx ) ; if ( x > d ) { break ; } else { arr . push ( points [ i ] ) ; } } for ( var i = m + 1 ; i < n ; ++ i ) { if ( Math . abs ( points [ i ] . x - mx ) > d ) { break ; } else { arr . push ( points [ i ] ) ; } } arr . sort ( ( a , b ) => ( a . y > b . y ) ? 1 : - 1 ) ; for ( var i = 0 ; i < arr . length ; ++ i ) { for ( var j = i + 1 ; j < arr . length && Math . abs ( arr [ j ] . y - arr [ i ] . y ) < d ; ++ j ) { var tmp = getPointDistance ( arr [ i ] , arr [ j ] ) ; if ( tmp < d ) d = tmp ; } } return d ; } var Circle2D = class Circle2D { constructor ( x , y , r ) { this . center = new Point2D ( x , y ) ; this . r = r ; } } function getCircleLineCrossPoints ( line , circle ) { var d = getDistanceLinePoint ( line , circle . center ) ; if ( d > circle . r ) { console . log ( \" return \" ) return ; } var pr = getProjectPoint ( line , circle . center ) ; if ( equalFloats ( d , circle . r ) ) { return pr ; } else { var unit = getUnitVector ( new Vector2D ( line . point1 . x - line . point2 . x , line . point1 . y - line . point2 . y ) ) ; var length = Math . sqrt ( ( circle . r * circle . r ) - getNorm ( subtractVector ( pr , circle . center ) ) ) ; var crossPoints = [ ] ; crossPoints [ 0 ] = addPoint ( pr , multiplyVector ( unit , length ) ) ; crossPoints [ 1 ] = subtractVector ( pr , multiplyVector ( unit , length ) ) ; return crossPoints ; } } function getPolar ( a , r ) { return new Point2D ( Math . cos ( r ) * a , Math . sin ( r ) * a ) ; } function getCircleCircleCrossPoints ( circle1 , circle2 ) { var crossPoints = [ ] ; var d = getPointDistance ( circle1 . center , circle2 . center ) ; var rDis = circle1 . r + circle2 . r ; if ( d > rDis ) { return ; } else if ( equalFloats ( d == rDis ) ) { var vec = new Vector2D ( circle2 . center . x - circle1 . center . x , circle2 . center . y - circle1 . center . y ) ; var unit = getUnitVector ( vec ) ; var point = multiplyVector ( unit , d ) ; crossPoints [ 0 ] = crossPoints [ 1 ] = point ; } else { var a = Math . acos ( ( circle1 . r * circle1 . r + d * d - circle2 . r * circle2 . r ) / ( 2 * circle1 . r * d ) ) ; var vec = subtractVector ( circle2 . center , circle1 . center ) ; var t = Math . atan2 ( vec . y , vec . x ) ; crossPoints [ 0 ] = addPoint ( circle1 . center , getPolar ( circle1 . r , t + a ) ) ; crossPoints [ 1 ] = addPoint ( circle1 . center , getPolar ( circle1 . r , t - a ) ) ; } return crossPoints ; } function getTangentsFromPoint ( circle , point ) { var base = subtractPoint ( point , circle . center ) ; var baseLength = getVectorLength2D ( base ) ; var radian = Math . acos ( circle . r / baseLength ) ; var vec1 = getDivideVector ( base , baseLength ) ; vec1 = multiplyVector ( vec1 , circle . r ) ; var points = [ ] ; points [ 0 ] = addPoint ( circle . center , getRotateVectorFromRad ( vec1 , radian ) ) ; points [ 1 ] = addPoint ( circle . center , getRotateVectorFromRad ( vec1 , - radian ) ) ; return points ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var points = [ ] Arr . forEach ( function ( v ) { var nums = v . split ( \" , \" ) . map ( Number ) ; points [ 0 ] = new Point2D ( nums [ 0 ] , nums [ 1 ] ) ; points [ 1 ] = new Point2D ( nums [ 2 ] , nums [ 3 ] ) ; points [ 2 ] = new Point2D ( nums [ 4 ] , nums [ 5 ] ) ; points [ 3 ] = new Point2D ( nums [ 6 ] , nums [ 7 ] ) ; ans = \" NO \" points = getConvexHoll ( points ) ; if ( points . length > 3 ) { ans = \" YES \" ; } console . log ( ans ) } ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( y , x ) { var AG = \" ABCDEFG \" . split ( \" \" ) ; for ( var i = 0 ; i < 7 ; i ++ ) { var dx , dy ; if ( i == 0 ) { dx = [ 0 , 1 , 0 , 1 ] ; dy = [ 0 , 0 , 1 , 1 ] ; } else if ( i == 1 ) { dx = [ 0 , 0 , 0 , 0 ] ; dy = [ 0 , 1 , 2 , 3 ] ; } else if ( i == 2 ) { dx = [ 0 , 1 , 2 , 3 ] ; dy = [ 0 , 0 , 0 , 0 ] ; } else if ( i == 3 ) { dx = [ 1 , 0 , 1 , 0 ] ; dy = [ 0 , 1 , 1 , 2 ] ; } else if ( i == 4 ) { dx = [ 0 , 1 , 1 , 2 ] ; dy = [ 0 , 0 , 1 , 1 ] ; } else if ( i == 5 ) { dx = [ 0 , 0 , 1 , 1 ] ; dy = [ 0 , 1 , 1 , 2 ] ; } else if ( i == 6 ) { dx = [ 1 , 2 , 0 , 1 ] ; dy = [ 0 , 0 , 1 , 1 ] ; } var cnt = 0 ; for ( var j = 0 ; j < 4 ; j ++ ) { var yy = y + dy [ j ] ; var xx = x + dx [ j ] ; if ( yy < 0 || yy >= 8 || xx < 0 || xx >= 8 ) break ; if ( yx [ yy ] [ xx ] == \" 1 \" ) cnt ++ ; if ( cnt == 4 ) { console . log ( AG [ i ] ) ; return ; } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = 0 ; var yx = [ ] ; for ( var i = 0 ; i < Arr . length ; i ++ ) { yx . push ( Arr [ i ] . split ( \" \" ) ) ; n ++ ; if ( n != 8 ) continue ; for ( var y = 0 ; y < 8 ; y ++ ) { for ( var x = 0 ; x < 8 ; x ++ ) { bomb ( y , x ) ; } } yx = [ ] ; n = 0 ; i ++ ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n \\n ' ) ; for ( var j = 0 ; j < p . length ; j ++ ) { var b = p [ j ] . split ( ' \\n ' ) ; var m = [ ] ; for ( var i = 0 ; i < b . length ; i ++ ) { m . push ( b [ i ] . split ( ' ' ) . map ( Number ) ) ; } console . log ( exists ( m ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function exists ( m ) { for ( var i = 0 ; i < 8 ; i ++ ) { for ( var j = 0 ; j < 8 ; j ++ ) { if ( m [ i ] [ j ] === 1 ) { return exists_ ( m , j , i ) ; } } } } function exists_ ( m , x , y ) { if ( check ( m , x + 1 , y ) && check ( m , x , y + 1 ) && check ( m , x + 1 , y + 1 ) ) { return ' A ' ; } if ( check ( m , x , y + 1 ) && check ( m , x , y + 2 ) && check ( m , x , y + 3 ) ) { return ' B ' ; } if ( check ( m , x + 1 , y ) && check ( m , x + 2 , y ) && check ( m , x + 3 , y ) ) { return ' C ' ; } if ( check ( m , x , y + 1 ) && check ( m , x - 1 , y + 1 ) && check ( m , x - 1 , y + 2 ) ) { return ' D ' ; } if ( check ( m , x + 1 , y ) && check ( m , x + 1 , y + 1 ) && check ( m , x + 2 , y + 1 ) ) { return ' E ' ; } if ( check ( m , x , y + 1 ) && check ( m , x + 1 , y + 1 ) && check ( m , x + 1 , y + 2 ) ) { return ' F ' ; } if ( check ( m , x + 1 , y ) && check ( m , x , y + 1 ) && check ( m , x - 1 , y + 1 ) ) { return ' G ' ; } } function check ( m , x , y ) { if ( x < 0 || x > 7 || y < 0 || y > 7 ) { return false ; } return m [ y ] [ x ] === 1 ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n \\n ' ) . map ( function ( i ) { l = / 1.*1 / . exec ( i . replace ( / \\s / g , ' ' ) ) [ 0 ] . length ; console . log ( l == 10 ? ' A ' : l == 25 ? ' B ' : l == 4 ? ' C ' : l == 16 ? ' D ' : l == 11 ? ' E ' : l == 9 ? ' G ' : ' F ' ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n \\n ' ) . map ( function ( i ) { l = / 1.*1 / . exec ( i . replace ( / \\s / g , ' ' ) ) [ 0 ] . length % 10 ; console . log ( l ? l == 5 ? ' B ' : l == 4 ? ' C ' : l == 6 ? ' D ' : l == 1 ? ' E ' : l == 9 ? ' G ' : ' F ' : ' A ' ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n \\n ' ) . map ( function ( i ) { l = / 1(\\d|\\n)*1 / m . exec ( i ) [ 0 ] . length % 11 ; console . log ( l ? l == 6 ? ' B ' : l == 4 ? ' C ' : l == 7 ? ' D ' : l == 1 ? ' E ' : l == 9 ? ' F ' : ' G ' : ' A ' ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n \\n ' ) . map ( function ( i ) { console . log ( ' AE..C.BD.FG ' [ / 1(\\d|\\n)*1 / m . exec ( i ) [ 0 ] . length % 11 ] ) } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n \\n ' ) . map ( function ( i ) { console . log ( ' AE..C.BD.FG ' [ / 1[01\\n]*1 / . exec ( i ) [ 0 ] . length % 11 ] ) } )",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var _HEIGHT = 8 ; var input_string = ' ' ; process . stdin . on ( ' data ' , function ( chunk ) { input_string += chunk . toString ( ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { var lines = input_string . split ( ' \\n ' ) ; lines = lines . filter ( function ( val ) { return val !== ' ' ; } ) ; while ( lines . length >= _HEIGHT ) { judge ( lines . splice ( 0 , _HEIGHT ) ) ; } } ) ; function judge ( ary ) { tmpAry = ary . filter ( function ( val ) { return val . indexOf ( ' 1 ' ) >= 0 ; } ) ; compShape ( tmpAry ) ; } function compShape ( ary ) { switch ( ary . length ) { case 1 : console . log ( ' C ' ) break ; case 2 : case2 ( ary ) ; break ; case 3 : case3 ( ary ) ; break ; case 4 : console . log ( ' B ' ) break ; default : console . log ( ' Error ' ) ; } } function case2 ( ary ) { ind0 = ary [ 0 ] . indexOf ( ' 1 ' ) ; ind1 = ary [ 1 ] . indexOf ( ' 1 ' ) ; if ( ind0 < ind1 ) { console . log ( ' E ' ) ; } else if ( ind0 > ind1 ) { console . log ( ' G ' ) ; } else { console . log ( ' A ' ) ; } } function case3 ( ary ) { ind0 = ary [ 0 ] . indexOf ( ' 1 ' ) ; ind1 = ary [ 1 ] . indexOf ( ' 1 ' ) ; if ( ind0 > ind1 ) { console . log ( ' D ' ) ; } else { console . log ( ' F ' ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var board = [ ] ; board . push ( line . split ( ' ' ) . map ( function ( f ) { return + f ; } ) ) ; for ( var i = 0 ; i < 7 ; i ++ ) { board . push ( lines . shift ( ) . split ( ' ' ) . map ( function ( f ) { return + f ; } ) ) ; } if ( lines . length > 0 ) lines . shift ( ) ; for ( var y = 0 ; y < 8 ; y ++ ) { for ( var x = 0 ; x < 8 ; x ++ ) { if ( board [ y ] [ x ] ) break ; } if ( board [ y ] [ x ] ) break ; } var fig ; if ( board [ y ] [ x + 1 ] & board [ ( y + 1 ) % 8 ] [ x ] & board [ ( y + 1 ) % 8 ] [ x + 1 ] ) fig = ' A ' ; else if ( board [ ( y + 1 ) % 8 ] [ x ] & board [ ( y + 2 ) % 8 ] [ x ] & board [ ( y + 3 ) % 8 ] [ x ] ) fig = ' B ' ; else if ( board [ y ] [ x + 1 ] & board [ y ] [ x + 2 ] & board [ y ] [ x + 3 ] ) fig = ' C ' ; else if ( board [ ( y + 1 ) % 8 ] [ x - 1 ] & board [ ( y + 1 ) % 8 ] [ x ] & board [ ( y + 2 ) % 8 ] [ x - 1 ] ) fig = ' D ' ; else if ( board [ y ] [ x + 1 ] & board [ ( y + 1 ) % 8 ] [ x + 1 ] & board [ ( y + 1 ) % 8 ] [ x + 2 ] ) fig = ' E ' ; else if ( board [ ( y + 1 ) % 8 ] [ x ] & board [ ( y + 1 ) % 8 ] [ x + 1 ] & board [ ( y + 2 ) % 8 ] [ x + 1 ] ) fig = ' F ' ; else fig = ' G ' ; console . log ( fig ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; const figureNames = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' , ' G ' ] const figureIndices = [ [ [ 1 , 0 ] , [ 0 , 1 ] , [ 1 , 1 ] ] , [ [ 0 , 1 ] , [ 0 , 2 ] , [ 0 , 3 ] ] , [ [ 1 , 0 ] , [ 2 , 0 ] , [ 3 , 0 ] ] , [ [ - 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 2 ] ] , [ [ 1 , 0 ] , [ 1 , 1 ] , [ 2 , 1 ] ] , [ [ 0 , 1 ] , [ 1 , 1 ] , [ 1 , 2 ] ] , [ [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] ] ] function distinguishFigure ( plane ) { const rows = plane . split ( ' \\n ' ) for ( let i = 0 , l = rows . length ; i < l ; i ++ ) { for ( let j = 0 , m = rows [ i ] . length ; j < m ; j ++ ) { if ( rows [ i ] [ j ] === ' 1 ' ) { for ( let k = 0 , n = figureIndices . length ; k < n ; k ++ ) { let figureIndex = figureIndices [ k ] let isFound = true for ( let index of figureIndex ) { let right = index [ 0 ] let down = index [ 1 ] if ( ! ( ( j + right ) < m && ( j + right ) >= 0 && ( i + down ) < l ) || rows [ i + down ] [ j + right ] === ' 0 ' ) { isFound = false break } } if ( isFound ) return figureNames [ k ] } } } } } const fs = require ( ' fs ' ) const length = fs . fstatSync ( process . stdin . fd ) . size const buffer = Buffer . alloc ( length ) const bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) const input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) let result = ' ' for ( let plane of input . split ( ' \\n \\n ' ) ) { result += ` ${ distinguishFigure ( plane ) } \\n ` } console . log ( result . slice ( 0 , - 1 ) )",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var m = [ ] ; for ( var i = 0 ; i < p . length ; i ++ ) { m . push ( p [ i ] . split ( ' ' ) . map ( Number ) ) } console . log ( ' R ' + move ( m , 0 , 0 , ' R ' ) ) ; } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function move ( m , x , y , d ) { if ( x === 0 && y === 0 && d === ' L ' ) { return ' ' ; } if ( d === ' R ' ) { if ( mm ( m , x + 1 , y - 1 ) ) { return ' U ' + move ( m , x + 1 , y - 1 , ' U ' ) ; } if ( mm ( m , x + 1 , y ) ) { return ' R ' + move ( m , x + 1 , y , ' R ' ) ; } if ( mm ( m , x + 1 , y + 1 ) ) { return ' D ' + move ( m , x + 1 , y + 1 , ' D ' ) ; } return ' L ' + move ( m , x , y , ' L ' ) ; } if ( d === ' L ' ) { if ( mm ( m , x , y + 1 ) ) { return ' D ' + move ( m , x , y + 1 , ' D ' ) ; } if ( mm ( m , x - 1 , y ) ) { return ' L ' + move ( m , x - 1 , y , ' L ' ) ; } if ( mm ( m , x , y - 1 ) ) { return ' U ' + move ( m , x , y - 1 , ' U ' ) ; } return ' R ' + move ( m , x , y , ' R ' ) ; } if ( d === ' D ' ) { if ( mm ( m , x , y + 1 ) ) { return ' R ' + move ( m , x , y + 1 , ' R ' ) ; } if ( mm ( m , x , y + 2 ) ) { return ' D ' + move ( m , x , y + 2 , ' D ' ) ; } if ( mm ( m , x - 1 , y + 1 ) ) { return ' L ' + move ( m , x - 1 , y + 1 , ' L ' ) ; } return ' U ' + move ( m , x , y , ' U ' ) ; } if ( d === ' U ' ) { if ( mm ( m , x - 1 , y - 1 ) ) { return ' L ' + move ( m , x - 1 , y - 1 , ' L ' ) ; } if ( mm ( m , x , y - 2 ) ) { return ' U ' + move ( m , x , y - 2 , ' U ' ) ; } if ( mm ( m , x , y - 1 ) ) { return ' R ' + move ( m , x , y - 1 , ' R ' ) ; } return ' D ' + move ( m , x , y , ' D ' ) ; } } function mm ( m , x , y ) { if ( y < 0 || y >= m . length ) { return 0 ; } if ( x < 0 || x >= m [ y ] . length ) { return 0 ; } return m [ y ] [ x ] === 1 ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var x = y = 0 ; var d = ' R ' ; var route = ' ' ; while ( true ) { var dy = y * 2 + 1 ; var uy = y * 2 - 1 ; var ny = y * 2 ; var lx = x - 1 ; var rx = x + 1 ; var nx = x ; switch ( d ) { case ' L ' : if ( dy < input . length && + input [ dy ] [ nx ] ) { d = ' D ' ; y ++ ; } else if ( + input [ ny ] [ lx ] ) { d = ' L ' ; x -- ; } else if ( uy > 0 && + input [ uy ] [ nx ] ) { d = ' U ' ; y -- ; } else { d = ' R ' ; x ++ ; } break ; case ' R ' : if ( uy > 0 && + input [ uy ] [ nx ] ) { d = ' U ' ; y -- ; } else if ( + input [ ny ] [ nx ] ) { d = ' R ' ; x ++ ; } else if ( dy < input . length && + input [ dy ] [ nx ] ) { d = ' D ' ; y ++ ; } else { d = ' L ' ; x -- ; } break ; case ' D ' : if ( + input [ ny ] [ nx ] ) { d = ' R ' ; x ++ ; } else if ( dy < input . length && + input [ dy ] [ nx ] ) { d = ' D ' ; y ++ ; } else if ( + input [ ny ] [ lx ] ) { d = ' L ' ; x -- ; } else { d = ' U ' ; y -- ; } break ; case ' U ' : if ( + input [ ny ] [ lx ] ) { d = ' L ' ; x -- ; } else if ( uy > 0 && + input [ uy ] [ nx ] ) { d = ' U ' ; y -- ; } else if ( + input [ ny ] [ nx ] ) { d = ' R ' ; x ++ ; } else { d = ' D ' ; y ++ ; } break ; default : return ; } route += d ; if ( ! x && ! y ) break ; } console . log ( route ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var I = 0 ; I < Arr . length ; I ++ ) { var a = Arr [ I ] . split ( \" , \" ) . map ( Number ) ; var arr = [ ] ; for ( var i = 0 ; i < 13 ; i ++ ) arr [ i ] = 0 ; a . forEach ( function ( v ) { arr [ v - 1 ] ++ ; } ) ; var copy = arr . slice ( ) ; arr . sort ( function ( a , b ) { return b - a ; } ) ; var ans ; if ( arr [ 0 ] >= 4 ) ans = \" four card \" ; else if ( arr [ 0 ] == 3 && arr [ 1 ] == 2 ) ans = \" full house \" ; else if ( ( copy . join ( \" \" ) ) . match ( / 11111|1000000001111 / ) ) ans = \" straight \" ; else if ( arr [ 0 ] == 3 ) ans = \" three card \" ; else if ( arr [ 0 ] == 2 && arr [ 1 ] == 2 ) ans = \" two pair \" ; else if ( arr [ 0 ] == 2 ) ans = \" one pair \" ; else ans = \" null \" ; console . log ( ans ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = p . length ; for ( var i = 0 ; i < n ; i ++ ) { var a = p . shift ( ) . split ( ' , ' ) . map ( Number ) ; var r = { } ; for ( var j = 0 ; j < a . length ; j ++ ) { if ( a [ j ] in r ) { r [ a [ j ] ] ++ ; } else { r [ a [ j ] ] = 1 ; } } var c = [ ] ; for ( var k in r ) { if ( r [ k ] in c ) { c [ r [ k ] ] . push ( k ) ; } else { c [ r [ k ] ] = [ k ] ; } } console . log ( check ( c ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function check ( c ) { if ( c [ 4 ] ) { return ' four card ' ; } if ( c [ 3 ] && c [ 2 ] ) { return ' full house ' ; } if ( c [ 1 ] && c [ 1 ] . length === 5 ) { var a = c [ 1 ] ; a = a . map ( Number ) . sort ( function ( a , b ) { return a - b ; } ) ; if ( a [ 0 ] > 9 ) { return ' null ' ; } if ( a [ 1 ] === 10 ) { return ' straight ' ; } if ( a [ 1 ] === a [ 0 ] + 1 && a [ 2 ] === a [ 1 ] + 1 && a [ 3 ] === a [ 2 ] + 1 && a [ 4 ] === a [ 3 ] + 1 ) { return ' straight ' ; } } if ( c [ 3 ] ) { return ' three card ' ; } if ( c [ 2 ] && c [ 2 ] . length === 2 ) { return ' two pair ' ; } if ( c [ 2 ] ) { return ' one pair ' ; } return ' null ' ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var c = input [ i ] . trim ( ) . split ( ' , ' ) . sort ( function ( a , b ) { return b - a ; } ) . map ( Number ) ; var result = \" null \" ; if ( ( c [ 0 ] == c [ 1 ] && c [ 1 ] == c [ 2 ] && c [ 2 ] == c [ 3 ] ) || ( c [ 1 ] == c [ 2 ] && c [ 2 ] == c [ 3 ] && c [ 3 ] == c [ 4 ] ) ) { result = \" four card \" ; } else if ( c [ 0 ] == c [ 1 ] && c [ 1 ] == c [ 2 ] && c [ 3 ] == c [ 4 ] || c [ 0 ] == c [ 1 ] && c [ 2 ] == c [ 3 ] && c [ 3 ] == c [ 4 ] ) { result = \" full house \" ; } else if ( c [ 0 ] == c [ 1 ] + 1 && c [ 1 ] == c [ 2 ] + 1 && c [ 2 ] == c [ 3 ] + 1 && ( ( c [ 0 ] == 13 && c [ 4 ] == 1 ) || ( c [ 3 ] == c [ 4 ] + 1 ) ) ) { result = \" straight \" ; } else if ( ( c [ 0 ] == c [ 1 ] && c [ 1 ] == c [ 2 ] ) || ( c [ 1 ] == c [ 2 ] && c [ 2 ] == c [ 3 ] ) || ( c [ 2 ] == c [ 3 ] && c [ 3 ] == c [ 4 ] ) ) { result = \" three card \" ; } else if ( ( c [ 0 ] == c [ 1 ] && ( c [ 2 ] == c [ 3 ] || c [ 3 ] == c [ 4 ] ) ) || ( c [ 1 ] == c [ 2 ] && c [ 3 ] == c [ 4 ] ) ) { result = \" two pair \" ; } else if ( c [ 0 ] == c [ 1 ] || c [ 1 ] == c [ 2 ] || c [ 2 ] == c [ 3 ] || c [ 3 ] == c [ 4 ] ) { result = \" one pair \" ; } console . log ( result ) ; } }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { f = function ( a , b ) { return b - a } ; a = [ ] , c = i . split ( \" , \" ) . sort ( f ) ; c . map ( function ( j ) { a [ j ] ? a [ j ] ++ : a [ j ] = 1 } ) ; a . sort ( f ) ; l = a [ 0 ] , n = a [ 1 ] ; console . log ( l == 4 ? \" four card \" : l == 3 ? ( n == 2 ? \" full house \" : \" three card \" ) : l == 2 ? ( n == 2 ? \" two pair \" : \" one pair \" ) : 4 == c [ 0 ] - c [ 4 ] || ( c [ 0 ] - c [ 3 ] == 3 && + c [ 4 ] == 1 ) ? \" straight \" : \" null \" ) } )",
    "label": 2
  },
  {
    "code": "var abc = \" abcdefghijklmnopqrstuvwxyz \" . split ( \" \" ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var I = 0 ; I < n ; I ++ ) { var str = Arr [ I ] ; [ 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ] . forEach ( function ( A ) { for ( var B = 0 ; B < 26 ; B ++ ) { var STR = \" \" ; for ( var i = 0 ; i < str . length ; i ++ ) { var index = abc . indexOf ( str [ i ] ) ; STR += ( index != - 1 ) ? abc [ ( A * ( index + B ) ) % 26 ] : \" \" ; } if ( STR . match ( / this|that / ) ) return console . log ( STR ) ; } } ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var p = input . replace ( / \\n$ / , ' ' ) . split ( ' \\n ' ) ; var n = Number ( p . shift ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { console . log ( conv ( p . shift ( ) ) ) ; } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ; function conv ( s ) { a = s . split ( ' ' ) ; for ( var i = 0 ; i < a . length ; i ++ ) { var r = check ( a [ i ] ) ; if ( r ) { return conv_ ( s , r ) ; } } return s ; } function conv_ ( s , r ) { var a = r [ 0 ] ; var b = r [ 1 ] ; var s = s . split ( ' ' ) . map ( function ( e ) { if ( e === ' ' ) { return e ; } return String . fromCharCode ( ( a * e . charCodeAt ( 0 ) + b ) % 26 + ' a ' . charCodeAt ( 0 ) ) ; } ) . join ( ' ' ) ; return s ; } function check ( str ) { if ( str . length !== 4 ) { return false ; } for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) { var s = conv_ ( str , [ i , j ] ) ; if ( s === ' this ' || s === ' that ' ) { return [ i , j ] ; } } } return false ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { for ( t = 26 ; t -- ; ) for ( s = 26 ; s -- ; ) r = i . replace ( / [\\w] / g , function ( j ) { return String . fromCharCode ( ( j . charCodeAt ( 0 ) * t + s ) % 26 + 97 ) } ) , r . match ( / th(is|at) / ) ? console . log ( r ) : 0 } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { for ( t = 1 ; t < 26 ; t += 2 ) for ( s = 26 ; s -- ; ) r = i . replace ( / [\\w] / g , function ( j ) { return String . fromCharCode ( ( j . charCodeAt ( 0 ) * t + s ) % 26 + 97 ) } ) , r . match ( / th(is|at) / ) ? console . log ( r ) : 0 } )",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var multiply = new Int8Array ( [ 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ] ) ; FIRST : for ( var i = 1 , len = + input [ 0 ] ; i <= len ; i ++ ) { var inp = input [ i ] ; for ( var j = 0 , lenj = multiply . length ; j < lenj ; j ++ ) { var alpha = multiply [ j ] ; for ( var beta = 26 ; beta -- ; ) { var alphabets = new Int8Array ( 26 ) ; for ( var conv = 26 ; conv -- ; ) { alphabets [ conv ] = ( conv * alpha + beta ) % 26 + 97 ; } var thChar = String . fromCharCode ( alphabets [ 19 ] , alphabets [ 7 ] ) ; var atChar = String . fromCharCode ( alphabets [ 0 ] , alphabets [ 19 ] ) ; var isChar = String . fromCharCode ( alphabets [ 8 ] , alphabets [ 18 ] ) ; if ( new RegExp ( thChar + \" ( \" + atChar + \" | \" + isChar + \" ) \" ) . test ( inp ) ) { console . log ( inp . replace ( / [a-z] / g , function ( a ) { for ( var b = 26 , c = a . charCodeAt ( 0 ) ; b -- ; ) if ( c == alphabets [ b ] ) { return String . fromCharCode ( b + 97 ) } } ) ) ; continue FIRST ; } } } } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' hex ' , 0 , bytesRead ) . split ( ' 0a ' ) ; main ( ) ; function main ( ) { var multiply = new Int8Array ( [ 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ] ) ; var alphabets = new Int8Array ( 26 ) ; var convertTable = new Int8Array ( 123 ) ; for ( var init = 123 ; init -- ; ) convertTable [ init ] = init ; FIRST : for ( var i = 1 , leni = input . length - 1 ; i < leni ; i ++ ) { var inp = input [ i ] ; var c = inp . split ( ' 20 ' ) ; for ( var j = 0 , lenj = multiply . length ; j < lenj ; j ++ ) { var alpha = multiply [ j ] ; for ( var beta = 26 ; beta -- ; ) { for ( var conv = 26 ; conv -- ; ) { alphabets [ conv ] = ( conv * alpha + beta ) % 26 + 97 ; } var thatIs = alphabets [ 19 ] . toString ( 16 ) + alphabets [ 7 ] . toString ( 16 ) + alphabets [ 0 ] . toString ( 16 ) + alphabets [ 19 ] . toString ( 16 ) ; var thisIs = alphabets [ 19 ] . toString ( 16 ) + alphabets [ 7 ] . toString ( 16 ) + alphabets [ 8 ] . toString ( 16 ) + alphabets [ 18 ] . toString ( 16 ) ; if ( new RegExp ( \" ( \" + thatIs + \" | \" + thisIs + \" ) \" ) . test ( inp ) ) { for ( var conv = 26 ; conv -- ; ) { var fromCode = alphabets [ conv ] ; convertTable [ fromCode ] = conv + 97 ; } var result = \" \" ; for ( var k = 0 ; k < inp . length ; k += 2 ) { result += String . fromCharCode ( convertTable [ parseInt ( inp [ k ] + inp [ k + 1 ] , 16 ) ] ) ; } console . log ( result ) ; continue FIRST ; } } } } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' hex ' , 0 , bytesRead ) . split ( ' 0a ' ) ; main ( ) ; function main ( ) { var multiply = new Int8Array ( [ 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ] ) ; var lenj = multiply . length ; var alphabets = new Int8Array ( 26 ) ; var convertTable = new Int8Array ( 123 ) ; for ( var init = 123 ; init -- ; ) convertTable [ init ] = init ; FIRST : for ( var i = 1 , leni = input . length - 1 ; i < leni ; i ++ ) { var inp = input [ i ] ; var c = inp . split ( ' 20 ' ) ; var clen = c . length ; for ( var j = 0 ; j < lenj ; j ++ ) { var alpha = multiply [ j ] ; for ( var beta = 26 ; beta -- ; ) { for ( var conv = 26 ; conv -- ; ) { alphabets [ conv ] = ( conv * alpha + beta ) % 26 + 97 ; } var thatIs = alphabets [ 19 ] . toString ( 16 ) + alphabets [ 7 ] . toString ( 16 ) + alphabets [ 0 ] . toString ( 16 ) + alphabets [ 19 ] . toString ( 16 ) ; var thisIs = alphabets [ 19 ] . toString ( 16 ) + alphabets [ 7 ] . toString ( 16 ) + alphabets [ 8 ] . toString ( 16 ) + alphabets [ 18 ] . toString ( 16 ) ; var found = false ; for ( var d = clen ; d -- ; ) { var cd = c [ d ] ; if ( cd == thatIs || cd == thisIs ) { found = true ; break ; } } if ( found ) { for ( var conv = 26 ; conv -- ; ) { var fromCode = alphabets [ conv ] ; convertTable [ fromCode ] = conv + 97 ; } var result = \" \" ; for ( var k = 0 ; k < inp . length ; k += 2 ) { result += String . fromCharCode ( convertTable [ parseInt ( inp [ k ] + inp [ k + 1 ] , 16 ) ] ) ; } console . log ( result ) ; continue FIRST ; } } } } }",
    "label": 2
  },
  {
    "code": "var print = console . log ; var input_lines ; function PreMain ( input ) { input_lines = input . split ( \" \\n \" ) ; var f = function ( ) { return input_lines . shift ( ) ; } ; Main ( f ) ; } function IL ( min1Flg ) { var s = input_lines . shift ( ) . split ( ' ' ) ; var offset = min1Flg ? - 1 : 0 ; var res = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { res . push ( parseInt ( s [ i ] ) ) ; } return res ; } Array . prototype . SUM = function SUM ( ) { var sum = 0 ; this . forEach ( function ( elm ) { sum += elm ; } ) ; return sum ; } ; Array . prototype . Format = function Format ( split ) { if ( split === undefined ) { split = \" \" ; } return this . join ( split ) ; } ; Array . prototype . Copy = function Copy ( ) { return [ ] . concat ( this ) ; } ; Array . prototype . Sort = function Sort ( ) { this . sort ( function ( a , b ) { if ( a < b ) return - 1 ; if ( a > b ) return 1 ; return 0 ; } ) ; } ; function prime_numbers ( n ) { var tbl = [ - 1 , - 1 ] ; for ( var i = 2 ; i <= n ; i ++ ) { tbl . push ( 0 ) } for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( tbl [ i ] === 0 ) { for ( var j = i * 2 ; j <= n ; j += i ) { tbl [ j ] = - 1 ; } } } var res = [ ] ; tbl . forEach ( function ( t , number ) { if ( t === 0 ) { res . push ( number ) ; } } ) ; return res ; } function range ( i , n ) { var res = [ ] ; for ( ; i < n ; i ++ ) { res . push ( i ) ; } return res ; } function get_a_pat ( ) { var pat = { } ; range ( 1 , 26 ) . forEach ( function ( a ) { if ( a % 2 === 0 || a % 13 === 0 ) { return ; } var acode = ' a ' . charCodeAt ( 0 ) ; for ( var b = 0 ; b < 26 ; b ++ ) { var tmp = ' ' ; var tmp2 = ' ' ; for ( var i = 0 ; i < 4 ; i ++ ) { var x = ' this ' . charCodeAt ( i ) - acode ; tmp += String . fromCharCode ( ( ( a * x + b ) % 26 ) + acode ) ; var y = ' that ' . charCodeAt ( i ) - acode ; tmp2 += String . fromCharCode ( ( ( a * y + b ) % 26 ) + acode ) ; } if ( pat . hasOwnProperty ( tmp ) ) { print ( tmp ) ; } if ( pat . hasOwnProperty ( tmp2 ) ) { print ( tmp2 ) ; } pat [ tmp ] = [ a , b ] ; pat [ tmp2 ] = [ a , b ] ; } } ) ; return pat ; } function get_foo ( a , b , str ) { var acode = ' a ' . charCodeAt ( 0 ) ; var tmp = ' ' ; for ( var i = 0 ; i < 26 ; i ++ ) { tmp += String . fromCharCode ( ( ( a * i + b ) % 26 ) + acode ) ; } var res = ' ' ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) === ' ' ) { res += ' ' ; } else { res += String . fromCharCode ( tmp . indexOf ( str . charAt ( i ) ) + acode ) ; } } return res ; } function Main ( input ) { var n = parseInt ( input ( ) ) ; var p = get_a_pat ( ) ; var key ; for ( var j = 0 ; j < n ; j ++ ) { var str_org = input ( ) ; var str = str_org . split ( ' ' ) ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( p . hasOwnProperty ( str [ i ] ) ) { key = p [ str [ i ] ] ; break ; } } print ( get_foo ( key [ 0 ] , key [ 1 ] , str_org ) ) ; } } PreMain ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var print = console . log ; var input_lines ; function PreMain ( input ) { input_lines = input . split ( \" \\n \" ) ; var f = function ( ) { return input_lines . shift ( ) ; } ; Main ( f ) ; } function IL ( min1Flg ) { var s = input_lines . shift ( ) . split ( ' ' ) ; var offset = min1Flg ? - 1 : 0 ; var res = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { res . push ( parseInt ( s [ i ] ) ) ; } return res ; } Array . prototype . SUM = function SUM ( ) { var sum = 0 ; this . forEach ( function ( elm ) { sum += elm ; } ) ; return sum ; } ; Array . prototype . Format = function Format ( split ) { if ( split === undefined ) { split = \" \" ; } return this . join ( split ) ; } ; Array . prototype . Copy = function Copy ( ) { return [ ] . concat ( this ) ; } ; Array . prototype . Sort = function Sort ( ) { this . sort ( function ( a , b ) { if ( a < b ) return - 1 ; if ( a > b ) return 1 ; return 0 ; } ) ; } ; function range ( i , n ) { var res = [ ] ; for ( ; i < n ; i ++ ) { res . push ( i ) ; } return res ; } function get_pattern ( ) { var pat = { } ; range ( 1 , 26 ) . forEach ( function ( a ) { if ( a % 2 === 0 || a % 13 === 0 ) { return ; } var acode = ' a ' . charCodeAt ( 0 ) ; for ( var b = 0 ; b < 26 ; b ++ ) { var converted_alphabet = ' ' ; for ( var c = 0 ; c < 26 ; c ++ ) { converted_alphabet += String . fromCharCode ( ( ( a * c + b ) % 26 ) + acode ) ; } var tmp = ' ' ; var tmp2 = ' ' ; for ( var i = 0 ; i < 4 ; i ++ ) { var x = ' this ' . charCodeAt ( i ) - acode ; tmp += converted_alphabet . charAt ( x ) ; var y = ' that ' . charCodeAt ( i ) - acode ; tmp2 += converted_alphabet . charAt ( y ) ; } pat [ tmp ] = converted_alphabet ; pat [ tmp2 ] = converted_alphabet ; } } ) ; return pat ; } function get_foo ( str , str2 ) { var acode = ' a ' . charCodeAt ( 0 ) ; var res = ' ' ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) === ' ' ) { res += ' ' ; } else { res += String . fromCharCode ( str2 . indexOf ( str . charAt ( i ) ) + acode ) ; } } return res ; } function Main ( input ) { var n = parseInt ( input ( ) ) ; var p = get_pattern ( ) ; var str2 ; for ( var j = 0 ; j < n ; j ++ ) { var str_org = input ( ) ; var str = str_org . split ( ' ' ) ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( p . hasOwnProperty ( str [ i ] ) ) { str2 = p [ str [ i ] ] ; break ; } } print ( get_foo ( str_org , str2 ) ) ; } } PreMain ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var result = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) result . push ( arr [ i ] ) ; } return result ; } var p = prime ( 999999 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var a = Arr [ i ] ; for ( var j = 0 ; j < p . length ; j ++ ) { if ( p [ j ] == a ) { console . log ( p [ j - 1 ] + \" \" + p [ j + 1 ] ) ; break ; } if ( p [ j ] > a ) { console . log ( p [ j - 1 ] + \" \" + p [ j ] ) ; break ; } } }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { var inp = input [ i ] - 0 ; var min = max = 0 ; for ( var j = 0 , jlen = primeNumbers . length ; j < jlen ; j ++ ) { var nowPrimeNumber = primeNumbers [ j ] ; var nextPrimeNumber = primeNumbers [ j + 1 ] ; if ( nowPrimeNumber < inp && nextPrimeNumber >= inp ) { min = nowPrimeNumber ; } if ( nowPrimeNumber <= inp && nextPrimeNumber > inp ) { max = nextPrimeNumber ; break ; } } console . log ( min , max ) ; } } function calcPrimeNumbers ( ) { var max = 50023 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( 5135 ) ; var j = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( ! primeNumbers [ i ] ) primeNums [ j ++ ] = i ; } return primeNums ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var i , j , flag , primes = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 ] ; for ( i = 19 ; i < 80000 ; i += 2 ) { flag = true ; for ( j = 0 ; primes [ j ] < i * i ; j ++ ) { if ( i % primes [ j ] == 0 ) { flag = false ; break ; } } if ( flag ) { primes . push ( i ) ; } } input . forEach ( function ( line ) { if ( line . trim ( ) === ' ' ) return ; var i , n = parseInt ( line , 10 ) ; for ( i = 0 ; n > primes [ i ] ; i ++ ) ; console . log ( ' %d %d ' , primes [ i - 1 ] , primes [ i ] === n ? primes [ i + 1 ] : primes [ i ] ) ; } ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function sl ( n ) { if ( n % 2 === 0 ) { return 2 ; } for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i === 0 ) { return i ; } } return n ; } var a = [ 2 , 3 ] ; for ( var i = 1 , l = 50024 ; i * 6 + 1 < l ; i ++ ) { var o = i * 6 - 1 , p = i * 6 + 1 ; sl ( o ) === o && a . push ( o ) ; sl ( p ) === p && a . push ( p ) ; } var l = a . length ; process . stdin . on ( \" data \" , function ( c ) { ( c + \" \" ) . trim ( ) . split ( \" \\n \" ) . some ( function ( n ) { n = + n ; for ( var i = 0 ; i < l ; i ++ ) { if ( n < a [ i ] ) { console . log ( ( a [ i - 1 ] === n ? a [ i - 2 ] : a [ i - 1 ] ) , a [ i ] ) ; break ; } } } ) ; } ) . resume ( ) ;",
    "label": 2
  },
  {
    "code": "function isPrime ( num ) { if ( num == 2 || num == 3 ) return true ; if ( num < 2 || num % 2 == 0 || num % 3 == 0 ) return false ; var limit = Math . round ( Math . sqrt ( num ) ) ; var i = 1 ; while ( i * 6 - 1 <= limit ) { if ( num % ( i * 6 - 1 ) == 0 || num % ( i * 6 + 1 ) == 0 ) return false ; i ++ ; } return true ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var num = + line ; var mp ; var lp ; if ( num == 3 ) mp = 2 ; var i = 3 ; while ( true ) { if ( isPrime ( i ) && i < num ) { mp = i ; } if ( isPrime ( i ) && i > num ) { lp = i ; break ; } i += 2 ; } console . log ( mp , lp ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var sum = 0 ; var cnt = 0 ; Arr . forEach ( function ( v ) { var arr = v . split ( \" , \" ) . map ( Number ) ; sum += arr [ 0 ] * arr [ 1 ] ; cnt += arr [ 1 ] ; } ) ; console . log ( sum ) ; console . log ( Math . round ( cnt / Arr . length ) ) ;",
    "label": 2
  },
  {
    "code": "t = s = a = 0 , require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { c = i . split ( ' , ' ) , t += c [ 0 ] * c [ 1 ] , s += + c [ 1 ] , a ++ } ) , console . log ( t + ' \\n ' + ~ ~ ( s / a + 0.5 ) )",
    "label": 2
  },
  {
    "code": "t = s = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) ; for ( a = j = i . length - 1 ; j -- ; ) s += ( b = + i [ j -- ] ) , t += b * i [ j ] ; console . log ( t + ' \\n ' + ~ ~ ( s / ( a / 2 ) + 0.5 ) )",
    "label": 2
  },
  {
    "code": "t = s = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) ; for ( a = j = i . length - 1 ; j -- ; ) s += ( b = + i [ j -- ] ) , t += b * i [ j ] ; console . log ( t + ' \\n ' + ~ ~ ( s / a * 2 + 0.5 ) )",
    "label": 2
  },
  {
    "code": "j = b = t = s = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) ; for ( ; a = i [ j ++ ] , b = + i [ j ++ ] ; ) s += b , t += b * a ; console . log ( t + ' \\n ' + ~ ~ ( s / ( j - 2 ) * 2 + 0.5 ) )",
    "label": 2
  },
  {
    "code": "for ( j = b = t = s = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) ; a = i [ j ++ ] , b = + i [ j ++ ] ; ) s += b , t += b * a ; console . log ( t + ' \\n ' + ~ ~ ( s / ( j - 2 ) * 2 + 0.5 ) )",
    "label": 2
  },
  {
    "code": "function main ( ) { var n = 0 , nsum = 0 , ssum = 0 ; input . forEach ( function ( line ) { if ( line . trim ( ) === ' ' ) return ; n += 1 ; line = line . split ( ' , ' ) . map ( parseFloat ) ; nsum += line [ 1 ] ; ssum += line [ 0 ] * line [ 1 ] ; } ) ; console . log ( ssum ) ; console . log ( ( nsum / n ) . toFixed ( 0 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var nums = lines . map ( function ( line ) { return line . split ( ' , ' ) . map ( function ( n ) { return + n ; } ) ; } ) ; var sum = nums . reduce ( function ( p , n ) { return p + n [ 0 ] * n [ 1 ] ; } , 0 ) ; var qsum = nums . reduce ( function ( p , n ) { return p + n [ 1 ] ; } , 0 ) ; console . log ( sum ) ; console . log ( Math . round ( qsum / nums . length ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var abc = { A : 1 , B : 0 , C : 0 } ; Arr . forEach ( function ( v ) { var arr = v . split ( \" , \" ) ; var m = abc [ arr [ 0 ] ] ; abc [ arr [ 0 ] ] = abc [ arr [ 1 ] ] ; abc [ arr [ 1 ] ] = m ; } ) ; for ( var i in abc ) { if ( abc [ i ] == 1 ) console . log ( i ) ; }",
    "label": 2
  },
  {
    "code": "B = C = 0 , A = 1 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\n|, / ) ; for ( j = 0 ; j < i . length - 1 ; ) eval ( ' t= ' + i [ j ] + ' , ' + i [ j ++ ] + ' = ' + i [ j ] + ' , ' + i [ j ++ ] + ' =t ' ) ; console . log ( A ? ' A ' : B ? ' B ' : ' C ' ) ;",
    "label": 2
  },
  {
    "code": "for ( a = b = 1 , r = ' A ' , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\n|, / ) , j = 0 ; a = i [ j ++ ] , b = i [ j ++ ] ; ) r == a ? r = b : r == b ? r = a : 0 ; console . log ( r ) ;",
    "label": 2
  },
  {
    "code": "for ( a = b = r = ' A ' , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\n|, / ) , j = 0 ; a = i [ j ++ ] , b = i [ j ++ ] ; ) r == a ? r = b : r == b ? r = a : 0 ; console . log ( r ) ;",
    "label": 2
  },
  {
    "code": "var table = { A : 0 , B : 1 , C : 2 , 0 : ' A ' , 1 : ' B ' , 2 : ' C ' , } , cups = [ true , false , false ] ; function main ( ) { input . forEach ( function ( line ) { if ( line . trim ( ) === ' ' ) return ; line = line . split ( ' , ' ) ; swap ( cups , table [ line [ 0 ] ] , table [ line [ 1 ] ] ) ; } ) ; console . log ( table [ cups . indexOf ( true ) ] ) ; } function swap ( xs , i , j ) { var x = xs [ i ] ; xs [ i ] = xs [ j ] ; xs [ j ] = x ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var C = [ \" A \" , \" B \" , \" C \" ] ; function swap ( A , i1 , i2 ) { var tmp = A [ i1 ] ; A [ i1 ] = A [ i2 ] ; A [ i2 ] = tmp ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var cups = [ 1 , 0 , 0 ] ; var line ; while ( line = lines . shift ( ) ) { var command = line . split ( ' , ' ) ; swap ( cups , C . indexOf ( command [ 0 ] ) , C . indexOf ( command [ 1 ] ) ) ; } for ( var i = 0 ; i < cups . length ; i ++ ) { if ( cups [ i ] ) { console . log ( C [ i ] ) ; break ; } }",
    "label": 2
  },
  {
    "code": "( function ( ) { var cls , fs ; cls = function ( a ) { switch ( false ) { case ! ( a <= 48.00 ) : return ' light fly ' ; case ! ( 48.00 < a && a <= 51.00 ) : return ' fly ' ; case ! ( 51.00 < a && a <= 54.00 ) : return ' bantam ' ; case ! ( 54.00 < a && a <= 57.00 ) : return ' feather ' ; case ! ( 57.00 < a && a <= 60.00 ) : return ' light ' ; case ! ( 60.00 < a && a <= 64.00 ) : return ' light welter ' ; case ! ( 64.00 < a && a <= 69.00 ) : return ' welter ' ; case ! ( 69.00 < a && a <= 75.00 ) : return ' light middle ' ; case ! ( 75.00 < a && a <= 81.00 ) : return ' middle ' ; case ! ( 81.00 < a && a <= 91.00 ) : return ' light heavy ' ; default : return ' heavy ' ; } } ; fs = require ( ' fs ' ) ; fs . readFile ( ' /dev/stdin ' , ' utf8 ' , function ( _ , out ) { return out . split ( ' \\n ' ) . slice ( 0 , - 1 ) . map ( function ( s ) { return + s ; } ) . forEach ( function ( s ) { return console . log ( cls ( s ) ) ; } ) ; } ) ; } ) . call ( this ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; Arr . forEach ( function ( v ) { var str = \" \" ; var k = \" light fly,fly,bantam,feather,light,light welter,welter,light middle,middle,light heavy,heavy \" . split ( \" , \" ) ; if ( v <= 48 ) str = k [ 0 ] ; if ( v > 48 ) str = k [ 1 ] ; if ( v > 51 ) str = k [ 2 ] ; if ( v > 54 ) str = k [ 3 ] ; if ( v > 57 ) str = k [ 4 ] ; if ( v > 60 ) str = k [ 5 ] ; if ( v > 64 ) str = k [ 6 ] ; if ( v > 69 ) str = k [ 7 ] ; if ( v > 75 ) str = k [ 8 ] ; if ( v > 81 ) str = k [ 9 ] ; if ( v > 91 ) str = k [ 10 ] ; console . log ( str ) ; } ) ;",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) . map ( function ( i ) { ( j = + i ) ? console . log ( j <= 48 ? ' light fly ' : j <= 51 ? ' fly ' : j <= 54 ? ' bantam ' : j <= 57 ? ' feather ' : j <= 60 ? ' light ' : j <= 64 ? ' light welter ' : j <= 69 ? ' welter ' : j <= 75 ? ' light middle ' : j <= 81 ? ' middle ' : j <= 91 ? ' light heavy ' : ' heavy ' ) : 0 } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) . map ( function ( j ) { j ? console . log ( j <= 48 ? ' light fly ' : j <= 51 ? ' fly ' : j <= 54 ? ' bantam ' : j <= 57 ? ' feather ' : j <= 60 ? ' light ' : j <= 64 ? ' light welter ' : j <= 69 ? ' welter ' : j <= 75 ? ' light middle ' : j <= 81 ? ' middle ' : j <= 91 ? ' light heavy ' : ' heavy ' ) : 0 } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) . map ( function ( i ) { i ? console . log ( i > 91 ? ' heavy ' : i > 81 ? ' light heavy ' : i > 75 ? ' middle ' : i > 69 ? ' light middle ' : i > 64 ? ' welter ' : i > 60 ? ' light welter ' : i > 57 ? ' light ' : i > 54 ? ' feather ' : i > 51 ? ' bantam ' : i > 48 ? ' fly ' : ' light fly ' ) : 0 } )",
    "label": 2
  },
  {
    "code": "a = ' light ' , require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) . map ( function ( i ) { i ? console . log ( i > 91 ? ' heavy ' : i > 81 ? a + ' heavy ' : i > 75 ? ' middle ' : i > 69 ? a + ' middle ' : i > 64 ? ' welter ' : i > 60 ? a + ' welter ' : i > 57 ? ' light ' : i > 54 ? ' feather ' : i > 51 ? ' bantam ' : i > 48 ? ' fly ' : a + ' fly ' ) : 0 } )",
    "label": 2
  },
  {
    "code": "a = ' light ' , b = ' heavy ' , c = ' middle ' , d = ' welter ' , require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) . map ( function ( i ) { i ? console . log ( i > 91 ? b : i > 81 ? a + b : i > 75 ? c : i > 69 ? a + c : i > 64 ? d : i > 60 ? a + d : i > 57 ? ' light ' : i > 54 ? ' feather ' : i > 51 ? ' bantam ' : ( i > 48 ? ' ' : a ) + ' fly ' ) : 0 } )",
    "label": 2
  },
  {
    "code": "var classes = { ' light fly ' : [ - Infinity , 48.00 ] , ' fly ' : [ 48.00 , 51.00 ] , ' bantam ' : [ 51.00 , 54.00 ] , ' feather ' : [ 54.00 , 57.00 ] , ' light ' : [ 57.00 , 60.00 ] , ' light welter ' : [ 60.00 , 64.00 ] , ' welter ' : [ 64.00 , 69.00 ] , ' light middle ' : [ 69.00 , 75.00 ] , ' middle ' : [ 75.00 , 81.00 ] , ' light heavy ' : [ 81.00 , 91.00 ] , ' heavy ' : [ 91.00 , Infinity ] , } ; function main ( ) { input . forEach ( function ( line ) { var className ; if ( line . trim ( ) === ' ' ) return ; line = parseFloat ( line ) ; Object . keys ( classes ) . forEach ( function ( name ) { var range = classes [ name ] ; if ( range [ 0 ] < line && line <= range [ 1 ] ) { className = name ; } } ) ; console . log ( className ) ; } ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var w = + line ; var c ; if ( w <= 48 ) c = ' light fly ' ; else if ( w <= 51 ) c = ' fly ' ; else if ( w <= 54 ) c = ' bantam ' ; else if ( w <= 57 ) c = ' feather ' ; else if ( w <= 60 ) c = ' light ' ; else if ( w <= 64 ) c = ' light welter ' ; else if ( w <= 69 ) c = ' welter ' ; else if ( w <= 75 ) c = ' light middle ' ; else if ( w <= 81 ) c = ' middle ' ; else if ( w <= 91 ) c = ' light heavy ' ; else c = ' heavy ' ; console . log ( c ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var abo = [ 0 , 0 , 0 , 0 ] ; Arr . forEach ( function ( v ) { var arr = v . split ( \" , \" ) ; if ( arr [ 1 ] == \" A \" ) abo [ 0 ] ++ ; if ( arr [ 1 ] == \" B \" ) abo [ 1 ] ++ ; if ( arr [ 1 ] == \" AB \" ) abo [ 2 ] ++ ; if ( arr [ 1 ] == \" O \" ) abo [ 3 ] ++ ; } ) ; console . log ( abo [ 0 ] ) ; console . log ( abo [ 1 ] ) ; console . log ( abo [ 2 ] ) ; console . log ( abo [ 3 ] ) ;",
    "label": 2
  },
  {
    "code": "for ( w = x = y = z = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) , c = j = - 1 ; c = i [ j += 2 ] ; n = ' \\n ' ) c == ' A ' ? w ++ : c == ' B ' ? x ++ : c == ' O ' ? z ++ : y ++ ; console . log ( w + n + x + n + y + n + z )",
    "label": 2
  },
  {
    "code": "for ( A = B = AB = O = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) , c = j = - 1 ; c = i [ j += 2 ] ; n = ' \\n ' ) eval ( c + ' ++ ' ) ; console . log ( A + n + B + n + AB + n + O )",
    "label": 2
  },
  {
    "code": "for ( A = B = AB = O = 0 , i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) , j = - 1 ; i [ j += 2 ] ; n = ' \\n ' ) eval ( i [ j ] + ' ++ ' ) ; console . log ( A + n + B + n + AB + n + O )",
    "label": 2
  },
  {
    "code": "for ( A = B = AB = O = 0 , c = j = - 1 ; c = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s|, / ) [ j += 2 ] ; n = ' \\n ' ) eval ( c + ' ++ ' ) ; console . log ( A + n + B + n + AB + n + O )",
    "label": 2
  },
  {
    "code": "function main ( ) { var total = { A : 0 , B : 0 , AB : 0 , O : 0 , } ; input . forEach ( function ( line ) { if ( line . trim ( ) === ' ' ) return ; total [ line . split ( ' , ' ) [ 1 ] ] ++ ; } ) ; console . log ( total . A ) ; console . log ( total . B ) ; console . log ( total . AB ) ; console . log ( total . O ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var a = lines . filter ( function ( line ) { return line . split ( ' , ' ) [ 1 ] == ' A ' ; } ) . length ; var b = lines . filter ( function ( line ) { return line . split ( ' , ' ) [ 1 ] == ' B ' ; } ) . length ; var ab = lines . filter ( function ( line ) { return line . split ( ' , ' ) [ 1 ] == ' AB ' ; } ) . length ; var o = lines . filter ( function ( line ) { return line . split ( ' , ' ) [ 1 ] == ' O ' ; } ) . length ; console . log ( a ) ; console . log ( b ) ; console . log ( ab ) ; console . log ( o ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var str = input . trim ( ) ; str = str . replace ( / apple|peach / g , function ( v ) { return ( v == \" apple \" ) ? \" peach \" : \" apple \" ; } ) ; console . log ( str ) ;",
    "label": 2
  },
  {
    "code": "console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . replace ( / apple / g , ' # ' ) . replace ( / peach / g , ' apple ' ) . replace ( / # / g , ' peach ' ) . trim ( ) )",
    "label": 2
  },
  {
    "code": "a = ' apple ' , console . log ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . replace ( / apple|peach / g , function ( c ) { return c == a ? ' peach ' : a } ) . trim ( ) )",
    "label": 2
  },
  {
    "code": "var util = require ( ' util ' ) ; function main ( ) { util . print ( input . replace ( / apple|peach / g , function ( w ) { return w === ' apple ' ? ' peach ' : ' apple ' ; } ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; input = input . replace ( / peach / g , ' xxxxxx ' ) ; input = input . replace ( / apple / g , ' peach ' ) ; input = input . replace ( / xxxxxx / g , ' apple ' ) ; console . log ( input ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == 0 ) break ; var cnt = 0 ; for ( var j = 1 ; j <= Arr [ i ] ; j ++ ) { var a = j ; while ( a % 5 == 0 ) { a /= 5 ; cnt ++ ; } } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var factorialArray = factorial ( ) ; for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var j = parseInt ( input [ i ] , 10 ) ; if ( ! j ) return ; console . log ( factorialArray [ j ] ) ; } } function factorial ( ) { var max = 20000 ; var factorialArray = new Int32Array ( max + 1 ) ; for ( var i = 5 ; i <= max ; i ++ ) { var j = i ; while ( ( j = ~ ~ j / 5 ) ) factorialArray [ i ] += j ; } return factorialArray ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . some ( function ( i ) { j = + i , s = 0 ; if ( j ) { while ( j = ~ ~ ( j / 5 ) ) s += j ; console . log ( s ) } } )",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( ' \\n ' ) . map ( function ( i ) { j = + i , s = 0 ; if ( j ) { while ( j = ~ ~ ( j / 5 ) ) s += j ; console . log ( s ) } } )",
    "label": 2
  },
  {
    "code": "function main ( ) { var i , x , n , len = input . length ; for ( i = 0 ; i < len ; i ++ ) { n = parseInt ( input [ i ] , 10 ) ; if ( n === 0 ) break ; x = 0 ; while ( n = Math . floor ( n / 5 ) ) x += n ; console . log ( x ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( ) { var input = ' ' ; function main ( ) { var inputLen , i , n , z ; for ( i = 0 , inputLen = input . length - 1 ; i < inputLen ; i += 1 ) { n = parseInt ( input [ i ] , 10 ) ; if ( n === 0 ) { break ; } else { z = zero ( n ) ; console . log ( z ) ; } } } function zero ( f ) { var j , zeroCnt = 0 ; for ( j = f ; j / 5 !== 0 ; j /= 5 ) { zeroCnt += Math . floor ( j / 5 ) ; } return zeroCnt ; } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ; } ( ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { if ( line == ' 0 ' ) break ; cnt2 = 0 ; cnt5 = 0 ; var n = + line ; for ( var i = 1 ; i <= n ; i ++ ) { var tmp = i ; while ( tmp % 2 == 0 ) { tmp /= 2 ; cnt2 ++ ; } while ( tmp % 5 == 0 ) { tmp /= 5 ; cnt5 ++ ; } } console . log ( Math . min ( cnt2 , cnt5 ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var abn = Arr [ i ] . split ( \" \" ) . map ( Number ) ; var a = abn [ 0 ] ; var b = abn [ 1 ] ; var n = abn [ 2 ] ; var arr = ( a / b + \" \" ) . split ( \" . \" ) ; var str = ( arr . length == 2 ) ? arr [ 1 ] : \" \" ; var sum = 0 ; for ( var j = 0 ; j < str . length ; j ++ ) { if ( j == n ) break ; sum += ( str [ j ] - 0 ) ; } console . log ( sum ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var c = input [ i ] . split ( ' ' ) ; var div = c [ 0 ] / c [ 1 ] + ' . ' ; var decimalNumber = div . split ( ' . ' ) [ 1 ] . split ( ' ' ) ; var result = 0 ; for ( var j = 0 ; j < + c [ 2 ] ; j ++ ) { var num = + decimalNumber [ j ] ; result += num ? num : 0 ; } console . log ( result ) ; } }",
    "label": 2
  },
  {
    "code": "for ( i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) , j = 0 ; a = i [ j ++ ] , b = i [ j ++ ] , c = i [ j ++ ] ; ) { for ( r = 0 ; c -- ; ) r += ~ ~ ( ( a = a % b * 10 ) / b ) ; console . log ( r ) }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; Arr . forEach ( function ( v ) { var arr = [ 0 , v ] ; for ( var i = 2 ; i <= 10 ; i ++ ) { arr [ i ] = ( i % 2 == 0 ) ? arr [ i - 1 ] * 2 : arr [ i - 1 ] / 3 ; } var sum = arr . reduce ( function ( a , b ) { return a + b ; } ) ; console . log ( sum . toFixed ( 8 ) ) ; } ) ;",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) { for ( r = + i , k = 10 ; -- k ; ) r += ( i = k % 2 ? i * 2 : i / 3 ) ; console . log ( r . toFixed ( 8 ) ) }",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) { for ( r = 0 , k = 10 ; k -- ; k % 2 ? i *= 2 : i /= 3 ) r += + i ; console . log ( r . toFixed ( 8 ) ) }",
    "label": 2
  },
  {
    "code": "function main ( ) { input . forEach ( function ( n ) { if ( n . trim ( ) === ' ' ) return ; n = parseFloat ( n ) ; console . log ( s ( n ) ) ; } ) ; } function s ( n ) { var i , x = 10 , a = [ n ] ; for ( i = 2 ; i <= 10 ; i ++ ) { if ( i % 2 === 0 ) { a [ a . length ] = a [ a . length - 1 ] * 2 ; } else { a [ a . length ] = a [ a . length - 1 ] / 3 ; } } return a . reduce ( function ( a , b ) { return a + b ; } ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var result = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) result . push ( arr [ i ] ) ; } return result ; } var p = prime ( 50000 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var cnt = 0 ; var k = p . length - 1 ; for ( var i = 0 ; i < p . length ; i ++ ) { while ( p [ i ] + p [ k ] > n ) k -- ; if ( k < i ) break ; if ( p [ i ] + p [ k ] == n ) cnt ++ ; } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; var primeCounts = new Int32Array ( 50001 ) ; for ( var i = 1 ; i < 5135 ; i ++ ) { for ( var k = 1 ; k <= i ; k ++ ) { var sum = primeNumbers [ i ] + primeNumbers [ k ] ; if ( sum > 50000 ) break ; primeCounts [ sum ] ++ ; } } var i = 0 ; while ( c = + input [ i ++ ] ) { console . log ( primeCounts [ c ] ) ; } } function calcPrimeNumbers ( ) { var max = 50021 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( 5134 + 1 ) ; var c = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( ! primeNumbers [ i ] ) { primeNums [ ++ c ] = i ; } } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; var primeCounts = new Int32Array ( 50001 ) ; for ( var i = 1 ; i < 5133 ; i ++ ) { var pni = primeNumbers [ i ] ; for ( var k = 1 ; k <= i ; k ++ ) { var sum = pni + primeNumbers [ k ] ; if ( sum > 50000 ) break ; primeCounts [ sum ] ++ ; } } var i = 0 ; while ( c = + input [ i ++ ] ) { console . log ( primeCounts [ c ] ) ; } } function calcPrimeNumbers ( ) { var max = 50021 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( 5134 + 1 ) ; var c = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( ! primeNumbers [ i ] ) { primeNums [ ++ c ] = i ; } } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; var primeCounts = new Int32Array ( 50001 ) ; for ( var i = 1 ; i < 5133 ; i ++ ) { var pni = primeNumbers [ i ] ; for ( var k = 1 ; k <= i ; k ++ ) { var sum = pni + primeNumbers [ k ] ; if ( sum > 50000 ) break ; primeCounts [ sum ] ++ ; } } var i = 0 ; while ( c = + input [ i ++ ] ) { console . log ( primeCounts [ c ] ) ; } } function calcPrimeNumbers ( ) { var max = 50021 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( 5134 + 1 ) ; var c = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( ! primeNumbers [ i ] ) { primeNums [ ++ c ] = i ; } } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; var primeCounts = new Int32Array ( 50001 ) ; for ( var i = 1 ; i < 5133 ; i ++ ) { var pni = primeNumbers [ i ] ; for ( var k = 1 ; k <= i ; k ++ ) { var sum = pni + primeNumbers [ k ] ; if ( sum > 50000 ) break ; primeCounts [ sum ] ++ ; } } var i = 0 ; while ( c = + input [ i ++ ] ) { console . log ( primeCounts [ c ] ) ; } } function calcPrimeNumbers ( ) { var max = 49999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( 5134 ) ; var c = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( ! primeNumbers [ i ] ) { primeNums [ ++ c ] = i ; } } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; var primeCounts = new Int32Array ( 100001 ) ; for ( var i = 1 ; i < 5133 ; i ++ ) { var pni = primeNumbers [ i ] ; for ( var k = 1 ; k <= i ; k ++ ) { var sum = pni + primeNumbers [ k ] ; primeCounts [ sum ] ++ ; } } var i = 0 ; while ( c = + input [ i ++ ] ) { console . log ( primeCounts [ c ] ) ; } } function calcPrimeNumbers ( ) { var max = 49999 ; var primeNumbers = new Int8Array ( max + 1 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int32Array ( 5134 ) ; var c = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( ! primeNumbers [ i ] ) { primeNums [ ++ c ] = i ; } } return primeNums ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var primeNumbers = calcPrimeNumbers ( ) ; var i = 0 ; while ( c = + input [ i ++ ] ) { console . log ( primeNumbers [ c ] ) ; } } function calcPrimeNumbers ( ) { var max = 49999 ; var primeNumbers = new Int8Array ( max + 1 ) ; var primeCounts = new Int16Array ( 50001 ) ; primeNumbers [ 0 ] = primeNumbers [ 1 ] = 1 ; for ( var i = 2 , maxI = ~ ~ Math . sqrt ( max ) ; i <= maxI ; i ++ ) { if ( primeNumbers [ i ] ) { continue ; } for ( var j = ( i << 1 ) ; j <= max ; j += i ) { primeNumbers [ j ] = 1 ; } } var primeNums = new Int16Array ( 5134 ) ; var c = 0 ; for ( var i = 1 ; i <= max ; i ++ ) { if ( primeNumbers [ i ] ) continue ; primeNums [ ++ c ] = i ; for ( var j = 1 ; j <= c ; j ++ ) { var sum = i + primeNums [ j ] ; if ( sum > 50000 ) break ; primeCounts [ sum ] ++ ; } } return primeCounts ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var i , j , n , m , x , len = input . length ; for ( i = 0 ; i < len ; i ++ ) { n = parseInt ( input [ i ] , 10 ) ; if ( n === 0 ) break ; m = ~ ~ ( n / 2 ) ; for ( x = 0 , j = 0 ; primes [ j ] <= m ; j ++ ) { if ( primesTable [ n - primes [ j ] ] ) x ++ ; } console . log ( x ) ; } } var primes = ( function ( n ) { var i , j , flag , primes = [ 2 ] ; if ( n < 2 ) return [ ] ; for ( i = 3 ; i <= n ; i += 2 ) { flag = true ; for ( j = 0 ; primes [ j ] < i * i ; j ++ ) { if ( i % primes [ j ] == 0 ) { flag = false ; break ; } } if ( flag ) { primes . push ( i ) ; } } return primes ; } ) ( 50000 ) , primesTable = primes . reduce ( function ( m , a ) { m [ a ] = true ; return m ; } , { } ) ; var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var n = ( Arr [ i ] - 0 ) + 1 ; var x = 1 / 2 * n * ( n - 1 ) ; console . log ( x + 1 ) ; }",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = + require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) console . log ( ( i * i + i + 2 ) / 2 )",
    "label": 2
  },
  {
    "code": "for ( j = 0 ; i = + require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) [ j ++ ] ; ) console . log ( ( i * i + i + 2 ) / 2 )",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var k1 ; var k2 ; if ( x2 - x1 !== 0 ) k1 = ( ( y2 - y1 ) / ( x2 - x1 ) ) ; else k1 = Infinity ; if ( x4 - x3 !== 0 ) k2 = ( y4 - y3 ) / ( x4 - x3 ) ; else k2 = Infinity ; var ans = \" NO \" ; if ( k1 == 0 && k2 == Infinity ) ans = \" YES \" ; if ( k2 == 0 && k1 == Infinity ) ans = \" YES \" ; if ( Math . abs ( k1 * k2 + 1 ) < 1.0e-8 ) ans = \" YES \" ; console . log ( ans ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var k1 = ( x2 - x1 == 0 ) ? Infinity : ( y2 - y1 ) / ( x2 - x1 ) ; var k2 = ( x4 - x3 == 0 ) ? Infinity : ( y4 - y3 ) / ( x4 - x3 ) ; var ans = \" NO \" ; if ( k1 == 0 && k2 == Infinity ) ans = \" YES \" ; if ( k2 == 0 && k1 == Infinity ) ans = \" YES \" ; if ( Math . abs ( k1 * k2 + 1 ) < 1.0e-8 ) ans = \" YES \" ; console . log ( ans ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) . map ( function ( i ) { c = i . split ( ' ' ) , console . log ( Math . abs ( ( c [ 2 ] - c [ 0 ] ) * ( c [ 6 ] - c [ 4 ] ) + ( c [ 3 ] - c [ 1 ] ) * ( c [ 7 ] - c [ 5 ] ) ) < 1e-10 ? ' YES ' : ' NO ' ) } )",
    "label": 2
  },
  {
    "code": "for ( i = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . split ( / \\s / ) , j = 0 ; a = i [ j ] ; j += 8 ) console . log ( Math . abs ( ( i [ j + 2 ] - a ) * ( i [ j + 6 ] - i [ j + 4 ] ) + ( i [ j + 3 ] - i [ j + 1 ] ) * ( i [ j + 7 ] - i [ j + 5 ] ) ) < 1e-10 ? ' YES ' : ' NO ' )",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var nums = v . split ( \" \" ) . map ( Number ) ; var ans = \" NO \" ; var x1 = nums [ 2 ] - nums [ 0 ] ; var y1 = nums [ 3 ] - nums [ 1 ] ; var x2 = nums [ 6 ] - nums [ 4 ] ; var y2 = nums [ 7 ] - nums [ 5 ] ; var k1 = ( nums [ 3 ] - nums [ 1 ] ) / ( nums [ 2 ] - nums [ 0 ] ) ; var k2 = ( nums [ 7 ] - nums [ 5 ] ) / ( nums [ 6 ] - nums [ 4 ] ) ; if ( x1 == 0 ) { if ( y2 == 0 ) { ans = \" YES \" ; } } else if ( x2 == 0 ) { if ( y1 == 0 ) { ans = \" YES \" } } else if ( Math . abs ( k1 * k2 + 1 ) < 1e-10 ) { ans = \" YES \" ; } console . log ( ans ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; var cnt = 0 ; ( function ( xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 ) { if ( xb2 >= xa1 && xb1 <= xa2 ) cnt ++ ; if ( yb2 >= ya1 && yb1 <= ya2 ) cnt ++ ; } ) . apply ( null , arr ) ; console . log ( ( cnt == 2 ) ? \" YES \" : \" NO \" ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . trim ( ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { for ( var i = 0 , len = input . length ; i < len ; i ++ ) { var c = input [ i ] . split ( ' ' ) . map ( Number ) ; var xa1 = c [ 0 ] , ya1 = c [ 1 ] , xa2 = c [ 2 ] , ya2 = c [ 3 ] , xb1 = c [ 4 ] , yb1 = c [ 5 ] , xb2 = c [ 6 ] , yb2 = c [ 7 ] ; var r = ( xa1 <= xb2 && xb1 <= xa2 ) && ( ya1 <= yb2 && yb1 <= ya2 ) ; console . log ( r ? ' YES ' : ' NO ' ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; var m = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; m = m . filter ( function ( v ) { return ( v != arr [ 0 ] && v != arr [ 1 ] && v != arr [ 2 ] ) ; } ) ; var y = 0 ; var n = 0 ; m . forEach ( function ( v ) { ( ( arr [ 0 ] + arr [ 1 ] + v ) <= 20 ) ? y ++ : n ++ ; } ) ; console . log ( y >= n ? \" YES \" : \" NO \" ) ; } ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; y = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; for ( i = 0 ; i < x . length - 1 ; i += 3 ) { count = 0 ; for ( j = 0 ; j < 10 ; j ++ ) { if ( y [ j ] <= 20 - ( x [ i ] * 1 + x [ i + 1 ] * 1 ) && y [ j ] != x [ i + 2 ] && y [ j ] != x [ i + 1 ] && y [ j ] != x [ i ] ) { count ++ ; } } if ( count >= 4 ) { console . log ( \" YES \" ) ; } else { console . log ( \" NO \" ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n 0,0 \\n \" ) ; var inputA = Arr [ 0 ] . split ( \" \\n \" ) ; var inputB = Arr [ 1 ] . split ( \" \\n \" ) . map ( Number ) ; var obj = { } ; var s = [ ] ; inputA . forEach ( function ( v ) { var arr = v . split ( \" , \" ) . map ( Number ) ; obj [ arr [ 0 ] ] = arr [ 1 ] ; s . push ( arr [ 1 ] ) ; } ) ; s . sort ( function ( a , b ) { return b - a ; } ) ; var s0 = s [ 0 ] ; var t = [ s0 ] ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s0 == s [ i ] ) continue ; s0 = s [ i ] ; t . push ( s [ i ] ) ; } inputB . forEach ( function ( v ) { console . log ( t . indexOf ( obj [ v ] ) + 1 ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; var score = [ ] ; var line ; while ( line = lines . shift ( ) ) { var arr = line . split ( ' , ' ) . map ( function ( n ) { return + n ; } ) ; if ( arr [ 0 ] + arr [ 1 ] == 0 ) break ; score . push ( { id : arr [ 0 ] , score : arr [ 1 ] } ) ; } var rank = score . map ( function ( o ) { return o . score ; } ) . filter ( function ( v , i , a ) { return a . indexOf ( v ) == i ; } ) . sort ( function ( a , b ) { return b - a ; } ) ; while ( line = lines . shift ( ) ) { var id = + line ; var team = score . filter ( function ( o ) { return o . id == id ; } ) [ 0 ] ; var r = rank . indexOf ( team . score ) + 1 ; console . log ( r ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var cnt = 0 ; Arr . forEach ( function ( v ) { var str = v . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; if ( str == v ) cnt ++ ; } ) ; console . log ( cnt ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; var ret = lines . filter ( function ( line ) { return line . trim ( ) == line . trim ( ) . split ( ' ' ) . reverse ( ) . join ( ' ' ) ; } ) ; console . log ( ret . length ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \" ) ; var num = 0 ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var str = Arr [ i ] ; str = str . replace ( / \\d+ / g , function ( s ) { num += ( s - 0 ) ; return s ; } ) ; } console . log ( num ) ;",
    "label": 2
  },
  {
    "code": "var pass = 0 ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var result = input . match ( / [0-9]+ / g ) ; for ( var i in result ) { pass += Number ( result [ i ] ) ; } } ) ; process . stdin . on ( ' end ' , function ( ) { console . log ( pass ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var ans = 0 ; require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . match ( / \\d+ / g ) . forEach ( function ( elem ) { ans += parseInt ( elem , 10 ) ; } ) ; console . log ( ans ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \\n \" ) ; var arrA = ( Arr [ 0 ] . split ( \" \\n \" ) ) . map ( function ( v ) { return v . replace ( / \\,.* / , \" \" ) - 0 ; } ) ; var arrB = ( Arr [ 1 ] . split ( \" \\n \" ) ) . map ( function ( v ) { return v . replace ( / \\,.* / , \" \" ) - 0 ; } ) ; arrA . sort ( function ( a , b ) { a - b ; } ) ; var c = { } ; arrA . forEach ( function ( v ) { if ( arrB . indexOf ( v ) !== - 1 ) c [ v ] = 0 ; } ) ; arrA . forEach ( function ( v ) { if ( c [ v ] !== undefined ) c [ v ] ++ ; } ) ; arrB . forEach ( function ( v ) { if ( c [ v ] !== undefined ) c [ v ] ++ ; } ) ; for ( var i in c ) console . log ( i + \" \" + c [ i ] ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var temp = [ ] ; var line ; while ( line = lines . shift ( ) ) { temp . push ( line . split ( ' , ' ) [ 0 ] ) ; } var tm = [ ] ; while ( line = lines . shift ( ) ) { tm . push ( line . split ( ' , ' ) [ 0 ] ) ; } temp . sort ( function ( a , b ) { return a - b ; } ) ; temp . filter ( function ( e , i , a ) { return a . indexOf ( e ) == i } ) . forEach ( function ( c ) { var cnt = tm . filter ( function ( n ) { return n == c ; } ) . length ; if ( cnt > 0 ) { var tcnt = temp . filter ( function ( n ) { return n == c } ) . length ; console . log ( c , cnt + tcnt ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . trim ( ) . split ( ' \\n ' ) ; var lm = [ ] ; var line ; while ( line = lines . shift ( ) ) { lm . push ( line . split ( ' , ' ) [ 0 ] ) ; } var tm = [ ] ; while ( line = lines . shift ( ) ) { tm . push ( line . split ( ' , ' ) [ 0 ] ) ; } lm . sort ( function ( a , b ) { return a - b ; } ) ; lm . filter ( function ( e , i , a ) { return a . indexOf ( e ) == i } ) . forEach ( function ( c ) { var cnt = tm . filter ( function ( n ) { return n == c ; } ) . length ; if ( cnt > 0 ) { var tcnt = lm . filter ( function ( n ) { return n == c } ) . length ; console . log ( c , cnt + tcnt ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( y , x ) { var dy = [ 0 , 0 , - 1 , 1 ] ; var dx = [ - 1 , 1 , 0 , 0 ] ; for ( var i = 0 ; i < 4 ; i ++ ) { var yy = y + dy [ i ] ; var xx = x + dx [ i ] ; if ( yy < 0 || yy >= 12 || xx < 0 || xx >= 12 ) continue ; if ( yx [ yy ] [ xx ] == \" a \" ) { yx [ yy ] [ xx ] = cnt ; bomb ( yy , xx ) ; } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = 0 ; var cnt = 0 ; var yx = [ ] ; for ( var I = 0 ; I < Arr . length ; I ++ ) { n ++ ; var v = Arr [ I ] . replace ( / 1 / g , \" a \" ) ; var arr = v . split ( \" \" ) ; yx . push ( arr ) ; if ( n != 12 ) continue ; cnt = 0 ; for ( var i = 0 ; i < 12 ; i ++ ) { for ( var j = 0 ; j < 12 ; j ++ ) { if ( yx [ i ] [ j ] == \" a \" ) { cnt ++ ; yx [ i ] [ j ] = cnt ; bomb ( i , j ) ; } } } console . log ( cnt ) ; n = 0 ; yx = [ ] ; I ++ ; }",
    "label": 2
  },
  {
    "code": "var COUNTER_CLOCKWISE = 1 ; var CLOCKWISE = - 1 ; var ONLINE_BACK = 2 ; var ONLINE_FRONT = - 2 ; var ON_SEGMENT = 0 ; var Vector2D = class Vector2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } Vector2D . prototype . Init = function ( x , y ) { this . x = x ; this . y = y ; } function rotateVector90 ( v ) { var r = new Vector2D ( ) ; r . x = - v . y ; r . y = v . x ; return r ; } function getDegreeToRadian ( degree ) { var pi = 3.14159265358979323846 ; return degree * pi / 180 ; } function getRotateVector ( vec , degree ) { var radian = getDegreeToRadian ( degree ) ; var sin = Math . sin ( radian ) ; var cos = Math . cos ( radian ) ; var r = new Vector2D ( ) ; r . x = vec . x * cos - vec . y * sin ; r . y = vec . x * sin + vec . y * cos ; return r ; } function isEqualVectors ( a , b ) { return equalFloats ( a . x - b . x , 0 ) && equalFloats ( a . y - b . y , 0 ) ; } function getUnitVector ( vec ) { var length = getVectorLength2D ( vec ) ; if ( length > 0 ) { return getDivideVector ( vec , length ) ; } return vec ; } function getVectorLength2D ( vec ) { return Math . sqrt ( ( vec . x * vec . x ) + ( vec . y * vec . y ) ) ; } function getDivideVector ( vec2D , length ) { vec2D . x = vec2D . x / length ; vec2D . y = vec2D . y / length ; return vec2D ; } function equalFloats ( a , b ) { var threshold = 1 / 8192 ; return Math . abs ( a - b ) < threshold ; } function isParallelVector ( vectorA , vectorB ) { var na = rotateVector90 ( vectorA ) ; return equalFloats ( 0 , dotProduct2D ( na , vectorB ) ) ; } function isVerticalVector ( vectorA , vectorB ) { return equalFloats ( 0 , dotProduct2D ( vectorA , vectorB ) ) ; } function subtractVector ( vecA , vecB ) { var vec = new Vector2D ( ) ; vec . x = vecA . x - vecB . x ; vec . y = vecA . y - vecB . y ; return vec ; } function dotProduct2D ( vecA , vecB ) { var dot = vecA . x * vecB . x + vecA . y * vecB . y ; return vecA . x * vecB . x + vecA . y * vecB . y ; } function getCross ( vecA , vecB ) { return vecA . x * vecB . y - vecA . y * vecB . x ; } var LineSegment2D = class LineSegment2D { constructor ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } } LineSegment2D . prototype . Init = function ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } function onOneSide ( axis , segment ) { var d1 = new Vector2D ( ) ; d1 = subtractVector ( segment . point1 , axis . base ) ; var d2 = new Vector2D ( ) ; d2 = subtractVector ( segment . point2 , axis . base ) ; var n = new Vector2D ( ) ; n = rotateVector90 ( axis . direction ) ; return dotProduct2D ( n , d1 ) * dotProduct2D ( n , d2 ) > 0 ; } function overLapping ( minA , maxA , minB , maxB ) { return minB <= maxA && minA <= maxB ; } function isSegmentsCollide ( segment1 , segment2 ) { var axisA = new Line ( ) ; var axisB = new Line ( ) ; axisA . base = segment1 . point1 ; axisA . direction = subtractVector ( segment1 . point2 , segment1 . point1 ) ; if ( onOneSide ( axisA , segment2 ) ) { return false ; } axisB . base = segment2 . point1 ; axisB . direction = subtractVector ( segment2 . point2 , segment2 . point1 ) ; if ( onOneSide ( axisB , segment1 ) ) { return false ; } if ( isParallelVector ( axisA . direction , axisB . direction ) ) { var rangeA = getProjectSegment ( segment1 , axisA . direction ) ; var rangeB = getProjectSegment ( segment2 , axisA . direction ) ; return isOverLappingRanges ( rangeA , rangeB ) ; } else { return true ; } } function Line ( ) { this . base ; this . direction } Line . prototype . Init = function ( base , direction , color ) { this . base = base ; this . direction = direction ; } var Range = class Range { constructor ( min , max ) { this . min = min ; this . max = max ; } } function getMaxMinRange ( range1 , range2 ) { var range = new Range ( ) ; range . min = range1 . min < range2 . min ? range1 . min : range2 . min ; range . max = range1 . max < range2 . max ? range2 . max : range1 . max ; return range ; } function getSortRange ( range ) { var sorted = new Range ( range . min , range . max ) ; if ( range . min > range . max ) { sorted . min = range . max ; sorted . max = range . min ; } return sorted ; } function getNegateVector ( vector ) { vector . x = - vector . x ; vector . y = - vector . y ; return vector ; } function getAddVector ( vecA , vecB ) { return new Vector2D ( vecA . x + vecB . x , vecA . y + vecB . y ) ; } function getProjectSegment ( segment , onto ) { var ontoUnitVec = getUnitVector ( onto ) ; var range = new Range ( ) ; range . min = dotProduct2D ( ontoUnitVec , segment . point1 ) ; range . max = dotProduct2D ( ontoUnitVec , segment . point2 ) ; range = getSortRange ( range ) ; return range ; } function isOverLappingRanges ( range1 , range2 ) { return overLapping ( range1 . min , range1 . max , range2 . min , range2 . max ) ; } function projectVector ( project , onto ) { var d = dotProduct2D ( onto , onto ) ; if ( 0 < d ) { var dp = dotProduct2D ( project , onto ) ; return multiplyVector ( onto , dp / d ) ; } return onto ; } function getNorm ( vec ) { return vec . x * vec . x + vec . y * vec . y ; } function getVec2DLength ( vec ) { return Math . sqrt ( getNorm ( vec ) ) ; } var Point2D = class Point2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } function addPoint ( point1 , point2 ) { return new Point2D ( point1 . x + point2 . x , point1 . y + point2 . y ) ; } function subtractPoint ( point1 , point2 ) { return new Point2D ( point1 . x - point2 . x , point1 . y - point2 . y ) ; } function multiplyPoint ( point , scalar ) { return new Point2D ( point . x * scalar , point . y * scalar ) ; } function getProjectPoint ( segment , point ) { var vec1 = new Vector2D ( segment . point2 . x - segment . point1 . x , segment . point2 . y - segment . point1 . y ) ; var vec2 = new Vector2D ( point . x - segment . point1 . x , point . y - segment . point1 . y ) ; var rate = dotProduct2D ( vec2 , vec1 ) / getNorm ( vec1 ) ; var vec3 = multiplyVector ( vec1 , rate ) ; var project = new Point2D ( segment . point1 . x + vec3 . x , segment . point1 . y + vec3 . y ) ; return project ; } function getReflectionPoint ( segment , point ) { var projection = getProjectPoint ( segment , point ) ; var vec = subtractPoint ( projection , point ) ; var refrectionPoint = multiplyPoint ( vec , 2 ) ; return addPoint ( refrectionPoint , point ) ; } function getCrossPoint ( segment1 , segment2 ) { var baseVector = new Vector2D ( segment2 . point2 . x - segment2 . point1 . x , segment2 . point2 . y - segment2 . point1 . y ) ; var d1Vec = new Vector2D ( segment1 . point1 . x - segment2 . point1 . x , segment1 . point1 . y - segment2 . point1 . y ) ; var d2Vec = new Vector2D ( segment1 . point2 . x - segment2 . point1 . x , segment1 . point2 . y - segment2 . point1 . y ) ; var d1 = Math . abs ( getCross ( baseVector , d1Vec ) ) ; var d2 = Math . abs ( getCross ( baseVector , d2Vec ) ) ; var t = d1 / ( d1 + d2 ) ; var x = segment1 . point1 . x + ( segment1 . point2 . x - segment1 . point1 . x ) * t ; var y = segment1 . point1 . y + ( segment1 . point2 . y - segment1 . point1 . y ) * t ; return new Point2D ( x , y ) ; } function multiplyVector ( vec , scalar ) { var temp = new Vector2D ( ) ; temp . x = vec . x * scalar ; temp . y = vec . y * scalar ; return temp ; } function clampOnRange ( x , min , max ) { if ( x < min ) { return min ; } else if ( x > max ) { return max ; } else { return x ; } } function getDistanceLinePoint ( line , point ) { var vec1 = new Vector2D ( line . point2 . x - line . point1 . x , line . point2 . y - line . point1 . y ) ; var vec2 = new Vector2D ( point . x - line . point1 . x , point . y - line . point1 . y ) ; return Math . abs ( getCross ( vec1 , vec2 ) / getVec2DLength ( vec1 ) ) ; } function getDistanceSegmentPoint ( segment , point ) { if ( dotProduct2D ( subtractPoint ( segment . point2 , segment . point1 ) , subtractPoint ( point , segment . point1 ) ) < 0 ) { return getVec2DLength ( subtractPoint ( point , segment . point1 ) ) ; } if ( dotProduct2D ( subtractPoint ( segment . point1 , segment . point2 ) , subtractPoint ( point , segment . point2 ) ) < 0 ) { return getVec2DLength ( subtractPoint ( point , segment . point2 ) ) ; } return getDistanceLinePoint ( segment , point ) ; } function getSegmentDistance ( segment1 , segment2 ) { if ( isSegmentsCollide ( segment1 , segment2 ) ) { return 0 ; } return Math . min ( Math . min ( getDistanceSegmentPoint ( segment1 , segment2 . point1 ) , getDistanceSegmentPoint ( segment1 , segment2 . point2 ) ) , Math . min ( getDistanceSegmentPoint ( segment2 , segment1 . point1 ) , getDistanceSegmentPoint ( segment2 , segment1 . point2 ) ) ) ; } function ccw ( point1 , point2 , point3 ) { var vec1 = new Vector2D ( point2 . x - point1 . x , point2 . y - point1 . y ) ; var vec2 = new Vector2D ( point3 . x - point1 . x , point3 . y - point1 . y ) ; var cross = getCross ( vec1 , vec2 ) ; if ( cross > Number . EPSILON ) { return COUNTER_CLOCKWISE ; } if ( cross < - Number . EPSILON ) { return CLOCKWISE ; } if ( dotProduct2D ( vec1 , vec2 ) < - Number . EPSILON ) { return ONLINE_BACK ; } if ( getVectorLength2D ( vec1 ) < getVectorLength2D ( vec2 ) ) { return ONLINE_FRONT ; } return ON_SEGMENT ; } function getConvexHoll ( points ) { if ( points . length < 3 ) { points . reverse ( ) ; return points ; } points . sort ( ( a , b ) => ( a . x > b . x ) ? 1 : ( a . x == b . x ) ? ( ( a . y > b . y ) ? 1 : - 1 ) : - 1 ) ; var u = [ ] ; u . push ( points [ 0 ] ) ; u . push ( points [ 1 ] ) ; var l = [ ] ; l . push ( points [ points . length - 1 ] ) ; l . push ( points [ points . length - 2 ] ) ; for ( var i = 2 ; i < points . length ; ++ i ) { for ( var j = u . length ; j >= 2 && ccw ( u [ j - 2 ] , u [ j - 1 ] , points [ i ] ) == COUNTER_CLOCKWISE ; -- j ) { u . pop ( ) ; } u . push ( points [ i ] ) ; } for ( var i = points . length - 3 ; i >= 0 ; -- i ) { for ( var j = l . length ; j >= 2 && ccw ( l [ j - 2 ] , l [ j - 1 ] , points [ i ] ) == COUNTER_CLOCKWISE ; -- j ) { l . pop ( ) ; } l . push ( points [ i ] ) ; } l . reverse ( ) ; for ( var i = u . length - 2 ; i >= 1 ; -- i ) { l . push ( u [ i ] ) ; } return l ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( 1 ) { var n = Arr [ 0 ] ; if ( n == 0 ) { break ; } var points = [ ] ; Arr . shift ( ) ; for ( var i = 0 ; i < n ; ++ i ) { var nums = Arr [ 0 ] . split ( \" , \" ) . map ( Number ) ; points [ i ] = new Point2D ( nums [ 0 ] , nums [ 1 ] ) ; Arr . shift ( ) ; } points = getConvexHoll ( points ) ; console . log ( n - points . length ) }",
    "label": 2
  },
  {
    "code": "var input = { } ; var data = [ ] ; var f = function ( startLine , startStep ) { if ( ! startStep ) startStep = 0 ; var now = startLine ; var result = [ now ] ; for ( var y = startStep ; y < data . length ; y ++ ) { now += data [ y ] [ now ] ; result . push ( now ) ; } return result ; } ; var rf = function ( endLine ) { var now = endLine ; var result = [ now ] ; for ( var y = data . length - 1 ; y >= 0 ; y -- ) { now += data [ y ] [ now ] ; result . push ( now ) ; } return result . reverse ( ) ; } ; var lines ; var loadInput = function ( ) { input = { steps : 4 } ; data = [ ] ; for ( var j = 0 ; j < 4 + input . steps ; j ++ ) { var e = lines [ j ] ; def = [ \" lines \" , \" start \" , \" end \" , \" steps \" ] ; if ( j < def . length ) { input [ def [ j ] ] = parseInt ( e ) ; continue ; } var line = [ ] ; for ( var i = 0 ; i < input . lines - 1 ; i ++ ) { var c = parseInt ( e . charAt ( i ) ) ; if ( i > 0 && c == 0 && line [ i - 1 ] == 1 ) c = - 1 ; line . push ( c ) ; } line . push ( ( line [ line . length - 1 ] == 1 ) ? - 1 : 0 ) ; data . push ( line ) ; } input . start -= 1 ; input . end -= 1 ; lines . splice ( 0 , 4 + input . steps ) ; return true ; } ; var calc = function ( ) { var route = f ( input . start ) ; if ( route [ route . length - 1 ] == input . end ) { console . log ( \" 0 \" ) ; return ; } var gRoute = rf ( input . end ) ; var result = \" 1 \" ; for ( var y = 0 ; y < input . steps ; y ++ ) { if ( Math . abs ( route [ y ] - gRoute [ y ] ) == 1 && data [ y ] [ route [ y ] ] == 0 && data [ y ] [ gRoute [ y ] ] == 0 ) { result = ( y + 1 ) + \" \" + ( Math . min ( route [ y ] , gRoute [ y ] ) + 1 ) ; break ; } } console . log ( result ) ; } ; var exec = function ( ) { if ( lines [ 0 ] == \" 0 \" ) return ; loadInput ( ) ; calc ( ) ; exec ( ) ; } ; var lines = [ ] ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { chunk . trim ( ) . split ( ' \\n ' ) . forEach ( function ( line ) { lines . push ( line ) ; } ) ; } ) ; process . stdin . on ( ' end ' , function ( ) { exec ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var dp = [ ] ; for ( var i = 0 ; i <= 10 ; i ++ ) { dp [ i ] = [ ] ; for ( var j = 0 ; j <= 330 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } var used = [ ] ; for ( var i = 0 ; i <= 9 ; i ++ ) used [ i ] = false ; function bomb ( sum , cnt ) { dp [ cnt ] [ sum ] ++ ; cnt ++ ; if ( cnt == 11 ) return ; for ( var i = 0 ; i <= 9 ; i ++ ) { if ( used [ i ] ) continue ; used [ i ] = true ; bomb ( sum + i * cnt , cnt ) ; used [ i ] = false ; } } bomb ( 0 , 0 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; arr . forEach ( function ( v ) { var ns = v . split ( \" \" ) . map ( Number ) ; var n = ns [ 0 ] ; var s = ns [ 1 ] ; var ans = ( dp [ n ] [ s ] == undefined ) ? 0 : dp [ n ] [ s ] console . log ( ans ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var dp = [ ] ; for ( var i = 0 ; i <= 10 ; i ++ ) { dp [ i ] = [ ] ; for ( var j = 0 ; j <= 330 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } var used = [ ] ; for ( var i = 0 ; i <= 9 ; i ++ ) used [ i ] = false ; function bomb ( sum , cnt ) { dp [ cnt ] [ sum ] ++ ; cnt ++ ; for ( var i = 0 ; i <= 9 ; i ++ ) { if ( used [ i ] ) continue ; used [ i ] = true ; bomb ( sum + i * cnt , cnt ) ; used [ i ] = false ; } } bomb ( 0 , 0 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; arr . forEach ( function ( v ) { var ns = v . split ( \" \" ) . map ( Number ) ; var n = ns [ 0 ] ; var s = ns [ 1 ] ; var ans = ( dp [ n ] [ s ] == undefined ) ? 0 : dp [ n ] [ s ] console . log ( ans ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function perm ( xs , n , s , callback ) { var x , i , len = xs . length ; s = s || [ ] ; if ( n === 0 ) { callback ( s ) ; } else { for ( i = 0 ; i < len ; i ++ ) { x = xs . shift ( ) ; s . push ( x ) ; perm ( xs , n - 1 , s , callback ) ; s . pop ( ) ; xs . push ( x ) ; } } } function main ( ) { var i , dp = { } , fact = [ 1 ] ; perm ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , 10 , [ ] , function ( xs ) { var i , t = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { t += xs [ i ] * ( i + 1 ) ; dp [ i ] = dp [ i ] || [ ] ; dp [ i ] [ t ] = ( dp [ i ] [ t ] || 0 ) + 1 ; } } ) ; for ( i = 1 ; i <= 9 ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } input . forEach ( function ( line ) { var n , s ; if ( line . trim ( ) === ' ' ) return ; line = line . split ( ' ' ) . map ( parseFloat ) ; n = line [ 0 ] ; s = line [ 1 ] ; if ( n < 0 || s >= 331 ) { console . log ( 0 ) ; } else if ( n === 0 ) { if ( s === 0 ) console . log ( 1 ) ; else console . log ( 0 ) ; } else { console . log ( ~ ~ ( dp [ n - 1 ] [ s ] / fact [ 10 - n ] ) ) ; } } ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( y , x ) { var dx = [ - 1 , 1 , 0 , 0 ] ; var dy = [ 0 , 0 , - 1 , 1 ] ; for ( var i = 0 ; i < 4 ; i ++ ) { for ( var j = 1 ; j <= 3 ; j ++ ) { var yy = y + ( dy [ i ] * j ) ; var xx = x + ( dx [ i ] * j ) ; if ( yy < 0 || yy >= 8 || xx < 0 || xx >= 8 ) continue ; if ( yx [ yy ] [ xx ] == 1 ) { yx [ yy ] [ xx ] = 0 ; bomb ( yy , xx ) ; } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var AL = Arr . shift ( ) ; for ( var i = 0 ; i < AL ; i ++ ) { Arr . shift ( ) ; var yx = [ ] ; for ( var j = 0 ; j < 8 ; j ++ ) { var line = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; yx . push ( line ) ; } var X = ( Arr . shift ( ) - 0 ) - 1 ; var Y = ( Arr . shift ( ) - 0 ) - 1 ; if ( yx [ Y ] [ X ] == 1 ) { yx [ Y ] [ X ] = 0 ; bomb ( Y , X ) ; } console . log ( \" Data \" + ( i + 1 ) + \" : \" ) ; for ( var j = 0 ; j < 8 ; j ++ ) console . log ( yx [ j ] . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var m = Arr . shift ( ) - 0 ; var N = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { N [ i ] = [ ] ; for ( var j = 0 ; j < n ; j ++ ) { N [ i ] [ j ] = Infinity ; if ( i == j ) N [ i ] [ j ] = 0 ; } } var arr = [ ] ; for ( var i = 0 ; i < m ; i ++ ) { var abc = Arr . shift ( ) . split ( \" , \" ) . map ( Number ) ; var a = abc [ 0 ] ; var b = abc [ 1 ] ; var c = ( abc [ 2 ] / 100 ) - 1 ; N [ a ] [ b ] = c ; N [ b ] [ a ] = c ; } var city = [ 0 ] ; var cost = 0 ; while ( true ) { if ( city . length == n ) break ; var min = Infinity ; var select = - 1 ; for ( var i = 0 ; i < city . length ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( city . indexOf ( j ) != - 1 ) continue ; if ( N [ city [ i ] ] [ j ] < min ) { select = j ; min = N [ city [ i ] ] [ j ] ; } } } if ( select != - 1 ) { cost += min ; city . push ( select ) ; } } console . log ( cost ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == - 1 ) break ; var n = Arr [ i ] - 2 ; var c = Math . sqrt ( 2 ) ; var r = 45 * Math . PI / 180 ; while ( n != 0 ) { r += Math . atan2 ( 1 , c ) ; c = Math . sqrt ( c * c + 1 ) ; n -- ; } var x = c * Math . cos ( r ) ; var y = c * Math . sin ( r ) ; console . log ( x . toFixed ( 2 ) ) ; console . log ( y . toFixed ( 2 ) ) ; }",
    "label": 2
  },
  {
    "code": "function heron ( a , b , c ) { var s = ( a + b + c ) / 2 ; var S = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return S ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var xy1 = ( Arr . shift ( ) ) . split ( \" , \" ) . map ( Number ) ; var xy2 = ( Arr . shift ( ) ) . split ( \" , \" ) . map ( Number ) ; var x1 = xy1 [ 0 ] ; var y1 = xy1 [ 1 ] ; var x2 = xy2 [ 0 ] ; var y2 = xy2 [ 1 ] ; var sum = 0 ; for ( var I = 0 ; I < Arr . length ; I ++ ) { var xy3 = Arr [ I ] . split ( \" , \" ) . map ( Number ) ; var x3 = xy3 [ 0 ] ; var y3 = xy3 [ 1 ] ; var d12 = Math . sqrt ( Math . pow ( x1 - x2 , 2 ) + Math . pow ( y1 - y2 , 2 ) ) ; var d13 = Math . sqrt ( Math . pow ( x1 - x3 , 2 ) + Math . pow ( y1 - y3 , 2 ) ) ; var d23 = Math . sqrt ( Math . pow ( x2 - x3 , 2 ) + Math . pow ( y2 - y3 , 2 ) ) ; sum += heron ( d12 , d13 , d23 ) ; x2 = xy3 [ 0 ] ; y2 = xy3 [ 1 ] ; } console . log ( sum . toFixed ( 6 ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var Q = Arr . shift ( ) - 0 ; if ( Q == - 1 ) break ; var x = Q / 2 ; while ( Math . abs ( Math . pow ( x , 3 ) - Q ) >= 0.00001 * Q ) { x = x - ( Math . pow ( x , 3 ) - Q ) / ( 3 * Math . pow ( x , 2 ) ) ; } console . log ( x . toFixed ( 6 ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" , \" ) . map ( Number ) ; ( function ( x1 , y1 , x2 , y2 , xq , yq ) { var k = ( x2 - x1 == 0 ) ? Infinity : ( y2 - y1 ) / ( x2 - x1 ) ; var ans ; if ( k == 0 ) ans = [ xq , y1 - ( yq - y1 ) ] ; else if ( k == Infinity ) ans = [ x1 - ( xq - x1 ) , yq ] ; else { var a1 = ( y2 - y1 ) / ( x2 - x1 ) ; var a2 = ( - 1 ) / a1 ; var b1 = y1 - a1 * x1 ; var b2 = yq - a2 * xq ; var xm = ( b2 - b1 ) / ( a1 - a2 ) ; var x = 2 * xm - xq ; var y = a2 * x + b2 ; ans = [ x , y ] ; } console . log ( ans [ 0 ] . toFixed ( 6 ) + \" \" + ans [ 1 ] . toFixed ( 6 ) ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "var log = console . log ; if ( typeof process != \" undefined \" ) { var input = \" \" ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { var lines = input . split ( \" \\n \" ) ; main ( lines ) ; } ) ; } function main ( lines ) { lines = lines . map ( function ( line ) { return line . split ( \" , \" ) . filter ( function ( e ) { return e != \" \" ; } ) . map ( function ( e ) { var n = Number ( e ) ; if ( n . toString ( ) == \" NaN \" ) { return e . replace ( / (\\r)|(\\n) / g , \" \" ) ; } return n ; } ) ; } ) ; var last = lines . pop ( ) ; if ( last . length == 6 ) { lines . push ( last ) ; } while ( lines . length > 0 ) { var dataset = lines . shift ( ) ; p_set ( dataset ) ; } } function p_set ( ps ) { var P1 = [ ps [ 0 ] , ps [ 1 ] ] ; var P2 = [ ps [ 2 ] , ps [ 3 ] ] ; var Q = [ ps [ 4 ] , ps [ 5 ] ] ; var P1_P2 = v_a ( P2 , v_m ( P1 , - 1 ) ) ; var P1_Q = v_a ( Q , v_m ( P1 , - 1 ) ) ; var length = cross ( P1_Q , P1_P2 ) / cross ( P1_P2 , P1_P2 ) ; var P1_Qd = v_m ( P1_P2 , length ) ; var Q_Qd = v_a ( v_m ( P1_Q , - 1 ) , P1_Qd ) ; var Q_R = v_m ( Q_Qd , 2 ) ; var R = v_a ( Q , Q_R ) ; log ( R . join ( \" \" ) ) ; } function sign_s_main ( pa , pb ) { return ( pa [ 0 ] * pb [ 1 ] - pa [ 1 ] * pb [ 0 ] ) ; } function cross ( va , vb ) { return va [ 0 ] * vb [ 0 ] + va [ 1 ] * vb [ 1 ] ; } function v_m ( v , s ) { return [ v [ 0 ] * s , v [ 1 ] * s ] ; } function v_a ( v1 , v2 ) { return [ v1 [ 0 ] + v2 [ 0 ] , v1 [ 1 ] + v2 [ 1 ] ] ; }",
    "label": 2
  },
  {
    "code": "var Vector2D = class Vector2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } Vector2D . prototype . Init = function ( x , y ) { this . x = x ; this . y = y ; } function rotateVector90 ( v ) { var r = new Vector2D ( ) ; r . x = - v . y ; r . y = v . x ; return r ; } function getDegreeToRadian ( degree ) { var pi = 3.14159265358979323846 ; return degree * pi / 180 ; } function getRotateVector ( vec , degree ) { var radian = getDegreeToRadian ( degree ) ; var sin = Math . sin ( radian ) ; var cos = Math . cos ( radian ) ; var r = new Vector2D ( ) ; r . x = vec . x * cos - vec . y * sin ; r . y = vec . x * sin + vec . y * cos ; return r ; } function isEqualVectors ( a , b ) { return equalFloats ( a . x - b . x , 0 ) && equalFloats ( a . y - b . y , 0 ) ; } function getUnitVector ( vec ) { var length = getVectorLength2D ( vec ) ; if ( length > 0 ) { return getDivideVector ( vec , length ) ; } return vec ; } function getVectorLength2D ( vec ) { return Math . sqrt ( ( vec . x * vec . x ) + ( vec . y * vec . y ) ) ; } function getDivideVector ( vec2D , length ) { vec2D . x = vec2D . x / length ; vec2D . y = vec2D . y / length ; return vec2D ; } function equalFloats ( a , b ) { var threshold = 1 / 8192 ; return Math . abs ( a - b ) < threshold ; } function isParallelVector ( vectorA , vectorB ) { var na = rotateVector90 ( vectorA ) ; return equalFloats ( 0 , dotProduct2D ( na , vectorB ) ) ; } function subtractVector ( vecA , vecB ) { var vec = new Vector2D ( ) ; vec . x = vecA . x - vecB . x ; vec . y = vecA . y - vecB . y ; return vec ; } function dotProduct2D ( vecA , vecB ) { return vecA . x * vecB . x + vecA . y * vecB . y ; } var LineSegment2D = class LineSegment2D { constructor ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } } LineSegment2D . prototype . Init = function ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } function Line ( ) { this . base ; this . direction } Line . prototype . Init = function ( base , direction , color ) { this . base = base ; this . direction = direction ; } var Range = class Range { constructor ( min , max ) { this . min = min ; this . max = max ; } } function getMaxMinRange ( range1 , range2 ) { var range = new Range ( ) ; range . min = range1 . min < range2 . min ? range1 . min : range2 . min ; range . max = range1 . max < range2 . max ? range2 . max : range1 . max ; return range ; } function getSortRange ( range ) { var sorted = new Range ( range . min , range . max ) ; if ( range . min > range . max ) { sorted . min = range . max ; sorted . max = range . min ; } return sorted ; } function getNegateVector ( vector ) { vector . x = - vector . x ; vector . y = - vector . y ; return vector ; } function getAddVector ( vecA , vecB ) { return new Vector2D ( vecA . x + vecB . x , vecA . y + vecB . y ) ; } function getProjectSegment ( segment , onto ) { var ontoUnitVec = getUnitVector ( onto ) ; var range = new Range ( ) ; range . min = dotProduct2D ( ontoUnitVec , segment . point1 ) ; range . max = dotProduct2D ( ontoUnitVec , segment . point2 ) ; range = getSortRange ( range ) ; return range ; } function isOverLappingRanges ( range1 , range2 ) { return overLapping ( range1 . min , range1 . max , range2 . min , range2 . max ) ; } function projectVector ( project , onto ) { var d = dotProduct2D ( onto , onto ) ; console . log ( \" d = \" + d ) ; if ( 0 < d ) { var dp = dotProduct2D ( project , onto ) ; console . log ( \" dp = \" + dp ) ; return multiplyVector ( onto , dp / d ) ; } return onto ; } function getNorm ( vec ) { return vec . x * vec . x + vec . y * vec . y ; } var Point2D = class Point2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } function addPoint ( point1 , point2 ) { return new Point2D ( point1 . x + point2 . x , point1 . y + point2 . y ) ; } function subtractPoint ( point1 , point2 ) { return new Point2D ( point1 . x - point2 . x , point1 . y - point2 . y ) ; } function multiplyPoint ( point , scalar ) { return new Point2D ( point . x * scalar , point . y * scalar ) ; } function getProjectPoint ( segment , point ) { var vec1 = new Vector2D ( segment . point2 . x - segment . point1 . x , segment . point2 . y - segment . point1 . y ) ; var vec2 = new Vector2D ( point . x - segment . point1 . x , point . y - segment . point1 . y ) ; var rate = dotProduct2D ( vec2 , vec1 ) / getNorm ( vec1 ) ; var vec3 = multiplyVector ( vec1 , rate ) ; var project = new Point2D ( segment . point1 . x + vec3 . x , segment . point1 . y + vec3 . y ) ; return project ; } function getReflectionPoint ( segment , point ) { var projection = getProjectPoint ( segment , point ) ; var vec = subtractPoint ( projection , point ) ; var refrectionPoint = multiplyPoint ( vec , 2 ) ; return addPoint ( refrectionPoint , point ) ; } function multiplyVector ( vec , scalar ) { var temp = new Vector2D ( ) ; temp . x = vec . x * scalar ; temp . y = vec . y * scalar ; return temp ; } function clampOnRange ( x , min , max ) { if ( x < min ) { return min ; } else if ( x > max ) { return max ; } else { return x ; } } let input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; let Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; let l = Arr . length ; for ( var i = 0 ; i < l ; ++ i ) { let nums = Arr [ 0 ] . split ( \" , \" ) . map ( Number ) ; let p1 = new Point2D ( nums [ 0 ] , nums [ 1 ] ) ; let p2 = new Point2D ( nums [ 2 ] , nums [ 3 ] ) ; let segment = new LineSegment2D ( p1 , p2 ) ; let p = new Point2D ( nums [ 4 ] , nums [ 5 ] ) ; let refrectionPoint = getReflectionPoint ( segment , p ) ; console . log ( refrectionPoint . x . toFixed ( 10 ) + \" \" + refrectionPoint . y . toFixed ( 10 ) ) ; Arr . shift ( ) ; }",
    "label": 2
  },
  {
    "code": "function G ( y , m , d ) { var date = new Date ( m + \" / \" + d + \" / \" + y ) ; return date . getTime ( ) ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; var y = arr [ 0 ] ; var m = arr [ 1 ] ; var d = arr [ 2 ] ; var time = G ( y , m , d ) ; var str = \" \" ; if ( time < G ( 1868 , 9 , 8 ) ) str = \" pre-meiji \" ; if ( time >= G ( 1868 , 9 , 8 ) ) str = \" meiji \" + ( y - 1868 + 1 ) + \" \" + m + \" \" + d ; if ( time >= G ( 1912 , 7 , 30 ) ) str = \" taisho \" + ( y - 1912 + 1 ) + \" \" + m + \" \" + d ; if ( time >= G ( 1926 , 12 , 25 ) ) str = \" showa \" + ( y - 1926 + 1 ) + \" \" + m + \" \" + d ; if ( time >= G ( 1989 , 1 , 8 ) ) str = \" heisei \" + ( y - 1989 + 1 ) + \" \" + m + \" \" + d ; console . log ( str ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var arr = line . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; var year = arr [ 0 ] ; var month = arr [ 1 ] ; var day = arr [ 2 ] ; var era = ' ' ; var today = new Date ( year , month - 1 , day ) ; if ( today < new Date ( 1868 , 8 , 8 ) ) { era = ' pre-meiji ' ; } else if ( today < new Date ( 1912 , 6 , 30 ) ) { era = ' meiji ' ; year -= 1867 ; } else if ( today < new Date ( 1926 , 11 , 25 ) ) { era = ' taisho ' ; year -= 1911 ; } else if ( today < new Date ( 1989 , 0 , 8 ) ) { era = ' showa ' ; year -= 1925 ; } else { era = ' heisei ' ; year -= 1988 ; } if ( era == ' pre-meiji ' ) { console . log ( ' pre-meiji ' ) ; continue ; } console . log ( era , year , month , day ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var nm = arr . shift ( ) ; if ( nm == \" 0 0 \" ) break ; nm = nm . split ( \" \" ) . map ( Number ) ; var n = nm [ 0 ] ; var m = nm [ 1 ] ; var ary = [ ] ; for ( var i = 0 ; i <= n ; i ++ ) ary [ i ] = true ; var i = 1 ; var j = 0 ; var cnt = 0 ; while ( true ) { if ( ary [ i ] ) { j ++ ; if ( j == m ) { ary [ i ] = false ; j = 0 ; cnt ++ ; if ( cnt == ary . length - 2 ) break ; } } i ++ ; if ( ary . length - 1 < i ) i = 1 ; } for ( var i = 1 ; i <= n ; i ++ ) { if ( ary [ i ] ) console . log ( i ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; var line ; while ( line = lines . shift ( ) ) { var nums = line . split ( ' ' ) ; var n = + nums [ 0 ] ; var m = + nums [ 1 ] ; if ( n + m == 0 ) break ; var p = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { p . push ( i + 1 ) ; } while ( p . length > 1 ) { for ( var i = 0 ; i < m - 1 ; i ++ ) { p . push ( p . shift ( ) ) ; } p . shift ( ) ; } console . log ( p [ 0 ] ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { if ( Arr . length == 0 ) break ; var arr = Arr . shift ( ) . split ( \" \" ) ; var s = [ ] ; arr . forEach ( function ( v ) { if ( / \\d / . test ( v ) ) { s . unshift ( v - 0 ) ; } else { var a = s . shift ( ) ; var b = s . shift ( ) ; if ( v == \" + \" ) s . unshift ( b + a ) ; if ( v == \" - \" ) s . unshift ( b - a ) ; if ( v == \" * \" ) s . unshift ( b * a ) ; if ( v == \" / \" ) s . unshift ( b / a ) ; } } ) ; console . log ( s [ 0 ] . toFixed ( 6 ) ) ; }",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; y = x . trim ( ) . split ( \" \\n \" ) ; while ( true ) { if ( y . length == 0 ) break ; var z = y . shift ( ) . split ( \" \" ) ; var s = [ ] ; z . forEach ( function ( v ) { if ( / \\d / . test ( v ) ) { s . unshift ( v - 0 ) ; } else { a = s . shift ( ) ; b = s . shift ( ) ; if ( v == \" + \" ) s . unshift ( b + a ) ; if ( v == \" - \" ) s . unshift ( b - a ) ; if ( v == \" * \" ) s . unshift ( b * a ) ; if ( v == \" / \" ) s . unshift ( b / a ) ; } } ) ; console . log ( s [ 0 ] . toFixed ( 6 ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . slice ( 0 , - 1 ) ) . split ( \" \\n \" ) ; var obj = { } ; obj [ \" \" ] = \" 101 \" ; obj [ \" ' \" ] = \" 000000 \" ; obj [ \" , \" ] = \" 000011 \" ; obj [ \" - \" ] = \" 10010001 \" ; obj [ \" . \" ] = \" 010001 \" ; obj [ \" ? \" ] = \" 000001 \" ; obj [ \" A \" ] = \" 100101 \" ; obj [ \" B \" ] = \" 10011010 \" ; obj [ \" C \" ] = \" 0101 \" ; obj [ \" D \" ] = \" 0001 \" ; obj [ \" E \" ] = \" 110 \" ; obj [ \" F \" ] = \" 01001 \" ; obj [ \" G \" ] = \" 10011011 \" ; obj [ \" H \" ] = \" 010000 \" ; obj [ \" I \" ] = \" 0111 \" ; obj [ \" J \" ] = \" 10011000 \" ; obj [ \" K \" ] = \" 0110 \" ; obj [ \" L \" ] = \" 00100 \" ; obj [ \" M \" ] = \" 10011001 \" ; obj [ \" N \" ] = \" 10011110 \" ; obj [ \" O \" ] = \" 00101 \" ; obj [ \" P \" ] = \" 111 \" ; obj [ \" Q \" ] = \" 10011111 \" ; obj [ \" R \" ] = \" 1000 \" ; obj [ \" S \" ] = \" 00110 \" ; obj [ \" T \" ] = \" 00111 \" ; obj [ \" U \" ] = \" 10011100 \" ; obj [ \" V \" ] = \" 10011101 \" ; obj [ \" W \" ] = \" 000010 \" ; obj [ \" X \" ] = \" 10010010 \" ; obj [ \" Y \" ] = \" 10010011 \" ; obj [ \" Z \" ] = \" 10010000 \" ; obj [ \" 00000 \" ] = \" A \" ; obj [ \" 00001 \" ] = \" B \" ; obj [ \" 00010 \" ] = \" C \" ; obj [ \" 00011 \" ] = \" D \" ; obj [ \" 00100 \" ] = \" E \" ; obj [ \" 00101 \" ] = \" F \" ; obj [ \" 00110 \" ] = \" G \" ; obj [ \" 00111 \" ] = \" H \" ; obj [ \" 01000 \" ] = \" I \" ; obj [ \" 01001 \" ] = \" J \" ; obj [ \" 01010 \" ] = \" K \" ; obj [ \" 01011 \" ] = \" L \" ; obj [ \" 01100 \" ] = \" M \" ; obj [ \" 01101 \" ] = \" N \" ; obj [ \" 01110 \" ] = \" O \" ; obj [ \" 01111 \" ] = \" P \" ; obj [ \" 10000 \" ] = \" Q \" ; obj [ \" 10001 \" ] = \" R \" ; obj [ \" 10010 \" ] = \" S \" ; obj [ \" 10011 \" ] = \" T \" ; obj [ \" 10100 \" ] = \" U \" ; obj [ \" 10101 \" ] = \" V \" ; obj [ \" 10110 \" ] = \" W \" ; obj [ \" 10111 \" ] = \" X \" ; obj [ \" 11000 \" ] = \" Y \" ; obj [ \" 11001 \" ] = \" Z \" ; obj [ \" 11010 \" ] = \" \" ; obj [ \" 11011 \" ] = \" . \" ; obj [ \" 11100 \" ] = \" , \" ; obj [ \" 11101 \" ] = \" - \" ; obj [ \" 11110 \" ] = \" ' \" ; obj [ \" 11111 \" ] = \" ? \" ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) ; var str = \" \" ; for ( var i = 0 ; i < arr . length ; i ++ ) { str += obj [ arr [ i ] ] ; } while ( str . length % 5 != 0 ) { str += \" 0 \" ; } str = str . replace ( / (.....) / g , function ( s ) { return obj [ s ] ; } ) ; console . log ( str ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( y , x , sum ) { YX [ y ] [ x ] = sum ; if ( y == yx . length - 1 ) { max = Math . max ( max , sum ) ; } else if ( ( yx . length - 1 ) / 2 > y ) { if ( YX [ y + 1 ] [ x ] < sum + yx [ y + 1 ] [ x ] ) bomb ( y + 1 , x , sum + yx [ y + 1 ] [ x ] ) ; if ( YX [ y + 1 ] [ x + 1 ] < sum + yx [ y + 1 ] [ x + 1 ] ) bomb ( y + 1 , x + 1 , sum + yx [ y + 1 ] [ x + 1 ] ) ; } else if ( ( yx . length - 1 ) / 2 <= y ) { if ( x - 1 >= 0 ) { if ( YX [ y + 1 ] [ x - 1 ] < sum + yx [ y + 1 ] [ x - 1 ] ) bomb ( y + 1 , x - 1 , sum + yx [ y + 1 ] [ x - 1 ] ) ; } if ( x < yx [ y ] . length - 1 ) { if ( YX [ y + 1 ] [ x ] < sum + yx [ y + 1 ] [ x ] ) bomb ( y + 1 , x , sum + yx [ y + 1 ] [ x ] ) ; } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var yx = [ ] ; var YX = [ ] ; Arr . forEach ( function ( v ) { var x = v . split ( \" , \" ) . map ( Number ) ; var X = x . map ( function ( v ) { return 0 ; } ) ; yx . push ( x ) ; YX . push ( X ) ; } ) ; var max = 0 ; bomb ( 0 , 0 , yx [ 0 ] [ 0 ] ) ; console . log ( max ) ;",
    "label": 2
  },
  {
    "code": "function check ( x ) { if ( x % 4 != 0 ) return false ; if ( x % 400 == 0 ) return true ; if ( x % 100 == 0 ) return false ; return true ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == \" 0 0 \" ) break ; if ( i != 0 ) console . log ( \" \" ) ; var a = ( Arr [ i ] . split ( \" \" ) ) [ 0 ] - 0 ; var b = ( Arr [ i ] . split ( \" \" ) ) [ 1 ] - 0 ; var arr = [ ] ; for ( var j = a ; j <= b ; j ++ ) { if ( check ( j ) ) arr . push ( j ) ; } if ( arr . length == 0 ) console . log ( \" NA \" ) ; if ( arr . length != 0 ) arr . forEach ( function ( v ) { console . log ( v ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "function check ( x ) { if ( x % 4 != 0 ) return false ; if ( x % 400 == 0 ) return true ; if ( x % 100 == 0 ) return false ; return true ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == \" 0 0 \" ) break ; if ( i != 0 ) console . log ( \" \" ) ; var a = ( Arr [ i ] . split ( \" \" ) ) [ 0 ] - 0 ; var b = ( Arr [ i ] . split ( \" \" ) ) [ 1 ] - 0 ; var arr = [ ] ; for ( var j = a ; j <= b ; j ++ ) { if ( check ( j ) ) arr . push ( j ) ; } if ( arr . length == 0 ) console . log ( \" NA \" ) ; if ( arr . length != 0 ) arr . forEach ( function ( v ) { console . log ( v ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; for ( i = 0 ; i < x . length - 2 ; i += 2 ) { count = 0 ; y = x [ i ] ; if ( i != 0 || i == x . length - 1 ) console . log ( \" \" ) ; if ( y + x [ i + 1 ] == 0 ) break ; arr = [ ] ; for ( ; y <= x [ i + 1 ] ; y ++ ) { if ( y % 400 == 0 || ( y % 4 == 0 && y % 100 != 0 ) ) { arr . push ( y ) ; count ++ ; } } if ( count == 0 ) { console . log ( \" NA \" ) ; } else { arr . forEach ( function ( v ) { console . log ( v ) ; } ) ; } }",
    "label": 2
  },
  {
    "code": "function isLeapYear ( y ) { return y % 4 === 0 && ( y % 100 !== 0 || y % 400 === 0 ) ; } function main ( ) { var i , a , b , line , leaps , len = input . length ; for ( i = 0 ; i < len ; i ++ ) { line = input [ i ] . split ( ' ' ) . map ( parseFloat ) ; a = line [ 0 ] ; b = line [ 1 ] ; if ( a === 0 && b === 0 ) break ; if ( i !== 0 ) { console . log ( ' ' ) ; } leaps = [ ] ; for ( ; a <= b ; a ++ ) { if ( isLeapYear ( a ) ) leaps . push ( a ) ; } console . log ( leaps . length ? leaps . join ( ' \\n ' ) : ' NA ' ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function isLeap ( year ) { if ( year % 400 == 0 ) return true ; else if ( year % 100 == 0 ) return false ; else if ( year % 4 == 0 ) return true ; else return false ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var lines = input . split ( ' \\n ' ) ; var strAll = ' ' ; while ( true ) { var years = lines . shift ( ) . split ( ' ' ) ; var from = + years [ 0 ] ; var to = + years [ 1 ] ; if ( from + to == 0 ) break ; var str = ' ' ; for ( var i = from ; i <= to ; i ++ ) { if ( isLeap ( i ) ) { str += i + ' \\n ' ; } } if ( str . length == 0 ) { str += ' NA \\n ' ; } strAll += str + ' \\n ' ; } strAll = strAll . substr ( 0 , strAll . length - 2 ) ; console . log ( strAll ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \" ) . map ( Number ) ; var a = Arr [ 0 ] * Arr [ 1 ] / 3.305785 ; console . log ( a . toFixed ( 4 ) ) ;",
    "label": 2
  },
  {
    "code": "var arr = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( / \\s / ) ; console . log ( arr [ 0 ] * arr [ 1 ] / 3.305785 ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; i = 0 ; for ( console . log ( Math . floor ( x [ i ++ ] * x [ i ++ ] / 0.000003305785 ) / 1000000 ) ; i < x . length - 1 ; ) { }",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; console . log ( Math . floor ( x [ 0 ] * x [ 1 ] / 0.000003305785 ) / 1000000 ) ;",
    "label": 2
  },
  {
    "code": "x = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( / \\s / ) ; console . log ( Math . floor ( x [ 0 ] * x [ 1 ] / 0.000003305785 ) / 1000000 ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { var ab = input . split ( ' ' ) ; console . log ( ab [ 0 ] * ab [ 1 ] / 3.305785 ) ; } ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var inputs = input . replace ( / \\r / g , ' ' ) . split ( \" \\n \" ) [ 0 ] . split ( ' ' ) , a = parseInt ( inputs . shift ( ) ) , b = parseInt ( inputs . shift ( ) ) , square = a * b , tsubo = square / 3.305785 ; console . log ( tsubo . toFixed ( 6 ) ) ; } ) ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( ) { var input = ' ' ; function main ( ) { var a , b , nums , TSUBO = 3.305785 ; nums = input . split ( ' ' ) ; a = parseInt ( nums [ 0 ] , 10 ) ; b = parseInt ( nums [ 1 ] , 10 ) ; console . log ( a * b / TSUBO ) ; } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input . split ( ' \\n ' ) ; main ( ) ; } ) ; } ( ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( ) { var input = ' ' ; function main ( ) { var a , b , nums , TSUBO = 3.305785 ; nums = input [ 0 ] . split ( ' ' ) ; a = parseInt ( nums [ 0 ] , 10 ) ; b = parseInt ( nums [ 1 ] , 10 ) ; console . log ( a * b / TSUBO ) ; } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ; } ( ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var nums = input . trim ( ) . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; var S = ( nums [ 0 ] * nums [ 1 ] ) / 3.305785 ; console . log ( S . toFixed ( 5 ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . shift ( ) ; var max = 0 ; var arr = [ ] ; Arr . forEach ( function ( v ) { var a = ( v . split ( \" \" ) ) [ 0 ] - 0 ; var b = ( v . split ( \" \" ) ) [ 1 ] - 0 ; if ( max == b ) arr . push ( a ) ; if ( max < b ) { max = b ; arr = [ a ] ; } } ) ; arr . sort ( function ( a , b ) { return a - b ; } ) ; console . log ( arr [ 0 ] + \" \" + max ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var inputs = input . replace ( / \\r / g , ' ' ) . split ( \" \\n \" ) , data = [ ] , n , line , max_index , a , b ; n = parseInt ( inputs . shift ( ) ) ; max_index = 101 ; max_value = - 1 ; while ( n -- ) { line = inputs . shift ( ) . split ( ' ' ) ; a = parseInt ( line [ 0 ] ) ; b = parseInt ( line [ 1 ] ) ; if ( b > max_value || b === max_value && a < max_index ) { max_index = a ; max_value = b ; } } console . log ( max_index + \" \" + max_value ) ; } ) ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var ab = [ ] ; for ( var i = 0 ; i <= 2000 ; i ++ ) ab [ i ] = 0 ; for ( var i = 0 ; i <= 1000 ; i ++ ) { for ( var j = 0 ; j <= 1000 ; j ++ ) { ab [ i + j ] ++ ; } } var arr = [ ] ; for ( var i = 0 ; i <= 4000 ; i ++ ) arr [ i ] = 0 ; for ( var i = 0 ; i < ab . length ; i ++ ) { for ( var j = 0 ; j < ab . length ; j ++ ) { arr [ i + j ] += ab [ i ] * ab [ j ] ; } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( Arr . length != 0 ) { console . log ( arr [ Arr . shift ( ) - 0 ] ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; var nq = arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var player = [ ] ; var maxValue = 0 ; var maxId = 0 ; for ( var i = 0 ; i < nq [ 0 ] ; i ++ ) player [ i ] = 0 ; arr . forEach ( function ( V ) { var av = V . split ( \" \" ) . map ( Number ) ; var a = av [ 0 ] - 1 ; var v = av [ 1 ] ; player [ a ] += v ; if ( a == maxId && v >= 0 ) maxValue += v ; else if ( maxValue == player [ a ] && maxId > a ) maxId = a ; else if ( maxValue < player [ a ] ) { maxValue = player [ a ] ; maxId = a ; } else if ( a == maxId && v < 0 ) { var max = ( - 1 * Infinity ) ; player . forEach ( function ( value , index ) { if ( max < value ) { max = value ; maxValue = value ; maxId = index ; } } ) ; } console . log ( ( maxId + 1 ) + \" \" + maxValue ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var obj = { } ; var abc = [ ] ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; if ( i != 0 && arr . length == 1 ) { var cnt = 0 ; for ( var j = 0 ; j < abc . length ; j ++ ) { if ( obj [ abc [ j ] ] >= 1000000 ) { console . log ( abc [ j ] ) ; cnt ++ ; } } if ( cnt == 0 ) console . log ( \" NA \" ) ; if ( arr [ 0 ] == 0 ) break ; obj = { } ; abc = [ ] ; } else if ( arr . length == 3 ) { if ( ! obj . hasOwnProperty ( arr [ 0 ] ) ) { obj [ arr [ 0 ] ] = arr [ 1 ] * arr [ 2 ] ; abc . push ( arr [ 0 ] ) ; } else obj [ arr [ 0 ] ] += arr [ 1 ] * arr [ 2 ] ; } }",
    "label": 2
  },
  {
    "code": "var d = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) ; while ( d [ 0 ] !== ' 0 ' ) { var lc = d . shift ( ) ; var data = [ ] ; for ( var i = 0 ; i < lc ; i ++ ) { var info = d . shift ( ) . split ( ' ' ) ; var j = - 1 ; for ( var k = 0 ; k < data . length ; k ++ ) { if ( data [ k ] . no === info [ 0 ] ) { j = k ; break ; } } var person = ( j === - 1 ) ? data [ data . length ] = { no : info [ 0 ] , sales : 0 } : data [ j ] ; person . sales += info [ 1 ] * info [ 2 ] ; } console . log ( data . filter ( function ( d ) { return d . sales >= 1000000 ; } ) . map ( function ( d ) { return d . no ; } ) . join ( ' \\n ' ) || ' NA ' ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var line = input . trim ( ) . split ( \" \\n \" ) ; var i = 0 ; for ( i = 0 ; i < line . length ; ) { var N = parseInt ( line [ i ++ ] . trim ( ) ) ; if ( N === 0 ) { break ; } else { var found , len , k , res , uid ; var qualified = [ ] , amount = [ ] ; for ( var j = 0 ; j < N ; ++ j ) { var dataset = line [ i ++ ] . trim ( ) . split ( \" \" ) ; res = parseInt ( dataset [ 1 ] ) * parseInt ( dataset [ 2 ] ) ; len = qualified . length ; found = 0 ; len = qualified . length ; uid = parseInt ( dataset [ 0 ] ) ; for ( k = 0 ; k < len ; ++ k ) { if ( qualified [ k ] === uid ) { found = 1 ; amount [ k ] = amount [ k ] + res ; break ; } } if ( found === 0 ) { qualified . push ( uid ) ; amount . push ( res ) ; } } found = 0 ; len = qualified . length ; for ( k = 0 ; k < len ; ++ k ) { if ( amount [ k ] >= 1000000 ) { console . log ( qualified [ k ] ) ; found = 1 ; } } if ( found === 0 ) { console . log ( \" NA \" ) ; } } } } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var line = input . trim ( ) . split ( \" \\n \" ) ; var i = 0 ; for ( i = 0 ; i < line . length ; ) { var N = parseInt ( line [ i ++ ] . trim ( ) ) ; if ( N === 0 ) { break ; } else { var found , len , k , res ; var qualified = [ ] , amount = [ ] ; for ( var j = 0 ; j < N ; ++ j ) { var dataset = line [ i ++ ] . trim ( ) . split ( \" \" ) ; res = parseInt ( dataset [ 1 ] ) * parseInt ( dataset [ 2 ] ) ; len = qualified . length ; found = 0 ; len = qualified . length ; for ( k = 0 ; k < len ; ++ k ) { if ( qualified [ k ] == dataset [ 0 ] ) { found = 1 ; amount [ k ] = amount [ k ] + res ; break ; } } if ( ! found ) { qualified . push ( dataset [ 0 ] ) ; amount . push ( res ) ; } } found = 0 ; len = qualified . length ; for ( k = 0 ; k < len ; ++ k ) { if ( amount [ k ] >= 1000000 ) { console . log ( qualified [ k ] ) ; found = 1 ; } } if ( ! found ) { console . log ( \" NA \" ) ; } } } } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var line = input . trim ( ) . split ( \" \\n \" ) ; var i = 0 ; for ( i = 0 ; i < line . length ; ) { var N = parseInt ( line [ i ++ ] . trim ( ) ) ; if ( N === 0 ) { break ; } else { var found , len , k , res ; var qualified = [ ] , amount = [ ] ; for ( var j = 0 ; j < N ; ++ j ) { var dataset = line [ i ++ ] . trim ( ) . split ( \" \" ) ; res = parseInt ( dataset [ 1 ] ) * parseInt ( dataset [ 2 ] ) ; found = 0 ; len = qualified . length ; for ( k = 0 ; k < len ; ++ k ) { if ( qualified [ k ] == dataset [ 0 ] ) { found = 1 ; amount [ k ] = amount [ k ] + res ; break ; } } if ( ! found ) { qualified . push ( dataset [ 0 ] ) ; amount . push ( res ) ; } } found = 0 ; len = qualified . length ; for ( k = 0 ; k < len ; ++ k ) { if ( amount [ k ] >= 1000000 ) { console . log ( qualified [ k ] ) ; found = 1 ; } } if ( ! found ) { console . log ( \" NA \" ) ; } } } } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var line = input . trim ( ) . split ( \" \\n \" ) ; var i = 0 ; while ( line [ i ] !== ' 0 ' ) { var N = parseInt ( line [ i ++ ] . trim ( ) ) ; { var found , res ; var qualified = [ ] , amount = [ ] ; for ( -- N ; N >= 0 ; -- N ) { var dataset = line [ i ++ ] . trim ( ) . split ( \" \" ) ; res = parseInt ( dataset [ 1 ] ) * parseInt ( dataset [ 2 ] ) ; for ( k = 0 ; k < qualified . length ; ++ k ) { if ( qualified [ k ] == dataset [ 0 ] ) { amount [ k ] += res ; break ; } } if ( k >= qualified . length ) { qualified . push ( dataset [ 0 ] ) ; amount . push ( res ) ; } } found = 0 ; for ( k = 0 ; k < qualified . length ; ++ k ) { if ( amount [ k ] >= 1000000 ) { console . log ( qualified [ k ] ) ; found = 1 ; } } if ( ! found ) { console . log ( \" NA \" ) ; } } } } ) ;",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var line = input . trim ( ) . split ( \" \\n \" ) ; var i = 0 ; while ( line [ i ] !== ' 0 ' ) { var N = parseInt ( line [ i ++ ] . trim ( ) ) ; { var found , len , k , res ; var qualified = [ ] , amount = [ ] ; for ( -- N ; N >= 0 ; -- N ) { var dataset = line [ i ++ ] . trim ( ) . split ( \" \" ) ; res = parseInt ( dataset [ 1 ] ) * parseInt ( dataset [ 2 ] ) ; found = 0 ; for ( k = 0 ; k < qualified . length ; ++ k ) { if ( qualified [ k ] == dataset [ 0 ] ) { found = 1 ; amount [ k ] = amount [ k ] + res ; break ; } } if ( ! found ) { qualified . push ( dataset [ 0 ] ) ; amount . push ( res ) ; } } found = 0 ; len = qualified . length ; for ( k = 0 ; k < len ; ++ k ) { if ( amount [ k ] >= 1000000 ) { console . log ( qualified [ k ] ) ; found = 1 ; } } if ( ! found ) { console . log ( \" NA \" ) ; } } } } ) ;",
    "label": 2
  },
  {
    "code": "function main ( input ) { var lines = input . split ( \" \\n \" ) ; var dataSetLength = parseInt ( lines [ 0 ] ) ; var currentLine = 1 ; var salesTotals = [ ] ; while ( currentLine < lines . length && dataSetLength > 0 ) { var sale = lines [ currentLine ] . split ( \" \" ) . map ( function ( value ) { return parseInt ( value ) } ) ; if ( sale . length === 1 ) { var validSales = salesTotals . reduce ( function ( result , value ) { if ( value . salesTotal >= 1000000 ) { result . push ( value . id ) ; } return result ; } , [ ] ) ; if ( validSales . length <= 0 ) { console . log ( \" NA \" ) ; } else { for ( var i = 0 ; i < validSales . length ; i ++ ) { if ( ! isNaN ( validSales [ i ] ) ) console . log ( validSales [ i ] ) ; } } salesTotals = [ ] ; dataSetLength = parseInt ( sale [ 0 ] ) ; } else if ( ! isNaN ( sale [ 1 ] ) && ! isNaN ( sale [ 2 ] ) ) { var saleIndex = 0 ; for ( ; saleIndex < salesTotals . length ; saleIndex ++ ) { if ( salesTotals [ saleIndex ] . id === sale [ 0 ] ) break ; } var currentSalesTotal = ( salesTotals [ saleIndex ] || { salesTotal : 0 } ) . salesTotal ; salesTotals [ saleIndex ] = { id : sale [ 0 ] , salesTotal : currentSalesTotal + ( sale [ 1 ] * sale [ 2 ] ) } ; } currentLine ++ ; } } main ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ) ;",
    "label": 2
  },
  {
    "code": "var print = console . log ; function read_input ( _input ) { var lines = _input . split ( \" \\n \" ) ; return function ( ) { return lines . shift ( ) ; } ; } String . prototype . dot = function dot ( x ) { var res = \" \" ; for ( var i = 0 ; i < x ; i ++ ) { res += this . toString ( ) ; } return res ; } ; function IL ( line , min1Flg ) { var s = line . split ( ' ' ) ; var offset = min1Flg ? - 1 : 0 ; var res = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { res . push ( parseInt ( s [ i ] ) ) ; } return res ; } function range ( i , n ) { var res = [ ] ; for ( ; i < n ; i ++ ) { res . push ( i ) ; } return res ; } function IMAX ( x , y ) { return x > y ? x : y ; } function IMIN ( x , y ) { return x < y ? x : y ; } function item_getter_key ( x ) { return function ( a , b ) { if ( a [ x ] < b [ x ] ) return - 1 ; else if ( a [ x ] > b [ x ] ) return 1 ; return 0 ; } ; } var Counter = function Counter ( ) { this . dic = { } ; var that = this ; this . add = function ( key , val ) { if ( that . dic . hasOwnProperty ( key ) ) { that . dic [ key ] += val ; } else { that . dic [ key ] = val ; } } ; this . get = function ( key ) { if ( that . dic . hasOwnProperty ( key ) ) { return that . dic [ key ] ; } return 0 ; } ; } ; Array . prototype . SUM = function SUM ( ) { var sum = 0 ; this . forEach ( function ( elm ) { sum += elm ; } ) ; return sum ; } ; Array . prototype . Print = function Print ( split ) { if ( split === undefined ) { split = \" \" ; } console . log ( this . join ( split ) ) ; } ; function Main ( _input ) { var input = read_input ( _input ) ; var N = parseInt ( input ( ) ) ; while ( N !== 0 ) { var keys = [ ] ; var counter = new Counter ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var tmp = IL ( input ( ) ) ; counter . add ( tmp [ 0 ] , tmp [ 1 ] * tmp [ 2 ] ) ; if ( keys . indexOf ( tmp [ 0 ] ) < 0 ) { keys . push ( tmp [ 0 ] ) ; } } var flg = false ; for ( var i = 0 ; i < keys . length ; i ++ ) { if ( counter . get ( keys [ i ] ) >= 1000000 ) { print ( keys [ i ] ) ; flg = true ; } } if ( ! flg ) { print ( ' NA ' ) ; } N = parseInt ( input ( ) ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "( function ( input ) { var inputs = input . replace ( / \\r / g , ' ' ) . split ( \" \\n \" ) , index = 0 , salesData = [ ] , exist ; while ( inputs [ index ] !== ' 0 ' ) { salesData = [ ] ; exist = false ; n = parseInt ( inputs [ index ++ ] ) ; for ( i = index ; i < n + index ; i ++ ) { datas = inputs [ i ] . split ( ' ' ) ; num = parseInt ( datas [ 0 ] ) ; sales = parseInt ( datas [ 1 ] ) * parseInt ( datas [ 2 ] ) ; for ( var j = 0 , len = salesData . length ; j < len ; j ++ ) { if ( salesData [ j ] . num === num ) { salesData [ j ] . sales += sales ; break ; } } if ( j >= len ) { salesData . push ( { num : num , sales : sales } ) ; } } salesData . forEach ( function ( employee ) { if ( employee . sales >= 1000000 ) { console . log ( employee . num ) ; exist = true ; } } ) ; if ( ! exist ) { console . log ( ' NA ' ) ; } index += n ; } } ) ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var L = ( Arr . shift ( ) ) - 0 ; for ( var i = 0 ; i < L ; i ++ ) { var str = Arr [ i ] ; console . log ( str . replace ( / Hoshino / g , \" Hoshina \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var d = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) ; d . shift ( ) ; d . forEach ( function ( p ) { console . log ( p . replace ( / Hoshino / g , ' Hoshina ' ) ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; lines . shift ( ) ; var line ; while ( line = lines . shift ( ) ) { console . log ( line . replace ( / Hoshino / g , ' Hoshina ' ) ) ; }",
    "label": 2
  },
  {
    "code": "String . prototype . rjust = function ( dig ) { var pre = ' ' ; for ( var i = 0 ; i < dig ; i ++ ) { pre += ' ' ; } return ( pre + this ) . slice ( - dig ) ; } ; Number . prototype . rjust = function ( dig ) { return ( this + ' ' ) . rjust ( dig ) ; } ; Array . prototype . rjust = function ( dig ) { return this . map ( function ( m ) { return m . rjust ( dig ) ; } ) ; } ; Array . prototype . sum = function ( ) { return this . reduce ( function ( m , n ) { return + n + m ; } , 0 ) ; } ; var d = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) ; while ( d [ 0 ] !== ' 0 ' ) { var lc = + d . shift ( ) ; var sums = [ ] ; var lastLine = [ ] ; for ( var i = 0 ; i < lc ; i ++ ) { var nums = d . shift ( ) . split ( ' ' ) ; sums . push ( nums ) ; nums . push ( nums . sum ( ) ) ; console . log ( nums . rjust ( 5 ) . join ( ' ' ) ) ; } for ( var i = 0 ; i < lc + 1 ; i ++ ) { lastLine . push ( sums . map ( function ( n ) { return n [ i ] ; } ) . sum ( ) ) ; } console . log ( lastLine . rjust ( 5 ) . join ( ' ' ) ) ; }",
    "label": 2
  },
  {
    "code": "Array . prototype . rjust = function ( dig ) { var pre = ' ' ; for ( var i = 0 ; i < dig ; i ++ ) { pre += ' ' ; } return this . map ( function ( m ) { return ( pre + m ) . slice ( - dig ) ; } ) ; } ; Array . prototype . sum = function ( ) { return this . reduce ( function ( m , n ) { return + n + m ; } , 0 ) ; } ; var d = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) ; while ( d [ 0 ] !== ' 0 ' ) { var lc = + d . shift ( ) ; var sums = [ ] ; var lastLine = [ ] ; for ( var i = 0 ; i < lc ; i ++ ) { var nums = d . shift ( ) . split ( ' ' ) ; nums . push ( nums . sum ( ) ) ; sums . push ( nums ) ; console . log ( nums . rjust ( 5 ) . join ( ' ' ) ) ; } for ( var i = 0 , max = lc + 1 ; i < max ; i ++ ) { lastLine . push ( sums . map ( function ( n ) { return n [ i ] ; } ) . sum ( ) ) ; } console . log ( lastLine . rjust ( 5 ) . join ( ' ' ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var S = [ ] ; for ( var i = 0 ; i <= n ; i ++ ) S [ i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var s = arr . reduce ( function ( a , b ) { return a + b ; } ) ; arr . push ( s ) ; arr . forEach ( function ( v , i ) { S [ i ] += v ; } ) ; arr . forEach ( function ( v , i ) { arr [ i ] = ( \" \" + v ) . slice ( - 5 ) } ) ; console . log ( arr . join ( \" \" ) ) ; } S . forEach ( function ( v , i ) { S [ i ] = ( \" \" + v ) . slice ( - 5 ) } ) ; console . log ( S . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var print = console . log ; function read_input ( _input ) { var lines = _input . split ( \" \\n \" ) ; return function ( ) { return lines . shift ( ) ; } ; } String . prototype . dot = function dot ( x ) { var res = \" \" ; for ( var i = 0 ; i < x ; i ++ ) { res += this . toString ( ) ; } return res ; } ; function IL ( line , min1Flg ) { var s = line . split ( ' ' ) ; var offset = min1Flg ? - 1 : 0 ; var res = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { res . push ( parseInt ( s [ i ] ) ) ; } return res ; } function range ( i , n ) { var res = [ ] ; for ( ; i < n ; i ++ ) { res . push ( i ) ; } return res ; } function IMAX ( x , y ) { return x > y ? x : y ; } function IMIN ( x , y ) { return x < y ? x : y ; } function item_getter_key ( x ) { return function ( a , b ) { if ( a [ x ] < b [ x ] ) return - 1 ; else if ( a [ x ] > b [ x ] ) return 1 ; return 0 ; } ; } Array . prototype . SUM = function SUM ( ) { var sum = 0 ; this . forEach ( function ( elm ) { sum += elm ; } ) ; return sum ; } ; Array . prototype . FORM = function FORM ( ) { return this . map ( function ( v ) { return ( ' ' + v ) . slice ( - 5 ) } ) ; } ; function Main ( _input ) { var lines = _input . split ( \" \\n \" ) ; while ( lines . length > 0 ) { var csum = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var N = lines . shift ( ) - 0 ; if ( N === 0 ) { return ; } for ( var i = 0 ; i < N ; i ++ ) { var tmp = IL ( lines . shift ( ) ) ; tmp . push ( tmp . SUM ( ) ) ; print ( tmp . FORM ( ) . join ( ' ' ) ) ; for ( var j = 0 ; j < N + 1 ; j ++ ) { csum [ j ] += tmp [ j ] ; } } print ( csum . splice ( 0 , N + 1 ) . FORM ( ) . join ( ' ' ) ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; var num ; while ( num = lines . shift ( ) ) { if ( num == ' 0 ' ) break ; var n = + num ; var m = [ ] ; var colsum = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var cols = lines . shift ( ) . split ( ' ' ) . map ( function ( n ) { return + n ; } ) ; cols [ cols . length ] = cols . reduce ( function ( p , n ) { return p + n ; } ) ; m . push ( cols ) ; for ( var j = 0 ; j < cols . length ; j ++ ) { if ( i == 0 ) { colsum . push ( cols [ j ] ) ; } else { colsum [ j ] += cols [ j ] ; } } } m . push ( colsum ) ; m . forEach ( function ( row ) { row . forEach ( function ( col ) { process . stdout . write ( ( ' ' + col ) . slice ( - 5 ) ) ; } ) ; console . log ( ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "var Baseball = function ( attackCount ) { this . attackCount = + attackCount ; this . outCount = 0 ; this . endCount = attackCount * 3 ; this . runners = [ ] ; this . score = 0 ; this . isChanged = false ; } ; Baseball . prototype . isEnd = function ( ) { return this . outCount === this . endCount ; } ; Baseball . prototype . echo = function ( ) { console . log ( this . score ) ; this . score = 0 ; this . runners = [ ] ; } ; Baseball . prototype . action = function ( command ) { switch ( command ) { case ' HIT ' : this . runners . push ( 0 ) ; this . runners = this . runners . map ( function ( r ) { return r + 1 ; } ) ; if ( this . runners [ 0 ] === 4 ) { this . score += 1 ; this . runners . shift ( ) ; } break ; case ' HOMERUN ' : this . score += this . runners . length + 1 ; this . runners = [ ] ; break ; case ' OUT ' : this . outCount += 1 ; if ( this . outCount % 3 === 0 ) return ' change ' break ; } return ' next ' ; } ; var d = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) . trim ( ) . split ( ' \\n ' ) ; var bb = new Baseball ( d . shift ( ) ) ; while ( true ) { if ( bb . action ( d . shift ( ) ) === ' change ' ) { bb . echo ( ) ; if ( bb . isEnd ( ) ) break ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var j = 0 ; j < n ; j ++ ) { var out = 0 ; var runner = 0 ; var score = 0 ; while ( out < 3 ) { var v = Arr . shift ( ) ; if ( v == \" HIT \" ) { runner ++ ; if ( runner == 4 ) { runner -- ; score ++ ; } } if ( v == \" HOMERUN \" ) { score += ( runner + 1 ) ; runner = 0 ; } if ( v == \" OUT \" ) out ++ ; } console . log ( score ) ; }",
    "label": 2
  },
  {
    "code": "var print = console . log ; function read_input ( _input ) { var lines = _input . split ( \" \\n \" ) ; var i = 0 ; return function ( ) { return lines [ i ++ ] ; } ; } String . prototype . dot = function dot ( x ) { var res = \" \" ; for ( var i = 0 ; i < x ; i ++ ) { res += this . toString ( ) ; } return res ; } ; function IL ( line , min1Flg ) { var s = line . split ( ' ' ) ; var offset = min1Flg ? - 1 : 0 ; var res = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { res . push ( parseInt ( s [ i ] ) ) ; } return res ; } function range ( i , n ) { var res = [ ] ; for ( ; i < n ; i ++ ) { res . push ( i ) ; } return res ; } function IMAX ( x , y ) { return x > y ? x : y ; } function IMIN ( x , y ) { return x < y ? x : y ; } function item_getter_key ( x ) { return function ( a , b ) { if ( a [ x ] < b [ x ] ) return - 1 ; else if ( a [ x ] > b [ x ] ) return 1 ; return 0 ; } ; } function Main ( _input ) { var input = read_input ( _input ) ; var N = parseInt ( input ( ) ) ; for ( var i = 0 ; i < N ; i ++ ) { var out = 0 ; var runner = 0 ; var pt = 0 ; while ( out < 3 ) { var v = input ( ) ; if ( v === ' HIT ' ) { if ( runner === 3 ) { pt += 1 ; } else { runner ++ ; } } else if ( v === ' HOMERUN ' ) { pt += runner + 1 ; runner = 0 ; } else { out ++ ; } } print ( pt ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var print = console . log ; function read_input ( _input ) { var lines = _input . split ( \" \\n \" ) ; return function ( ) { return lines . shift ( ) ; } ; } String . prototype . dot = function dot ( x ) { var res = \" \" ; for ( var i = 0 ; i < x ; i ++ ) { res += this . toString ( ) ; } return res ; } ; function IL ( line , min1Flg ) { var s = line . split ( ' ' ) ; var offset = min1Flg ? - 1 : 0 ; var res = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { res . push ( parseInt ( s [ i ] ) ) ; } return res ; } function range ( i , n ) { var res = [ ] ; for ( ; i < n ; i ++ ) { res . push ( i ) ; } return res ; } function IMAX ( x , y ) { return x > y ? x : y ; } function IMIN ( x , y ) { return x < y ? x : y ; } function item_getter_key ( x ) { return function ( a , b ) { if ( a [ x ] < b [ x ] ) return - 1 ; else if ( a [ x ] > b [ x ] ) return 1 ; return 0 ; } ; } function Main ( _input ) { var input = read_input ( _input ) ; var N = input ( ) - 0 ; for ( var i = 0 ; i < N ; i ++ ) { var out = 0 ; var runner = 0 ; var pt = 0 ; while ( out < 3 ) { var v = input ( ) ; if ( v === ' HIT ' ) { runner ++ ; if ( runner === 4 ) { pt ++ ; runner -- ; } } else if ( v === ' HOMERUN ' ) { pt += runner + 1 ; runner = 0 ; } else { out ++ ; } } print ( pt ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var print = console . log ; function read_input ( _input ) { var lines = _input . split ( \" \\n \" ) ; return function ( ) { return lines . shift ( ) ; } ; } function Main ( _input ) { var input = read_input ( _input ) ; var N = input ( ) - 0 ; for ( var i = 0 ; i < N ; i ++ ) { var out = 0 ; var runner = 0 ; var pt = 0 ; while ( out < 3 ) { var v = input ( ) ; if ( v === ' HIT ' ) { runner ++ ; if ( runner === 4 ) { pt ++ ; runner -- ; } } else if ( v === ' HOMERUN ' ) { pt += runner + 1 ; runner = 0 ; } else { out ++ ; } } print ( pt ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ; var lines = input . split ( ' \\n ' ) ; var inning = + lines . shift ( ) ; var out = 0 ; var score = 0 ; var runner = 0 ; var line ; while ( line = lines . shift ( ) ) { if ( line == ' HIT ' ) { runner ++ ; if ( runner > 3 ) { score ++ ; runner -- ; } } else if ( line == ' HOMERUN ' ) { score += runner + 1 ; runner = 0 ; } else { out ++ ; if ( out == 3 ) { console . log ( score ) ; out = 0 ; score = 0 ; runner = 0 ; continue ; } } }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ; function main ( ) { var i , n = + input [ 0 ] , lines = input . slice ( 1 ) ; for ( i = 0 ; i < n ; i ++ ) { console . log ( calc ( lines [ i ] ) ) ; } } function calc ( src ) { src = src . replace ( / ([-+*\\/()=]) / g , ' $1 ' ) . split ( ' ' ) . filter ( function ( s ) { return s . trim ( ) !== ' ' ; } ) ; return add ( src ) ; function add ( src ) { var ret = mul ( src ) ; while ( src [ 0 ] in { ' + ' : 1 , ' - ' : 1 } ) { switch ( src . shift ( ) ) { case ' + ' : ret += mul ( src ) ; break ; case ' - ' : ret -= mul ( src ) ; break ; } } return ret ; } function mul ( src ) { var val , sign , ret = prim ( src ) ; while ( src [ 0 ] in { ' * ' : 1 , ' / ' : 1 } ) { switch ( src . shift ( ) ) { case ' * ' : ret *= prim ( src ) ; break ; case ' / ' : val = prim ( src ) ; sign = ret * val < 0 ? - 1 : 1 ; ret = sign * Math . floor ( Math . abs ( ret ) / Math . abs ( val ) ) ; break ; } } return ret ; } function prim ( src ) { var ret , head = src . shift ( ) ; switch ( head ) { case ' + ' : return prim ( src ) ; case ' - ' : return - prim ( src ) ; case ' ( ' : ret = add ( src ) ; src . shift ( ) ; return ret ; default : return parseInt ( head , 10 ) ; } } }",
    "label": 2
  },
  {
    "code": "( function ( ) { var a = [ ] ; var stdin = process . openStdin ( ) ; stdin . setEncoding ( ' utf8 ' ) ; var proc = function ( s ) { var bidx , count , eidx , m ; bidx = s . indexOf ( ' ( ' ) ; while ( bidx !== - 1 ) { count = 1 ; eidx = bidx + 1 ; while ( count > 0 ) { if ( s [ eidx ] === ' ( ' ) { count ++ ; } if ( s [ eidx ] === ' ) ' ) { count -- ; } eidx ++ ; } s = s . substring ( 0 , bidx ) + proc ( s . substring ( bidx + 1 , eidx - 1 ) ) + s . substring ( eidx ) ; bidx = s . indexOf ( ' ( ' ) ; } while ( ( m = / ^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$ / . exec ( s ) ) != null ) { if ( m [ 3 ] === ' * ' ) { s = m [ 1 ] + ( parseInt ( m [ 2 ] ) * parseInt ( m [ 4 ] ) ) + m [ 5 ] ; } else { s = m [ 1 ] + ( parseInt ( m [ 2 ] ) / parseInt ( m [ 4 ] ) ^ 0 ) + m [ 5 ] ; } } while ( ( m = / ^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$ / . exec ( s ) ) != null ) { if ( m [ 3 ] === ' + ' ) { s = m [ 1 ] + ( parseInt ( m [ 2 ] ) + parseInt ( m [ 4 ] ) ) + m [ 5 ] ; } else { s = m [ 1 ] + ( parseInt ( m [ 2 ] ) - parseInt ( m [ 4 ] ) ) + m [ 5 ] ; } } return s ; } ; stdin . on ( ' data ' , function ( input ) { var e , x ; x = ( function ( ) { var _i , _len , _ref , _results ; _ref = input . split ( \" \\n \" ) ; _results = [ ] ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { e = _ref [ _i ] ; _results . push ( e ) ; } return _results ; } ) ( ) ; if ( x . length > 2 || ! isNaN ( x [ 1 ] ) ) { return a = x ; } else { return a . push ( x [ 0 ] ) ; } } ) ; stdin . on ( ' end ' , function ( z ) { var i , n , s , _i , _results ; n = parseInt ( a [ 0 ] ) ; _results = [ ] ; for ( i = _i = 1 ; 1 <= n ? _i <= n : _i >= n ; i = 1 <= n ? ++ _i : -- _i ) { s = a [ i ] . substring ( 0 , a [ i ] . indexOf ( ' = ' ) ) . replace ( / - / g , ' Z ' ) ; _results . push ( console . log ( proc ( s ) ) ) ; } return _results ; } ) ; } ) . call ( this ) ;",
    "label": 2
  },
  {
    "code": "#!/usr/bin/node (function() { var a=[]; var stdin = process.openStdin(); stdin.setEncoding('utf8'); var proc = function(s){ var bidx=s.indexOf('('),count,eidx,m; while(bidx!=-1){ eidx=bidx+1; for(count=1;count;eidx++){ if(s[eidx]=='(')count++; if(s[eidx]==')')count--; } s=s.substring(0,bidx)+proc(s.substring(bidx+1,eidx-1))+s.substring(eidx); bidx=s.indexOf('('); } while(m = /^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$/.exec(s)){ if (m[3] == '*') { s = m[1] + (parseInt(m[2]) * parseInt(m[4])) + m[5]; } else { s = m[1] + (parseInt(m[2]) / parseInt(m[4]) ^ 0) + m[5]; } } while(m = /^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$/.exec(s)){ if (m[3] == '+') { s = m[1] + (parseInt(m[2]) + parseInt(m[4])) + m[5]; } else { s = m[1] + (parseInt(m[2]) - parseInt(m[4])) + m[5]; } } return s; }; stdin.on('data', function(input) { var i=0,len,ref,x=[]; ref=input.split(\"\\n\"); for(len=ref.length;i<len;i++)x.push(ref[i]); if(x.length>2||!isNaN(x[1]))a=x; else a.push(x[0]); }); stdin.on('end', function(z) { var i,n,s; n = parseInt(a[0]); for(i=1;i<=n;i++){ s=a[i].substring(0,a[i].indexOf('=')).replace(/-/g,'Z'); console.log(proc(s)); } }); }).call(this);",
    "label": 2
  },
  {
    "code": "#!/usr/bin/node (function() { var a=[]; var stdin = process.openStdin(); stdin.setEncoding('utf8'); var proc = function(s){ var bidx=s.indexOf('('),count,eidx,m; while(bidx!=-1){ eidx=bidx+1; for(count=1;count;eidx++){ if(s[eidx]=='(')count++; if(s[eidx]==')')count--; } s=s.substring(0,bidx)+proc(s.substring(bidx+1,eidx-1))+s.substring(eidx); bidx=s.indexOf('('); } while(m = /^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$/.exec(s)){ if(m[3]=='*')s=m[1]+(parseInt(m[2])*parseInt(m[4]))+m[5]; else s=m[1]+(parseInt(m[2])/parseInt(m[4])^0)+m[5]; } while(m = /^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$/.exec(s)){ if(m[3]=='+')s=m[1]+(parseInt(m[2])+parseInt(m[4]))+m[5]; else s=m[1]+(parseInt(m[2])-parseInt(m[4]))+m[5]; } return s; }; stdin.on('data', function(input) { var i=0,len,ref,x=[]; ref=input.split(\"\\n\"); for(len=ref.length;i<len;i++)x.push(ref[i]); if(x.length>2||!isNaN(x[1]))a=x; else a.push(x[0]); }); stdin.on('end', function(z) { var i,n,s; n = parseInt(a[0]); for(i=1;i<=n;i++){ s=a[i].substring(0,a[i].indexOf('=')).replace(/-/g,'Z'); console.log(proc(s)); } }); }).call(this);",
    "label": 2
  },
  {
    "code": "\" use strict \" ; var util = require ( \" util \" ) , puts = console . log , p = util . print , cin = parseInput ( ) ; function expression ( ) { var n = term ( ) ; while ( true ) { if ( line [ idx ] == \" + \" ) { idx ++ ; n += term ( ) ; } else if ( line [ idx ] == \" - \" ) { idx ++ ; n -= term ( ) ; } else { break ; } } return n ; } function term ( ) { var n = factor ( ) ; while ( true ) { if ( line [ idx ] == \" * \" ) { idx ++ ; n *= factor ( ) ; } else if ( line [ idx ] == \" / \" ) { idx ++ ; n = ~ ~ ( n / factor ( ) ) ; } else { break ; } } return n ; } function factor ( ) { if ( line [ idx ] == \" ( \" ) { idx ++ ; var ret = expression ( ) ; idx ++ ; return ret ; } else { return number ( ) ; } } function number ( ) { var ret = 0 , sign = 1 ; if ( line [ idx ] == \" - \" ) { idx ++ ; sign = - 1 ; } while ( / ^\\d / . test ( line [ idx ] ) ) { ret = ret * 10 + + line [ idx ] ; idx ++ ; } return ret * sign ; } var n = cin . nextInt ( ) , line , idx ; while ( n -- ) { idx = 0 ; line = cin . next ( ) ; line = line . slice ( 0 , line . length - 1 ) ; puts ( expression ( ) ) ; } function parseInput ( useSplitSpace ) { var index = 0 , ret = [ ] , input = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) , inputs = input . replace ( / \\r / g , ' ' ) . split ( \" \\n \" ) ; useSplitSpace = useSplitSpace || true ; inputs . forEach ( function ( val ) { if ( useSplitSpace && val !== \" \" ) { val . split ( \" \" ) . forEach ( function ( el ) { if ( el !== \" \" ) ret . push ( el ) ; } ) ; } else { ret . push ( val ) ; } } ) ; return { hasNext : function ( val ) { if ( typeof val === \" undefined \" ) { return typeof ret [ index ] !== \" undefined \" ; } else { return ret [ index ] === val ; } } , next : function ( ) { if ( typeof ret [ index + 1 ] === \" undefined \" ) throw new RangeError ( \" Index out of bounds at ' \" + index + 1 + \" ' \" ) ; return ret [ index ++ ] ; } , nextNumber : function ( ) { if ( ! / ^\\d+$ / . test ( this . top ( ) ) ) throw new TypeError ( \" ' \" + this . top ( ) + \" ' cannot convet to Number \" ) ; return + this . next ( ) ; } , nextInt : function ( ) { return parseInt ( this . nextNumber ( ) ) ; } , top : function ( ) { return ret [ index ] ; } , rewind : function ( ) { index = 0 ; } } ; }",
    "label": 2
  },
  {
    "code": "function bigAdd ( x , y ) { var a = ( x + \" \" ) . split ( \" \" ) . reverse ( ) . map ( Number ) ; var b = ( y + \" \" ) . split ( \" \" ) . reverse ( ) . map ( Number ) ; var c = [ ] ; var max = Math . max ( a . length , b . length ) ; for ( var i = 0 ; i < max + 1 ; i ++ ) c [ i ] = 0 ; for ( var i = 0 ; i < max ; i ++ ) { var sum = 0 ; if ( a . length > i ) sum += a [ i ] ; if ( b . length > i ) sum += b [ i ] ; c [ i ] += sum ; } for ( var i = 0 ; i < max ; i ++ ) { if ( c [ i ] >= 10 ) { c [ i ] -= 10 ; c [ i + 1 ] ++ ; } } if ( c [ c . length - 1 ] == 0 ) c . pop ( ) ; var str = c . reverse ( ) . join ( \" \" ) ; return str ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { if ( Arr . length == 0 ) break ; var arr = Arr . shift ( ) . split ( / [\\+\\=] / ) ; var ans = [ ] ; for ( var i = 0 ; i <= 9 ; i ++ ) { var a = arr [ 0 ] . replace ( / X / g , i ) ; var b = arr [ 1 ] . replace ( / X / g , i ) ; var c = arr [ 2 ] . replace ( / X / g , i ) ; if ( bigAdd ( a , b ) == c ) ans . push ( i ) ; } console . log ( ( ans . length == 1 ) ? ans [ 0 ] : \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "function A ( x ) { var table = { } ; table [ ' A ' ] = \" 00000 \" ; table [ ' B ' ] = \" 00001 \" ; table [ ' C ' ] = \" 00010 \" ; table [ ' D ' ] = \" 00011 \" ; table [ ' E ' ] = \" 00100 \" ; table [ ' F ' ] = \" 00101 \" ; table [ ' G ' ] = \" 00110 \" ; table [ ' H ' ] = \" 00111 \" ; table [ ' I ' ] = \" 01000 \" ; table [ ' J ' ] = \" 01001 \" ; table [ ' K ' ] = \" 01010 \" ; table [ ' L ' ] = \" 01011 \" ; table [ ' M ' ] = \" 01100 \" ; table [ ' N ' ] = \" 01101 \" ; table [ ' O ' ] = \" 01110 \" ; table [ ' P ' ] = \" 01111 \" ; table [ ' Q ' ] = \" 10000 \" ; table [ ' R ' ] = \" 10001 \" ; table [ ' S ' ] = \" 10010 \" ; table [ ' T ' ] = \" 10011 \" ; table [ ' U ' ] = \" 10100 \" ; table [ ' V ' ] = \" 10101 \" ; table [ ' W ' ] = \" 10110 \" ; table [ ' X ' ] = \" 10111 \" ; table [ ' Y ' ] = \" 11000 \" ; table [ ' Z ' ] = \" 11001 \" ; table [ ' ' ] = \" 11010 \" ; table [ ' . ' ] = \" 11011 \" ; table [ ' , ' ] = \" 11100 \" ; table [ ' - ' ] = \" 11101 \" ; table [ ' \\' ' ] = \" 11110 \" ; table [ ' ? ' ] = \" 11111 \" ; var str = \" \" ; for ( var i = 0 ; i < x . length ; i ++ ) { str += table [ x [ i ] ] ; } return str ; } function B ( x ) { var table = { } ; table [ \" 101 \" ] = ' ' ; table [ \" 000000 \" ] = ' \\' ' ; table [ \" 000011 \" ] = ' , ' ; table [ \" 10010001 \" ] = ' - ' ; table [ \" 010001 \" ] = ' . ' ; table [ \" 000001 \" ] = ' ? ' ; table [ \" 100101 \" ] = ' A ' ; table [ \" 10011010 \" ] = ' B ' ; table [ \" 0101 \" ] = ' C ' ; table [ \" 0001 \" ] = ' D ' ; table [ \" 110 \" ] = ' E ' ; table [ \" 01001 \" ] = ' F ' ; table [ \" 10011011 \" ] = ' G ' ; table [ \" 010000 \" ] = ' H ' ; table [ \" 0111 \" ] = ' I ' ; table [ \" 10011000 \" ] = ' J ' ; table [ \" 0110 \" ] = ' K ' ; table [ \" 00100 \" ] = ' L ' ; table [ \" 10011001 \" ] = ' M ' ; table [ \" 10011110 \" ] = ' N ' ; table [ \" 00101 \" ] = ' O ' ; table [ \" 111 \" ] = ' P ' ; table [ \" 10011111 \" ] = ' Q ' ; table [ \" 1000 \" ] = ' R ' ; table [ \" 00110 \" ] = ' S ' ; table [ \" 00111 \" ] = ' T ' ; table [ \" 10011100 \" ] = ' U ' ; table [ \" 10011101 \" ] = ' V ' ; table [ \" 000010 \" ] = ' W ' ; table [ \" 10010010 \" ] = ' X ' ; table [ \" 10010011 \" ] = ' Y ' ; table [ \" 10010000 \" ] = ' Z ' ; var str = \" \" ; var memo = \" \" ; for ( var i = 0 ; i < x . length ; i ++ ) { memo += x [ i ] ; if ( table . hasOwnProperty ( memo ) ) { str += table [ memo ] ; memo = \" \" ; } } return str ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { v = A ( v ) ; v = B ( v ) ; console . log ( v ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var arr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var v = Arr . shift ( ) - 0 ; arr . push ( v ) ; } arr . sort ( function ( a , b ) { return a - b ; } ) ; var wait = [ ] ; var time = 0 ; for ( var i = 0 ; i < n ; i ++ ) { wait . push ( time ) ; time += arr [ i ] ; } var sum = wait . reduce ( function ( a , b ) { return a + b ; } ) ; console . log ( sum ) ; }",
    "label": 2
  },
  {
    "code": "function warshall ( ) { for ( var k = 0 ; k < n ; k ++ ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k ] [ j ] ) ; } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; var m = Arr . shift ( ) - 0 ; var C = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { C [ i ] = [ ] ; for ( var j = 0 ; j < n ; j ++ ) { C [ i ] [ j ] = ( i === j ) ? 0 : Infinity ; } } for ( var i = 0 ; i < m ; i ++ ) { var A = ( Arr . shift ( ) ) . split ( \" , \" ) . map ( Number ) ; C [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] = A [ 2 ] ; C [ A [ 1 ] - 1 ] [ A [ 0 ] - 1 ] = A [ 3 ] ; } warshall ( ) ; var last = ( Arr . shift ( ) ) . split ( \" , \" ) . map ( Number ) ; var cost = C [ last [ 0 ] - 1 ] [ last [ 1 ] - 1 ] + C [ last [ 1 ] - 1 ] [ last [ 0 ] - 1 ] + last [ 3 ] ; console . log ( last [ 2 ] - cost ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( y , x , v ) { var arr = [ [ y , x , v ] ] ; while ( true ) { if ( arr . length == 0 ) break ; var yxv = arr . shift ( ) ; var y = yxv [ 0 ] ; var x = yxv [ 1 ] ; var v = yxv [ 2 ] ; var dy = [ 0 , 0 , - 1 , 1 ] ; var dx = [ - 1 , 1 , 0 , 0 ] ; for ( var i = 0 ; i < 4 ; i ++ ) { var yy = y + dy [ i ] ; var xx = x + dx [ i ] ; if ( yy < 0 || yy >= n [ 0 ] || xx < 0 || xx >= n [ 1 ] ) continue ; if ( v == yx [ yy ] [ xx ] ) { yx [ yy ] [ xx ] = 0 ; arr . unshift ( [ yy , xx , v ] ) } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( n [ 0 ] == 0 && n [ 1 ] == 0 ) break ; var yx = [ ] ; for ( var i = 0 ; i < n [ 0 ] ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) ; yx . push ( arr ) ; } var cnt = 0 ; for ( var i = 0 ; i < n [ 0 ] ; i ++ ) { for ( var j = 0 ; j < n [ 1 ] ; j ++ ) { var v = yx [ i ] [ j ] ; if ( v == \" @ \" || v == \" # \" || v == \" * \" ) { cnt ++ ; yx [ i ] [ j ] = 0 ; bomb ( i , j , v ) ; } } } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var m = Arr . shift ( ) - 0 ; var n = Arr . shift ( ) - 0 ; var M = [ ] ; var check = [ ] ; for ( var i = 0 ; i < m ; i ++ ) M [ i ] = [ ] ; for ( var i = 0 ; i < m ; i ++ ) check [ i ] = false ; for ( var i = 0 ; i < n ; i ++ ) { var v = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; M [ v [ 0 ] - 1 ] . push ( v [ 1 ] - 1 ) ; } var L = [ ] ; for ( var i = 0 ; i < m ; i ++ ) { visit ( i ) ; } function visit ( x ) { if ( check [ x ] == true ) return ; else check [ x ] = true ; M [ x ] . forEach ( function ( v ) { visit ( v ) ; } ) ; L . push ( x ) ; } L . reverse ( ) ; L . forEach ( function ( v ) { console . log ( v + 1 ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( x , y , z ) { max = Math . max ( max , z ) ; if ( max == n ) return ; var dx = [ - 1 , 0 , 1 , - 2 , 2 , - 2 , 2 , - 2 , 2 , - 1 , 0 , 1 ] ; var dy = [ - 2 , - 2 , - 2 , - 1 , - 1 , 0 , 0 , 1 , 1 , 2 , 2 , 2 ] ; var Safe = { } ; for ( var i = - 1 ; i <= 1 ; i ++ ) { for ( var j = - 1 ; j <= 1 ; j ++ ) { Safe [ ( water [ z * 2 ] + i ) + \" \" + ( water [ z * 2 + 1 ] + j ) ] = true ; } } for ( var i = 0 ; i < 12 ; i ++ ) { var xx = x + dx [ i ] ; var yy = y + dy [ i ] ; if ( xx < 0 || yy < 0 || xx >= 10 || yy >= 10 ) continue ; if ( Safe . hasOwnProperty ( xx + \" \" + yy ) ) bomb ( xx , yy , z + 1 ) ; } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var xy = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( xy [ 0 ] == 0 && xy [ 1 ] == 0 ) break ; var map = [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ; var n = Arr . shift ( ) - 0 ; var water = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var max = 0 ; bomb ( xy [ 0 ] , xy [ 1 ] , 0 ) ; console . log ( ( max == n ) ? \" OK \" : \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "function bomb ( x , y , z ) { max = Math . max ( max , z ) ; if ( max == n ) return ; var dx = [ - 1 , 0 , 1 , - 2 , 2 , - 2 , 2 , - 2 , 2 , - 1 , 0 , 1 ] ; var dy = [ - 2 , - 2 , - 2 , - 1 , - 1 , 0 , 0 , 1 , 1 , 2 , 2 , 2 ] ; var Safe = { } ; for ( var i = - 1 ; i <= 1 ; i ++ ) { for ( var j = - 1 ; j <= 1 ; j ++ ) { Safe [ ( water [ z * 2 ] + i ) + \" \" + ( water [ z * 2 + 1 ] + j ) ] = true ; } } for ( var i = 0 ; i < 12 ; i ++ ) { var xx = x + dx [ i ] ; var yy = y + dy [ i ] ; if ( xx < 0 || yy < 0 || xx >= 10 || yy >= 10 ) continue ; if ( Safe . hasOwnProperty ( xx + \" \" + yy ) ) bomb ( xx , yy , z + 1 ) ; } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var xy = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( xy [ 0 ] == 0 && xy [ 1 ] == 0 ) break ; var n = Arr . shift ( ) - 0 ; var water = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var max = 0 ; bomb ( xy [ 0 ] , xy [ 1 ] , 0 ) ; console . log ( ( max == n ) ? \" OK \" : \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "' use strict ' ; var AOJ = { } ; ( function ( ns ) { var isBrowser = function ( ) { return typeof window !== ' undefined ' ; } ns . isBrowser = isBrowser ; var isNodejs = function ( ) { return ! isBrowser ( ) ; } ns . isNodejs = isNodejs ; if ( isBrowser ( ) ) { var getHtmlEncoded = function ( string0 ) { return String ( string0 ) . replace ( / & / g , ' &amp; ' ) . replace ( / \" / g , ' &quot; ' ) . replace ( / ' / g , ' &#39; ' ) . replace ( / < / g , ' &lt; ' ) . replace ( / > / g , ' &gt; ' ) ; } ns . getHtmlEncoded = getHtmlEncoded ; var outputCode = function ( function0 ) { document . getElementById ( ' code ' ) . innerHTML = ' <pre><code> ' + getHtmlEncoded ( function0 ) + ' </code></pre> ' ; } ns . outputCode = outputCode ; } var getInput = function ( ) { var inputLines = [ ] ; if ( isBrowser ( ) ) { var html = document . getElementById ( ' input ' ) . innerHTML ; inputLines = html . split ( ' <br> ' ) ; for ( var i = 0 ; i < inputLines . length ; i ++ ) { inputLines [ i ] = inputLines [ i ] . trim ( ) ; } } if ( isNodejs ( ) ) { inputLines = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( ' \\n ' ) ; } return inputLines ; } var setLineReader = function ( callback ) { if ( isBrowser ( ) ) { var lines = getInput ( ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { callback ( lines [ i ] ) ; } } if ( isNodejs ( ) ) { var readStream = require ( ' fs ' ) . ReadStream ( ' /dev/stdin ' ) ; var readlineInterface = require ( ' readline ' ) . createInterface ( { ' input ' : readStream , ' output ' : { } } ) ; readlineInterface . on ( ' line ' , function ( line ) { callback ( line ) ; } ) ; } } ns . setLineReader = setLineReader ; var doOutput = function ( outputLines ) { if ( isBrowser ( ) ) { document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { for ( var i = 0 ; i < outputLines . length ; i ++ ) { console . log ( outputLines [ i ] ) ; } } } ns . doOutput = doOutput ; var outputLines = [ ] var doOutputLine = function ( outputLine ) { if ( isBrowser ( ) ) { outputLines . push ( outputLine ) ; document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { console . log ( outputLine ) ; } } ns . doOutputLine = doOutputLine ; var doMain = function ( main ) { if ( isBrowser ( ) ) { window . onload = function ( ) { outputCode ( main ) ; main ( ) ; } } if ( isNodejs ( ) ) { main ( ) ; } } ns . doMain = doMain ; } ) ( AOJ ) ; var main = function ( ) { var fieldX = 0 ; var fieldY = 0 ; var fieldWidth = 10 ; var fieldHeight = 10 ; var phyonkichiMoves = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 2 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ - 2 , 0 ] , [ 2 , 0 ] , [ - 2 , 1 ] , [ 2 , 1 ] , [ - 1 , 2 ] , [ 0 , 2 ] , [ 1 , 2 ] ] ; var splinklerMoves = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 0 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] ; var dataTypes = { } ; dataTypes . phyonkichiLocation = 0 ; dataTypes . numSprinklers = 1 ; dataTypes . splinklerLocations = 2 ; var input ; var lineCount = 0 ; var isLocationInField = function ( x , y ) { if ( fieldX <= x && x < fieldWidth ) { if ( fieldY <= y && y < fieldHeight ) { return true ; } else { return false ; } } else { return false ; } } var getMovedLocations = function ( location , moves ) { var movedLocations = [ ] ; for ( var i = 0 ; i < moves . length ; i ++ ) { var move = moves [ i ] ; var x = location [ 0 ] + move [ 0 ] ; var y = location [ 1 ] + move [ 1 ] ; if ( isLocationInField ( x , y ) ) { movedLocations . push ( [ x , y ] ) ; } } return movedLocations ; } var getNextPhyonkichiLocations = function ( phyonkichiLocation ) { return getMovedLocations ( phyonkichiLocation , phyonkichiMoves ) ; } var getWetLocations = function ( splinklerLocation ) { return getMovedLocations ( splinklerLocation , splinklerMoves ) ; } var cache ; var stack ; var callCount ; var canSurvive = function ( phyonkichiLocation , splinklerLocations ) { callCount ++ ; var cacheKey = splinklerLocations . length + ' , ' + phyonkichiLocation [ 0 ] + ' , ' + phyonkichiLocation [ 1 ] ; if ( cacheKey in cache ) { return cache [ cacheKey ] ; } stack . push ( phyonkichiLocation ) ; if ( splinklerLocations . length <= 0 ) { return true ; } var splinklerLocation = splinklerLocations [ 0 ] ; var nextPhyonkichiLocations = getNextPhyonkichiLocations ( phyonkichiLocation ) ; var wetLocations = getWetLocations ( splinklerLocation ) ; for ( var i = 0 ; i < nextPhyonkichiLocations . length ; i ++ ) { var nextPhyonkichiLocation = nextPhyonkichiLocations [ i ] ; for ( var j = 0 ; j < wetLocations . length ; j ++ ) { var wetLocation = wetLocations [ j ] ; if ( nextPhyonkichiLocation [ 0 ] === wetLocation [ 0 ] && nextPhyonkichiLocation [ 1 ] === wetLocation [ 1 ] ) { var nextSplinklerLocations = splinklerLocations . slice ( 1 ) ; var can = canSurvive ( nextPhyonkichiLocation , nextSplinklerLocations ) ; if ( can ) { return true ; } } } } stack . splice ( stack . length - 1 , 1 ) ; cache [ cacheKey ] = false ; return false ; } var handleLine = function ( line ) { var args = line . split ( ' ' ) ; for ( var i = 0 ; i < args . length ; i ++ ) { args [ i ] = parseFloat ( args [ i ] ) ; } var dataType = lineCount % Object . keys ( dataTypes ) . length ; if ( dataType === dataTypes . phyonkichiLocation ) { input = { } ; input . phyonkichi = { } ; input . splinklerLocations = [ ] ; input . phyonkichi . x = args [ 0 ] ; input . phyonkichi . y = args [ 1 ] ; if ( input . phyonkichi . x === 0 && input . phyonkichi . y === 0 ) { } } else if ( dataType === dataTypes . numSprinklers ) { input . numSprinklers = args [ 0 ] ; } else if ( dataType === dataTypes . splinklerLocations ) { for ( var i = 0 ; i < args . length ; i += 2 ) { input . splinklerLocations . push ( [ args [ i ] , args [ i + 1 ] ] ) ; } callCount = 0 ; cache = { } ; stack = [ ] ; if ( canSurvive ( [ input . phyonkichi . x , input . phyonkichi . y ] , input . splinklerLocations ) ) { AOJ . doOutputLine ( ' OK ' ) ; } else { AOJ . doOutputLine ( ' NA ' ) ; } } else { } lineCount ++ ; } AOJ . setLineReader ( handleLine ) ; } AOJ . doMain ( main ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; var AOJ = { } ; ( function ( ns ) { var isBrowser = function ( ) { return typeof window !== ' undefined ' ; } ns . isBrowser = isBrowser ; var isNodejs = function ( ) { return ! isBrowser ( ) ; } ns . isNodejs = isNodejs ; if ( isBrowser ( ) ) { var getHtmlEncoded = function ( string0 ) { return String ( string0 ) . replace ( / & / g , ' &amp; ' ) . replace ( / \" / g , ' &quot; ' ) . replace ( / ' / g , ' &#39; ' ) . replace ( / < / g , ' &lt; ' ) . replace ( / > / g , ' &gt; ' ) ; } ns . getHtmlEncoded = getHtmlEncoded ; var outputCode = function ( function0 ) { document . getElementById ( ' code ' ) . innerHTML = ' <pre><code> ' + getHtmlEncoded ( function0 ) + ' </code></pre> ' ; } ns . outputCode = outputCode ; } var getInput = function ( ) { var inputLines = [ ] ; if ( isBrowser ( ) ) { var html = document . getElementById ( ' input ' ) . innerHTML ; inputLines = html . split ( ' <br> ' ) ; for ( var i = 0 ; i < inputLines . length ; i ++ ) { inputLines [ i ] = inputLines [ i ] . trim ( ) ; } } if ( isNodejs ( ) ) { inputLines = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( ' \\n ' ) ; } return inputLines ; } ns . getInput = getInput ; var setLineReader = function ( callback ) { if ( isBrowser ( ) ) { var lines = getInput ( ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { callback ( lines [ i ] ) ; } } if ( isNodejs ( ) ) { var readStream = require ( ' fs ' ) . ReadStream ( ' /dev/stdin ' ) ; var readlineInterface = require ( ' readline ' ) . createInterface ( { ' input ' : readStream , ' output ' : { } } ) ; readlineInterface . on ( ' line ' , function ( line ) { callback ( line ) ; } ) ; } } ns . setLineReader = setLineReader ; var doOutput = function ( outputLines ) { if ( isBrowser ( ) ) { document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { for ( var i = 0 ; i < outputLines . length ; i ++ ) { console . log ( outputLines [ i ] ) ; } } } ns . doOutput = doOutput ; var outputLines = [ ] var doOutputLine = function ( outputLine ) { if ( isBrowser ( ) ) { outputLines . push ( outputLine ) ; document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { console . log ( outputLine ) ; } } ns . doOutputLine = doOutputLine ; var doMain = function ( main ) { if ( isBrowser ( ) ) { window . onload = function ( ) { outputCode ( main ) ; main ( ) ; } } if ( isNodejs ( ) ) { main ( ) ; } } ns . doMain = doMain ; } ) ( AOJ ) ; var main = function ( ) { var fieldX = 0 ; var fieldY = 0 ; var fieldWidth = 10 ; var fieldHeight = 10 ; var phyonkichiMoves = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 2 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ - 2 , 0 ] , [ 2 , 0 ] , [ - 2 , 1 ] , [ 2 , 1 ] , [ - 1 , 2 ] , [ 0 , 2 ] , [ 1 , 2 ] ] ; var splinklerMoves = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 0 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] ; var dataTypes = { } ; dataTypes . phyonkichiLocation = 0 ; dataTypes . numSprinklers = 1 ; dataTypes . splinklerLocations = 2 ; var input ; var lineCount = 0 ; var isLocationInField = function ( x , y ) { if ( fieldX <= x && x < fieldWidth ) { if ( fieldY <= y && y < fieldHeight ) { return true ; } else { return false ; } } else { return false ; } } var getMovedLocations = function ( location , moves ) { var movedLocations = [ ] ; for ( var i = 0 ; i < moves . length ; i ++ ) { var move = moves [ i ] ; var x = location [ 0 ] + move [ 0 ] ; var y = location [ 1 ] + move [ 1 ] ; if ( isLocationInField ( x , y ) ) { movedLocations . push ( [ x , y ] ) ; } } return movedLocations ; } var getNextPhyonkichiLocations = function ( phyonkichiLocation ) { return getMovedLocations ( phyonkichiLocation , phyonkichiMoves ) ; } var getWetLocations = function ( splinklerLocation ) { return getMovedLocations ( splinklerLocation , splinklerMoves ) ; } var cache ; var stack ; var callCount ; var canSurvive = function ( phyonkichiLocation , splinklerLocations ) { callCount ++ ; var cacheKey = splinklerLocations . length + ' , ' + phyonkichiLocation [ 0 ] + ' , ' + phyonkichiLocation [ 1 ] ; if ( cacheKey in cache ) { return cache [ cacheKey ] ; } stack . push ( phyonkichiLocation ) ; if ( splinklerLocations . length <= 0 ) { return true ; } var splinklerLocation = splinklerLocations [ 0 ] ; var nextPhyonkichiLocations = getNextPhyonkichiLocations ( phyonkichiLocation ) ; var wetLocations = getWetLocations ( splinklerLocation ) ; for ( var i = 0 ; i < nextPhyonkichiLocations . length ; i ++ ) { var nextPhyonkichiLocation = nextPhyonkichiLocations [ i ] ; for ( var j = 0 ; j < wetLocations . length ; j ++ ) { var wetLocation = wetLocations [ j ] ; if ( nextPhyonkichiLocation [ 0 ] === wetLocation [ 0 ] && nextPhyonkichiLocation [ 1 ] === wetLocation [ 1 ] ) { var nextSplinklerLocations = splinklerLocations . slice ( 1 ) ; var can = canSurvive ( nextPhyonkichiLocation , nextSplinklerLocations ) ; if ( can ) { return true ; } } } } stack . splice ( stack . length - 1 , 1 ) ; cache [ cacheKey ] = false ; return false ; } var handleLine = function ( line ) { var args = line . split ( ' ' ) ; for ( var i = 0 ; i < args . length ; i ++ ) { args [ i ] = parseFloat ( args [ i ] ) ; } var dataType = lineCount % Object . keys ( dataTypes ) . length ; if ( dataType === dataTypes . phyonkichiLocation ) { input = { } ; input . phyonkichi = { } ; input . splinklerLocations = [ ] ; input . phyonkichi . x = args [ 0 ] ; input . phyonkichi . y = args [ 1 ] ; if ( input . phyonkichi . x === 0 && input . phyonkichi . y === 0 ) { } } else if ( dataType === dataTypes . numSprinklers ) { input . numSprinklers = args [ 0 ] ; } else if ( dataType === dataTypes . splinklerLocations ) { for ( var i = 0 ; i < args . length ; i += 2 ) { input . splinklerLocations . push ( [ args [ i ] , args [ i + 1 ] ] ) ; } callCount = 0 ; cache = { } ; stack = [ ] ; if ( canSurvive ( [ input . phyonkichi . x , input . phyonkichi . y ] , input . splinklerLocations ) ) { AOJ . doOutputLine ( ' OK ' ) ; } else { AOJ . doOutputLine ( ' NA ' ) ; } } else { } lineCount ++ ; } AOJ . setLineReader ( handleLine ) ; } AOJ . doMain ( main ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; var AOJ = { } ; ( function ( ns ) { var isBrowser = function ( ) { return typeof window !== ' undefined ' ; } ns . isBrowser = isBrowser ; var isNodejs = function ( ) { return ! isBrowser ( ) ; } ns . isNodejs = isNodejs ; if ( isBrowser ( ) ) { var getHtmlEncoded = function ( string0 ) { return String ( string0 ) . replace ( / & / g , ' &amp; ' ) . replace ( / \" / g , ' &quot; ' ) . replace ( / ' / g , ' &#39; ' ) . replace ( / < / g , ' &lt; ' ) . replace ( / > / g , ' &gt; ' ) ; } ns . getHtmlEncoded = getHtmlEncoded ; var outputCode = function ( function0 ) { document . getElementById ( ' code ' ) . innerHTML = ' <pre><code> ' + getHtmlEncoded ( function0 ) + ' </code></pre> ' ; } ns . outputCode = outputCode ; } var getInput = function ( ) { var inputLines = [ ] ; if ( isBrowser ( ) ) { var html = document . getElementById ( ' input ' ) . innerHTML ; inputLines = html . split ( ' <br> ' ) ; for ( var i = 0 ; i < inputLines . length ; i ++ ) { inputLines [ i ] = inputLines [ i ] . trim ( ) ; } } if ( isNodejs ( ) ) { inputLines = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( ' \\n ' ) ; } return inputLines ; } ns . getInput = getInput ; var setLineReader = function ( callback ) { if ( isBrowser ( ) ) { var lines = getInput ( ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { callback ( lines [ i ] ) ; } } if ( isNodejs ( ) ) { var readStream = require ( ' fs ' ) . ReadStream ( ' /dev/stdin ' ) ; var readlineInterface = require ( ' readline ' ) . createInterface ( { ' input ' : readStream , ' output ' : { } } ) ; readlineInterface . on ( ' line ' , function ( line ) { callback ( line ) ; } ) ; } } ns . setLineReader = setLineReader ; var doOutput = function ( outputLines ) { if ( isBrowser ( ) ) { document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { for ( var i = 0 ; i < outputLines . length ; i ++ ) { console . log ( outputLines [ i ] ) ; } } } ns . doOutput = doOutput ; var outputLines = [ ] var doOutputLine = function ( outputLine ) { if ( isBrowser ( ) ) { outputLines . push ( outputLine ) ; document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { console . log ( outputLine ) ; } } ns . doOutputLine = doOutputLine ; var doMain = function ( main ) { if ( isBrowser ( ) ) { window . onload = function ( ) { outputCode ( main ) ; main ( ) ; } } if ( isNodejs ( ) ) { main ( ) ; } } ns . doMain = doMain ; } ) ( AOJ ) ; var main = function ( ) { var fieldX = 0 ; var fieldY = 0 ; var fieldWidth = 10 ; var fieldHeight = 10 ; var phyonkichiMoves = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 2 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ - 2 , 0 ] , [ 2 , 0 ] , [ - 2 , 1 ] , [ 2 , 1 ] , [ - 1 , 2 ] , [ 0 , 2 ] , [ 1 , 2 ] ] ; var splinklerMoves = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 0 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] ; var input ; var lineCount = 0 ; var isLocationInField = function ( x , y ) { if ( fieldX <= x && x < fieldWidth ) { if ( fieldY <= y && y < fieldHeight ) { return true ; } else { return false ; } } else { return false ; } } var getMovedLocations = function ( location , moves ) { var movedLocations = [ ] ; for ( var i = 0 ; i < moves . length ; i ++ ) { var move = moves [ i ] ; var x = location [ 0 ] + move [ 0 ] ; var y = location [ 1 ] + move [ 1 ] ; if ( isLocationInField ( x , y ) ) { movedLocations . push ( [ x , y ] ) ; } } return movedLocations ; } var getNextPhyonkichiLocations = function ( phyonkichiLocation ) { return getMovedLocations ( phyonkichiLocation , phyonkichiMoves ) ; } var getWetLocations = function ( splinklerLocation ) { return getMovedLocations ( splinklerLocation , splinklerMoves ) ; } var cache ; var stack ; var callCount ; var canSurvive = function ( phyonkichiLocation , splinklerLocations ) { callCount ++ ; var cacheKey = splinklerLocations . length + ' , ' + phyonkichiLocation [ 0 ] + ' , ' + phyonkichiLocation [ 1 ] ; if ( cacheKey in cache ) { return cache [ cacheKey ] ; } stack . push ( phyonkichiLocation ) ; if ( splinklerLocations . length <= 0 ) { return true ; } var splinklerLocation = splinklerLocations [ 0 ] ; var nextPhyonkichiLocations = getNextPhyonkichiLocations ( phyonkichiLocation ) ; var wetLocations = getWetLocations ( splinklerLocation ) ; for ( var i = 0 ; i < nextPhyonkichiLocations . length ; i ++ ) { var nextPhyonkichiLocation = nextPhyonkichiLocations [ i ] ; for ( var j = 0 ; j < wetLocations . length ; j ++ ) { var wetLocation = wetLocations [ j ] ; if ( nextPhyonkichiLocation [ 0 ] === wetLocation [ 0 ] && nextPhyonkichiLocation [ 1 ] === wetLocation [ 1 ] ) { var nextSplinklerLocations = splinklerLocations . slice ( 1 ) ; var can = canSurvive ( nextPhyonkichiLocation , nextSplinklerLocations ) ; if ( can ) { return true ; } } } } stack . splice ( stack . length - 1 , 1 ) ; cache [ cacheKey ] = false ; return false ; } var dataTypes = { } ; dataTypes . phyonkichiLocation = 0 ; dataTypes . numSprinklers = 1 ; dataTypes . splinklerLocations = 2 ; var handleLine = function ( line ) { var args = line . split ( ' ' ) ; for ( var i = 0 ; i < args . length ; i ++ ) { args [ i ] = parseFloat ( args [ i ] ) ; } var dataType = lineCount % Object . keys ( dataTypes ) . length ; if ( dataType === dataTypes . phyonkichiLocation ) { input = { } ; input . phyonkichi = { } ; input . splinklerLocations = [ ] ; input . phyonkichi . x = args [ 0 ] ; input . phyonkichi . y = args [ 1 ] ; if ( input . phyonkichi . x === 0 && input . phyonkichi . y === 0 ) { } } else if ( dataType === dataTypes . numSprinklers ) { input . numSprinklers = args [ 0 ] ; } else if ( dataType === dataTypes . splinklerLocations ) { for ( var i = 0 ; i < args . length ; i += 2 ) { input . splinklerLocations . push ( [ args [ i ] , args [ i + 1 ] ] ) ; } callCount = 0 ; cache = { } ; stack = [ ] ; if ( canSurvive ( [ input . phyonkichi . x , input . phyonkichi . y ] , input . splinklerLocations ) ) { AOJ . doOutputLine ( ' OK ' ) ; } else { AOJ . doOutputLine ( ' NA ' ) ; } } else { } lineCount ++ ; } AOJ . setLineReader ( handleLine ) ; } AOJ . doMain ( main ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; var AOJ = { } ; ( function ( ns ) { var isBrowser = function ( ) { return typeof window !== ' undefined ' ; } ns . isBrowser = isBrowser ; var isNodejs = function ( ) { return ! isBrowser ( ) ; } ns . isNodejs = isNodejs ; if ( isBrowser ( ) ) { var getHtmlEncoded = function ( string0 ) { return String ( string0 ) . replace ( / & / g , ' &amp; ' ) . replace ( / \" / g , ' &quot; ' ) . replace ( / ' / g , ' &#39; ' ) . replace ( / < / g , ' &lt; ' ) . replace ( / > / g , ' &gt; ' ) ; } ns . getHtmlEncoded = getHtmlEncoded ; var outputCode = function ( function0 ) { document . getElementById ( ' code ' ) . innerHTML = ' <pre><code> ' + getHtmlEncoded ( function0 ) + ' </code></pre> ' ; } ns . outputCode = outputCode ; } var getInput = function ( ) { var inputLines = [ ] ; if ( isBrowser ( ) ) { var html = document . getElementById ( ' input ' ) . innerHTML ; inputLines = html . split ( ' <br> ' ) ; for ( var i = 0 ; i < inputLines . length ; i ++ ) { inputLines [ i ] = inputLines [ i ] . trim ( ) ; } } if ( isNodejs ( ) ) { inputLines = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( ' \\n ' ) ; } return inputLines ; } ns . getInput = getInput ; var setLineReader = function ( callback ) { if ( isBrowser ( ) ) { var lines = getInput ( ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { callback ( lines [ i ] ) ; } } if ( isNodejs ( ) ) { var readStream = require ( ' fs ' ) . ReadStream ( ' /dev/stdin ' ) ; var readlineInterface = require ( ' readline ' ) . createInterface ( { ' input ' : readStream , ' output ' : { } } ) ; readlineInterface . on ( ' line ' , function ( line ) { callback ( line ) ; } ) ; } } ns . setLineReader = setLineReader ; var doOutput = function ( outputLines ) { if ( isBrowser ( ) ) { document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { for ( var i = 0 ; i < outputLines . length ; i ++ ) { console . log ( outputLines [ i ] ) ; } } } ns . doOutput = doOutput ; var outputLines = [ ] var doOutputLine = function ( outputLine ) { if ( isBrowser ( ) ) { outputLines . push ( outputLine ) ; document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { console . log ( outputLine ) ; } } ns . doOutputLine = doOutputLine ; var doMain = function ( main ) { if ( isBrowser ( ) ) { window . onload = function ( ) { outputCode ( main ) ; main ( ) ; } } if ( isNodejs ( ) ) { main ( ) ; } } ns . doMain = doMain ; } ) ( AOJ ) ; var main = function ( ) { var fieldX = 0 ; var fieldY = 0 ; var fieldWidth = 10 ; var fieldHeight = 10 ; var phyonkichiMoves = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 2 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ - 2 , 0 ] , [ 2 , 0 ] , [ - 2 , 1 ] , [ 2 , 1 ] , [ - 1 , 2 ] , [ 0 , 2 ] , [ 1 , 2 ] ] ; var splinklerMoves = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 0 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] ; var input ; var isLocationInField = function ( x , y ) { if ( fieldX <= x && x < fieldWidth ) { if ( fieldY <= y && y < fieldHeight ) { return true ; } else { return false ; } } else { return false ; } } var getMovedLocations = function ( location , moves ) { var movedLocations = [ ] ; for ( var i = 0 ; i < moves . length ; i ++ ) { var move = moves [ i ] ; var x = location [ 0 ] + move [ 0 ] ; var y = location [ 1 ] + move [ 1 ] ; if ( isLocationInField ( x , y ) ) { movedLocations . push ( [ x , y ] ) ; } } return movedLocations ; } var getNextPhyonkichiLocations = function ( phyonkichiLocation ) { return getMovedLocations ( phyonkichiLocation , phyonkichiMoves ) ; } var getWetLocations = function ( splinklerLocation ) { return getMovedLocations ( splinklerLocation , splinklerMoves ) ; } var cache ; var stack ; var callCount ; var canSurvive = function ( phyonkichiLocation , splinklerLocations ) { callCount ++ ; var cacheKey = splinklerLocations . length + ' , ' + phyonkichiLocation [ 0 ] + ' , ' + phyonkichiLocation [ 1 ] ; if ( cacheKey in cache ) { return cache [ cacheKey ] ; } stack . push ( phyonkichiLocation ) ; if ( splinklerLocations . length <= 0 ) { return true ; } var splinklerLocation = splinklerLocations [ 0 ] ; var nextPhyonkichiLocations = getNextPhyonkichiLocations ( phyonkichiLocation ) ; var wetLocations = getWetLocations ( splinklerLocation ) ; for ( var i = 0 ; i < nextPhyonkichiLocations . length ; i ++ ) { var nextPhyonkichiLocation = nextPhyonkichiLocations [ i ] ; for ( var j = 0 ; j < wetLocations . length ; j ++ ) { var wetLocation = wetLocations [ j ] ; if ( nextPhyonkichiLocation [ 0 ] === wetLocation [ 0 ] && nextPhyonkichiLocation [ 1 ] === wetLocation [ 1 ] ) { var nextSplinklerLocations = splinklerLocations . slice ( 1 ) ; var can = canSurvive ( nextPhyonkichiLocation , nextSplinklerLocations ) ; if ( can ) { return true ; } } } } stack . splice ( stack . length - 1 , 1 ) ; cache [ cacheKey ] = false ; return false ; } var dataTypes = { } ; dataTypes . phyonkichiLocation = 0 ; dataTypes . numSprinklers = 1 ; dataTypes . splinklerLocations = 2 ; var lineCount = 0 ; var handleLine = function ( line ) { var args = line . split ( ' ' ) ; for ( var i = 0 ; i < args . length ; i ++ ) { args [ i ] = parseFloat ( args [ i ] ) ; } var dataType = lineCount % Object . keys ( dataTypes ) . length ; if ( dataType === dataTypes . phyonkichiLocation ) { input = { } ; input . phyonkichi = { } ; input . splinklerLocations = [ ] ; input . phyonkichi . x = args [ 0 ] ; input . phyonkichi . y = args [ 1 ] ; if ( input . phyonkichi . x === 0 && input . phyonkichi . y === 0 ) { } } else if ( dataType === dataTypes . numSprinklers ) { input . numSprinklers = args [ 0 ] ; } else if ( dataType === dataTypes . splinklerLocations ) { for ( var i = 0 ; i < args . length ; i += 2 ) { input . splinklerLocations . push ( [ args [ i ] , args [ i + 1 ] ] ) ; } callCount = 0 ; cache = { } ; stack = [ ] ; if ( canSurvive ( [ input . phyonkichi . x , input . phyonkichi . y ] , input . splinklerLocations ) ) { AOJ . doOutputLine ( ' OK ' ) ; } else { AOJ . doOutputLine ( ' NA ' ) ; } } else { } lineCount ++ ; } AOJ . setLineReader ( handleLine ) ; } AOJ . doMain ( main ) ;",
    "label": 2
  },
  {
    "code": "' use strict ' ; var AOJ = { } ; ( function ( ns ) { var isBrowser = function ( ) { return typeof window !== ' undefined ' ; } ns . isBrowser = isBrowser ; var isNodejs = function ( ) { return ! isBrowser ( ) ; } ns . isNodejs = isNodejs ; if ( isBrowser ( ) ) { var getHtmlEncoded = function ( string0 ) { return String ( string0 ) . replace ( / & / g , ' &amp; ' ) . replace ( / \" / g , ' &quot; ' ) . replace ( / ' / g , ' &#39; ' ) . replace ( / < / g , ' &lt; ' ) . replace ( / > / g , ' &gt; ' ) ; } ns . getHtmlEncoded = getHtmlEncoded ; var outputCode = function ( function0 ) { document . getElementById ( ' code ' ) . innerHTML = ' <pre><code> ' + getHtmlEncoded ( function0 ) + ' </code></pre> ' ; } ns . outputCode = outputCode ; } var getInput = function ( ) { var inputLines = [ ] ; if ( isBrowser ( ) ) { var html = document . getElementById ( ' input ' ) . innerHTML ; inputLines = html . split ( ' <br> ' ) ; for ( var i = 0 ; i < inputLines . length ; i ++ ) { inputLines [ i ] = inputLines [ i ] . trim ( ) ; } } if ( isNodejs ( ) ) { inputLines = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) . split ( ' \\n ' ) ; } return inputLines ; } ns . getInput = getInput ; var setLineReader = function ( callback ) { if ( isBrowser ( ) ) { var lines = getInput ( ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { callback ( lines [ i ] ) ; } } if ( isNodejs ( ) ) { var readStream = require ( ' fs ' ) . ReadStream ( ' /dev/stdin ' ) ; var readlineInterface = require ( ' readline ' ) . createInterface ( { ' input ' : readStream , ' output ' : { } } ) ; readlineInterface . on ( ' line ' , function ( line ) { callback ( line ) ; } ) ; } } ns . setLineReader = setLineReader ; var doOutput = function ( outputLines ) { if ( isBrowser ( ) ) { document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { for ( var i = 0 ; i < outputLines . length ; i ++ ) { console . log ( outputLines [ i ] ) ; } } } ns . doOutput = doOutput ; var outputLines = [ ] var doOutputLine = function ( outputLine ) { if ( isBrowser ( ) ) { outputLines . push ( outputLine ) ; document . getElementById ( ' output ' ) . innerHTML = outputLines . map ( getHtmlEncoded ) . join ( ' <br> \\n ' ) ; } if ( isNodejs ( ) ) { console . log ( outputLine ) ; } } ns . doOutputLine = doOutputLine ; var doMain = function ( main ) { if ( isBrowser ( ) ) { window . onload = function ( ) { outputCode ( main ) ; main ( ) ; } } if ( isNodejs ( ) ) { main ( ) ; } } ns . doMain = doMain ; } ) ( AOJ ) ; var main = function ( ) { var fieldX = 0 ; var fieldY = 0 ; var fieldWidth = 10 ; var fieldHeight = 10 ; var phyonkichiMoves = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 2 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ - 2 , 0 ] , [ 2 , 0 ] , [ - 2 , 1 ] , [ 2 , 1 ] , [ - 1 , 2 ] , [ 0 , 2 ] , [ 1 , 2 ] ] ; var splinklerMoves = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 0 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] ; var isLocationInField = function ( x , y ) { if ( fieldX <= x && x < fieldWidth ) { if ( fieldY <= y && y < fieldHeight ) { return true ; } else { return false ; } } else { return false ; } } var getMovedLocations = function ( location , moves ) { var movedLocations = [ ] ; for ( var i = 0 ; i < moves . length ; i ++ ) { var move = moves [ i ] ; var x = location [ 0 ] + move [ 0 ] ; var y = location [ 1 ] + move [ 1 ] ; if ( isLocationInField ( x , y ) ) { movedLocations . push ( [ x , y ] ) ; } } return movedLocations ; } var getNextPhyonkichiLocations = function ( phyonkichiLocation ) { return getMovedLocations ( phyonkichiLocation , phyonkichiMoves ) ; } var getWetLocations = function ( splinklerLocation ) { return getMovedLocations ( splinklerLocation , splinklerMoves ) ; } var cache ; var stack ; var callCount ; var canSurvive = function ( phyonkichiLocation , splinklerLocations ) { callCount ++ ; var cacheKey = splinklerLocations . length + ' , ' + phyonkichiLocation [ 0 ] + ' , ' + phyonkichiLocation [ 1 ] ; if ( cacheKey in cache ) { return cache [ cacheKey ] ; } stack . push ( phyonkichiLocation ) ; if ( splinklerLocations . length <= 0 ) { return true ; } var splinklerLocation = splinklerLocations [ 0 ] ; var nextPhyonkichiLocations = getNextPhyonkichiLocations ( phyonkichiLocation ) ; var wetLocations = getWetLocations ( splinklerLocation ) ; for ( var i = 0 ; i < nextPhyonkichiLocations . length ; i ++ ) { var nextPhyonkichiLocation = nextPhyonkichiLocations [ i ] ; for ( var j = 0 ; j < wetLocations . length ; j ++ ) { var wetLocation = wetLocations [ j ] ; if ( nextPhyonkichiLocation [ 0 ] === wetLocation [ 0 ] && nextPhyonkichiLocation [ 1 ] === wetLocation [ 1 ] ) { var nextSplinklerLocations = splinklerLocations . slice ( 1 ) ; var can = canSurvive ( nextPhyonkichiLocation , nextSplinklerLocations ) ; if ( can ) { return true ; } } } } stack . splice ( stack . length - 1 , 1 ) ; cache [ cacheKey ] = false ; return false ; } var dataTypes = { } ; dataTypes . phyonkichiLocation = 0 ; dataTypes . numSprinklers = 1 ; dataTypes . splinklerLocations = 2 ; var input ; var lineCount = 0 ; var handleLine = function ( line ) { var args = line . split ( ' ' ) ; for ( var i = 0 ; i < args . length ; i ++ ) { args [ i ] = parseFloat ( args [ i ] ) ; } var dataType = lineCount % Object . keys ( dataTypes ) . length ; if ( dataType === dataTypes . phyonkichiLocation ) { input = { } ; input . phyonkichi = { } ; input . splinklerLocations = [ ] ; input . phyonkichi . x = args [ 0 ] ; input . phyonkichi . y = args [ 1 ] ; if ( input . phyonkichi . x === 0 && input . phyonkichi . y === 0 ) { } } else if ( dataType === dataTypes . numSprinklers ) { input . numSprinklers = args [ 0 ] ; } else if ( dataType === dataTypes . splinklerLocations ) { for ( var i = 0 ; i < args . length ; i += 2 ) { input . splinklerLocations . push ( [ args [ i ] , args [ i + 1 ] ] ) ; } callCount = 0 ; cache = { } ; stack = [ ] ; if ( canSurvive ( [ input . phyonkichi . x , input . phyonkichi . y ] , input . splinklerLocations ) ) { AOJ . doOutputLine ( ' OK ' ) ; } else { AOJ . doOutputLine ( ' NA ' ) ; } } else { } lineCount ++ ; } AOJ . setLineReader ( handleLine ) ; } AOJ . doMain ( main ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; Arr . forEach ( function ( v ) { var arr = v . split ( \" \" ) . map ( Number ) ; var a = arr [ 0 ] ; var b = arr [ 1 ] ; var ans ; if ( 35.5 > a && 71 > b ) ans = \" AAA \" ; else if ( 37.5 > a && 77 > b ) ans = \" AA \" ; else if ( 40 > a && 83 > b ) ans = \" A \" ; else if ( 43 > a && 89 > b ) ans = \" B \" ; else if ( 50 > a && 105 > b ) ans = \" C \" ; else if ( 55 > a && 116 > b ) ans = \" D \" ; else if ( 70 > a && 148 > b ) ans = \" E \" ; else ans = \" NA \" ; console . log ( ans ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var I = 0 ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; if ( I != 0 ) console . log ( \" \" ) ; I ++ ; var rank = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) ; var score = ( 3 * ( arr [ 1 ] - 0 ) ) + ( arr [ 3 ] - 0 ) + ( ( 10 - i ) * 0.01 ) ; rank . push ( [ arr [ 0 ] , score ] ) ; } rank . sort ( function ( a , b ) { a = a [ 1 ] ; b = b [ 1 ] ; return b - a ; } ) ; rank . forEach ( function ( v ) { console . log ( v [ 0 ] + \" , \" + Math . floor ( v [ 1 ] ) ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "function year ( x ) { var m = [ 365 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; if ( x % 4 == 0 ) { m [ 2 ] = 29 ; m [ 0 ] = 366 ; if ( x % 100 == 0 ) { m [ 2 ] = 28 ; m [ 0 ] = 365 ; } if ( x % 400 == 0 ) { m [ 2 ] = 29 ; m [ 0 ] = 366 ; } } return m ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var str = Arr . shift ( ) ; if ( str == \" -1 -1 -1 -1 -1 -1 \" ) break ; var arr = str . split ( \" \" ) . map ( Number ) ; ( function ( y1 , m1 , d1 , y2 , m2 , d2 ) { var sum1 = 0 ; var sum2 = 0 ; var Y1 = year ( y1 ) ; var Y2 = year ( y2 ) ; sum1 += Y1 [ m1 ] - d1 ; sum2 += Y2 [ m2 ] - d2 ; while ( m1 < 12 ) { m1 ++ ; sum1 += Y1 [ m1 ] ; } while ( m2 < 12 ) { m2 ++ ; sum2 += Y2 [ m2 ] ; } var days = sum1 - sum2 ; while ( y1 != y2 ) { y1 ++ ; days += ( year ( y1 ) ) [ 0 ] ; } console . log ( days ) ; } ) . apply ( null , arr ) ; }",
    "label": 2
  },
  {
    "code": "function NotOne ( arr ) { var cnt = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; arr . forEach ( function ( v ) { cnt [ ( v - 0 ) ] ++ ; } ) ; var bad = [ ] ; cnt . forEach ( function ( v , i ) { if ( v >= 2 ) bad . push ( i ) ; } ) ; var result = [ ] ; arr . forEach ( function ( v , i ) { if ( bad . indexOf ( v ) != - 1 ) result . push ( i ) ; } ) ; return result ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = input . trim ( ) . split ( \" \\n \" ) ; var STR = \" \" ; var n = Arr . shift ( ) - 0 ; for ( var I = 0 ; I < n ; I ++ ) { var yx = [ ] ; var YX = [ ] ; for ( var i = 0 ; i < 9 ; i ++ ) { var v = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; yx . push ( v ) ; YX . push ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) ; } for ( var i = 0 ; i < 9 ; i ++ ) { var re = NotOne ( yx [ i ] ) ; re . forEach ( function ( v ) { YX [ i ] [ v ] ++ ; } ) ; } for ( var i = 0 ; i < 9 ; i ++ ) { var yy = [ ] ; for ( var j = 0 ; j < 9 ; j ++ ) yy . push ( yx [ j ] [ i ] ) ; var re = NotOne ( yy ) ; re . forEach ( function ( v ) { YX [ v ] [ i ] ++ ; } ) ; } for ( var y = 0 ; y < 3 ; y ++ ) { for ( var x = 0 ; x < 3 ; x ++ ) { var i = y * 3 ; var j = x * 3 ; var z = [ [ 0 + i , 0 + j ] , [ 0 + i , 1 + j ] , [ 0 + i , 2 + j ] , [ 1 + i , 0 + j ] , [ 1 + i , 1 + j ] , [ 1 + i , 2 + j ] , [ 2 + i , 0 + j ] , [ 2 + i , 1 + j ] , [ 2 + i , 2 + j ] ] ; var zz = [ ] ; z . forEach ( function ( v ) { zz . push ( yx [ v [ 0 ] ] [ v [ 1 ] ] ) ; } ) ; var re = NotOne ( zz ) ; re . forEach ( function ( v ) { YX [ z [ v ] [ 0 ] ] [ z [ v ] [ 1 ] ] ++ ; } ) ; } } yx . forEach ( function ( V , i ) { V . forEach ( function ( v , j ) { yx [ i ] [ j ] = ( YX [ i ] [ j ] >= 1 ) ? \" * \" + v : \" \" + v ; } ) ; } ) ; STR += yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) + \" \\n \\n \" ; } console . log ( STR . trim ( ) ) ;",
    "label": 2
  },
  {
    "code": "function NotOne ( arr ) { var cnt = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; arr . forEach ( function ( v ) { cnt [ ( v - 0 ) ] ++ ; } ) ; var bad = [ ] ; cnt . forEach ( function ( v , i ) { if ( v >= 2 ) bad . push ( i ) ; } ) ; var result = [ ] ; arr . forEach ( function ( v , i ) { if ( bad . indexOf ( v ) != - 1 ) result . push ( i ) ; } ) ; return result ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = input . trim ( ) . split ( \" \\n \" ) ; var STR = \" \" ; var n = Arr . shift ( ) - 0 ; for ( var I = 0 ; I < n ; I ++ ) { var yx = [ ] ; var YX = [ ] ; for ( var i = 0 ; i < 9 ; i ++ ) { var v = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; yx . push ( v ) ; YX . push ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) ; } for ( var i = 0 ; i < 9 ; i ++ ) { var re = NotOne ( yx [ i ] ) ; re . forEach ( function ( v ) { YX [ i ] [ v ] ++ ; } ) ; } for ( var i = 0 ; i < 9 ; i ++ ) { var yy = [ ] ; for ( var j = 0 ; j < 9 ; j ++ ) yy . push ( yx [ j ] [ i ] ) ; var re = NotOne ( yy ) ; re . forEach ( function ( v ) { YX [ v ] [ i ] ++ ; } ) ; } for ( var y = 0 ; y < 3 ; y ++ ) { for ( var x = 0 ; x < 3 ; x ++ ) { var z = [ [ 0 + y * 3 , 0 + x * 3 ] , [ 0 + y * 3 , 1 + x * 3 ] , [ 0 + y * 3 , 2 + x * 3 ] , [ 1 + y * 3 , 0 + x * 3 ] , [ 1 + y * 3 , 1 + x * 3 ] , [ 1 + y * 3 , 2 + x * 3 ] , [ 2 + y * 3 , 0 + x * 3 ] , [ 2 + y * 3 , 1 + x * 3 ] , [ 2 + y * 3 , 2 + x * 3 ] ] ; var zz = [ ] ; z . forEach ( function ( v ) { zz . push ( yx [ v [ 0 ] ] [ v [ 1 ] ] ) ; } ) ; var re = NotOne ( zz ) ; re . forEach ( function ( v ) { YX [ z [ v ] [ 0 ] ] [ z [ v ] [ 1 ] ] ++ ; } ) ; } } yx . forEach ( function ( V , i ) { V . forEach ( function ( v , j ) { yx [ i ] [ j ] = ( YX [ i ] [ j ] >= 1 ) ? \" * \" + v : \" \" + v ; } ) ; } ) ; STR += yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) + \" \\n \\n \" ; } console . log ( STR . trim ( ) ) ;",
    "label": 2
  },
  {
    "code": "function NotOne ( arr ) { var cnt = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; arr . forEach ( function ( v ) { cnt [ ( v - 0 ) ] ++ ; } ) ; var bad = [ ] ; cnt . forEach ( function ( v , i ) { if ( v >= 2 ) bad . push ( i ) ; } ) ; var result = [ ] ; arr . forEach ( function ( v , i ) { if ( bad . indexOf ( v ) != - 1 ) result . push ( i ) ; } ) ; return result ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = input . trim ( ) . split ( \" \\n \" ) ; var STR = \" \" ; var n = Arr . shift ( ) - 0 ; for ( var I = 0 ; I < n ; I ++ ) { var yx = [ ] ; var YX = [ ] ; for ( var i = 0 ; i < 9 ; i ++ ) { var v = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; yx . push ( v ) ; YX . push ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) ; } for ( var i = 0 ; i < 9 ; i ++ ) { var reX = NotOne ( yx [ i ] ) ; reX . forEach ( function ( v ) { YX [ i ] [ v ] ++ ; } ) ; var yy = [ ] ; for ( var j = 0 ; j < 9 ; j ++ ) yy . push ( yx [ j ] [ i ] ) ; var reY = NotOne ( yy ) ; reY . forEach ( function ( v ) { YX [ v ] [ i ] ++ ; } ) ; var y = ~ ~ ( i / 3 ) ; var x = i % 3 ; var z = [ [ 0 + y * 3 , 0 + x * 3 ] , [ 0 + y * 3 , 1 + x * 3 ] , [ 0 + y * 3 , 2 + x * 3 ] , [ 1 + y * 3 , 0 + x * 3 ] , [ 1 + y * 3 , 1 + x * 3 ] , [ 1 + y * 3 , 2 + x * 3 ] , [ 2 + y * 3 , 0 + x * 3 ] , [ 2 + y * 3 , 1 + x * 3 ] , [ 2 + y * 3 , 2 + x * 3 ] ] ; var zz = [ ] ; z . forEach ( function ( v ) { zz . push ( yx [ v [ 0 ] ] [ v [ 1 ] ] ) ; } ) ; var reZ = NotOne ( zz ) ; reZ . forEach ( function ( v ) { YX [ z [ v ] [ 0 ] ] [ z [ v ] [ 1 ] ] ++ ; } ) ; } for ( var i = 0 ; i < 9 ; i ++ ) { for ( var j = 0 ; j < 9 ; j ++ ) { yx [ i ] [ j ] = ( YX [ i ] [ j ] >= 1 ) ? \" * \" + yx [ i ] [ j ] : \" \" + yx [ i ] [ j ] ; } } STR += yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) + \" \\n \\n \" ; } console . log ( STR . trim ( ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var L = Arr . shift ( ) ; for ( var i = 0 ; i < L ; i ++ ) { var str = Arr [ i ] ; str = str . replace ( / \\-\\> / g , \" A \" ) ; str = str . replace ( / \\<\\- / g , \" Z \" ) ; var m = str . split ( \" \" ) ; var arr = [ m [ 0 ] ] ; var n = 1 ; m . forEach ( function ( v ) { if ( v == \" A \" ) n ++ ; else if ( v == \" Z \" ) n -- ; else { if ( n == 0 ) { arr . unshift ( v ) ; n = 1 ; } if ( n > arr . length ) arr . push ( v ) ; } } ) ; console . log ( arr . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var L = Arr . shift ( ) ; for ( var i = 0 ; i < L ; i ++ ) { var str = Arr [ i ] ; str = str . replace ( / \\-\\> / g , \" A \" ) ; str = str . replace ( / \\<\\- / g , \" Z \" ) ; var abc = str . split ( \" \" ) ; var arr = [ ] ; var n = 0 ; abc . forEach ( function ( v ) { if ( v == \" A \" ) n ++ ; else if ( v == \" Z \" ) n -- ; else { if ( n == 0 ) { arr . unshift ( v ) ; n = 1 ; } if ( n > arr . length ) arr . push ( v ) ; } } ) ; console . log ( arr . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "function move ( yx ) { var arr = [ ] ; for ( var y = 0 ; y < 8 ; y ++ ) arr [ y ] = [ ] ; for ( var y = 0 ; y < 8 ; y ++ ) { for ( var x = 0 ; x < 8 ; x ++ ) { arr [ y ] [ x ] = yx [ 7 - x ] [ y ] ; } } return arr ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var yx = [ ] ; for ( var i = 0 ; i < 8 ; i ++ ) yx . push ( Arr [ i ] . split ( \" \" ) ) ; yx = move ( yx ) ; console . log ( \" 90 \\n \" + yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) ) ; yx = move ( yx ) ; console . log ( \" 180 \\n \" + yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) ) ; yx = move ( yx ) ; console . log ( \" 270 \\n \" + yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; var n = Arr . shift ( ) ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += Arr [ i ] ; } console . log ( Math . floor ( sum / n ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var I = 0 ; I < n ; I ++ ) { var arr = Arr [ I ] . split ( \" : \" ) ; var h = parseInt ( arr [ 0 ] , 10 ) ; var m = parseInt ( arr [ 1 ] , 10 ) ; var H = h * ( 360 / 12 ) + m * ( ( 360 / 12 ) / 60 ) ; var M = m * ( 360 / 60 ) ; var hm = Math . abs ( H - M ) ; hm = Math . min ( hm , 360 - hm ) ; var ans ; if ( hm >= 0 && hm < 30 ) ans = \" alert \" ; else if ( hm >= 90 && hm <= 180 ) ans = \" safe \" ; else ans = \" warning \" console . log ( ans ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var abc = [ [ ] , [ ] , [ ] ] ; var obj = { } ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; abc [ Math . floor ( i / 8 ) ] . push ( arr [ 1 ] ) ; obj [ arr [ 1 ] ] = arr [ 0 ] ; } for ( var i = 0 ; i < 3 ; i ++ ) abc [ i ] . sort ( function ( a , b ) { return a - b ; } ) ; console . log ( obj [ abc [ 0 ] [ 0 ] ] + \" \" + ( abc [ 0 ] [ 0 ] . toFixed ( 2 ) ) ) ; console . log ( obj [ abc [ 0 ] [ 1 ] ] + \" \" + ( abc [ 0 ] [ 1 ] . toFixed ( 2 ) ) ) ; console . log ( obj [ abc [ 1 ] [ 0 ] ] + \" \" + ( abc [ 1 ] [ 0 ] . toFixed ( 2 ) ) ) ; console . log ( obj [ abc [ 1 ] [ 1 ] ] + \" \" + ( abc [ 1 ] [ 1 ] . toFixed ( 2 ) ) ) ; console . log ( obj [ abc [ 2 ] [ 0 ] ] + \" \" + ( abc [ 2 ] [ 0 ] . toFixed ( 2 ) ) ) ; console . log ( obj [ abc [ 2 ] [ 1 ] ] + \" \" + ( abc [ 2 ] [ 1 ] . toFixed ( 2 ) ) ) ; var d = [ ] ; for ( var i = 0 ; i < 3 ; i ++ ) d . push ( abc [ i ] [ 2 ] ) ; d . sort ( function ( a , b ) { return a - b ; } ) ; console . log ( obj [ d [ 0 ] ] + \" \" + ( d [ 0 ] . toFixed ( 2 ) ) ) ; console . log ( obj [ d [ 1 ] ] + \" \" + ( d [ 1 ] . toFixed ( 2 ) ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var str = Arr [ i ] ; var strA = str . replace ( / \\>\\'(\\=+)\\#(\\=+)\\~ / , function ( s , s1 , s2 ) { if ( s1 == s2 ) s = s . replace ( / \\=+ / g , \" = \" ) ; return s ; } ) ; var strB = str . replace ( / \\>\\^(Q=)+~~ / , function ( s ) { return \" >^Q=~~ \" ; } ) ; if ( strA == \" >'=#=~ \" ) { console . log ( \" A \" ) ; continue ; } if ( strB == \" >^Q=~~ \" ) { console . log ( \" B \" ) ; continue ; } console . log ( \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var str = Arr [ i ] ; if ( / >'(=+)#\\1~ / . test ( str ) ) console . log ( \" A \" ) ; else if ( / >\\^(Q=)+~~ / . test ( str ) ) console . log ( \" B \" ) ; else console . log ( \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( / ^>'(=+)#\\1~$ / . test ( Arr [ i ] ) ) console . log ( \" A \" ) ; else if ( / ^>\\^(Q=)+~~$ / . test ( Arr [ i ] ) ) console . log ( \" B \" ) ; else console . log ( \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; var s = arr [ 0 ] ; var g = arr [ 1 ] ; var ans = [ s ] ; var plus = 1 ; if ( s < g ) { do { s ++ ; ans . push ( s ) ; } while ( s != g ) ; } else if ( s > g && s <= 5 ) { do { s -- ; ans . push ( s ) ; } while ( s != g ) ; } else if ( s > g && s >= 6 ) { do { s += plus ; if ( s == 10 ) { s = 5 ; plus = - 1 ; } ; if ( s == 0 ) { plus = 1 ; } ; ans . push ( s ) ; } while ( s != g ) ; } console . log ( ans . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; var s = arr [ 0 ] ; var g = arr [ 1 ] ; var ans = [ s ] ; var plus = 1 ; if ( s < g ) { do { s ++ ; ans . push ( s ) ; } while ( s != g ) } else if ( s > g && s <= 5 ) { do { s -- ; ans . push ( s ) ; } while ( s != g ) } else if ( s > g && s >= 6 ) { do { s += plus ; if ( s == 10 ) { s = 5 ; plus = - 1 ; } if ( s == 0 ) { plus = 1 ; } ans . push ( s ) ; } while ( s != g ) ; } console . log ( ans . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var n = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; var s = arr [ 0 ] ; var g = arr [ 1 ] ; var ans = [ s ] ; var plus = 1 ; if ( s < g ) { do { s ++ ; ans . push ( s ) ; } while ( s != g ) } else if ( s > g && s <= 5 ) { do { s -- ; ans . push ( s ) ; } while ( s != g ) } else if ( s > g && s >= 6 ) { do { s += plus ; if ( s == 10 ) { s = 5 ; plus = - 1 ; } if ( s == 0 ) { plus = 1 ; } ans . push ( s ) ; } while ( s != g ) ; } console . log ( ans . join ( \" \" ) ) ; }",
    "label": 2
  },
  {
    "code": "function bomb ( y , x , z ) { if ( yx [ y ] [ x ] != \" + \" ) return ; var dy = [ - 1 , 0 , 1 , 0 ] ; var dx = [ 0 , 1 , 0 , - 1 ] ; var Y = y + dy [ z ] ; var X = x + dx [ z ] ; if ( Y < 0 || X < 0 || Y >= n || X >= n ) { z = ( z + 1 ) % 4 ; bomb ( y , x , z ) ; } else { if ( yx [ Y ] [ X ] == \" # \" ) { yx [ Y - dy [ z ] ] [ X - dx [ z ] ] = \" + \" ; if ( z == 3 ) bomb ( Y - 2 * dy [ z ] - 1 , X - 2 * dx [ z ] , 0 ) ; else if ( z == 0 ) bomb ( Y - 2 * dy [ z ] , X - 2 * dx [ z ] + 1 , 1 ) ; else if ( z == 1 ) bomb ( Y - 2 * dy [ z ] + 1 , X - 2 * dx [ z ] , 2 ) ; else if ( z == 2 ) bomb ( Y - 2 * dy [ z ] , X - 2 * dx [ z ] - 1 , 3 ) ; } else { yx [ y ] [ x ] = \" # \" ; last = [ y , x ] ; bomb ( Y , X , z ) ; } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) . map ( Number ) ; var d = arr . shift ( ) ; var str = \" \" ; for ( var k = 0 ; k < d ; k ++ ) { if ( k != 0 ) str += \" \\n \\n \" ; var n = arr . shift ( ) ; if ( n == 0 ) { str += \" \" ; continue ; } if ( n == 1 ) { str += \" # \" ; continue ; } if ( n == 2 ) { str += \" ## \\n # \" ; continue ; } var yx = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { yx [ i ] = [ ] ; for ( var j = 0 ; j < n ; j ++ ) { yx [ i ] [ j ] = \" + \" ; } } var last = [ ] ; bomb ( n - 1 , 0 , 0 ) ; if ( n % 2 == 0 ) yx [ last [ 0 ] ] [ last [ 1 ] ] = \" + \" ; str += yx . join ( \" \\n \" ) . replace ( / \\, / g , \" \" ) . replace ( / \\+ / g , \" \" ) ; } console . log ( str ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) . map ( Number ) ; while ( true ) { var n = arr . shift ( ) ; if ( n == 0 ) break ; if ( n == 1 ) { continue ; } var ary = [ ] ; for ( var i = 0 ; i < n ; i ++ ) ary [ i ] = false ; for ( var i = 1 ; i < n ; i ++ ) { ary [ i * i % n ] = true ; } var m = [ ] ; ary . forEach ( function ( v , i ) { if ( v ) m . push ( i ) ; } ) ; var ans = [ ] ; var len = ( n - 1 ) / 2 ; for ( var i = 0 ; i <= len ; i ++ ) ans [ i ] = 0 ; for ( var i = 0 ; i < m . length ; i ++ ) { for ( var j = i + 1 ; j < m . length ; j ++ ) { var x = m [ i ] - m [ j ] ; if ( x < 0 ) x += n ; if ( len < x ) x = n - x ; ans [ x ] += 2 ; } } ans . shift ( ) ; ans . forEach ( function ( v ) { console . log ( v ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) . map ( Number ) ; while ( true ) { var n = arr . shift ( ) ; if ( n == 0 ) break ; var ary = [ ] ; for ( var i = 0 ; i < n ; i ++ ) ary [ i ] = false ; for ( var i = 1 ; i < n ; i ++ ) { ary [ i * i % n ] = true ; } var m = [ ] ; ary . forEach ( function ( v , i ) { if ( v ) m . push ( i ) ; } ) ; var ans = [ ] ; var len = ( n - 1 ) / 2 ; for ( var i = 0 ; i <= len ; i ++ ) ans [ i ] = 0 ; for ( var i = 0 ; i < m . length ; i ++ ) { for ( var j = i + 1 ; j < m . length ; j ++ ) { var x = m [ i ] - m [ j ] ; if ( x < 0 ) x += n ; if ( len < x ) x = n - x ; ans [ x ] += 2 ; } } ans . shift ( ) ; ans . forEach ( function ( v ) { console . log ( v ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "var COUNTER_CLOCKWISE = 1 ; var CLOCKWISE = - 1 ; var ONLINE_BACK = 2 ; var ONLINE_FRONT = - 2 ; var ON_SEGMENT = 0 ; var Vector2D = class Vector2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } Vector2D . prototype . Init = function ( x , y ) { this . x = x ; this . y = y ; } function rotateVector90 ( v ) { var r = new Vector2D ( ) ; r . x = - v . y ; r . y = v . x ; return r ; } function getDegreeToRadian ( degree ) { var pi = 3.14159265358979323846 ; return degree * pi / 180 ; } function getRotateVector ( vec , degree ) { var radian = getDegreeToRadian ( degree ) ; var sin = Math . sin ( radian ) ; var cos = Math . cos ( radian ) ; var r = new Vector2D ( ) ; r . x = vec . x * cos - vec . y * sin ; r . y = vec . x * sin + vec . y * cos ; return r ; } function getRotateVectorFromRad ( vec , radian ) { var sin = Math . sin ( radian ) ; var cos = Math . cos ( radian ) ; var r = new Vector2D ( ) ; r . x = vec . x * cos - vec . y * sin ; r . y = vec . x * sin + vec . y * cos ; return r ; } function isEqualVectors ( a , b ) { return equalFloats ( a . x - b . x , 0 ) && equalFloats ( a . y - b . y , 0 ) ; } function getUnitVector ( vec ) { var length = getVectorLength2D ( vec ) ; if ( length > 0 ) { return getDivideVector ( vec , length ) ; } return vec ; } function getVectorLength2D ( vec ) { return Math . sqrt ( ( vec . x * vec . x ) + ( vec . y * vec . y ) ) ; } function getNorm ( vec ) { return vec . x * vec . x + vec . y * vec . y ; } function getDivideVector ( vec2D , length ) { var vec = new Vector2D ( ) ; vec . x = vec2D . x / length ; vec . y = vec2D . y / length ; return vec ; } function equalFloats ( a , b ) { var threshold = 1 / 8192 ; return Math . abs ( a - b ) < threshold ; } function isParallelVector ( vectorA , vectorB ) { var na = rotateVector90 ( vectorA ) ; return equalFloats ( 0 , dotProduct2D ( na , vectorB ) ) ; } function isVerticalVector ( vectorA , vectorB ) { return equalFloats ( 0 , dotProduct2D ( vectorA , vectorB ) ) ; } function subtractVector ( vecA , vecB ) { var vec = new Vector2D ( ) ; vec . x = vecA . x - vecB . x ; vec . y = vecA . y - vecB . y ; return vec ; } function dotProduct2D ( vecA , vecB ) { var dot = vecA . x * vecB . x + vecA . y * vecB . y ; return vecA . x * vecB . x + vecA . y * vecB . y ; } function getCross ( vecA , vecB ) { return vecA . x * vecB . y - vecA . y * vecB . x ; } var LineSegment2D = class LineSegment2D { constructor ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } } LineSegment2D . prototype . Init = function ( point1 , point2 ) { this . point1 = point1 ; this . point2 = point2 ; } function onOneSide ( axis , segment ) { var d1 = new Vector2D ( ) ; d1 = subtractVector ( segment . point1 , axis . base ) ; var d2 = new Vector2D ( ) ; d2 = subtractVector ( segment . point2 , axis . base ) ; var n = new Vector2D ( ) ; n = rotateVector90 ( axis . direction ) ; return dotProduct2D ( n , d1 ) * dotProduct2D ( n , d2 ) > 0 ; } function overLapping ( minA , maxA , minB , maxB ) { return minB <= maxA && minA <= maxB ; } function isSegmentsCollide ( segment1 , segment2 ) { var axisA = new Line ( ) ; var axisB = new Line ( ) ; axisA . base = segment1 . point1 ; axisA . direction = subtractVector ( segment1 . point2 , segment1 . point1 ) ; if ( onOneSide ( axisA , segment2 ) ) { return false ; } axisB . base = segment2 . point1 ; axisB . direction = subtractVector ( segment2 . point2 , segment2 . point1 ) ; if ( onOneSide ( axisB , segment1 ) ) { return false ; } if ( isParallelVector ( axisA . direction , axisB . direction ) ) { var rangeA = getProjectSegment ( segment1 , axisA . direction ) ; var rangeB = getProjectSegment ( segment2 , axisA . direction ) ; return isOverLappingRanges ( rangeA , rangeB ) ; } else { return true ; } } function Line ( ) { this . base ; this . direction } Line . prototype . Init = function ( base , direction , color ) { this . base = base ; this . direction = direction ; } var Range = class Range { constructor ( min , max ) { this . min = min ; this . max = max ; } } function getMaxMinRange ( range1 , range2 ) { var range = new Range ( ) ; range . min = range1 . min < range2 . min ? range1 . min : range2 . min ; range . max = range1 . max < range2 . max ? range2 . max : range1 . max ; return range ; } function getSortRange ( range ) { var sorted = new Range ( range . min , range . max ) ; if ( range . min > range . max ) { sorted . min = range . max ; sorted . max = range . min ; } return sorted ; } function getNegateVector ( vector ) { vector . x = - vector . x ; vector . y = - vector . y ; return vector ; } function addVector ( vecA , vecB ) { return new Vector2D ( vecA . x + vecB . x , vecA . y + vecB . y ) ; } function getProjectSegment ( segment , onto ) { var ontoUnitVec = getUnitVector ( onto ) ; var range = new Range ( ) ; range . min = dotProduct2D ( ontoUnitVec , segment . point1 ) ; range . max = dotProduct2D ( ontoUnitVec , segment . point2 ) ; range = getSortRange ( range ) ; return range ; } function isOverLappingRanges ( range1 , range2 ) { return overLapping ( range1 . min , range1 . max , range2 . min , range2 . max ) ; } function projectVector ( project , onto ) { var d = dotProduct2D ( onto , onto ) ; if ( 0 < d ) { var dp = dotProduct2D ( project , onto ) ; return multiplyVector ( onto , dp / d ) ; } return onto ; } var Point2D = class Point2D { constructor ( x , y ) { this . x = x ; this . y = y ; } } function addPoint ( point1 , point2 ) { return new Point2D ( point1 . x + point2 . x , point1 . y + point2 . y ) ; } function subtractPoint ( point1 , point2 ) { return new Point2D ( point1 . x - point2 . x , point1 . y - point2 . y ) ; } function multiplyPoint ( point , scalar ) { return new Point2D ( point . x * scalar , point . y * scalar ) ; } function getProjectPoint ( segment , point ) { var vec1 = new Vector2D ( segment . point2 . x - segment . point1 . x , segment . point2 . y - segment . point1 . y ) ; var vec2 = new Vector2D ( point . x - segment . point1 . x , point . y - segment . point1 . y ) ; var rate = dotProduct2D ( vec2 , vec1 ) / getNorm ( vec1 ) ; var vec3 = multiplyVector ( vec1 , rate ) ; var project = new Point2D ( segment . point1 . x + vec3 . x , segment . point1 . y + vec3 . y ) ; return project ; } function getReflectionPoint ( segment , point ) { var projection = getProjectPoint ( segment , point ) ; var vec = subtractPoint ( projection , point ) ; var refrectionPoint = multiplyPoint ( vec , 2 ) ; return addPoint ( refrectionPoint , point ) ; } function getCrossPoint ( segment1 , segment2 ) { var baseVector = new Vector2D ( segment2 . point2 . x - segment2 . point1 . x , segment2 . point2 . y - segment2 . point1 . y ) ; var d1Vec = new Vector2D ( segment1 . point1 . x - segment2 . point1 . x , segment1 . point1 . y - segment2 . point1 . y ) ; var d2Vec = new Vector2D ( segment1 . point2 . x - segment2 . point1 . x , segment1 . point2 . y - segment2 . point1 . y ) ; var d1 = Math . abs ( getCross ( baseVector , d1Vec ) ) ; var d2 = Math . abs ( getCross ( baseVector , d2Vec ) ) ; var t = d1 / ( d1 + d2 ) ; var x = segment1 . point1 . x + ( segment1 . point2 . x - segment1 . point1 . x ) * t ; var y = segment1 . point1 . y + ( segment1 . point2 . y - segment1 . point1 . y ) * t ; return new Point2D ( x , y ) ; } function multiplyVector ( vec , scalar ) { var temp = new Vector2D ( ) ; temp . x = vec . x * scalar ; temp . y = vec . y * scalar ; return temp ; } function clampOnRange ( x , min , max ) { if ( x < min ) { return min ; } else if ( x > max ) { return max ; } else { return x ; } } function getDistanceLinePoint ( line , point ) { var vec1 = new Vector2D ( line . point2 . x - line . point1 . x , line . point2 . y - line . point1 . y ) ; var vec2 = new Vector2D ( point . x - line . point1 . x , point . y - line . point1 . y ) ; return Math . abs ( getCross ( vec1 , vec2 ) / getVectorLength2D ( vec1 ) ) ; } function getDistanceSegmentPoint ( segment , point ) { if ( dotProduct2D ( subtractPoint ( segment . point2 , segment . point1 ) , subtractPoint ( point , segment . point1 ) ) < 0 ) { return getVectorLength2D ( subtractPoint ( point , segment . point1 ) ) ; } if ( dotProduct2D ( subtractPoint ( segment . point1 , segment . point2 ) , subtractPoint ( point , segment . point2 ) ) < 0 ) { return getVectorLength2D ( subtractPoint ( point , segment . point2 ) ) ; } return getDistanceLinePoint ( segment , point ) ; } function getSegmentDistance ( segment1 , segment2 ) { if ( isSegmentsCollide ( segment1 , segment2 ) ) { return 0 ; } return Math . min ( Math . min ( getDistanceSegmentPoint ( segment1 , segment2 . point1 ) , getDistanceSegmentPoint ( segment1 , segment2 . point2 ) ) , Math . min ( getDistanceSegmentPoint ( segment2 , segment1 . point1 ) , getDistanceSegmentPoint ( segment2 , segment1 . point2 ) ) ) ; } function ccw ( point1 , point2 , point3 ) { var vec1 = new Vector2D ( point2 . x - point1 . x , point2 . y - point1 . y ) ; var vec2 = new Vector2D ( point3 . x - point1 . x , point3 . y - point1 . y ) ; var cross = getCross ( vec1 , vec2 ) ; if ( cross > Number . EPSILON ) { return COUNTER_CLOCKWISE ; } if ( cross < - Number . EPSILON ) { return CLOCKWISE ; } if ( dotProduct2D ( vec1 , vec2 ) < - Number . EPSILON ) { return ONLINE_BACK ; } if ( getVectorLength2D ( vec1 ) < getVectorLength2D ( vec2 ) ) { return ONLINE_FRONT ; } return ON_SEGMENT ; } function getConvexHoll ( points ) { if ( points . length < 3 ) { return points ; } points . sort ( ( a , b ) => ( a . x > b . x ) ? 1 : ( a . x == b . x ) ? ( ( a . y > b . y ) ? 1 : - 1 ) : - 1 ) ; var u = [ ] ; u . push ( points [ 0 ] ) ; u . push ( points [ 1 ] ) ; var l = [ ] ; l . push ( points [ points . length - 1 ] ) ; l . push ( points [ points . length - 2 ] ) ; for ( var i = 2 ; i < points . length ; ++ i ) { for ( var j = u . length ; j >= 2 && ccw ( u [ j - 2 ] , u [ j - 1 ] , points [ i ] ) == COUNTER_CLOCKWISE ; -- j ) { u . pop ( ) ; } u . push ( points [ i ] ) ; } for ( var i = points . length - 3 ; i >= 0 ; -- i ) { for ( var j = l . length ; j >= 2 && ccw ( l [ j - 2 ] , l [ j - 1 ] , points [ i ] ) == COUNTER_CLOCKWISE ; -- j ) { l . pop ( ) ; ; } l . push ( points [ i ] ) ; } l . reverse ( ) ; for ( var i = u . length - 2 ; i >= 1 ; -- i ) { l . push ( u [ i ] ) ; } return l ; } function getConvexDiameter ( points ) { var is = 0 ; var js = 0 ; for ( var i = 1 ; i < points . length ; i ++ ) { if ( points [ i ] . y > points [ is ] . y ) is = i ; if ( points [ i ] . y < points [ js ] . y ) js = i ; } var distance = getNorm ( subtractVector ( points [ is ] , points [ js ] ) ) ; var maxi = is , i = js , maxj = js , j = js ; do { if ( getCross ( subtractVector ( points [ ( i + 1 ) % points . length ] , points [ i ] ) , subtractVector ( points [ ( j + 1 ) % points . length ] , points [ j ] ) ) >= 0 ) { j = ( j + 1 ) % points . length ; } else { i = ( i + 1 ) % points . length ; } if ( getNorm ( subtractVector ( points [ i ] , points [ j ] ) ) > distance ) { distance = getNorm ( subtractVector ( points [ i ] , points [ j ] ) ) ; maxi = i ; maxj = j ; } } while ( i != is || j != js ) ; return distance ; } function getArea ( points ) { var area = 0 ; for ( var i = 0 ; i < points . length ; ++ i ) { area += getCross ( points [ i ] , points [ ( i + 1 ) % points . length ] ) ; } return area / 2 ; } function getConvexCut ( points , point1 , point2 ) { var convex = [ ] ; for ( var i = 0 ; i < points . length ; ++ i ) { var nowPoint = points [ i ] ; var nextPoint = points [ ( i + 1 ) % points . length ] ; var nowPointCcw = ccw ( point1 , point2 , nowPoint ) ; if ( nowPointCcw != CLOCKWISE ) { convex . push ( nowPoint ) ; } if ( nowPointCcw * ccw ( point1 , point2 , nextPoint ) == CLOCKWISE ) { var crossPoint = getCrossPointFromPoints ( point1 , point2 , nowPoint , nextPoint ) ; convex . push ( crossPoint ) ; } } return convex ; } function getPointDistance ( point1 , point2 ) { var x = point1 . x - point2 . x ; var y = point1 . y - point2 . y ; return Math . sqrt ( x * x + y * y ) ; } function closestPair ( points , n ) { if ( n == 1 ) return Number . MAX_SAFE_INTEGER ; var d = Number . MAX_SAFE_INTEGER ; var m = Math . floor ( n / 2 ) ; d = Math . min ( closestPair ( points , m ) , closestPair ( points . slice ( m ) , n - m ) ) ; var mx = points [ m ] . x ; var arr = [ ] ; for ( var i = m ; i >= 0 ; -- i ) { var x = Math . abs ( points [ i ] . x - mx ) ; if ( x > d ) { break ; } else { arr . push ( points [ i ] ) ; } } for ( var i = m + 1 ; i < n ; ++ i ) { if ( Math . abs ( points [ i ] . x - mx ) > d ) { break ; } else { arr . push ( points [ i ] ) ; } } arr . sort ( ( a , b ) => ( a . y > b . y ) ? 1 : - 1 ) ; for ( var i = 0 ; i < arr . length ; ++ i ) { for ( var j = i + 1 ; j < arr . length && Math . abs ( arr [ j ] . y - arr [ i ] . y ) < d ; ++ j ) { var tmp = getPointDistance ( arr [ i ] , arr [ j ] ) ; if ( tmp < d ) d = tmp ; } } return d ; } var Circle2D = class Circle2D { constructor ( x , y , r ) { this . center = new Point2D ( x , y ) ; this . r = r ; } } function getCircleLineCrossPoints ( line , circle ) { var d = getDistanceLinePoint ( line , circle . center ) ; if ( d > circle . r ) { console . log ( \" return \" ) return ; } var pr = getProjectPoint ( line , circle . center ) ; if ( equalFloats ( d , circle . r ) ) { return pr ; } else { var unit = getUnitVector ( new Vector2D ( line . point1 . x - line . point2 . x , line . point1 . y - line . point2 . y ) ) ; var length = Math . sqrt ( ( circle . r * circle . r ) - getNorm ( subtractVector ( pr , circle . center ) ) ) ; var crossPoints = [ ] ; crossPoints [ 0 ] = addPoint ( pr , multiplyVector ( unit , length ) ) ; crossPoints [ 1 ] = subtractVector ( pr , multiplyVector ( unit , length ) ) ; return crossPoints ; } } function getPolar ( a , r ) { return new Point2D ( Math . cos ( r ) * a , Math . sin ( r ) * a ) ; } function getCircleCircleCrossPoints ( circle1 , circle2 ) { var crossPoints = [ ] ; var d = getPointDistance ( circle1 . center , circle2 . center ) ; var rDis = circle1 . r + circle2 . r ; if ( d > rDis ) { return ; } else if ( equalFloats ( d == rDis ) ) { var vec = new Vector2D ( circle2 . center . x - circle1 . center . x , circle2 . center . y - circle1 . center . y ) ; var unit = getUnitVector ( vec ) ; var point = multiplyVector ( unit , d ) ; crossPoints [ 0 ] = crossPoints [ 1 ] = point ; } else { var a = Math . acos ( ( circle1 . r * circle1 . r + d * d - circle2 . r * circle2 . r ) / ( 2 * circle1 . r * d ) ) ; var vec = subtractVector ( circle2 . center , circle1 . center ) ; var t = Math . atan2 ( vec . y , vec . x ) ; crossPoints [ 0 ] = addPoint ( circle1 . center , getPolar ( circle1 . r , t + a ) ) ; crossPoints [ 1 ] = addPoint ( circle1 . center , getPolar ( circle1 . r , t - a ) ) ; } return crossPoints ; } function getTangentsFromPoint ( circle , point ) { var base = subtractPoint ( point , circle . center ) ; var baseLength = getVectorLength2D ( base ) ; var radian = Math . acos ( circle . r / baseLength ) ; var vec1 = getDivideVector ( base , baseLength ) ; vec1 = multiplyVector ( vec1 , circle . r ) ; var points = [ ] ; points [ 0 ] = addPoint ( circle . center , getRotateVectorFromRad ( vec1 , radian ) ) ; points [ 1 ] = addPoint ( circle . center , getRotateVectorFromRad ( vec1 , - radian ) ) ; return points ; } function get3PointCross ( point1 , point2 , point3 ) { var vec1 = new Vector2D ( point2 . x - point1 . x , point2 . y - point1 . y ) ; var vec2 = new Vector2D ( point3 . x - point1 . x , point3 . y - point1 . y ) ; var cross = getCross ( vec1 , vec2 ) ; return cross ; } function inTriangle ( p1 , p2 , p3 , p ) { let ccw1 = get3PointCross ( p1 , p2 , p ) ; let ccw2 = get3PointCross ( p2 , p3 , p ) ; let ccw3 = get3PointCross ( p3 , p1 , p ) ; if ( ccw1 > 0 && ccw2 > 0 && ccw3 > 0 || ccw1 < 0 && ccw2 < 0 && ccw3 < 0 ) { return true ; } return false ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; let arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; arr . shift ( ) for ( var i = 0 ; i < arr . length ; ++ i ) { let ans = \" NG \" var numbers = arr [ i ] . split ( \" \" ) . map ( Number ) ; var p1 = new Point2D ( numbers [ 0 ] , numbers [ 1 ] ) ; var p2 = new Point2D ( numbers [ 2 ] , numbers [ 3 ] ) ; var p3 = new Point2D ( numbers [ 4 ] , numbers [ 5 ] ) ; var p4 = new Point2D ( numbers [ 6 ] , numbers [ 7 ] ) ; var p5 = new Point2D ( numbers [ 8 ] , numbers [ 9 ] ) ; if ( inTriangle ( p1 , p2 , p3 , p4 ) ^ inTriangle ( p1 , p2 , p3 , p5 ) ) { ans = \" OK \" } console . log ( ans ) ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var waitTime = [ 0 , 0 , 0 , 0 , 0 , 0 , 14 , 9 , 4 , 0 , 0 , 8 , 3 , 2 , 0 , 0 , 15 , 10 , 15 , 10 , 6 , 12 , 7 , 9 , 11 , 6 , 23 , 18 , 13 , 8 , 3 , 23 , 18 , 13 , 8 , 3 , 34 , 29 , 24 , 22 , 17 , 28 , 23 , 24 , 19 , 27 , 34 , 29 , 35 , 30 , 28 , 31 , 28 , 23 , 24 , 28 , 42 , 37 , 32 , 27 , 22 , 42 , 37 , 32 , 27 , 22 , 53 , 48 , 43 , 41 , 36 , 47 , 42 , 43 , 38 , 46 , 64 , 59 , 54 , 49 , 44 , 61 , 56 , 51 , 46 , 44 , 72 , 67 , 62 , 57 , 52 , 72 , 67 , 62 , 57 , 52 , 83 , 78 , 73 , 71 ] ; for ( var i = 0 ; i < ( input . length - 1 ) ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { for ( var i = 0 ; i < seats . length ; i ++ ) { seats [ i ] = seats [ i ] == 0 ? 0 : seats [ i ] - 1 ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 ; i < seats . length ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex ; i < ( needsSequencialSeats + startIndex ) ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 ; i < ( input . length - 1 ) ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 ; i < seats . length ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex ; i < ( needsSequencialSeats + startIndex ) ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 ; i < ( input . length - 1 ) ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { var slen = seats . length ; for ( ; slen -- ; ) { seats [ slen ] = mx ( seats [ slen ] - 1 , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 , sl = seats . length ; i < sl ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex , total = ( needsSequencialSeats + startIndex ) ; i < total ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 , ilen = ( input . length - 1 ) ; i < ilen ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function mx ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ ] ; while ( waitTime . length < 100 ) { for ( var i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( var i = 0 ; i < seats . length ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; break ; } } if ( startIndex != - 1 ) { waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var i = startIndex ; i < ( needsSequencialSeats + startIndex ) ; i ++ ) { seats [ i ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; } else { break ; } } pastMinutes ++ ; } for ( var i = 0 ; i < ( input . length - 1 ) ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var waitTime = calc ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calc ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var lastMembers = 100 ; while ( true ) { var i ; for ( i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 && i != 17 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( i = 0 ; i < seats . length ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { startIndex = i - ( needsSequencialSeats - 1 ) ; waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var j = startIndex ; j < ( needsSequencialSeats + startIndex ) ; j ++ ) { seats [ j ] = eatTimes [ headGroup % 6 ] ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; if ( ! ( -- lastMembers ) ) { return waitTime ; } break ; } } } pastMinutes ++ ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var waitTime = calc ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calc ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var lastMembers = 100 ; while ( true ) { var i ; for ( i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 && i != 17 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( i = 0 , len = seats . length ; i < len ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { var eatTime = eatTimes [ headGroup % 6 ] ; startIndex = i - ( needsSequencialSeats - 1 ) ; waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var j = startIndex , len = ( needsSequencialSeats + startIndex ) ; j < len ; j ++ ) { seats [ j ] = eatTime ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; if ( ! ( -- lastMembers ) ) { return waitTime ; } break ; } } } pastMinutes ++ ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var waitTime = calc ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calc ( ) { var seats = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var groupMembers = [ 2 , 5 , 2 , 2 , 2 ] ; var eatTimes = [ 19 , 39 , 25 , 36 , 22 , 42 ] ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var lastMembers = 100 ; while ( true ) { var i ; for ( i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 && i != 17 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( i = 0 , len = seats . length ; i < len ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { var eatTime = eatTimes [ headGroup % 6 ] ; startIndex = i - ( needsSequencialSeats - 1 ) ; waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var j = startIndex , len = ( needsSequencialSeats + startIndex ) ; j < len ; j ++ ) { seats [ j ] = eatTime ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; if ( ! ( -- lastMembers ) ) { return waitTime ; } break ; } } } pastMinutes ++ ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var waitTime = calc ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calc ( ) { var seats = new Int32Array ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) ; var groupMembers = new Int32Array ( [ 2 , 5 , 2 , 2 , 2 ] ) ; var eatTimes = new Int32Array ( [ 19 , 39 , 25 , 36 , 22 , 42 ] ) ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = new Int32Array ( 100 ) ; var lastMembers = 100 ; while ( true ) { var i ; for ( i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 && i != 17 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( i = 0 ; i < 17 ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { var eatTime = eatTimes [ headGroup % 6 ] ; startIndex = i - ( needsSequencialSeats - 1 ) ; waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var j = startIndex , len = ( needsSequencialSeats + startIndex ) ; j < len ; j ++ ) { seats [ j ] = eatTime ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; if ( ! ( -- lastMembers ) ) { return waitTime ; } break ; } } } pastMinutes ++ ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var waitTime = calc ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calc ( ) { var seats = new Int32Array ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) ; var groupMembers = new Int32Array ( [ 2 , 5 , 2 , 2 , 2 ] ) ; var eatTimes = new Int32Array ( [ 19 , 39 , 25 , 36 , 22 , 42 ] ) ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = new Int32Array ( 100 ) ; var lastMembers = 100 ; while ( true ) { var i ; for ( i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 && i != 17 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( i = 0 ; i < 17 ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { var eatTime = eatTimes [ headGroup % 6 ] ; startIndex = i - ( needsSequencialSeats - 1 ) ; waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var j = startIndex , len = ( needsSequencialSeats + startIndex ) ; j < len ; j ++ ) { seats [ j ] = eatTime ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; if ( ! ( -- lastMembers ) ) { return waitTime ; } break ; } } } pastMinutes ++ ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var waitTime = calc ( ) ; for ( var i = 0 , len = input . length - 1 ; i < len ; i ++ ) { console . log ( waitTime [ parseInt ( input [ i ] , 10 ) ] ) ; } } function calc ( ) { var seats = new Int32Array ( 17 ) ; var groupMembers = new Int32Array ( [ 2 , 5 , 2 , 2 , 2 ] ) ; var eatTimes = new Int32Array ( [ 19 , 39 , 25 , 36 , 22 , 42 ] ) ; var headGroup = - 1 ; var pastMinutes = 0 ; var waitTime = new Int32Array ( 100 ) ; var lastMembers = 100 ; while ( true ) { var i ; for ( i = 17 ; i -- ; ) { seats [ i ] = max ( -- seats [ i ] , 0 ) ; } if ( headGroup == - 1 && pastMinutes % 5 == 0 ) { headGroup = pastMinutes / 5 ; } while ( headGroup != - 1 && i != 17 ) { var needsSequencialSeats = groupMembers [ headGroup % 5 ] ; var sequencialSeats = 0 ; var startIndex = - 1 ; for ( i = 0 ; i < 17 ; i ++ ) { sequencialSeats = seats [ i ] == 0 ? sequencialSeats + 1 : 0 ; if ( sequencialSeats == needsSequencialSeats ) { var eatTime = eatTimes [ headGroup % 6 ] ; startIndex = i - ( needsSequencialSeats - 1 ) ; waitTime [ headGroup ] = pastMinutes - ( headGroup * 5 ) ; for ( var j = startIndex , len = ( needsSequencialSeats + startIndex ) ; j < len ; j ++ ) { seats [ j ] = eatTime ; } headGroup = ( ( ( headGroup + 1 ) * 5 ) <= pastMinutes ) ? headGroup + 1 : - 1 ; if ( ! ( -- lastMembers ) ) { return waitTime ; } break ; } } } pastMinutes ++ ; } } function max ( a , b ) { var t = ( a - b ) ; return a - ( t & ( t >> 31 ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var a = Arr [ i ] % 39 ; a = ( \" 0 \" + a ) . slice ( - 2 ) ; if ( a == \" 00 \" ) a = \" 39 \" ; console . log ( \" 3C \" + a ) ; }",
    "label": 2
  },
  {
    "code": "let input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; let Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; ++ i ) { let n = Arr [ i ] ; var ans = n % 39 ; if ( ans == 0 ) ans = 39 if ( ans < 10 ) { ans = \" 0 \" + ans } console . log ( \" 3C \" + ans ) ; }",
    "label": 2
  },
  {
    "code": "function count ( y , x ) { var dy = [ 0 , 1 , 1 , 1 ] ; var dx = [ 1 , - 1 , 0 , 1 ] ; var max = 0 ; for ( var i = 0 ; i < 4 ; i ++ ) { var cnt = 0 ; for ( var j = 0 ; j <= n ; j ++ ) { var yy = y + ( dy [ i ] * j ) ; var xx = x + ( dx [ i ] * j ) ; if ( yy < 0 || xx < 0 || yy >= n || xx >= n ) break ; if ( yx [ yy ] [ xx ] != 1 ) break ; cnt ++ ; } max = Math . max ( max , cnt ) ; cnt = 0 ; } return max ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var yx = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { yx [ i ] = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; } var max = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( yx [ i ] [ j ] == 1 ) max = Math . max ( max , count ( i , j ) ) ; } } console . log ( max ) ; }",
    "label": 2
  },
  {
    "code": "function count ( y , x ) { var dy = [ 0 , 1 , 1 , 1 ] ; var dx = [ 1 , - 1 , 0 , 1 ] ; var max = 1 ; for ( var i = 0 ; i < 4 ; i ++ ) { var cnt = 0 ; for ( var j = 0 ; j <= n ; j ++ ) { var yy = y + ( dy [ i ] * j ) ; var xx = x + ( dx [ i ] * j ) ; if ( yy < 0 || xx < 0 || yy >= n || xx >= n ) break ; if ( yx [ yy ] [ xx ] != 1 ) break ; cnt ++ ; } max = Math . max ( max , cnt ) ; cnt = 0 ; } return max ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var yx = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { yx [ i ] = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; } var max = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( yx [ i ] [ j ] == 1 ) max = Math . max ( max , count ( i , j ) ) ; } } console . log ( max ) ; }",
    "label": 2
  },
  {
    "code": "function count ( y , x ) { var dy = [ 0 , 1 , 1 , 1 ] ; var dx = [ 1 , - 1 , 0 , 1 ] ; var max = 1 ; for ( var i = 0 ; i < 4 ; i ++ ) { var cnt = 1 ; for ( var j = 1 ; j <= n ; j ++ ) { var yy = y + ( dy [ i ] * j ) ; var xx = x + ( dx [ i ] * j ) ; if ( yy < 0 || xx < 0 || yy >= n || xx >= n ) break ; if ( yx [ yy ] [ xx ] != 1 ) break ; cnt ++ ; } max = Math . max ( max , cnt ) ; cnt = 1 ; } return max ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var yx = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { yx [ i ] = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; } var max = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( yx [ i ] [ j ] == 1 ) max = Math . max ( max , count ( i , j ) ) ; } } console . log ( max ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n === 0 ) break ; var ans = [ ] ; for ( var I = 0 ; I < n ; I ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) ; var name = arr . shift ( ) - 0 ; arr = arr . map ( Number ) ; var score = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var bonus = [ ] ; var ab = 0 ; var now = 0 ; for ( var i = 0 ; i < arr . length ; i ++ ) { var v = arr [ i ] ; score [ now ] += v ; if ( bonus . indexOf ( \" b1 \" ) != - 1 ) bonus [ bonus . indexOf ( \" b1 \" ) ] = v ; if ( bonus . indexOf ( \" b1 \" ) != - 1 ) bonus [ bonus . indexOf ( \" b1 \" ) ] = v ; if ( bonus . indexOf ( \" b2 \" ) != - 1 ) bonus [ bonus . indexOf ( \" b2 \" ) ] = \" b1 \" ; if ( now == 9 ) continue ; if ( v == 10 ) { if ( ab == 0 ) { bonus . push ( \" b1 \" ) ; bonus . push ( \" b2 \" ) ; } if ( ab == 1 ) bonus . push ( \" b1 \" ) ; now ++ ; ab = 0 ; } else if ( ab == 1 ) { if ( score [ now ] == 10 ) bonus . push ( \" b1 \" ) ; now ++ ; ab = 0 ; } else if ( ab == 0 ) { ab = 1 ; } } score = score . concat ( bonus ) ; var sum = score . reduce ( function ( a , b ) { return a + b ; } ) ; ans . push ( [ name , sum ] ) ; } ans . sort ( function ( a , b ) { if ( a [ 1 ] == b [ 1 ] ) return a [ 0 ] - b [ 0 ] ; else return b [ 1 ] - a [ 1 ] ; } ) ; ans . forEach ( function ( v ) { console . log ( v [ 0 ] + \" \" + v [ 1 ] ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "function bomb ( start , sum ) { dp [ start ] [ sum ] ++ ; if ( start == card . length ) return ; var v = card [ start ] [ 0 ] ; var k = card [ start ] [ 1 ] ; for ( var i = 0 ; i <= k ; i ++ ) { bomb ( start + 1 , sum + v * i ) ; } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var m = arr . shift ( ) - 0 ; if ( m == 0 ) break ; var card = [ ] ; while ( m -- ) card . push ( arr . shift ( ) . split ( \" \" ) . map ( Number ) ) ; var g = arr . shift ( ) - 0 ; var dp = [ ] ; for ( var i = 0 ; i <= card . length ; i ++ ) { dp [ i ] = [ ] ; for ( var j = 0 ; j <= 1000 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } bomb ( 0 , 0 ) ; while ( g -- ) console . log ( dp [ card . length ] [ arr . shift ( ) - 0 ] ) ; }",
    "label": 2
  },
  {
    "code": "function Longest ( ) { ary . sort ( function ( a , b ) { if ( a [ 0 ] == b [ 0 ] ) return a [ 1 ] - b [ 1 ] ; else return a [ 0 ] - b [ 0 ] } ) ; var A = ary . filter ( function ( v , i ) { if ( i == 0 ) return true ; else if ( ary [ i - 1 ] [ 0 ] != v [ 0 ] ) return true ; } ) ; A = A . map ( function ( v ) { return v [ 1 ] ; } ) ; var L = [ ] ; L [ 0 ] = A [ 0 ] ; var length = 1 ; for ( var i = 1 ; i < A . length ; i ++ ) { if ( L [ length - 1 ] < A [ i ] ) L [ length ++ ] = A [ i ] ; else { for ( var j = 0 ; j < length ; j ++ ) { if ( L [ j ] >= A [ i ] ) { L [ j ] = A [ i ] ; break ; } } } } return length ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var n = arr . shift ( ) - 0 ; if ( n == 0 ) break ; var ary = [ ] ; for ( var i = 0 ; i < n ; i ++ ) ary . push ( arr . shift ( ) . split ( \" \" ) . map ( Number ) ) ; var m = arr . shift ( ) - 0 ; for ( var i = 0 ; i < m ; i ++ ) ary . push ( arr . shift ( ) . split ( \" \" ) . map ( Number ) ) ; var R = Longest ( ) ; ary = ary . map ( function ( v ) { return [ v [ 1 ] , v [ 0 ] ] ; } ) ; var H = Longest ( ) ; console . log ( Math . max ( R , H ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var L = arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ; var W = arr [ 3 ] ; var x ; if ( L > 160 ) x = 0 ; if ( L <= 160 ) x = 1600 ; if ( L <= 140 ) x = 1400 ; if ( L <= 120 ) x = 1200 ; if ( L <= 100 ) x = 1000 ; if ( L <= 80 ) x = 800 ; if ( L <= 60 ) x = 600 ; var y ; if ( W > 25 ) y = 0 ; if ( W <= 25 ) y = 1600 ; if ( W <= 20 ) y = 1400 ; if ( W <= 15 ) y = 1200 ; if ( W <= 10 ) y = 1000 ; if ( W <= 5 ) y = 800 ; if ( W <= 2 ) y = 600 ; if ( x != 0 && y != 0 ) sum += Math . max ( x , y ) ; } console . log ( sum ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var team = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var a = ( arr [ 1 ] * 60 ) + arr [ 2 ] ; var b = ( arr [ 3 ] * 60 ) + arr [ 4 ] ; var c = ( arr [ 5 ] * 60 ) + arr [ 6 ] ; var d = ( arr [ 7 ] * 60 ) + arr [ 8 ] ; team . push ( [ arr [ 0 ] , a + b + c + d ] ) ; } team . sort ( function ( a , b ) { a = a [ 1 ] ; b = b [ 1 ] ; return a - b ; } ) ; console . log ( team [ 0 ] [ 0 ] ) ; console . log ( team [ 1 ] [ 0 ] ) ; console . log ( team [ team . length - 2 ] [ 0 ] ) ; }",
    "label": 2
  },
  {
    "code": "function hamming ( ) { var obj = { } ; for ( var i = 1 ; i <= 1000000 ; i ++ ) { var h = i ; while ( h % 2 == 0 ) h /= 2 ; while ( h % 3 == 0 ) h /= 3 ; while ( h % 5 == 0 ) h /= 5 ; if ( h == 1 ) obj [ i ] = true } return obj ; } var Numbers = hamming ( ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var mn = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( mn [ 0 ] == 0 ) break ; var cnt = 0 ; for ( var i = mn [ 0 ] ; i <= mn [ 1 ] ; i ++ ) { if ( Numbers [ i ] ) cnt ++ ; } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var x = { } ; x [ \" 1to2 \" ] = 300 ; x [ \" 1to3 \" ] = 500 ; x [ \" 1to4 \" ] = 600 ; x [ \" 1to5 \" ] = 700 ; x [ \" 1to6 \" ] = 1350 ; x [ \" 1to7 \" ] = 1650 ; x [ \" 2to1 \" ] = 6 ; x [ \" 2to3 \" ] = 350 ; x [ \" 2to4 \" ] = 450 ; x [ \" 2to5 \" ] = 600 ; x [ \" 2to6 \" ] = 1150 ; x [ \" 2to7 \" ] = 1500 ; x [ \" 3to1 \" ] = 13 ; x [ \" 3to2 \" ] = 7 ; x [ \" 3to4 \" ] = 250 ; x [ \" 3to5 \" ] = 400 ; x [ \" 3to6 \" ] = 1000 ; x [ \" 3to7 \" ] = 1350 ; x [ \" 4to1 \" ] = 18 ; x [ \" 4to2 \" ] = 12 ; x [ \" 4to3 \" ] = 5 ; x [ \" 4to5 \" ] = 250 ; x [ \" 4to6 \" ] = 850 ; x [ \" 4to7 \" ] = 1300 ; x [ \" 5to1 \" ] = 23 ; x [ \" 5to2 \" ] = 17 ; x [ \" 5to3 \" ] = 10 ; x [ \" 5to4 \" ] = 5 ; x [ \" 5to6 \" ] = 600 ; x [ \" 5to7 \" ] = 1150 ; x [ \" 6to1 \" ] = 43 ; x [ \" 6to2 \" ] = 37 ; x [ \" 6to3 \" ] = 30 ; x [ \" 6to4 \" ] = 25 ; x [ \" 6to5 \" ] = 20 ; x [ \" 6to7 \" ] = 500 ; x [ \" 7to1 \" ] = 58 ; x [ \" 7to2 \" ] = 52 ; x [ \" 7to3 \" ] = 45 ; x [ \" 7to4 \" ] = 40 ; x [ \" 7to5 \" ] = 35 ; x [ \" 7to6 \" ] = 15 ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var s = Arr . shift ( ) - 0 ; if ( s == 0 ) break ; var hm1 = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var g = Arr . shift ( ) - 0 ; var hm2 = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var S = ( parseInt ( hm1 [ 0 ] , 10 ) * 60 ) + parseInt ( hm1 [ 1 ] , 10 ) ; var G = ( parseInt ( hm2 [ 0 ] , 10 ) * 60 ) + parseInt ( hm2 [ 1 ] , 10 ) ; var cnt = 0 ; if ( ( S <= 1050 && G <= 1170 ) || ( S >= 1050 && G >= 1170 ) || ( S >= 1050 && G <= 1170 ) ) cnt ++ ; if ( x [ g + \" to \" + s ] <= 40 ) cnt ++ ; var money = x [ s + \" to \" + g ] ; if ( cnt == 2 ) { money = Math . floor ( money / 2 ) ; while ( money % 50 != 0 ) money ++ ; } console . log ( money ) ; }",
    "label": 2
  },
  {
    "code": "var x = { } ; x [ \" 1to2 \" ] = 300 ; x [ \" 1to3 \" ] = 500 ; x [ \" 1to4 \" ] = 600 ; x [ \" 1to5 \" ] = 700 ; x [ \" 1to6 \" ] = 1350 ; x [ \" 1to7 \" ] = 1650 ; x [ \" 2to1 \" ] = 6 ; x [ \" 2to3 \" ] = 350 ; x [ \" 2to4 \" ] = 450 ; x [ \" 2to5 \" ] = 600 ; x [ \" 2to6 \" ] = 1150 ; x [ \" 2to7 \" ] = 1500 ; x [ \" 3to1 \" ] = 13 ; x [ \" 3to2 \" ] = 7 ; x [ \" 3to4 \" ] = 250 ; x [ \" 3to5 \" ] = 400 ; x [ \" 3to6 \" ] = 1000 ; x [ \" 3to7 \" ] = 1350 ; x [ \" 4to1 \" ] = 18 ; x [ \" 4to2 \" ] = 12 ; x [ \" 4to3 \" ] = 5 ; x [ \" 4to5 \" ] = 250 ; x [ \" 4to6 \" ] = 850 ; x [ \" 4to7 \" ] = 1300 ; x [ \" 5to1 \" ] = 23 ; x [ \" 5to2 \" ] = 17 ; x [ \" 5to3 \" ] = 10 ; x [ \" 5to4 \" ] = 5 ; x [ \" 5to6 \" ] = 600 ; x [ \" 5to7 \" ] = 1150 ; x [ \" 6to1 \" ] = 43 ; x [ \" 6to2 \" ] = 37 ; x [ \" 6to3 \" ] = 30 ; x [ \" 6to4 \" ] = 25 ; x [ \" 6to5 \" ] = 20 ; x [ \" 6to7 \" ] = 500 ; x [ \" 7to1 \" ] = 58 ; x [ \" 7to2 \" ] = 52 ; x [ \" 7to3 \" ] = 45 ; x [ \" 7to4 \" ] = 40 ; x [ \" 7to5 \" ] = 35 ; x [ \" 7to6 \" ] = 15 ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var s = Arr . shift ( ) - 0 ; if ( s == 0 ) break ; var hm1 = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var g = Arr . shift ( ) - 0 ; var hm2 = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var S = ( parseInt ( hm1 [ 0 ] , 10 ) * 60 ) + parseInt ( hm1 [ 1 ] , 10 ) ; var G = ( parseInt ( hm2 [ 0 ] , 10 ) * 60 ) + parseInt ( hm2 [ 1 ] , 10 ) ; var cnt = 0 ; if ( ( S >= 1050 && S <= 1170 ) || G >= 1050 && G <= 1170 ) cnt ++ ; if ( x [ g + \" to \" + s ] <= 40 ) cnt ++ ; var money = x [ s + \" to \" + g ] ; if ( cnt == 2 ) { money = Math . floor ( money / 2 ) ; while ( money % 50 != 0 ) money ++ ; } console . log ( money ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var ball = 32 ; var i = 0 ; while ( true ) { ball -= ( ball - 1 ) % 5 ; console . log ( ball ) ; if ( ball == 1 ) { console . log ( 0 ) ; break ; } ball -= arr [ i % n ] ; i ++ ; console . log ( ball ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var arr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var x = Arr . shift ( ) - 0 ; arr . push ( x ) ; } var L = 1 ; var cnt = 0 ; while ( true ) { if ( arr . length == L ) break ; for ( var i = 0 ; i < arr . length - L ; i ++ ) { var memo = arr [ i ] ; if ( arr [ i ] > arr [ i + 1 ] ) { cnt ++ ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = memo ; } } L ++ ; } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "#!/usr/bin/node (function(){ var T=[]; var stdin = process.openStdin(); stdin.setEncoding('utf8'); var a=[1,1,2]; for(var i=3;i<31;i++)a.push(a[i-1]+a[i-2]+a[i-3]); var input_fragment=\"\"; stdin.on('data', function(input) { var ref=(input_fragment+input).split(\"\\n\"); input_fragment=ref.pop(); for(var i=0;i<ref.length;i++){ if(ref[i]=='')continue; T.push(ref[i]^0); } }); stdin.on('end', function(z) { for(var i=0;T[i];i++){ console.log((a[T[i]]+3649)/3650^0); } }); })();",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var dp = [ 1 , 2 , 4 ] ; for ( var i = 3 ; i <= 31 ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; } while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; console . log ( Math . ceil ( dp [ n - 1 ] / 3650 ) ) ; }",
    "label": 2
  },
  {
    "code": "var tab = { } ; tab [ 0 ] = 1 ; tab [ 1 ] = 1 ; tab [ 2 ] = 2 ; function af ( n ) { if ( n in tab ) return tab [ n ] ; tab [ n ] = af ( n - 1 ) + af ( n - 2 ) + af ( n - 3 ) ; return tab [ n ] ; } function solve ( n ) { return Math . ceil ( af ( n ) / 10 / 365 ) } require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf-8 \" ) . split ( \" \\n \" ) . forEach ( function ( x ) { x = + x ; if ( x == 0 ) return ; console . log ( solve ( x ) ) } )",
    "label": 2
  },
  {
    "code": "#!/usr/bin/node (function(){ var T=[]; var stdin = process.openStdin(); stdin.setEncoding('utf8'); var a=[1,1,2]; for(var i=3;i<31;i++)a.push(a[i-1]+a[i-2]+a[i-3]); stdin.on('data', function(input) { var i=0,len,ref,x=[]; ref=input.split(\"\\n\"); for(len=ref.length;i<len;i++){ if(ref[i]=='')continue; x.push(ref[i]^0); } if(x.length>2||!isNaN(x[1]))T=x; else T.push(x[0]); }); stdin.on('end', function(z) { for(var i=0;T[i];i++){ console.log((a[T[i]]+3649)/3650^0); } }); })();",
    "label": 2
  },
  {
    "code": "function Main ( s ) { var arr = s . split ( \" \\n \" ) ; var dp = [ 1 , 1 , 2 ] ; for ( var i = 3 ; i < 31 ; i ++ ) { dp [ i ] = dp [ i - 3 ] + dp [ i - 2 ] + dp [ i - 1 ] ; } for ( var i = 0 ; i < s . length - 1 ; i ++ ) { if ( arr [ i ] == \" 0 \" ) break ; console . log ( Math . ceil ( dp [ arr [ i ] ] / 3650 ) ) ; } } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( arr [ 0 ] == 0 ) break ; var sum = 0 ; arr = arr . filter ( function ( v ) { if ( v > 10 ) v = 10 ; sum += v ; return v == 1 ; } ) ; var i = arr . length ; while ( i != 0 ) { if ( sum + 10 <= 21 ) sum += 10 ; i -- ; } console . log ( ( sum > 21 ) ? 0 : sum ) ; }",
    "label": 2
  },
  {
    "code": "const stdin = require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" UTF-8 \" ) ; const lines = stdin . split ( / \\r?\\n / g ) . filter ( x => ! ! x ) ; for ( const line of lines ) { if ( line == \" 0 \" ) break ; const c = line . split ( \" \" ) . map ( x => Math . min ( 10 , + x ) ) ; const ones = c . filter ( x => x === 1 ) . length ; const s0 = c . reduce ( ( a , b ) => a + b , 0 ) ; let snum = 0 ; for ( let i = 0 ; i <= ones ; i ++ ) { const siraw = s0 + 10 * i ; const si = siraw > 21 ? 0 : siraw ; snum = Math . max ( snum , si ) ; } console . log ( snum ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var n = arr . shift ( ) - 0 ; if ( n == 0 ) break ; var nww = [ ] ; for ( var i = 0 ; i < n ; i ++ ) nww [ i ] = arr . shift ( ) . split ( \" \" ) ; nww = nww . map ( v => [ v [ 0 ] , v [ 1 ] - 0 , v [ 2 ] - 0 ] ) ; nww . sort ( ( a , b ) => { return b [ 1 ] - a [ 1 ] ; } ) ; var max = 0 ; var ans = [ ] ; var bomb = function ( arrA , arrB , sum , g ) { if ( arrB . length == 0 ) { if ( max < g / sum ) { ans = arrA ; max = g / sum ; } return ; } for ( var i = 0 ; i < arrB . length ; i ++ ) { var v = arrB [ i ] ; if ( sum <= nww [ v ] [ 2 ] ) { var a = arrA . concat ( v ) ; var b = arrB . filter ( n => v != n ) ; bomb ( a , b , sum + nww [ v ] [ 1 ] , g + nww [ v ] [ 1 ] * ( arrA . length + 1 ) ) ; } } } ; var bombArr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) bombArr . push ( i ) ; bomb ( [ ] , bombArr , 0 , 0 ) ; console . log ( ans . map ( v => nww [ v ] [ 0 ] ) . reverse ( ) . join ( \" \\n \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var n = arr . shift ( ) - 0 ; if ( n == 0 ) break ; var nww = [ ] ; for ( var i = 0 ; i < n ; i ++ ) nww [ i ] = arr . shift ( ) . split ( \" \" ) ; nww = nww . map ( v => [ v [ 0 ] , v [ 1 ] - 0 , v [ 2 ] - 0 ] ) ; nww . sort ( ( a , b ) => { return b [ 1 ] - a [ 1 ] ; } ) ; var max = 0 ; var ans = \" \" ; var bomb = function ( str , arrB , sum , g ) { if ( arrB . length == 0 ) { if ( max < g / sum ) { ans = str ; max = g / sum ; } return ; } for ( var i = 0 ; i < arrB . length ; i ++ ) { var v = arrB [ i ] ; if ( sum <= nww [ v ] [ 2 ] ) { var a = str + v ; var b = arrB . filter ( n => v != n ) ; bomb ( a , b , sum + nww [ v ] [ 1 ] , g + nww [ v ] [ 1 ] * ( str . length + 1 ) ) ; } } } ; var bombArr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) bombArr . push ( i ) ; bomb ( \" \" , bombArr , 0 , 0 ) ; console . log ( ans . split ( \" \" ) . map ( v => nww [ v - 0 ] [ 0 ] ) . reverse ( ) . join ( \" \\n \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var n = arr . shift ( ) - 0 ; if ( n == 0 ) break ; var nww = [ ] ; for ( var i = 0 ; i < n ; i ++ ) nww [ i ] = arr . shift ( ) . split ( \" \" ) ; nww = nww . map ( v => [ v [ 0 ] , v [ 1 ] - 0 , v [ 2 ] - 0 ] ) ; nww . sort ( ( a , b ) => { return b [ 1 ] - a [ 1 ] ; } ) ; var max = 0 ; var ans = [ ] ; var bomb = function ( strA , strB , sum , g ) { if ( strB . length == 0 ) { if ( max < g / sum ) { ans = strA ; max = g / sum ; } return ; } for ( var i = 0 ; i < strB . length ; i ++ ) { var v = strB [ i ] ; if ( sum <= nww [ v ] [ 2 ] ) { var a = strA + v ; var b = strB . replace ( v , \" \" ) ; bomb ( a , b , sum + nww [ v - 0 ] [ 1 ] , g + nww [ v - 0 ] [ 1 ] * ( strA . length + 1 ) ) ; } } } ; var str = \" \" ; for ( var i = 0 ; i < n ; i ++ ) str += i ; bomb ( \" \" , str , 0 , 0 ) ; console . log ( ans . split ( \" \" ) . map ( v => nww [ v - 0 ] [ 0 ] ) . reverse ( ) . join ( \" \\n \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var n = arr . shift ( ) - 0 ; if ( n == 0 ) break ; var nww = [ ] ; for ( var i = 0 ; i < n ; i ++ ) nww [ i ] = arr . shift ( ) . split ( \" \" ) ; nww = nww . map ( v => [ v [ 0 ] , v [ 1 ] - 0 , v [ 2 ] - 0 ] ) ; nww . sort ( ( a , b ) => { return b [ 1 ] - a [ 1 ] ; } ) ; var max = 0 ; var ans = \" \" ; var bomb = function ( strA , strB , sum , g ) { if ( strB . length == 0 ) { if ( max < g ) { ans = strA ; max = g ; } return ; } for ( var i = 0 ; i < strB . length ; i ++ ) { var v = strB [ i ] ; if ( sum <= nww [ v ] [ 2 ] ) { var a = strA + v ; var b = strB . replace ( v , \" \" ) ; bomb ( a , b , sum + nww [ v - 0 ] [ 1 ] , g + nww [ v - 0 ] [ 1 ] * ( strA . length + 1 ) ) ; } } } ; var str = \" \" ; for ( var i = 0 ; i < n ; i ++ ) str += i ; bomb ( \" \" , str , 0 , 0 ) ; console . log ( ans . split ( \" \" ) . map ( v => nww [ v - 0 ] [ 0 ] ) . reverse ( ) . join ( \" \\n \" ) ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) ; var a = ( arr [ 1 ] - 0 ) + ( arr [ 2 ] - 0 ) ; var b = ( arr [ 1 ] - 0 ) * 200 + ( arr [ 2 ] - 0 ) * 300 ; console . log ( arr [ 0 ] + \" \" + a + \" \" + b ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var color = \" black,blue,lime,aqua,red,fuchsia,yellow,white \" . split ( \" , \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == \" 0 \" ) break ; var str = Arr [ i ] . slice ( 1 ) ; var arr = [ ] ; str . replace ( / (..) / g , function ( v ) { arr . push ( parseInt ( v , 16 ) ) ; } ) ; var r = arr [ 0 ] ; var g = arr [ 1 ] ; var b = arr [ 2 ] ; var R = Math . pow ( r - 255 , 2 ) ; var G = Math . pow ( g - 255 , 2 ) ; var B = Math . pow ( b - 255 , 2 ) ; var abc = [ ] ; abc . push ( Math . sqrt ( r * r + g * g + b * b ) ) ; abc . push ( Math . sqrt ( r * r + g * g + B ) ) ; abc . push ( Math . sqrt ( r * r + G + b * b ) ) ; abc . push ( Math . sqrt ( r * r + G + B ) ) ; abc . push ( Math . sqrt ( R + g * g + b * b ) ) ; abc . push ( Math . sqrt ( R + g * g + B ) ) ; abc . push ( Math . sqrt ( R + G + b * b ) ) ; abc . push ( Math . sqrt ( R + G + B ) ) ; var min = Math . min . apply ( null , abc ) ; console . log ( color [ abc . indexOf ( min ) ] ) ; }",
    "label": 2
  },
  {
    "code": "( function ( input ) { var lines = input . split ( \" \\n \" ) ; var colors = [ [ ' black ' , 0x00 , 0x00 , 0x00 ] , [ ' blue ' , 0x00 , 0x00 , 0xff ] , [ ' lime ' , 0x00 , 0xff , 0x00 ] , [ ' aqua ' , 0x00 , 0xff , 0xff ] , [ ' red ' , 0xff , 0x00 , 0x00 ] , [ ' fuchsia ' , 0xff , 0x00 , 0xff ] , [ ' yellow ' , 0xff , 0xff , 0x00 ] , [ ' white ' , 0xff , 0xff , 0xff ] , ] ; for ( var i = 0 ; i < lines . length ; ++ i ) { if ( lines [ i ] [ 0 ] === ' # ' ) { var best_color ; var min_d = 3 * 256 * 256 + 1 ; var r = parseInt ( lines [ i ] . substr ( 1 , 2 ) , 16 ) ; var g = parseInt ( lines [ i ] . substr ( 3 , 2 ) , 16 ) ; var b = parseInt ( lines [ i ] . substr ( 5 , 2 ) , 16 ) ; for ( var j = 0 ; j < colors . length ; ++ j ) { var d = Math . pow ( r - colors [ j ] [ 1 ] , 2 ) + Math . pow ( g - colors [ j ] [ 2 ] , 2 ) + Math . pow ( b - colors [ j ] [ 3 ] , 2 ) ; if ( d < min_d ) { min_d = d ; best_color = colors [ j ] [ 0 ] ; } } console . log ( best_color ) ; } } } ) ( require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . trim ( ) ) ;",
    "label": 2
  },
  {
    "code": "function BFS ( x ) { var obj = { } ; var bfs = [ [ x , 0 ] ] ; obj [ x ] = true ; while ( true ) { if ( bfs . length == 0 ) { ans = \" NA \" ; break ; } var leaf = bfs . shift ( ) ; var str = leaf [ 0 ] ; var cnt = leaf [ 1 ] ; if ( / ^0+$|^1+$|^2+$ / . test ( str ) ) { ans = cnt ; break ; } for ( var i = 0 ; i < str . length - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) continue ; var arr = str . split ( \" \" ) ; var color = 3 - ( + arr [ i ] ) - ( + arr [ i + 1 ] ) ; arr [ i ] = color ; arr [ i + 1 ] = color ; var Str = arr . join ( \" \" ) ; if ( obj . hasOwnProperty ( Str ) == false ) { bfs . push ( [ Str , cnt + 1 ] ) ; obj [ Str ] = true ; } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var rgb = Arr . shift ( ) ; if ( rgb == \" 0 \" ) break ; rgb = rgb . replace ( / r / g , \" 0 \" ) . replace ( / g / g , \" 1 \" ) . replace ( / b / g , \" 2 \" ) var ans ; BFS ( rgb ) ; console . log ( ans ) ; }",
    "label": 2
  },
  {
    "code": "const input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; const inputs = input . trim ( ) . split ( ' \\n ' ) ; const COLORS = [ ' r ' , ' g ' , ' b ' ] ; class Worm { constructor ( id , depth ) { this . id = id ; this . depth = depth ; this . colors = id . split ( ' ' ) ; } getNextWormIds ( ) { const nextWormIds = [ ] ; for ( let i = 0 ; i < this . colors . length - 1 ; i ++ ) { const color = this . colors [ i ] ; const nextColor = this . colors [ i + 1 ] ; if ( color === nextColor ) { continue ; } const changedColor = COLORS . filter ( s => s !== color && s !== nextColor ) [ 0 ] ; const changedColors = this . colors . slice ( ) ; changedColors . splice ( i , 2 , changedColor , changedColor ) ; nextWormIds . push ( changedColors . join ( ' ' ) ) ; } return nextWormIds ; } } class Graph { constructor ( ) { this . map = new Map ( ) ; } has ( id ) { return this . map . has ( id ) ; } get ( id ) { return this . map . get ( id ) ; } set ( id , depth ) { this . map . set ( id , new Worm ( id , depth ) ) ; } bfs ( wormId ) { this . queue = [ ] ; this . set ( wormId , 0 ) ; this . queue . push ( wormId ) ; while ( this . queue . length ) { const wormId = this . queue . shift ( ) ; const worm = this . get ( wormId ) ; const wormIds = worm . getNextWormIds ( ) ; if ( ! wormIds . length ) { return worm ; } wormIds . forEach ( wormId => { if ( this . has ( wormId ) ) { return ; } this . set ( wormId , worm . depth + 1 ) ; this . queue . push ( wormId ) ; } ) } } print ( ) { for ( let i = 1 ; i <= this . map . size ; i ++ ) { const node = this . map . get ( i ) ; console . log ( node . toString ( ) ) ; } } } inputs . forEach ( wormId => { if ( wormId === ' 0 ' ) { return ; } const graph = new Graph ( ) ; const worm = graph . bfs ( wormId ) ; console . log ( worm ? worm . depth : ' NA ' ) ; } ) ;",
    "label": 2
  },
  {
    "code": "const input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; const inputs = input . trim ( ) . split ( ' \\n ' ) ; const COLORS = [ ' r ' , ' g ' , ' b ' ] ; class Worm { constructor ( id , depth ) { this . id = id ; this . depth = depth ; this . colors = id . split ( ' ' ) ; } getNextWormIds ( ) { const nextWormIds = [ ] ; for ( let i = 0 ; i < this . colors . length - 1 ; i ++ ) { const [ current , next ] = this . colors . slice ( i , i + 2 ) ; if ( current === next ) { continue ; } const changed = COLORS . filter ( s => s !== current && s !== next ) [ 0 ] ; const changedColors = this . colors . slice ( ) ; changedColors . splice ( i , 2 , changed , changed ) ; nextWormIds . push ( changedColors . join ( ' ' ) ) ; } return nextWormIds ; } } class Graph { constructor ( ) { this . map = new Map ( ) ; } has ( id ) { return this . map . has ( id ) ; } get ( id ) { return this . map . get ( id ) ; } set ( id , depth ) { this . map . set ( id , new Worm ( id , depth ) ) ; } bfs ( wormId ) { this . queue = [ ] ; this . map . set ( wormId , new Worm ( wormId , 0 ) ) ; this . queue . push ( wormId ) ; while ( this . queue . length ) { const wormId = this . queue . shift ( ) ; const worm = this . map . get ( wormId ) ; const wormIds = worm . getNextWormIds ( ) ; if ( ! wormIds . length ) { return worm ; } wormIds . forEach ( wormId => { if ( this . map . has ( wormId ) ) { return ; } this . map . set ( wormId , new Worm ( wormId , worm . depth + 1 ) ) ; this . queue . push ( wormId ) ; } ) } } } inputs . forEach ( wormId => { if ( wormId === ' 0 ' ) { return ; } const graph = new Graph ( ) ; const worm = graph . bfs ( wormId ) ; console . log ( worm ? worm . depth : ' NA ' ) ; } ) ;",
    "label": 2
  },
  {
    "code": "const input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; const inputs = input . trim ( ) . split ( ' \\n ' ) ; const COLORS = [ ' r ' , ' g ' , ' b ' ] ; class Worm { constructor ( id , depth ) { this . id = id ; this . depth = depth ; this . colors = id . split ( ' ' ) ; } getNextWormIds ( ) { const nextWormIds = [ ] ; for ( let i = 0 ; i < this . colors . length - 1 ; i ++ ) { const [ current , next ] = this . colors . slice ( i , i + 2 ) ; if ( current === next ) { continue ; } const changed = COLORS . filter ( s => s !== current && s !== next ) [ 0 ] ; const changedColors = this . colors . slice ( ) ; changedColors . splice ( i , 2 , changed , changed ) ; nextWormIds . push ( changedColors . join ( ' ' ) ) ; } return nextWormIds ; } } class Graph { constructor ( ) { this . map = new Map ( ) ; } bfs ( wormId ) { this . queue = [ ] ; this . map . set ( wormId , new Worm ( wormId , 0 ) ) ; this . queue . push ( wormId ) ; while ( this . queue . length ) { const wormId = this . queue . shift ( ) ; const worm = this . map . get ( wormId ) ; const wormIds = worm . getNextWormIds ( ) ; if ( ! wormIds . length ) { return worm ; } wormIds . forEach ( wormId => { if ( this . map . has ( wormId ) ) { return ; } this . map . set ( wormId , new Worm ( wormId , worm . depth + 1 ) ) ; this . queue . push ( wormId ) ; } ) } } } inputs . forEach ( wormId => { if ( wormId === ' 0 ' ) { return ; } const graph = new Graph ( ) ; const worm = graph . bfs ( wormId ) ; console . log ( worm ? worm . depth : ' NA ' ) ; } ) ;",
    "label": 2
  },
  {
    "code": "const input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; const inputs = input . trim ( ) . split ( ' \\n ' ) ; const COLORS = [ ' r ' , ' g ' , ' b ' ] ; class Worm { constructor ( id , depth ) { this . id = id ; this . depth = depth ; this . colors = id . split ( ' ' ) ; } getNextWormIds ( ) { const nextWormIds = [ ] ; for ( let i = 0 ; i < this . colors . length - 1 ; i ++ ) { const [ current , next ] = this . colors . slice ( i , i + 2 ) ; if ( current === next ) { continue ; } const changed = COLORS . find ( s => s !== current && s !== next ) ; const changedColors = this . colors . slice ( ) ; changedColors . splice ( i , 2 , changed , changed ) ; nextWormIds . push ( changedColors . join ( ' ' ) ) ; } return nextWormIds ; } } class Graph { constructor ( ) { this . map = new Map ( ) ; } bfs ( wormId ) { this . queue = [ ] ; this . map . set ( wormId , new Worm ( wormId , 0 ) ) ; this . queue . push ( wormId ) ; while ( this . queue . length ) { const wormId = this . queue . shift ( ) ; const worm = this . map . get ( wormId ) ; const wormIds = worm . getNextWormIds ( ) ; if ( ! wormIds . length ) { return worm ; } wormIds . forEach ( wormId => { if ( this . map . has ( wormId ) ) { return ; } this . map . set ( wormId , new Worm ( wormId , worm . depth + 1 ) ) ; this . queue . push ( wormId ) ; } ) } } } inputs . forEach ( wormId => { if ( wormId === ' 0 ' ) { return ; } const graph = new Graph ( ) ; const worm = graph . bfs ( wormId ) ; console . log ( worm ? worm . depth : ' NA ' ) ; } ) ;",
    "label": 2
  },
  {
    "code": "const input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; const inputs = input . trim ( ) . split ( ' \\n ' ) ; const COLORS = [ ' r ' , ' g ' , ' b ' ] ; class Worm { constructor ( id , seconds ) { this . id = id ; this . seconds = seconds ; } getNextWormIds ( ) { const nextWormIds = [ ] ; for ( let i = 0 ; i < this . id . length - 1 ; i ++ ) { const [ current , next ] = this . id . substr ( i , 2 ) ; if ( current === next ) { continue ; } const changed = COLORS . find ( color => color !== current && color !== next ) ; const changedId = this . id . substr ( 0 , i ) + changed . repeat ( 2 ) + this . id . substr ( i + 2 ) ; nextWormIds . push ( changedId ) ; } return nextWormIds ; } } class Graph { constructor ( ) { this . map = new Map ( ) ; } bfs ( wormId ) { this . queue = [ ] ; this . map . set ( wormId , new Worm ( wormId , 0 ) ) ; this . queue . push ( wormId ) ; while ( this . queue . length ) { const wormId = this . queue . shift ( ) ; const worm = this . map . get ( wormId ) ; const wormIds = worm . getNextWormIds ( ) ; if ( ! wormIds . length ) { return worm ; } wormIds . forEach ( wormId => { if ( this . map . has ( wormId ) ) { return ; } this . map . set ( wormId , new Worm ( wormId , worm . seconds + 1 ) ) ; this . queue . push ( wormId ) ; } ) } } } inputs . forEach ( wormId => { if ( wormId === ' 0 ' ) { return ; } const graph = new Graph ( ) ; const worm = graph . bfs ( wormId ) ; console . log ( worm ? worm . seconds : ' NA ' ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var nm = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var n = nm [ 0 ] ; var m = nm [ 1 ] ; if ( n == 0 && m == 0 ) break ; var N = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { N [ i ] = [ ] ; for ( var j = 0 ; j < n ; j ++ ) { N [ i ] [ j ] = Infinity ; if ( i == j ) N [ i ] [ j ] = 0 ; } } var arr = [ ] ; for ( var i = 0 ; i < m ; i ++ ) { var abc = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var a = abc [ 0 ] ; var b = abc [ 1 ] ; var c = abc [ 2 ] ; N [ a ] [ b ] = c ; N [ b ] [ a ] = c ; } var city = [ 0 ] ; var cost = 0 ; while ( true ) { if ( city . length == n ) break ; var min = Infinity ; var select = - 1 ; for ( var i = 0 ; i < city . length ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( city . indexOf ( j ) != - 1 ) continue ; if ( N [ city [ i ] ] [ j ] < min ) { select = j ; min = N [ city [ i ] ] [ j ] ; } } } if ( select != - 1 ) { cost += min ; city . push ( select ) ; } } console . log ( cost ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var x = Arr . shift ( ) . split ( \" \" ) ; if ( x [ 0 ] == \" 0 \" ) break ; var y = Arr . shift ( ) . split ( \" \" ) ; var z = Arr . shift ( ) . split ( \" \" ) ; var ans = \" NA \" ; for ( var i = 0 ; i < 2 ; i ++ ) { var s = ( [ \" b \" , \" w \" ] ) [ i ] ; if ( x [ 0 ] + x [ 1 ] + x [ 2 ] == s + s + s ) ans = s ; if ( y [ 0 ] + y [ 1 ] + y [ 2 ] == s + s + s ) ans = s ; if ( z [ 0 ] + z [ 1 ] + z [ 2 ] == s + s + s ) ans = s ; if ( x [ 0 ] + y [ 0 ] + z [ 0 ] == s + s + s ) ans = s ; if ( x [ 1 ] + y [ 1 ] + z [ 1 ] == s + s + s ) ans = s ; if ( x [ 2 ] + y [ 2 ] + z [ 2 ] == s + s + s ) ans = s ; if ( x [ 0 ] + y [ 1 ] + z [ 2 ] == s + s + s ) ans = s ; if ( x [ 2 ] + y [ 1 ] + z [ 0 ] == s + s + s ) ans = s ; } console . log ( ans ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; let s = [ \" \" , \" \" , \" \" ] function isMatch ( s1 , s2 ) { if ( s1 != s2 || s1 == \" + \" ) return false return true } function search ( s ) { let t = s [ 0 ] [ 0 ] for ( var i = 1 ; i < 3 ; ++ i ) { if ( ! isMatch ( t , s [ i ] [ i ] ) ) break if ( i == 2 ) return t } t = s [ 2 ] [ 0 ] for ( var i = 1 ; i < 3 ; ++ i ) { if ( ! isMatch ( t , s [ 2 - i ] [ i ] ) ) break if ( i == 2 ) return t } for ( var i = 0 ; i < 3 ; ++ i ) { t = s [ i ] [ 0 ] for ( var j = 1 ; j < 3 ; ++ j ) { if ( ! isMatch ( t , s [ i ] [ j ] ) ) break if ( j == 2 ) return t } } for ( var i = 0 ; i < 3 ; ++ i ) { t = s [ 0 ] [ i ] for ( var j = 1 ; j < 3 ; ++ j ) { if ( ! isMatch ( t , s [ j ] [ i ] ) ) break if ( j == 2 ) return t } } return \" NA \" } while ( 1 ) { for ( var i = 0 ; i < 3 ; ++ i ) { s [ i ] = Arr . shift ( ) } if ( s [ 0 ] == \" 0 \" ) { break } console . log ( search ( s ) ) }",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var result = { } ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) result [ arr [ i ] ] = true ; } return result ; } var p = prime ( 1000000 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var I = 0 ; I < Arr . length ; I ++ ) { var v = Arr [ I ] ; if ( v == 0 ) break ; var cnt = 0 ; var obj = { } ; for ( var k in p ) { if ( k >= v ) break ; if ( obj . hasOwnProperty ( k ) ) continue ; obj [ v - k ] = true ; if ( p . hasOwnProperty ( v - k ) ) cnt ++ ; } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) . map ( Number ) ; while ( true ) { var n = arr . shift ( ) ; if ( n == 0 ) break ; var ary = [ ] ; for ( var i = 0 ; i < n ; i ++ ) ary . push ( arr . shift ( ) ) ; var s = arr . shift ( ) ; var cnt = 0 ; var L = 0 ; var R = ary . length - 1 ; while ( true ) { cnt ++ ; var m = Math . floor ( ( L + R ) / 2 ) ; if ( ary [ m ] == s ) { break ; } else if ( ary [ m ] > s ) { R = m - 1 ; } else if ( ary [ m ] < s ) { L = m + 1 ; } if ( L > R ) break ; } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var abc = [ ] ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( abc . length == 0 && Arr [ i ] == \" 0 0 \" ) break ; var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; abc . push ( arr [ 0 ] + arr [ 1 ] ) ; if ( abc . length == 5 ) { var max = abc . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; var ABC = \" ABCDE \" . split ( \" \" ) ; var str = ABC [ abc . indexOf ( max ) ] ; console . log ( str + \" \" + max ) ; abc = [ ] ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var team = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) ; var name = arr . shift ( ) ; var scoreA = 0 ; var scoreB = 0 ; for ( var j = 0 ; j < n - 1 ; j ++ ) { if ( arr [ j ] - 0 === 0 ) scoreA ++ ; if ( arr [ j ] - 0 === 1 ) scoreB ++ ; } team . push ( [ name , scoreA * 100 + ( 10 - scoreB ) + ( ( 10 - j ) * 0.01 ) ] ) ; } team . sort ( function ( a , b ) { return b [ 1 ] - a [ 1 ] ; } ) ; team . forEach ( function ( v ) { console . log ( v [ 0 ] ) ; } ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var str = Arr . shift ( ) ; if ( str == \" 0 0 \" ) break ; var arr = str . split ( \" \" ) . map ( Number ) ; arr . sort ( function ( a , b ) { return b - a ; } ) ; var x = arr [ 0 ] ; var y = arr [ 1 ] ; var cnt = 0 ; while ( y !== 0 ) { var m = x % y ; x = y ; y = m ; cnt ++ ; } console . log ( x + \" \" + cnt ) ; }",
    "label": 2
  },
  {
    "code": "( function ( ) { var input = ' ' , cnt = 0 ; function main ( ) { var inputLen , nums , x , y , temp , ans ; inputLen = input . length ; for ( i = 0 ; i < inputLen ; i += 1 ) { nums = input [ i ] . split ( ' ' ) ; x = parseInt ( nums [ 0 ] , 10 ) ; y = parseInt ( nums [ 1 ] , 10 ) ; if ( x === 0 && y === 0 ) { break ; } else if ( x < y ) { temp = x ; x = y ; y = temp ; } ans = gcd ( x , y ) ; showResult ( ans , cnt ) ; cnt = 0 ; } } function gcd ( x , y ) { cnt += 1 ; return x % y === 0 ? y : gcd ( y , x % y ) ; } function showResult ( result , cnt ) { console . log ( result + ' ' + cnt ) ; } process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ; } ( ) ) ;",
    "label": 2
  },
  {
    "code": "function move ( d1 , d2 , d3 , d4 , d5 , d6 ) { var x = this . toString ( ) ; if ( x == \" N \" ) return [ d2 , d6 , d3 , d4 , d1 , d5 ] ; if ( x == \" E \" ) return [ d4 , d2 , d1 , d6 , d5 , d3 ] ; } function roll ( d1 , d2 , d3 , d4 , d5 , d6 ) { return [ d1 , d3 , d5 , d2 , d4 , d6 ] ; } function rolls ( arr ) { for ( var i = 0 ; i < 4 ; i ++ ) { obj [ arr . join ( \" , \" ) ] = true ; arr = roll . apply ( null , arr ) ; } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var OBJ = { } ; var result = \" Yes \" ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var obj = { } ; var color = \" Red,Yellow,Blue,Magenta,Green,Cyan \" . split ( \" , \" ) ; var dice = ( Arr . shift ( ) ) . split ( \" \" ) ; dice = dice . map ( function ( v ) { return color . indexOf ( v ) ; } ) ; for ( var j = 0 ; j < 4 ; j ++ ) { rolls ( dice ) ; dice = move . apply ( \" N \" , dice ) ; } dice = move . apply ( \" E \" , dice ) ; rolls ( dice ) ; dice = move . apply ( \" E \" , dice ) ; dice = move . apply ( \" E \" , dice ) ; rolls ( dice ) ; for ( var k in obj ) { if ( OBJ . hasOwnProperty ( k ) ) { cnt ++ ; break ; } else OBJ [ k ] = true ; } } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "function warshall ( ) { for ( var k = 0 ; k < nm [ 1 ] ; k ++ ) { for ( var i = 0 ; i < nm [ 1 ] ; i ++ ) { for ( var j = 0 ; j < nm [ 1 ] ; j ++ ) { C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k ] [ j ] ) ; T [ i ] [ j ] = Math . min ( T [ i ] [ j ] , T [ i ] [ k ] + T [ k ] [ j ] ) ; } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var nm = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( nm [ 0 ] == 0 && nm [ 1 ] == 0 ) break ; var C = [ ] ; var T = [ ] ; for ( var i = 0 ; i < nm [ 1 ] ; i ++ ) { C [ i ] = [ ] ; T [ i ] = [ ] ; for ( var j = 0 ; j < nm [ 1 ] ; j ++ ) { C [ i ] [ j ] = ( i === j ) ? 0 : Infinity ; T [ i ] [ j ] = ( i === j ) ? 0 : Infinity ; } } for ( var i = 0 ; i < nm [ 0 ] ; i ++ ) { var A = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; C [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] = C [ A [ 1 ] - 1 ] [ A [ 0 ] - 1 ] = Math . min ( A [ 2 ] , C [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] ) ; T [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] = T [ A [ 1 ] - 1 ] [ A [ 0 ] - 1 ] = Math . min ( A [ 3 ] , T [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] ) ; } warshall ( ) ; var k = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < k ; i ++ ) { var B = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( B [ 2 ] == 0 ) console . log ( C [ B [ 0 ] - 1 ] [ B [ 1 ] - 1 ] ) ; if ( B [ 2 ] == 1 ) console . log ( T [ B [ 0 ] - 1 ] [ B [ 1 ] - 1 ] ) ; } }",
    "label": 2
  },
  {
    "code": "function warshall ( ) { for ( var k = 0 ; k < nm [ 1 ] ; k ++ ) { for ( var i = 0 ; i < nm [ 1 ] ; i ++ ) { for ( var j = 0 ; j < nm [ 1 ] ; j ++ ) { C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k ] [ j ] ) ; T [ i ] [ j ] = Math . min ( T [ i ] [ j ] , T [ i ] [ k ] + T [ k ] [ j ] ) ; } } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var nm = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( nm [ 0 ] == 0 && nm [ 1 ] == 0 ) break ; var C = [ ] ; var T = [ ] ; for ( var i = 0 ; i < nm [ 1 ] ; i ++ ) { C [ i ] = [ ] ; T [ i ] = [ ] ; for ( var j = 0 ; j < nm [ 1 ] ; j ++ ) { C [ i ] [ j ] = ( i === j ) ? 0 : Infinity ; T [ i ] [ j ] = ( i === j ) ? 0 : Infinity ; } } for ( var i = 0 ; i < nm [ 0 ] ; i ++ ) { var A = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; C [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] = C [ A [ 1 ] - 1 ] [ A [ 0 ] - 1 ] = A [ 2 ] ; T [ A [ 0 ] - 1 ] [ A [ 1 ] - 1 ] = T [ A [ 1 ] - 1 ] [ A [ 0 ] - 1 ] = A [ 3 ] ; } warshall ( ) ; var k = Arr . shift ( ) - 0 ; for ( var i = 0 ; i < k ; i ++ ) { var B = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; if ( B [ 2 ] == 0 ) console . log ( C [ B [ 0 ] - 1 ] [ B [ 1 ] - 1 ] ) ; if ( B [ 2 ] == 1 ) console . log ( T [ B [ 0 ] - 1 ] [ B [ 1 ] - 1 ] ) ; } }",
    "label": 2
  },
  {
    "code": "function main ( ) { var inf = 10e9 , line , n , m , a , b , c , t , p , q , r , i , j , k ; while ( true ) { line = input . shift ( ) . split ( ' ' ) . map ( parseFloat ) ; n = line [ 0 ] ; m = line [ 1 ] ; if ( n === 0 && m === 0 ) break ; cost = [ ] ; time = [ ] ; for ( i = 1 ; i <= m ; i ++ ) { cost [ i ] = [ ] ; cost [ i ] [ i ] = 0 ; time [ i ] = [ ] ; time [ i ] [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { line = input . shift ( ) . split ( ' ' ) . map ( parseFloat ) ; a = line [ 0 ] ; b = line [ 1 ] ; c = line [ 2 ] ; t = line [ 3 ] ; cost [ a ] [ b ] = cost [ b ] [ a ] = Math . min ( c , cost [ a ] [ b ] || inf ) ; time [ a ] [ b ] = time [ b ] [ a ] = Math . min ( t , time [ a ] [ b ] || inf ) ; } for ( k = 1 ; k <= m ; k ++ ) { for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { cost [ i ] [ j ] = Math . min ( cost [ i ] [ j ] || inf , ( cost [ i ] [ k ] || inf ) + ( cost [ k ] [ j ] || inf ) ) ; time [ i ] [ j ] = Math . min ( time [ i ] [ j ] || inf , ( time [ i ] [ k ] || inf ) + ( time [ k ] [ j ] || inf ) ) ; } } } k = parseFloat ( input . shift ( ) ) ; for ( i = 0 ; i < k ; i ++ ) { line = input . shift ( ) . split ( ' ' ) . map ( parseFloat ) ; p = line [ 0 ] ; q = line [ 1 ] ; r = line [ 2 ] ; console . log ( p === q ? 0 : [ cost , time ] [ r ] [ p ] [ q ] ) ; } } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function bomb ( name ) { var min = obj [ name ] ; M . forEach ( function ( v ) { if ( name == v [ 0 ] ) { var sum = 0 ; v [ 1 ] . forEach ( function ( value ) { sum += bomb ( value ) ; } ) ; min = Math . min ( min , sum ) ; } } ) ; return min ; } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var n = arr . shift ( ) - 0 ; if ( n == 0 ) break ; var obj = { } ; for ( var i = 0 ; i < n ; i ++ ) { var data = arr . shift ( ) . split ( \" \" ) ; obj [ data [ 0 ] ] = data [ 1 ] - 0 ; } var m = arr . shift ( ) - 0 ; var M = [ ] ; for ( var i = 0 ; i < m ; i ++ ) { var data = arr . shift ( ) . split ( \" \" ) ; var name = data . shift ( ) ; data . shift ( ) ; M . push ( [ name , data ] ) ; } var item = arr . shift ( ) ; console . log ( bomb ( item ) ) ; }",
    "label": 2
  },
  {
    "code": "function howMuch ( items , item , s ) { try { var recipe , price = items [ item ] . price , sum , flag = false , j ; s = s || [ ] ; if ( recipe = items [ item ] . recipe ) { s . push ( item ) ; sum = 0 ; flag = true ; for ( j = 0 ; j < recipe . length ; j ++ ) { if ( s . indexOf ( recipe [ j ] ) !== - 1 || ! ( recipe [ j ] in items ) ) { flag = false ; break ; } sum += howMuch ( items , recipe [ j ] , s ) ; } if ( flag ) { price = min ( price , sum ) ; } s . pop ( ) ; } } catch ( e ) { throw [ e , items , item ] ; } return price ; } function min ( x , y ) { return x < y ? x : y ; } function main ( ) { var i , n , m , line , len = input . length , items ; for ( i = 0 ; i < len ; ) { items = { } ; n = parseInt ( input [ i ++ ] , 10 ) + i ; if ( n === i ) break ; for ( ; i < n ; i ++ ) { line = input [ i ] . split ( ' ' ) ; items [ line [ 0 ] ] = { price : parseInt ( line [ 1 ] , 10 ) } ; } m = parseInt ( input [ i ++ ] , 10 ) + i ; for ( ; i < m ; i ++ ) { line = input [ i ] . split ( ' ' ) ; items [ line [ 0 ] ] . recipe = line . slice ( 2 ) ; } console . log ( howMuch ( items , input [ i ++ ] ) ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function howMuch ( items , item , s ) { try { var recipe , price = items [ item ] . price , sum , flag = false , j ; s = s || [ ] ; if ( recipe = items [ item ] . recipe ) { s . push ( item ) ; sum = 0 ; flag = true ; for ( j = 0 ; j < recipe . length ; j ++ ) { if ( s . indexOf ( recipe [ j ] ) !== - 1 || ! ( recipe [ j ] in items ) ) { flag = false ; break ; } sum += howMuch ( items , recipe [ j ] , s ) ; } if ( flag ) { price = min ( price , sum ) ; } s . pop ( ) ; } } catch ( e ) { throw [ e , items , item ] ; } return price ; } function min ( x , y ) { return x < y ? x : y ; } function main ( ) { var i , n , m , line , len = input . length , items ; for ( i = 0 ; i < len ; ) { items = { } ; n = parseInt ( input [ i ++ ] , 10 ) + i ; if ( n === i ) break ; for ( ; i < n ; i ++ ) { line = input [ i ] . split ( ' ' ) ; items [ line [ 0 ] ] = { price : parseInt ( line [ 1 ] , 10 ) } ; } m = parseInt ( input [ i ++ ] , 10 ) + i ; for ( ; i < m ; i ++ ) { line = input [ i ] . split ( ' ' ) ; items [ line [ 0 ] ] . recipe = line . slice ( 2 ) ; } console . log ( howMuch ( items , input [ i ++ ] ) ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var obj = { } ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) obj [ arr [ i ] ] = true ; } return obj ; } var p = prime ( 1000000 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var nx = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var n = nx [ 0 ] ; var x = nx [ 1 ] ; if ( n == 0 && x == 0 ) break ; var dp = [ ] ; for ( var i = 0 ; i <= 1000000 ; i ++ ) dp [ i ] = false ; var arr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var v = Arr . shift ( ) - 0 ; arr . push ( v ) ; dp [ v ] = true ; } dp [ 0 ] = true ; for ( var i = 0 ; i <= 1000000 ; i ++ ) { for ( var j = 0 ; j < arr . length ; j ++ ) { if ( i + arr [ j ] > 1000000 ) continue ; if ( dp [ i ] ) dp [ i + arr [ j ] ] = true ; } } for ( var i = x ; i > 0 ; i -- ) { if ( dp [ i ] && p . hasOwnProperty ( i ) ) break ; } console . log ( ( i === 0 ) ? \" NA \" : i ) ; }",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var obj = { } ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) obj [ arr [ i ] ] = true ; } return obj ; } var p = prime ( 1000000 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var nx = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var n = nx [ 0 ] ; var x = nx [ 1 ] ; if ( n == 0 && x == 0 ) break ; var dp = [ ] ; for ( var i = 0 ; i <= x ; i ++ ) dp [ i ] = false ; var arr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) arr . push ( Arr . shift ( ) - 0 ) ; dp [ 0 ] = true ; for ( var i = 0 ; i < x ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( i + arr [ j ] > x ) continue ; if ( dp [ i ] ) dp [ i + arr [ j ] ] = true ; } } for ( var i = x ; i > 0 ; i -- ) { if ( dp [ i ] && p . hasOwnProperty ( i ) ) break ; } console . log ( ( i === 0 ) ? \" NA \" : i ) ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var n , m , i = 0 , j , ans , dp , dp_ , x , k , line , xs ; for ( ; ; ) { line = input [ i ++ ] . split ( ' ' ) . map ( parseFloat ) ; n = line [ 0 ] ; m = line [ 1 ] ; if ( n === 0 && m === 0 ) break ; xs = [ ] ; for ( j = 0 ; j < n ; j ++ ) { xs . push ( parseInt ( input [ i ++ ] , 10 ) ) ; } dp = { } ; ans = 0 ; dp [ 0 ] = true ; for ( j = 0 ; j < n ; j ++ ) { for ( k = xs [ j ] ; k <= m ; k ++ ) { if ( dp [ k - xs [ j ] ] ) { dp [ k ] = true ; if ( ps [ k ] ) ans = Math . max ( ans , k ) ; } } } console . log ( ans || ' NA ' ) ; } } function prims ( n ) { var i , j , flag , prims = [ false , false ] ; for ( i = 2 ; i <= n ; i ++ ) prims [ i ] = true ; for ( i = 2 ; i <= n ; i ++ ) if ( prims [ i ] ) { for ( j = i + i ; j <= n ; j += i ) prims [ j ] = false ; } return prims ; } var ps = prims ( 1000000 ) ; var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var n , m , i = 0 , j , ans , dp , dp_ , x , k , line , xs ; for ( ; ; ) { line = input [ i ++ ] . split ( ' ' ) . map ( parseFloat ) ; n = line [ 0 ] ; m = line [ 1 ] ; if ( n === 0 && m === 0 ) break ; xs = [ ] ; for ( j = 0 ; j < n ; j ++ ) { xs . push ( parseInt ( input [ i ++ ] , 10 ) ) ; } dp = { } ; ans = 0 ; dp [ 0 ] = true ; for ( j = 0 ; j < n ; j ++ ) { for ( k = xs [ j ] ; k <= m ; k ++ ) { if ( dp [ k - xs [ j ] ] ) { dp [ k ] = true ; if ( ps [ k ] ) ans = Math . max ( ans , k ) ; } } } console . log ( ans || ' NA ' ) ; } } function prims ( n ) { var i , j , prims = [ false , false ] ; for ( i = 2 ; i <= n ; i ++ ) prims [ i ] = true ; for ( i = 2 ; i <= n ; i ++ ) if ( prims [ i ] ) { for ( j = i + i ; j <= n ; j += i ) prims [ j ] = false ; } return prims ; } var ps = prims ( 1000000 ) ; var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var arr = input . trim ( ) . split ( \" \\n \" ) ; while ( true ) { var wh = arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var w = wh [ 0 ] ; var h = wh [ 1 ] ; if ( w == 0 && h == 0 ) break ; var yx = [ ] ; for ( var i = 0 ; i < h ; i ++ ) yx . push ( arr . shift ( ) . split ( \" \" ) . map ( Number ) ) ; var dp = [ ] ; for ( var i = 0 ; i < h ; i ++ ) { dp [ i ] = [ ] ; for ( var j = 0 ; j < w ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 0 ; i < h ; i ++ ) { for ( var j = 0 ; j < w ; j ++ ) { if ( i == 0 && yx [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 1 ; else if ( i >= 1 ) { var a = ( j == 0 || yx [ i - 1 ] [ j - 1 ] == 2 ) ? 0 : dp [ i - 1 ] [ j - 1 ] ; var b = ( yx [ i - 1 ] [ j ] == 2 ) ? 0 : dp [ i - 1 ] [ j ] ; var c = ( j == w - 1 || yx [ i - 1 ] [ j + 1 ] == 2 ) ? 0 : dp [ i - 1 ] [ j + 1 ] ; var d = ( i >= 2 && yx [ i - 2 ] [ j ] == 2 ) ? dp [ i - 2 ] [ j ] : 0 ; if ( yx [ i ] [ j ] == 0 ) dp [ i ] [ j ] += a + b + c + d ; else if ( yx [ i ] [ j ] == 1 ) dp [ i ] [ j ] = 0 ; else if ( yx [ i ] [ j ] == 2 ) dp [ i ] [ j ] += b + d ; } } } var sum = 0 ; for ( var i = h - 2 ; i < h ; i ++ ) { for ( var j = 0 ; j < w ; j ++ ) { if ( h >= 2 && i == h - 2 && yx [ i ] [ j ] == 2 ) sum += dp [ i ] [ j ] ; if ( h >= 1 && i == h - 1 && ( yx [ i ] [ j ] == 0 || yx [ i ] [ j ] == 2 ) ) sum += dp [ i ] [ j ] ; } } console . log ( sum ) ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 , j , y , x , xy , cells , answers = { } , dummy = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ; for ( ; ; ) { xy = input [ i ++ ] . split ( ' ' ) . map ( parseFloat ) ; cells = [ ] ; if ( xy [ 0 ] === 0 && xy [ 1 ] === 0 ) break ; for ( j = 0 ; j < xy [ 1 ] ; j ++ ) { cells . push ( input [ i ++ ] . split ( ' ' ) . map ( parseFloat ) ) ; } cells . push ( dummy ) ; answer = 0 ; answers = { } ; for ( x = 0 ; x < xy [ 0 ] ; x ++ ) answers [ [ x , 0 ] ] = cells [ 0 ] [ x ] === 0 ? 1 : 0 ; for ( y = 0 ; y < xy [ 1 ] ; y ++ ) { for ( x = 0 ; x < xy [ 0 ] ; x ++ ) { answers [ [ x , y ] ] = answers [ [ x , y ] ] || 0 ; switch ( cells [ y ] [ x ] ) { case 0 : if ( cells [ y + 1 ] [ x - 1 ] !== 2 ) answers [ [ x - 1 , y + 1 ] ] = ( answers [ [ x - 1 , y + 1 ] ] || 0 ) + answers [ [ x , y ] ] ; answers [ [ x , y + 1 ] ] = ( answers [ [ x , y + 1 ] ] || 0 ) + answers [ [ x , y ] ] ; if ( cells [ y + 1 ] [ x + 1 ] !== 2 ) answers [ [ x + 1 , y + 1 ] ] = ( answers [ [ x + 1 , y + 1 ] ] || 0 ) + answers [ [ x , y ] ] ; break ; case 1 : break ; case 2 : answers [ [ x , y + 2 ] ] = ( answers [ [ x , y + 2 ] ] || 0 ) + answers [ [ x , y ] ] ; break ; } } } for ( y = xy [ 1 ] ; y <= xy [ 1 ] + 1 ; y ++ ) { for ( x = 0 ; x < xy [ 0 ] ; x ++ ) { answer += answers [ [ x , y ] ] || 0 ; } } console . log ( answer ) ; } } function show ( xy , answers ) { var x , y , line ; for ( y = 0 ; y <= xy [ 1 ] ; y ++ ) { line = [ ] ; for ( x = 0 ; x < xy [ 0 ] ; x ++ ) { line . push ( answers [ [ x , y ] ] || 0 ) ; } console . log ( line . join ( ' ' ) ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 , j , y , x , xy , cells , answers = { } , dummy = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ; for ( ; ; ) { xy = input [ i ++ ] . split ( ' ' ) . map ( parseFloat ) ; cells = [ ] ; if ( xy [ 0 ] === 0 && xy [ 1 ] === 0 ) break ; for ( j = 0 ; j < xy [ 1 ] ; j ++ ) { cells . push ( input [ i ++ ] . split ( ' ' ) . map ( parseFloat ) ) ; } cells . push ( dummy ) ; answer = 0 ; answers = { } ; for ( x = 0 ; x < xy [ 0 ] ; x ++ ) answers [ [ x , 0 ] ] = cells [ 0 ] [ x ] === 0 ? 1 : 0 ; for ( y = 0 ; y < xy [ 1 ] ; y ++ ) { for ( x = 0 ; x < xy [ 0 ] ; x ++ ) { answers [ [ x , y ] ] = answers [ [ x , y ] ] || 0 ; switch ( cells [ y ] [ x ] ) { case 0 : if ( cells [ y + 1 ] [ x - 1 ] !== 2 ) answers [ [ x - 1 , y + 1 ] ] = ( answers [ [ x - 1 , y + 1 ] ] || 0 ) + answers [ [ x , y ] ] ; answers [ [ x , y + 1 ] ] = ( answers [ [ x , y + 1 ] ] || 0 ) + answers [ [ x , y ] ] ; if ( cells [ y + 1 ] [ x + 1 ] !== 2 ) answers [ [ x + 1 , y + 1 ] ] = ( answers [ [ x + 1 , y + 1 ] ] || 0 ) + answers [ [ x , y ] ] ; break ; case 1 : break ; case 2 : answers [ [ x , y + 2 ] ] = ( answers [ [ x , y + 2 ] ] || 0 ) + answers [ [ x , y ] ] ; break ; } } } for ( y = xy [ 1 ] ; y <= xy [ 1 ] + 1 ; y ++ ) { for ( x = 0 ; x < xy [ 0 ] ; x ++ ) { answer += answers [ [ x , y ] ] || 0 ; } } console . log ( answer ) ; } } function show ( xy , answers ) { var x , y , line ; for ( y = 0 ; y <= xy [ 1 ] ; y ++ ) { line = [ ] ; for ( x = 0 ; x < xy [ 0 ] ; x ++ ) { line . push ( answers [ [ x , y ] ] || 0 ) ; } console . log ( line . join ( ' ' ) ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var a0 = Arr . shift ( ) - 0 ; if ( a0 == 0 ) break ; var a1 = Arr . shift ( ) - 0 ; var a2 = Arr . shift ( ) - 0 ; var a3 = Arr . shift ( ) - 0 ; var a4 = Arr . shift ( ) - 0 ; var arr = [ a0 , a1 , a2 , a3 , a4 ] ; var rps = [ 1 , 2 , 3 ] ; rps = rps . filter ( function ( v ) { return ( v != a0 && v != a1 && v != a2 && v != a3 && v != a4 ) ; } ) ; if ( rps . length == 2 || rps . length == 0 ) { for ( var i = 0 ; i < 5 ; i ++ ) console . log ( 3 ) ; } else { arr . forEach ( function ( v ) { if ( rps [ 0 ] == 1 ) console . log ( ( v == 2 ) ? 1 : 2 ) ; if ( rps [ 0 ] == 2 ) console . log ( ( v == 1 ) ? 2 : 1 ) ; if ( rps [ 0 ] == 3 ) console . log ( ( v == 1 ) ? 1 : 2 ) ; } ) ; } }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( input ) { var data = input . split ( \" \\n \" ) ; while ( data [ 0 ] != 0 ) { var unit = data . splice ( 0 , 5 ) ; var result , te = [ ] ; unit . forEach ( function ( v ) { if ( te . indexOf ( v ) < 0 ) te . push ( v ) ; } ) ; if ( te . length == 3 || te . length == 1 ) { result = [ 3 , 3 , 3 ] ; } else { if ( te . indexOf ( \" 1 \" ) < 0 ) result = [ 0 , 1 , 2 ] else if ( te . indexOf ( \" 2 \" ) < 0 ) result = [ 2 , 0 , 1 ] else if ( te . indexOf ( \" 3 \" ) < 0 ) result = [ 1 , 2 , 0 ] } unit . forEach ( function ( v ) { console . log ( result [ v - 1 ] ) ; } ) } } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var hands , pattern , swap , i = 0 , j ; for ( ; ; ) { if ( input [ i ] == 0 ) break ; hands = [ ] ; for ( j = 0 ; j < 5 ; j ++ ) { hands . push ( Number ( input [ i ++ ] ) ) ; } pattern = hands . reduce ( function ( pat , h ) { return ( pat [ h ] = true , pat ) ; } , { } ) ; keys = Object . keys ( pattern ) . map ( Number ) . sort ( function ( x , y ) { return x - y ; } ) ; if ( keys . length === 2 ) { if ( keys [ 1 ] - keys [ 0 ] == 2 ) { swap = keys [ 0 ] ; keys [ 0 ] = keys [ 1 ] ; keys [ 1 ] = swap ; } hands . forEach ( function ( h ) { console . log ( keys . indexOf ( h ) + 1 ) ; } ) ; } else { hands . forEach ( function ( ) { console . log ( 3 ) ; } ) ; } } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var hands , pattern , swap , i = 0 , j ; for ( ; ; ) { if ( input [ i ] == 0 ) break ; hands = [ ] ; for ( j = 0 ; j < 5 ; j ++ ) { hands . push ( Number ( input [ i ++ ] ) ) ; } pattern = hands . reduce ( function ( pat , h ) { return ( pat [ h ] = true , pat ) ; } , { } ) ; keys = Object . keys ( pattern ) . map ( Number ) . sort ( function ( x , y ) { return x - y ; } ) ; if ( keys . length === 2 ) { if ( keys [ 1 ] - keys [ 0 ] == 2 ) { swap = keys [ 0 ] ; keys [ 0 ] = keys [ 1 ] ; keys [ 1 ] = swap ; } hands . forEach ( function ( h ) { console . log ( keys . indexOf ( h ) + 1 ) ; } ) ; } else { hands . forEach ( function ( ) { console . log ( 3 ) ; } ) ; } } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var L = Arr [ i ] - 0 ; if ( L == 0 ) break ; var sum = 0 ; for ( var j = 1 ; j <= 12 ; j ++ ) { var arr = Arr [ i + j ] . split ( \" \" ) . map ( Number ) ; sum += arr [ 0 ] - arr [ 1 ] ; if ( sum >= L ) break ; } ( sum >= L ) ? console . log ( j ) : console . log ( \" NA \" ) ; i = i + 12 ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { var lines = input . split ( ' \\n ' ) ; var l = 0 ; while ( true ) { var loan = parseInt ( lines [ l ++ ] ) ; if ( loan === 0 ) { break ; } var ans = ' NA ' ; for ( var i = 0 ; i < 12 ; i ++ ) { var vs = lines [ l ++ ] . split ( ' ' ) ; loan -= vs [ 0 ] - vs [ 1 ] ; if ( ans === ' NA ' && loan <= 0 ) { ans = i + 1 ; } } console . log ( ans ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 , j , flag , L , MN ; for ( ; ; ) { L = Number ( input [ i ++ ] ) ; if ( L === 0 ) break ; flag = true ; for ( j = 0 ; j < 12 ; j ++ ) { MN = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; L -= MN [ 0 ] - MN [ 1 ] ; if ( flag && L <= 0 ) { console . log ( j + 1 ) ; flag = false ; } } if ( flag ) console . log ( ' NA ' ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 , j , flag , L , MN ; for ( ; ; ) { L = Number ( input [ i ++ ] ) ; if ( L === 0 ) break ; flag = true ; for ( j = 0 ; j < 12 ; j ++ ) { MN = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; L -= MN [ 0 ] - MN [ 1 ] ; if ( flag && L <= 0 ) { console . log ( j + 1 ) ; flag = false ; } } if ( flag ) console . log ( ' NA ' ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function block ( c , d , x , y ) { var dx , dy ; if ( d == 0 ) { dy = [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ; dx = [ 0 , 1 , 2 , 3 , 0 , 1 , 2 , 3 ] ; } if ( d == 1 ) { dy = [ 0 , 1 , 2 , 3 , 0 , 1 , 2 , 3 ] ; dx = [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ; } for ( var i = 0 ; i < 8 ; i ++ ) { yx [ ( y - 1 ) + dy [ i ] ] [ ( x - 1 ) + dx [ i ] ] = c ; } } function bomb ( y , x ) { var dy = [ - 1 , 0 , 0 , 1 ] ; var dx = [ 0 , - 1 , 1 , 0 ] ; for ( var i = 0 ; i < 4 ; i ++ ) { var yy = y + dy [ i ] ; var xx = x + dx [ i ] ; if ( yy < 0 || yy >= H || xx < 0 || xx >= W ) continue ; if ( yx [ yy ] [ xx ] == color ) { yx [ yy ] [ xx ] = \" a \" ; bomb ( yy , xx ) ; } } } var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var WH = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var W = WH [ 0 ] ; var H = WH [ 1 ] ; if ( W == 0 && H == 0 ) break ; var xyS = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var xS = xyS [ 0 ] - 1 ; var yS = xyS [ 1 ] - 1 ; var xyE = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var xE = xyE [ 0 ] - 1 ; var yE = xyE [ 1 ] - 1 ; var n = ( Arr . shift ( ) ) - 0 ; var yx = [ ] ; for ( var i = 0 ; i < H ; i ++ ) { yx [ i ] = [ ] ; for ( var j = 0 ; j < W ; j ++ ) { yx [ i ] [ j ] = 0 ; } } for ( var i = 0 ; i < n ; i ++ ) { var cdxy = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; block . apply ( null , cdxy ) ; } var color = yx [ yS ] [ xS ] ; if ( color == 0 ) { console . log ( \" NG \" ) ; continue ; } if ( yx [ yS ] [ xS ] == color ) { yx [ yS ] [ xS ] = \" a \" ; bomb ( yS , xS ) ; } var result = ( yx [ yE ] [ xE ] == \" a \" ) ? \" OK \" : \" NG \" ; console . log ( result ) ; }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { main ( input ) } ) ; function main ( input ) { var args = input . trim ( ) . split ( ' \\n ' ) ; var i = 0 ; while ( true ) { var map = [ ] ; var wh = splitNum ( args [ i ++ ] ) ; if ( isEnd ( wh ) ) break ; initMap ( wh , map ) ; var startXY = splitNum ( args [ i ++ ] ) ; var goalXY = splitNum ( args [ i ++ ] ) ; var blockCount = parseInt ( args [ i ++ ] ) ; for ( var j = 0 ; j < blockCount ; j += 1 ) { var block = splitNum ( args [ i ++ ] ) ; putBlock ( map , block ) ; } var res = isReachable ( map , startXY [ 0 ] - 1 , startXY [ 1 ] - 1 , goalXY [ 0 ] - 1 , goalXY [ 1 ] - 1 ) ; console . log ( res ? \" OK \" : \" NG \" ) ; } } function initMap ( wh , map ) { for ( var x = 0 ; x < wh [ 0 ] ; x += 1 ) { var buff = [ ] ; for ( var y = 0 ; y < wh [ 1 ] ; y += 1 ) { buff . push ( 0 ) ; } map . push ( buff ) ; } } function putBlock ( map , block ) { var isHorizontal = ! block [ 1 ] ; var bw = isHorizontal ? 4 : 2 ; var bh = isHorizontal ? 2 : 4 ; var x = block [ 2 ] - 1 ; var y = block [ 3 ] - 1 ; for ( var mx = x ; mx < x + bw ; mx += 1 ) { for ( var my = y ; my < y + bh ; my += 1 ) { map [ mx ] [ my ] = block [ 0 ] ; } } } function isReachable ( map , nowX , nowY , goalX , goalY ) { if ( nowX === goalX && nowY === goalY ) { return true ; } var color = map [ nowX ] [ nowY ] ; map [ nowX ] [ nowY ] = - 2 ; var flag = false ; [ - 1 , 0 , 1 ] . forEach ( function ( dx ) { [ - 1 , 0 , 1 ] . forEach ( function ( dy ) { if ( ! dx && ! dy ) { return ; } var cx = nowX + dx , cy = nowY + dy ; if ( map [ cx ] && map [ cx ] [ cy ] === color ) { flag = flag || isReachable ( map , cx , cy , goalX , goalY ) ; } } ) } ) ; return flag ; } function splitNum ( str ) { return str . split ( ' ' ) . map ( Number ) ; } function isEnd ( arr ) { return arr [ 0 ] === 0 && arr [ 1 ] === 0 ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 , j , wh , startXY , goalXY , n , board ; for ( ; ; ) { wh = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; if ( ! wh [ 0 ] && ! wh [ 1 ] ) break ; board = initBoard ( wh [ 0 ] , wh [ 1 ] ) ; startXY = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; goalXY = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; n = Number ( input [ i ++ ] ) ; for ( j = 0 ; j < n ; j ++ ) { putBlock . bind ( null , board ) . apply ( null , input [ i ++ ] . split ( ' ' ) . map ( Number ) ) ; } console . log ( canGoToGoal ( board , startXY , goalXY ) ? ' OK ' : ' NG ' ) ; } } function initBoard ( w , h ) { var i , j , board = [ ] ; for ( i = 0 ; i < w ; i ++ ) { board . push ( [ ] ) ; for ( j = 0 ; j < h ; j ++ ) { board [ i ] [ j ] = 0 ; } } return board ; } function putBlock ( board , c , d , x , y ) { var i , j , b = [ [ 4 , 2 ] , [ 2 , 4 ] ] [ d ] ; for ( i = 0 ; i < b [ 0 ] ; i ++ ) { for ( j = 0 ; j < b [ 1 ] ; j ++ ) { board [ x - 1 + i ] [ y - 1 + j ] = c ; } } } function canGoToGoal ( board , startXY , goalXY ) { var to = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] , sx = startXY [ 0 ] - 1 , sy = startXY [ 1 ] - 1 , gx = goalXY [ 0 ] - 1 , gy = goalXY [ 1 ] - 1 , m = { } , c = board [ sx ] [ sy ] ; if ( c === 0 ) return false ; return ( function search ( x , y ) { var i ; if ( [ x , y ] in m ) return m [ [ x , y ] ] ; if ( x < 0 || board . length <= x || board [ x ] [ y ] !== c ) return m [ [ x , y ] ] = false ; if ( x === gx && y === gy ) return m [ [ x , y ] ] = true ; m [ [ x , y ] ] = false ; for ( i = 0 ; i < 8 ; i ++ ) { if ( ! ( [ x + to [ i ] [ 0 ] , y + to [ i ] [ 1 ] ] in m ) ) { if ( search ( x + to [ i ] [ 0 ] , y + to [ i ] [ 1 ] ) ) return m [ [ x , y ] ] = true ; } } return m [ [ x , y ] ] = false ; } ) ( sx , sy ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 , j , wh , startXY , goalXY , n , board ; for ( ; ; ) { wh = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; if ( ! wh [ 0 ] && ! wh [ 1 ] ) break ; board = initBoard ( wh [ 0 ] , wh [ 1 ] ) ; startXY = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; goalXY = input [ i ++ ] . split ( ' ' ) . map ( Number ) ; n = Number ( input [ i ++ ] ) ; for ( j = 0 ; j < n ; j ++ ) { putBlock . bind ( null , board ) . apply ( null , input [ i ++ ] . split ( ' ' ) . map ( Number ) ) ; } console . log ( canGoToGoal ( board , startXY , goalXY ) ? ' OK ' : ' NG ' ) ; } } function initBoard ( w , h ) { var i , j , board = [ ] ; for ( i = 0 ; i < w ; i ++ ) { board . push ( [ ] ) ; for ( j = 0 ; j < h ; j ++ ) { board [ i ] [ j ] = 0 ; } } return board ; } function putBlock ( board , c , d , x , y ) { var i , j , b = [ [ 4 , 2 ] , [ 2 , 4 ] ] [ d ] ; for ( i = 0 ; i < b [ 0 ] ; i ++ ) { for ( j = 0 ; j < b [ 1 ] ; j ++ ) { board [ x - 1 + i ] [ y - 1 + j ] = c ; } } } function canGoToGoal ( board , startXY , goalXY ) { var to = [ [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ 1 , 0 ] , [ - 1 , 1 ] , [ 0 , 1 ] , [ 1 , 1 ] ] , sx = startXY [ 0 ] - 1 , sy = startXY [ 1 ] - 1 , gx = goalXY [ 0 ] - 1 , gy = goalXY [ 1 ] - 1 , m = { } , c = board [ sx ] [ sy ] ; if ( c === 0 ) return false ; return ( function search ( x , y ) { var i ; if ( [ x , y ] in m ) return m [ [ x , y ] ] ; if ( x < 0 || board . length <= x || board [ x ] [ y ] !== c ) return m [ [ x , y ] ] = false ; if ( x === gx && y === gy ) return m [ [ x , y ] ] = true ; m [ [ x , y ] ] = false ; for ( i = 0 ; i < 8 ; i ++ ) { if ( ! ( [ x + to [ i ] [ 0 ] , y + to [ i ] [ 1 ] ] in m ) ) { if ( search ( x + to [ i ] [ 0 ] , y + to [ i ] [ 1 ] ) ) return m [ [ x , y ] ] = true ; } } return m [ [ x , y ] ] = false ; } ) ( sx , sy ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; function solve ( n ) { } function main ( ) { while ( input [ 0 ] !== ' 0 ' ) { console . log ( ( input . shift ( ) - 0 ) . toString ( 8 ) . split ( ' ' ) . map ( function ( ch ) { if ( ch === ' 4 ' ) { return + ch + 1 ; } if ( ch - 0 >= 5 ) { return + ch + 2 ; } return + ch ; } ) . join ( ' ' ) ) ; } } main ( ) ;",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; ! function ( k ) { input . forEach ( function ( l ) { return l - 0 && console . log ( ( l - 0 ) . toString ( 8 ) . split ( ' ' ) . map ( function ( ch ) { return k [ ch - 0 ] ; } ) . join ( ' ' ) ) ; } ) ; } ( [ 0 , 1 , 2 , 3 , 5 , 7 , 8 , 9 ] ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var str = n . toString ( 8 ) + \" \" ; str = str . replace ( / 7 / g , \" 9 \" ) ; str = str . replace ( / 6 / g , \" 8 \" ) ; str = str . replace ( / 5 / g , \" 7 \" ) ; str = str . replace ( / 4 / g , \" 5 \" ) ; console . log ( str ) ; }",
    "label": 2
  },
  {
    "code": "function main ( ) { var line , a , b ; for ( ; ; ) { n = parseInt ( input . shift ( ) , 10 ) ; if ( n === 0 ) break ; console . log ( n . toString ( 8 ) . split ( ' ' ) . map ( function ( c ) { return ' 01235789 ' . charAt ( + c ) ; } ) . join ( ' ' ) ) ; } } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] . push ( new Pos ( x , y ) ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var e = 0 ; e < 5 ; e ++ ) { dp [ e ] . length = 1000 ; for ( var ei = 0 ; ei < 1000 ; ei ++ ) { dp [ e ] [ ei ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = Math . min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] . push ( new Pos ( x , y ) ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = Math . min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d !== undefined && d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] . push ( new Pos ( x , y ) ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = new Pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = new Pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; for ( var j = 0 , firstLength = elem [ first ] . length ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; for ( var j = 0 , nowLength = elem [ now ] . length ; j < nowLength ; j ++ ) { for ( var k = 0 , nextLength = elem [ next ] . length ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = new Pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; for ( var j = 0 , firstLength = elem [ first ] . length ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; for ( var j = 0 , nowLength = elem [ now ] . length ; j < nowLength ; j ++ ) { for ( var k = 0 , nextLength = elem [ next ] . length ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = new Pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; for ( var j = 0 , firstLength = elem [ first ] . length ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; for ( var j = 0 , nowLength = elem [ now ] . length ; j < nowLength ; j ++ ) { for ( var k = 0 , nextLength = elem [ next ] . length ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = new Pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; for ( var j = 0 , firstLength = elem [ first ] . length ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; for ( var j = 0 , nowLength = elem [ now ] . length ; j < nowLength ; j ++ ) { for ( var k = 0 , nextLength = elem [ next ] . length ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = new Pos ( x , y ) ; break ; case ' G ' : goal = new Pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] . push ( new Pos ( x , y ) ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function Pos ( a , b ) { this . x = a ; this . y = b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return Math . abs ( ( from >> 11 ) - ( to >> 11 ) ) + Math . abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { return a1 < a2 ? a1 : a2 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { var t = ( a1 - a2 ) ; return a2 + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a1 , a2 ) { var t = ( a1 - a2 ) ; return a2 + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( width == 0 && height == 0 ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) >= 5 ? startElem - 4 : startElem + 1 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) >= 5 ? ( first + e ) - 5 : first + e ; var next = ( now + 1 ) == 5 ? now - 4 : now + 1 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( width == 0 && height == 0 ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) >= 5 ? startElem - 4 : startElem + 1 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) >= 5 ? ( first + e ) - 5 : first + e ; var next = ( now + 1 ) == 5 ? now - 4 : now + 1 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { var d = dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ; if ( d > dp [ next ] [ k ] ) continue ; dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + d ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( width == 0 && height == 0 ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) >= 5 ? startElem - 4 : startElem + 1 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } var d ; for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) >= 5 ? ( first + e ) - 5 : first + e ; var next = ( now + 1 ) == 5 ? now - 4 : now + 1 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { d = dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ; if ( d > dp [ next ] [ k ] ) continue ; dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + d ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( width == 0 && height == 0 ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) >= 5 ? startElem - 4 : startElem + 1 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) >= 5 ? ( first + e ) - 5 : first + e ; var next = ( now + 1 ) == 5 ? now - 4 : now + 1 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { var d = dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ; if ( d > dp [ next ] [ k ] ) continue ; dp [ next ] [ k ] = min ( dp [ next ] [ k ] , dp [ now ] [ j ] + d ) ; } } } var last = ( first + 3 ) >= 5 ? first - 2 : first + 3 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a1 , a2 ) { return a1 > a2 ? a2 : a1 ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var bestElement = - 1 ; var distance = Infinity ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = Infinity ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == Infinity ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = firstLength ; j -- ; ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = nowLength ; j -- ; ) { for ( var k = nextLength ; k -- ; ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = lastLength ; j -- ; ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = firstLength ; j -- ; ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = nowLength ; j -- ; ) { for ( var k = nextLength ; k -- ; ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = lastLength ; j -- ; ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = nowLength ; j -- ; ) { for ( var k = nextLength ; k -- ; ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; for ( var j = elem [ first ] . length ; j -- ; ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; for ( var j = elem [ now ] . length ; j -- ; ) { for ( var k = elem [ next ] . length ; k -- ; ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; for ( var j = elem [ last ] . length ; j -- ; ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; for ( var j = elem [ first ] . length ; j -- ; ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; for ( var j = elem [ now ] . length ; j -- ; ) { for ( var k = elem [ next ] . length ; k -- ; ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; for ( var j = elem [ last ] . length ; j -- ; ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var inp = input ; var i = 0 ; while ( true ) { var fieldInfo = inp [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; elem [ 0 ] . length = 0 ; elem [ 1 ] . length = 0 ; elem [ 2 ] . length = 0 ; elem [ 3 ] . length = 0 ; elem [ 4 ] . length = 0 ; for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = inp [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var inp = input ; var i = 0 ; while ( true ) { var fieldInfo = inp [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; elem [ 0 ] . length = 0 ; elem [ 1 ] . length = 0 ; elem [ 2 ] . length = 0 ; elem [ 3 ] . length = 0 ; elem [ 4 ] . length = 0 ; for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = inp [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var inp = input ; var i = 0 ; while ( true ) { var fieldInfo = inp [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = inp [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var inp = input ; var i = 0 ; while ( true ) { var fieldInfo = inp [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = width ; x -- ; ) { var c = inp [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var inp = input ; var i = 0 ; while ( true ) { var fieldInfo = inp [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = width ; x -- ; ) { var c = inp [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] ) ; var height = parseInt ( fieldInfo [ 1 ] ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ parseInt ( c ) - 1 ] [ elem [ parseInt ( c ) - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] ) ; var height = parseInt ( fieldInfo [ 1 ] ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; case ' . ' : break ; default : elem [ parseInt ( c ) - 1 ] . push ( pos ( x , y ) ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = 0 ; y < height ; y ++ ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = width ; x -- ; ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = width ; x -- ; ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = width ; x -- ; ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { switch ( input [ i ] [ x ] ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ input [ i ] [ x ] - 1 ] [ elem [ input [ i ] [ x ] - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var tg = elem [ c - 1 ] ; tg [ tg . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var jn = elem [ now ] . length ; var nextLength = elem [ next ] . length ; while ( jn -- ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ jn ] + dist ( elem [ now ] [ jn ] , elem [ next ] [ k ] ) ) ; } } ; } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var y = height ; for ( ; y -- ; ) { i ++ ; var x = width ; for ( ; x -- ; ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; for ( var j = nowLength ; j -- ; ) { for ( var k = nextLength ; k -- ; ) { dp [ next ] [ k ] = fmin ( dp [ next ] [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var ei = 0 ; ei < 5 ; ei ++ ) { elem [ ei ] . length = 0 ; } for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; for ( var j = 0 ; j < firstLength ; j ++ ) { dp [ first ] [ j ] = dist ( start , elem [ first ] [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; for ( var x = 0 ; x < width ; x ++ ) { var c = input [ i ] [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : elem [ c - 1 ] [ elem [ c - 1 ] . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpn = dp [ next ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpn [ k ] = fmin ( dpn [ k ] , dp [ now ] [ j ] + dist ( elem [ now ] [ j ] , elem [ next ] [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dp [ last ] [ j ] + dist ( elem [ last ] [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = 0 ; y < height ; y ++ ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = 0 ; y < height ; y ++ ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { return Math . abs ( a ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; var d ; for ( var j = 0 ; j < lastLength ; j ++ ) { d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; elemf . forEach ( function ( v , j , ar ) { dpf [ j ] = dist ( start , v ) ; } ) ; for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e . push ( pos ( x , y ) ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; default : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; var c ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var k ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; var c ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni . charCodeAt ( x ) ; if ( c === 46 ) { } else if ( c <= 53 ) { var e = elem [ c - 49 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === 83 ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var k ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; var c ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni . charCodeAt ( x ) ; if ( c == 46 ) { } else if ( c <= 53 ) { var e = elem [ c - 49 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == 83 ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var k ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni . charAt ( x ) ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni . charAt ( x ) ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni . charAt ( x ) ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ new Array ( ) , new Array ( ) , new Array ( ) , new Array ( ) , new Array ( ) ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni . charAt ( x ) ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { var c = ni . charAt ( x ) ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var dph = dp [ h ] ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var hLength0 = elem [ 0 ] . length ; var dp0 = dp [ 0 ] ; dp0 . length = hLength0 ; for ( var hidx = 0 ; hidx < hLength0 ; hidx ++ ) { dp0 [ hidx ] = INF ; } var hLength1 = elem [ 1 ] . length ; var dp1 = dp [ 1 ] ; dp1 . length = hLength1 ; for ( var hidx = 0 ; hidx < hLength1 ; hidx ++ ) { dp1 [ hidx ] = INF ; } var hLength2 = elem [ 2 ] . length ; var dp2 = dp [ 2 ] ; dp2 . length = hLength2 ; for ( var hidx = 0 ; hidx < hLength2 ; hidx ++ ) { dp2 [ hidx ] = INF ; } var hLength3 = elem [ 3 ] . length ; var dp3 = dp [ 3 ] ; dp3 . length = hLength3 ; for ( var hidx = 0 ; hidx < hLength3 ; hidx ++ ) { dp3 [ hidx ] = INF ; } var hLength4 = elem [ 4 ] . length ; var dp4 = dp [ 4 ] ; dp4 . length = hLength4 ; for ( var hidx = 0 ; hidx < hLength4 ; hidx ++ ) { dp4 [ hidx ] = INF ; } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var dph ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dph = dp [ h ] ; dph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var nowLength = elem [ now ] . length ; var nextLength = elem [ next ] . length ; var dpnx = dp [ next ] ; var dpnw = dp [ now ] ; var elnx = elem [ next ] ; var elnw = elem [ now ] ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnw [ j ] + dist ( elnw [ j ] , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] , elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var dpl = dp [ last ] ; var ell = elem [ last ] ; var lastLength = ell . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var dpl = dp [ last ] ; var ell = elem [ last ] ; var lastLength = ell . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var dpl = dp [ last ] ; var ell = elem [ last ] ; var lastLength = ell . length ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = ( x << 11 ) + y ; } else if ( c === ' S ' ) { start = ( x << 11 ) + y ; } else { goal = ( x << 11 ) + y ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return fabs ( ( from >> 11 ) - ( to >> 11 ) ) + fabs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function fabs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = ( x << 11 ) + y ; } else if ( c === ' S ' ) { start = ( x << 11 ) + y ; } else { goal = ( x << 11 ) + y ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { var diff1 = ( from >> 11 ) - ( to >> 11 ) ; var mask1 = diff1 >> 31 ; var diff2 = ( from & 2047 ) - ( to & 2047 ) ; var mask2 = diff2 >> 31 ; return ( ( diff1 ^ mask1 ) - mask1 ) + ( ( diff2 ^ mask2 ) - mask2 ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = ( x << 11 ) + y ; } else if ( c === ' S ' ) { start = ( x << 11 ) + y ; } else { goal = ( x << 11 ) + y ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { dp [ h ] [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = fmin ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { var diff1 = ( from >> 11 ) - ( to >> 11 ) ; var mask1 = diff1 >> 31 ; var diff2 = ( from & 2047 ) - ( to & 2047 ) ; var mask2 = diff2 >> 31 ; return ( ( diff1 ^ mask1 ) - mask1 ) + ( ( diff2 ^ mask2 ) - mask2 ) ; } function fmin ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { dp [ h ] . length = 1000 ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < 1000 ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var e1 = ( startElem + 1 ) % 5 ; var e2 = ( startElem + 2 ) % 5 ; var e3 = ( startElem + 3 ) % 5 ; var e4 = ( startElem + 4 ) % 5 ; var dpe1 = dp [ e1 ] ; var dpe2 = dp [ e2 ] ; var dpe3 = dp [ e3 ] ; var dpe4 = dp [ e4 ] ; var ele1 = elem [ e1 ] ; var ele2 = elem [ e2 ] ; var ele3 = elem [ e3 ] ; var ele4 = elem [ e4 ] ; var e1len = ele1 . length ; var e2len = ele2 . length ; var e3len = ele3 . length ; var e4len = ele4 . length ; for ( var j = 0 ; j < e1len ; j ++ ) { var dpe1j = dpe1 [ j ] = dist ( start , ele1 [ j ] ) ; var ele1j = ele1 [ j ] ; for ( var k = 0 ; k < e2len ; k ++ ) { dpe2 [ k ] = min ( dpe2 [ k ] , dpe1j + dist ( ele1j , ele2 [ k ] ) ) ; } } for ( var j = 0 ; j < e2len ; j ++ ) { var dpe2j = dpe2 [ j ] ; var ele2j = ele2 [ j ] ; for ( var k = 0 ; k < e3len ; k ++ ) { dpe3 [ k ] = min ( dpe3 [ k ] , dpe2j + dist ( ele2j , ele3 [ k ] ) ) ; } } for ( var j = 0 ; j < e3len ; j ++ ) { var dpe3j = dpe3 [ j ] ; var ele3j = ele3 [ j ] ; for ( var k = 0 ; k < e4len ; k ++ ) { dpe4 [ k ] = min ( dpe4 [ k ] , dpe3j + dist ( ele3j , ele4 [ k ] ) ) ; } } for ( var j = 0 ; j < e4len ; j ++ ) { var d = dpe4 [ j ] + dist ( ele4 [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var e1 = ( startElem + 1 ) % 5 ; var e2 = ( startElem + 2 ) % 5 ; var e3 = ( startElem + 3 ) % 5 ; var e4 = ( startElem + 4 ) % 5 ; var dpe1 = dp [ e1 ] ; var dpe2 = dp [ e2 ] ; var dpe3 = dp [ e3 ] ; var dpe4 = dp [ e4 ] ; var ele1 = elem [ e1 ] ; var ele2 = elem [ e2 ] ; var ele3 = elem [ e3 ] ; var ele4 = elem [ e4 ] ; var e1len = ele1 . length ; var e2len = ele2 . length ; var e3len = ele3 . length ; var e4len = ele4 . length ; for ( var j = 0 ; j < e1len ; j ++ ) { var dpe1j = dpe1 [ j ] = dist ( start , ele1 [ j ] ) ; } for ( var j = 0 ; j < e1len ; j ++ ) { var dpe1j = dpe1 [ j ] ; var ele1j = ele1 [ j ] ; for ( var k = 0 ; k < e2len ; k ++ ) { dpe2 [ k ] = min ( dpe2 [ k ] , dpe1j + dist ( ele1j , ele2 [ k ] ) ) ; } } for ( var j = 0 ; j < e2len ; j ++ ) { var dpe2j = dpe2 [ j ] ; var ele2j = ele2 [ j ] ; for ( var k = 0 ; k < e3len ; k ++ ) { dpe3 [ k ] = min ( dpe3 [ k ] , dpe2j + dist ( ele2j , ele3 [ k ] ) ) ; } } for ( var j = 0 ; j < e3len ; j ++ ) { var dpe3j = dpe3 [ j ] ; var ele3j = ele3 [ j ] ; for ( var k = 0 ; k < e4len ; k ++ ) { dpe4 [ k ] = min ( dpe4 [ k ] , dpe3j + dist ( ele3j , ele4 [ k ] ) ) ; } } for ( var j = 0 ; j < e4len ; j ++ ) { var d = dpe4 [ j ] + dist ( ele4 [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { var elemfj = elemf [ j ] ; var dpfj = dpf [ j ] ; dpfj = dist ( start , elemfj ) ; var next = ( first + 1 ) % 5 ; var dpnx = dp [ next ] ; var elnx = elem [ next ] ; var nextLength = elnx . length ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpfj + dist ( elemfj , elnx [ k ] ) ) ; } } for ( var e = 1 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { var elemfj = elemf [ j ] ; var dpfj = dpf [ j ] ; dpfj = dist ( start , elemfj ) ; var next = ( first + 1 ) % 5 ; var dpnx = dp [ next ] ; var elnx = elem [ next ] ; var nextLength = elnx . length ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpfj + dist ( elemfj , elnx [ k ] ) ) ; } } for ( var e = 1 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c !== ' S ' && c !== ' G ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { var elemfj = elemf [ j ] ; var dpfj = dpf [ j ] ; dpfj = dist ( start , elemfj ) ; var next = ( first + 1 ) % 5 ; var dpnx = dp [ next ] ; var elnx = elem [ next ] ; var nextLength = elnx . length ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpfj + dist ( elemfj , elnx [ k ] ) ) ; } } for ( var e = 1 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c !== ' S ' && c !== ' G ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = dp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var orgdp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 0 ; h < 5 ; h ++ ) { var hLength = elem [ h ] . length ; var initdph = orgdp [ h ] ; initdph . length = hLength ; for ( var hidx = 0 ; hidx < hLength ; hidx ++ ) { initdph [ hidx ] = INF ; } } for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = JSON . parse ( JSON . stringify ( orgdp ) ) ; var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = firstLength ; j -- ; ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = nowLength ; j -- ; ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = nextLength ; k -- ; ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = lastLength ; j -- ; ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = firstLength ; j -- ; ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = nowLength ; j -- ; ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = nextLength ; k -- ; ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = lastLength ; j -- ; ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = firstLength ; j -- ; ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = nowLength ; j -- ; ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = nextLength ; k -- ; ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = lastLength ; j -- ; ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = ( ( dpl [ j ] + dist ( ell [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = ( ( dpl [ j ] + dist ( ell [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = ( ( dpl [ j ] + dist ( ell [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 5 ; startElem -- ; ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = ( ( dpl [ j ] + dist ( ell [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; var startElem = 5 ; for ( ; startElem -- ; ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = ( ( dpl [ j ] + dist ( ell [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 268435455 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { var now = ( first + e ) % 5 ; var next = ( now + 1 ) % 5 ; var dpnw = dp [ now ] ; var dpnx = dp [ next ] ; var elnw = elem [ now ] ; var elnx = elem [ next ] ; var nowLength = elnw . length ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = ( ( dpl [ j ] + dist ( ell [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dp [ now ] ; var elnw = elem [ now ] ; var nowLength = elnw . length ; for ( var e = 0 ; e < 3 ; e ++ ) { var next = ( now + 1 ) % 5 ; var dpnx = dp [ next ] ; var elnx = elem [ next ] ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dp [ now ] ; var elnw = elem [ now ] ; var nowLength = elnw . length ; for ( var e = 0 ; e < 3 ; e ++ ) { var next = ( now + 1 ) % 5 ; var dpnx = dp [ next ] ; var elnx = elem [ next ] ; var nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } var last = ( first + 3 ) % 5 ; var lastLength = elem [ last ] . length ; var dpl = dp [ last ] ; var ell = elem [ last ] ; for ( var j = 0 ; j < lastLength ; j ++ ) { var d = dpl [ j ] + dist ( ell [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var initi = 5 ; while ( initi -- ) { var len = elem [ initi ] . length ; dp [ initi ] . length = len ; var dpi = dp [ initi ] ; while ( len -- ) { dpi [ len ] = INF ; } } var now = ( startElem + 1 ) % 5 ; var elnw = elem [ now ] ; var nwlen = elnw . length ; var dpnw = dp [ now ] ; for ( var j = 0 ; j < nwlen ; j ++ ) { dpnw [ j ] = dist ( start , elnw [ j ] ) ; } var next , dpnx , elnx , nxlen ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nxlen = elnx . length ; for ( var j = 0 ; j < nwlen ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nxlen ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nwlen = elnw . length ; } for ( var j = 0 ; j < nxlen ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var initi = 5 ; while ( initi -- ) { var len = elem [ initi ] . length ; dp [ initi ] . length = len ; var dpi = dp [ initi ] ; while ( len -- ) { dpi [ len ] = INF ; } } var now = ( startElem + 1 ) % 5 ; var elnw = elem [ now ] ; var nwlen = elnw . length ; var dpnw = dp [ now ] ; for ( var j = 0 ; j < nwlen ; j ++ ) { dpnw [ j ] = dist ( start , elnw [ j ] ) ; } var next , dpnx , elnx , nxlen ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nxlen = elnx . length ; for ( var j = 0 ; j < nwlen ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nxlen ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nwlen = elnw . length ; } for ( var j = 0 ; j < nxlen ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var initi = 5 ; while ( initi -- ) { var len = elem [ initi ] . length ; dp [ initi ] . length = len ; var dpi = dp [ initi ] ; while ( len -- ) { dpi [ len ] = INF ; } } var now = ( startElem + 1 ) % 5 ; var elnw = elem [ now ] ; var nwlen = elnw . length ; var dpnw = dp [ now ] ; for ( var j = 0 ; j < nwlen ; j ++ ) { dpnw [ j ] = dist ( start , elnw [ j ] ) ; } var next ; var dpnx ; var elnx ; var nxlen ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nxlen = elnx . length ; for ( var j = 0 ; j < nwlen ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nxlen ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nwlen = elnw . length ; } for ( var j = 0 ; j < nxlen ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var initi = 5 ; while ( initi -- ) { var len = elem [ initi ] . length ; dp [ initi ] . length = len ; var dpi = dp [ initi ] ; while ( len -- ) { dpi [ len ] = INF ; } } var now = ( startElem + 1 ) % 5 ; var elnw = elem [ now ] ; var nwlen = elnw . length ; var dpnw = dp [ now ] ; for ( var j = 0 ; j < nwlen ; j ++ ) { dpnw [ j ] = dist ( start , elnw [ j ] ) ; } var next ; var dpnx ; var elnx ; var nxlen ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nxlen = elnx . length ; for ( var j = 0 ; j < nwlen ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nxlen ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nwlen = elnw . length ; } for ( var j = 0 ; j < nxlen ; j ++ ) { var d = ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' 1 ' : case ' 2 ' : case ' 3 ' : case ' 4 ' : case ' 5 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' S ' : start = pos ( x , y ) ; break ; default : goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var initi = 5 ; while ( initi -- ) { var len = elem [ initi ] . length ; dp [ initi ] . length = len ; var dpi = dp [ initi ] ; while ( len -- ) { dpi [ len ] = INF ; } } var now = ( startElem + 1 ) % 5 ; var elnw = elem [ now ] ; var nwlen = elnw . length ; var dpnw = dp [ now ] ; for ( var j = 0 ; j < nwlen ; j ++ ) { dpnw [ j ] = dist ( start , elnw [ j ] ) ; } var next ; var dpnx ; var elnx ; var nxlen ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nxlen = elnx . length ; for ( var j = 0 ; j < nwlen ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nxlen ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nwlen = elnw . length ; } for ( var j = 0 ; j < nxlen ; j ++ ) { var d = ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' 1 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 2 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 3 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 4 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 5 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' S ' : start = pos ( x , y ) ; break ; default : goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var initi = 5 ; while ( initi -- ) { var len = elem [ initi ] . length ; dp [ initi ] . length = len ; var dpi = dp [ initi ] ; while ( len -- ) { dpi [ len ] = INF ; } } var now = ( startElem + 1 ) % 5 ; var elnw = elem [ now ] ; var nwlen = elnw . length ; var dpnw = dp [ now ] ; for ( var j = 0 ; j < nwlen ; j ++ ) { dpnw [ j ] = dist ( start , elnw [ j ] ) ; } var next ; var dpnx ; var elnx ; var nxlen ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nxlen = elnx . length ; for ( var j = 0 ; j < nwlen ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nxlen ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nwlen = elnw . length ; } for ( var j = 0 ; j < nxlen ; j ++ ) { var d = ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ; distance = min ( d , distance ) ; } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; switch ( c ) { case ' . ' : break ; case ' 1 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 2 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 3 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 4 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' 5 ' : var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; break ; case ' S ' : start = pos ( x , y ) ; break ; default : goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; } var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { input = input . split ( ' \\n ' ) ; main ( ) ; } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) . split ( ' \\n ' ) ; var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var lines = [ ] ; var reader = require ( ' readline ' ) . createInterface ( { input : process . stdin , output : process . stdout } ) ; reader . on ( ' line ' , function ( line ) { lines . push ( line ) ; } ) ; reader . on ( ' close ' , function ( ) { var i = 0 ; while ( true ) { var fieldInfo = lines [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = lines [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } ) ; function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var lines = [ ] ; var reader = require ( ' readline ' ) . createInterface ( { input : process . stdin , output : process . stdout } ) ; reader . on ( ' line ' , function ( line ) { lines [ lines . length ] = line ; } ) ; reader . on ( ' close ' , function ( ) { var i = 0 ; while ( true ) { var fieldInfo = lines [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = lines [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } ) ; function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } const INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var bestElement = - 1 ; var distance = 2147483647 ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = 2147483647 ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === 2147483647 ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var mask = a >> 31 ; return ( a ^ mask ) - mask ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance === INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; var jk ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( jk = 0 ; jk < nextLength ; jk ++ ) { dpnx [ jk ] = min ( dpnx [ jk ] , dpnwj + dist ( elnwj , elnx [ jk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; var jk ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( jk = 0 ; jk < nextLength ; jk ++ ) { dpnx [ jk ] = min ( dpnx [ jk ] , dpnwj + dist ( elnwj , elnx [ jk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) , inputCache , width = fieldInfo [ 0 ] - 0 , height = fieldInfo [ 1 ] - 0 , start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , elemCache , chr , INF = 1 << 30 , bestElement = - 1 ; var distance = INF ; if ( ! width && ! height ) { break ; } for ( y = height ; y -- ; ) { i ++ ; inputCache = input [ i ] ; for ( x = width ; x -- ; ) { chr = inputCache [ x ] ; if ( chr == ' . ' ) { } else if ( chr == ' 1 ' || chr == ' 2 ' || chr == ' 3 ' || chr == ' 4 ' || chr == ' 5 ' ) { elemCache = elem [ chr - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( chr == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) , inputCache , width = fieldInfo [ 0 ] - 0 , height = fieldInfo [ 1 ] - 0 , start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , elemCache , chr , INF = 1 << 30 , bestElement = - 1 , distance = INF ; if ( ! width && ! height ) { break ; } for ( y = height ; y -- ; ) { i ++ ; inputCache = input [ i ] ; for ( x = width ; x -- ; ) { chr = inputCache [ x ] ; if ( chr == ' . ' ) { } else if ( chr == ' 1 ' || chr == ' 2 ' || chr == ' 3 ' || chr == ' 4 ' || chr == ' 5 ' ) { elemCache = elem [ chr - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( chr == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , idxj , idxk ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { var dpnwj = dpnw [ idxj ] ; var elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } var inxl , tdist ; for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = 0 ; idxf < firstLength ; idxf ++ ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = 0 ; idxf < firstLength ; idxf ++ ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = 0 ; idxf < firstLength ; idxf ++ ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = 0 ; idxf < firstLength ; idxf ++ ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = firstLength ; idxf -- ; ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = 0 ; idxj < nowLength ; idxj ++ ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = 0 ; idxk < nextLength ; idxk ++ ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = firstLength ; idxf -- ; ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = nowLength ; idxj -- ; ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = nextLength ; idxk -- ; ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = 0 ; idxl < nextLength ; idxl ++ ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 , idxf , firstLength = elem [ first ] . length , dpf = dp [ first ] , elemf = elem [ first ] , now = first , dpnw = dpf , elnw = elemf , nowLength = elnw . length , next , dpnx , elnx , nextLength , dpnwj , elnwj , idxj , idxk , inxl , tdist ; for ( idxf = firstLength ; idxf -- ; ) { dpf [ idxf ] = dist ( start , elemf [ idxf ] ) ; } for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( idxj = nowLength ; idxj -- ; ) { dpnwj = dpnw [ idxj ] ; elnwj = elnw [ idxj ] ; for ( idxk = nextLength ; idxk -- ; ) { dpnx [ idxk ] = min ( dpnx [ idxk ] , dpnwj + dist ( elnwj , elnx [ idxk ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( idxl = nextLength ; idxl -- ; ) { tdist = dpnx [ idxl ] + dist ( elnx [ idxl ] , goal ) ; if ( tdist < distance ) { distance = tdist ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { distance = min ( distance , ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ) ; } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { distance = min ( distance , ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ) ; } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 27 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { distance = min ( distance , ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ) ; } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 26 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { distance = min ( distance , ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ) ; } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 26 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { distance = min ( distance , ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ) ; } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elem [ c - 1 ] . push ( pos ( x , y ) ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 26 ; var bestElement = - 1 ; var distance = INF ; var elemSize = 5 ; var startIdx = 0 ; for ( var startElem = startIdx ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = elemSize ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % elemSize ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = startIdx ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = startIdx ; e < 3 ; e ++ ) { next = ( now + 1 ) % elemSize ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = startIdx ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = startIdx ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = startIdx ; j < nextLength ; j ++ ) { distance = min ( distance , ( ( dpnx [ j ] + dist ( elnx [ j ] , goal ) ) << 3 ) + startElem ) ; } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( distance & 7 ) + 1 ) + \" \" + ( distance >> 3 ) ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = 0 ; y < height ; y ++ ) { i ++ ; var ni = input [ i ] ; for ( var x = 0 ; x < width ; x ++ ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var i = 0 ; while ( true ) { var fieldInfo = input [ i ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; for ( var y = height ; y -- ; ) { i ++ ; var ni = input [ i ] ; for ( var x = width ; x -- ; ) { c = ni [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { var e = elem [ c - 1 ] ; e [ e . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var distance = INF ; for ( var startElem = 0 ; startElem < 5 ; startElem ++ ) { var dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( var h = 5 ; h -- ; ) { var hLength = elem [ h ] . length ; dp [ h ] . length = hLength ; var initdph = dp [ h ] ; for ( ; hLength -- ; ) { initdph [ hLength ] = INF ; } } var first = ( startElem + 1 ) % 5 ; var firstLength = elem [ first ] . length ; var dpf = dp [ first ] ; var elemf = elem [ first ] ; for ( var j = 0 ; j < firstLength ; j ++ ) { dpf [ j ] = dist ( start , elemf [ j ] ) ; } var now = first ; var dpnw = dpf ; var elnw = elemf ; var nowLength = elnw . length ; var next ; var dpnx ; var elnx ; var nextLength ; for ( var e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpnx = dp [ next ] ; elnx = elem [ next ] ; nextLength = elnx . length ; for ( var j = 0 ; j < nowLength ; j ++ ) { var dpnwj = dpnw [ j ] ; var elnwj = elnw [ j ] ; if ( dpnwj > distance ) { continue ; } for ( var k = 0 ; k < nextLength ; k ++ ) { dpnx [ k ] = min ( dpnx [ k ] , dpnwj + dist ( elnwj , elnx [ k ] ) ) ; } } now = next ; dpnw = dpnx ; elnw = elnx ; nowLength = elnw . length ; } for ( var j = 0 ; j < nextLength ; j ++ ) { var d = dpnx [ j ] + dist ( elnx [ j ] , goal ) ; if ( d < distance ) { distance = d ; bestElement = startElem + 1 ; } } } if ( distance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + distance ) ; } i ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start , goal , elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] , i , j , e , rowData , c , INF = 1 << 30 , bestElement = - 1 , currentDisance , nearestDistance = INF , dp , len , dpCacheNow , dpCacheNowi , dpCacheNext , elemCacheNow , elemCacheNowi , elemCacheNext , now , nowLength , next , nextLength ; for ( i = height ; i -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( j = width ; j -- ; ) { c = rowData [ j ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCacheNow = elem [ c - 1 ] ; elemCacheNow [ elemCacheNow . length ] = pos ( j , i ) ; } else if ( c == ' S ' ) { start = pos ( j , i ) ; } else { goal = pos ( j , i ) ; } } } for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; var breakTimer ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; y = height ; while ( y -- ) { readLines ++ ; rowData = input [ readLines ] ; x = width ; while ( x -- ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; var breakTimer ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; i = 5 ; while ( i -- ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; y = height ; while ( y -- ) { readLines ++ ; rowData = input [ readLines ] ; x = width ; while ( x -- ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; var breakTimer ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; i = 5 ; while ( i -- ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; var breakTimer ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; for ( ; len -- ; ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; var breakTimer ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; for ( ; len -- ; ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! ( width + height ) ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] ; dpCache . length = len ; for ( ; len -- ; ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] ; dpCache . length = len ; for ( ; len -- ; ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { var dpCacheNextj = dpCacheNext [ j ] ; dpCacheNext [ j ] = min ( dpCacheNextj , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] ; dpCache . length = len ; for ( ; len -- ; ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi < nearestDistance ) { for ( j = 0 ; j < nextLength ; j ++ ) { var dpCacheNextj = dpCacheNext [ j ] ; dpCacheNext [ j ] = min ( dpCacheNextj , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi > nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; SEARCH : for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; var limit = nowLength ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { limit -- ; continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } if ( ! limit ) { continue SEARCH ; } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; SEARCH : for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; var limit = nowLength ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { limit -- ; continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } if ( ! limit ) { continue SEARCH ; } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; SEARCH : for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; for ( e = 0 ; e < 2 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; var limit = nowLength ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { limit -- ; continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } if ( ! limit ) { continue SEARCH ; } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem + 1 ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( bestElement + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' ascii ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 10 ) - ( to >> 10 ) ) + abs ( ( from & 1023 ) - ( to & 1023 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 10 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 10 ) - ( to >> 10 ) ) + abs ( ( from & 1023 ) - ( to & 1023 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 10 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 10 ) - ( to >> 10 ) ) + abs ( ( from & 0x03FF ) - ( to & 0x03FF ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 10 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 10 ) - ( to >> 10 ) ) + abs ( ( from & 0x3FF ) - ( to & 0x3FF ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 10 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; var e1 = 0 ; var e2 = 0 ; var e3 = 0 ; var e4 = 0 ; var e5 = 0 ; var elemCache1 = elem [ 0 ] ; var elemCache2 = elem [ 1 ] ; var elemCache3 = elem [ 2 ] ; var elemCache4 = elem [ 3 ] ; var elemCache5 = elem [ 4 ] ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; switch ( c ) { case ' . ' : break ; case ' 1 ' : elemCache1 [ e1 ++ ] = pos ( x , y ) ; break ; case ' 2 ' : elemCache2 [ e2 ++ ] = pos ( x , y ) ; break ; case ' 3 ' : elemCache3 [ e3 ++ ] = pos ( x , y ) ; break ; case ' 4 ' : elemCache4 [ e4 ++ ] = pos ( x , y ) ; break ; case ' 5 ' : elemCache5 [ e5 ++ ] = pos ( x , y ) ; break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 10 ) - ( to >> 10 ) ) + abs ( ( from & 0x3FF ) - ( to & 0x3FF ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 10 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; var e1 = 0 ; var e2 = 0 ; var e3 = 0 ; var e4 = 0 ; var e5 = 0 ; var elemCache1 = elem [ 0 ] ; var elemCache2 = elem [ 1 ] ; var elemCache3 = elem [ 2 ] ; var elemCache4 = elem [ 3 ] ; var elemCache5 = elem [ 4 ] ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; switch ( c ) { case ' . ' : break ; case ' 1 ' : elemCache1 [ e1 ] = pos ( x , y ) ; e1 ++ ; break ; case ' 2 ' : elemCache2 [ e2 ] = pos ( x , y ) ; e2 ++ ; break ; case ' 3 ' : elemCache3 [ e3 ] = pos ( x , y ) ; e3 ++ ; break ; case ' 4 ' : elemCache4 [ e4 ] = pos ( x , y ) ; e4 ++ ; break ; case ' 5 ' : elemCache5 [ e5 ] = pos ( x , y ) ; e5 ++ ; break ; case ' S ' : start = pos ( x , y ) ; break ; case ' G ' : goal = pos ( x , y ) ; break ; } } } var selectElem ; var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 10 ) - ( to >> 10 ) ) + abs ( ( from & 0x3FF ) - ( to & 0x3FF ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 10 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var dpCacheNextj ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var elemCacheNextj ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { elemCacheNextj = elemCacheNext [ j ] ; dpCacheNextj = dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNextj ) ) ; if ( e == 2 ) { currentDistance = dpCacheNextj + dist ( elemCacheNextj , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var dpCacheNextj ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var elemCacheNextj ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { elemCacheNowi = elemCacheNow [ i ] ; if ( e == 0 ) { dpCacheNow [ i ] = dist ( start , elemCacheNowi ) ; } dpCacheNowi = dpCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { elemCacheNextj = elemCacheNext [ j ] ; dpCacheNextj = dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNextj ) ) ; if ( e != 2 ) { continue ; } currentDistance = dpCacheNextj + dist ( elemCacheNextj , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { var t = a - b ; return b + ( t & ( t >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] ; dpCache . length = len ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c === ' . ' ) { } else if ( c === ' 1 ' || c === ' 2 ' || c === ' 3 ' || c === ' 4 ' || c === ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c === ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] ; dpCache . length = len ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance + ( 3 - e ) ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { var elemCacheNextj = elemCacheNext [ j ] ; var dpCacheNextj = dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNextj ) ) ; if ( e == 2 ) { currentDistance = dpCacheNextj + dist ( elemCacheNextj , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dp [ i ] . length = len ; dpCache = dp [ i ] ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { var elemCacheNextj = elemCacheNext [ j ] ; var dpCacheNextj = dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNextj ) ) ; if ( e === 2 ) { currentDistance = dpCacheNextj + dist ( elemCacheNextj , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = new Number ( height ) ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = new Number ( width ) ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ parseInt ( c , 10 ) - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ parseInt ( c , 10 ) - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 27 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { nearestDistance = min ( nearestDistance , ( ( dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ) << 3 ) + selectElem ) ; } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( ( nearestDistance & 7 ) + 1 ) + \" \" + ( nearestDistance >> 3 ) ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } const INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "const INF = 1 << 30 ; var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "const INF = 1 << 30 ; const SHIFT_ELEM_X = 11 ; var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> SHIFT_ELEM_X ) - ( to >> SHIFT_ELEM_X ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << SHIFT_ELEM_X ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "const INF = 1 << 30 ; const ELEM_X = 11 ; const ELEM_Y = 2047 ; var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> ELEM_X ) - ( to >> ELEM_X ) ) + abs ( ( from & ELEM_Y ) - ( to & ELEM_Y ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << ELEM_X ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( getX ( from ) - getX ( to ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function getX ( elem ) { return elem >> 11 ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( getX ( from ) - getX ( to ) ) + abs ( getY ( from ) - getY ( to ) ) ; } function getX ( elem ) { return elem >> 11 ; } function getY ( elem ) { return elem & 2047 ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( getX ( from ) - getX ( to ) ) + abs ( getY ( from ) - getY ( to ) ) ; } function getX ( elem ) { return elem >> 11 ; } function getY ( elem ) { return elem & 2047 ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { var t = a >> 31 ; return ( a ^ t ) - t ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { rowData = input [ ++ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { rowData = input [ ++ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = c - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( input ) ; function main ( inp ) { var readLines = 0 ; while ( true ) { var fieldInfo = inp [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = inp [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "( function ( ) { var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( input ) ; } ) ( ) ; function main ( inp ) { var readLines = 0 ; while ( true ) { var fieldInfo = inp [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = inp [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = parseInt ( c , 10 ) - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = parseInt ( c , 10 ) - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; nowLength = elemCacheNow . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = parseInt ( c , 10 ) - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; nowLength = elemCacheNow . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width || ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = parseInt ( c , 10 ) - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; nowLength = elemCacheNow . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width || ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = parseInt ( c , 10 ) - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ 0 , 0 , 0 , 0 , 0 ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; nowLength = elemCacheNow . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = parseInt ( fieldInfo [ 0 ] , 10 ) ; var height = parseInt ( fieldInfo [ 1 ] , 10 ) ; if ( ! width || ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var cIdx ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { cIdx = parseInt ( c , 10 ) - 1 ; elemCache = elem [ cIdx ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = [ 0 , 0 , 0 , 0 , 0 ] ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; nowLength = elemCacheNow . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData . charAt ( x ) ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] . split ( ' ' ) ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' ascii ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var fs = require ( ' fs ' ) , length = fs . fstatSync ( process . stdin . fd ) . size , buffer = new Buffer ( length ) , bytesRead = fs . readSync ( process . stdin . fd , buffer , 0 , length , 0 ) , input = buffer . toString ( ' utf8 ' , 0 , bytesRead ) . split ( ' \\n ' ) ; main ( ) ; function main ( ) { var readLines = 0 ; while ( true ) { var fieldInfo = input [ readLines ] . split ( ' ' ) ; var width = fieldInfo [ 0 ] - 0 ; var height = fieldInfo [ 1 ] - 0 ; if ( ! width && ! height ) { break ; } var start ; var goal ; var elem = [ [ ] , [ ] , [ ] , [ ] , [ ] ] ; var c ; var rowData ; var elemCache ; var y ; var x ; for ( y = height ; y -- ; ) { readLines ++ ; rowData = input [ readLines ] ; for ( x = width ; x -- ; ) { c = rowData [ x ] ; if ( c == ' . ' ) { } else if ( c == ' 1 ' || c == ' 2 ' || c == ' 3 ' || c == ' 4 ' || c == ' 5 ' ) { elemCache = elem [ c - 1 ] ; elemCache [ elemCache . length ] = pos ( x , y ) ; } else if ( c == ' S ' ) { start = pos ( x , y ) ; } else { goal = pos ( x , y ) ; } } } for ( var elemInit = 5 ; elemInit -- ; ) { elem [ elemInit ] = new Int32Array ( elem [ elemInit ] ) ; } var INF = 1 << 30 ; var bestElement = - 1 ; var currentDisance ; var nearestDistance = INF ; var dp ; var i ; var j ; var e ; var len ; var dpCacheNow ; var dpCacheNowi ; var dpCacheNext ; var elemCacheNow ; var elemCacheNowi ; var elemCacheNext ; var now ; var nowLength ; var next ; var nextLength ; for ( var selectElem = 0 ; selectElem < 5 ; selectElem ++ ) { dp = new Array ( 5 ) ; for ( i = 5 ; i -- ; ) { len = elem [ i ] . length ; dpCache = dp [ i ] = new Int32Array ( len ) ; while ( len -- ) { dpCache [ len ] = INF ; } } now = ( selectElem + 1 ) % 5 ; nowLength = elem [ now ] . length ; dpCacheNow = dp [ now ] ; elemCacheNow = elem [ now ] ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNow [ i ] = dist ( start , elemCacheNow [ i ] ) ; } for ( e = 0 ; e < 3 ; e ++ ) { next = ( now + 1 ) % 5 ; dpCacheNext = dp [ next ] ; elemCacheNext = elem [ next ] ; nextLength = elemCacheNext . length ; for ( i = 0 ; i < nowLength ; i ++ ) { dpCacheNowi = dpCacheNow [ i ] ; elemCacheNowi = elemCacheNow [ i ] ; if ( dpCacheNowi >= nearestDistance ) { continue ; } for ( j = 0 ; j < nextLength ; j ++ ) { dpCacheNext [ j ] = min ( dpCacheNext [ j ] , dpCacheNowi + dist ( elemCacheNowi , elemCacheNext [ j ] ) ) ; } } now = next ; dpCacheNow = dpCacheNext ; elemCacheNow = elemCacheNext ; nowLength = nextLength ; } for ( i = 0 ; i < nextLength ; i ++ ) { currentDistance = dpCacheNext [ i ] + dist ( elemCacheNext [ i ] , goal ) ; if ( currentDistance < nearestDistance ) { nearestDistance = currentDistance ; bestElement = selectElem ; } } } if ( nearestDistance == INF ) { console . log ( \" NA \" ) ; } else { console . log ( ( bestElement + 1 ) + \" \" + nearestDistance ) ; } readLines ++ ; } } function dist ( from , to ) { return abs ( ( from >> 11 ) - ( to >> 11 ) ) + abs ( ( from & 2047 ) - ( to & 2047 ) ) ; } function min ( a , b ) { return b + ( ( a - b ) & ( ( a - b ) >> 31 ) ) ; } function pos ( a , b ) { return ( a << 11 ) + b ; } function abs ( a ) { return ( a ^ ( a >> 31 ) ) - ( a >> 31 ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == - 1 ) break ; var a = Arr [ i ] ; var sum = 1150 ; if ( a > 10 && a <= 20 ) sum = 1150 + 125 * ( a - 10 ) ; else if ( a > 20 && a <= 30 ) sum = 1150 + 125 * 10 + 140 * ( a - 20 ) ; else if ( a > 30 ) sum = 1150 + 125 * 10 + 140 * 10 + 160 * ( a - 30 ) ; console . log ( 4280 - sum ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { var lines = input . split ( ' \\n ' ) ; var l = 0 ; while ( true ) { var w = Number ( lines [ l ++ ] ) ; if ( w === - 1 ) { break ; } var ans = 1150 ; if ( w > 10 ) { ans += Math . min ( 10 , w - 10 ) * 125 ; } if ( w > 20 ) { ans += Math . min ( 10 , w - 20 ) * 140 ; } if ( w > 30 ) { ans += ( w - 30 ) * 160 ; } console . log ( 4280 - ans ) ; } } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; var p = \" \" ; var max = 0 ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; if ( arr . length == 1 ) { if ( i == 0 ) continue ; console . log ( p + \" \" + max ) ; if ( arr [ 0 ] == \" 0 \" ) break ; p = \" \" ; max = 0 ; } else { var sum = arr [ 1 ] + arr [ 2 ] ; if ( max <= sum ) { max = sum ; p = arr [ 0 ] ; } } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == \" 0 \" ) break ; var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; if ( arr . length == 1 ) continue ; var ave = ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 3 ; var str = \" C \" ; if ( arr . indexOf ( 100 ) != - 1 ) { str = \" A \" ; } else if ( ( arr [ 0 ] + arr [ 1 ] ) / 2 >= 90 ) { str = \" A \" ; } else if ( ave >= 80 ) { str = \" A \" ; } else if ( ave >= 70 ) { str = \" B \" ; } else if ( ave >= 50 && ( arr [ 0 ] >= 80 || arr [ 1 ] >= 80 ) ) { str = \" B \" ; } console . log ( str ) ; }",
    "label": 2
  },
  {
    "code": "process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; var input = ' ' ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) ; process . stdin . on ( ' end ' , function ( ) { var lines = input . split ( ' \\n ' ) ; var l = 0 ; while ( true ) { var n = Number ( lines [ l ++ ] ) ; if ( n === 0 ) { break ; } for ( var i = 0 ; i < n ; i ++ ) { var values = lines [ l ++ ] . split ( ' ' ) . map ( Number ) ; var pm = values [ 0 ] ; var pe = values [ 1 ] ; var pj = values [ 2 ] ; var ans = ' C ' ; if ( pm === 100 || pe === 100 || pj === 100 ) { ans = ' A ' ; } else if ( ( pm + pe ) / 2 >= 90 ) { ans = ' A ' ; } else { var average = ( pm + pe + pj ) / 3 ; if ( average >= 80 ) { ans = ' A ' ; } else if ( average >= 70 ) { ans = ' B ' ; } else if ( average >= 50 && ( pm >= 80 || pe >= 80 ) ) { ans = ' B ' ; } } console . log ( ans ) ; } } } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; while ( true ) { var L = Arr . shift ( ) ; if ( L == 0 ) break ; var arr = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; for ( var i = 0 ; i < L ; i ++ ) { arr [ Arr . shift ( ) ] ++ ; } for ( var i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] == 0 ) console . log ( \" - \" ) ; else console . log ( Array ( arr [ i ] + 1 ) . join ( \" * \" ) ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; var nums = [ ] ; for ( var i = 7 ; i >= - 4 ; i -- ) { nums . push ( Math . pow ( 2 , i ) ) ; } while ( true ) { var x = Arr . shift ( ) - 0 ; if ( x == - 1 ) break ; var str = \" \" ; for ( var i = 0 ; i < nums . length ; i ++ ) { if ( x >= nums [ i ] ) { x -= nums [ i ] ; str += \" 1 \" ; } else { str += \" 0 \" ; } if ( i == 7 ) str += \" . \" ; } if ( x !== 0 ) str = \" NA \" ; console . log ( str ) ; }",
    "label": 2
  },
  {
    "code": "function prime ( max ) { var arr = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) arr [ i ] = i ; arr [ 0 ] = false ; arr [ 1 ] = false ; var sqrt = Math . floor ( Math . sqrt ( max ) ) ; for ( var i = 2 ; i <= sqrt ; i ++ ) { if ( arr [ i ] == false ) continue ; for ( var j = i + i ; j <= max ; j += i ) { arr [ j ] = false ; } } var result = [ ] ; for ( var i = 0 ; i <= max ; i ++ ) { if ( arr [ i ] !== false ) result . push ( arr [ i ] ) ; } return result ; } var p = prime ( 9999999 ) ; var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { var a = Arr [ i ] ; if ( a == 0 ) break ; var quad = \" \" ; for ( var j = 5 ; j < p . length ; j ++ ) { if ( p [ j ] > a ) break ; var x = p [ j ] - 8 ; if ( x == p [ j - 3 ] && x + 2 == p [ j - 2 ] && x + 6 == p [ j - 1 ] ) quad = p [ j ] ; } console . log ( quad ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < Arr . length ; i ++ ) { if ( Arr [ i ] == \" 0 0 \" ) break ; var arr = Arr [ i ] . split ( \" \" ) ; var x = ( arr [ 0 ] ) . split ( \" \" ) ; var y = ( arr [ 1 ] ) . split ( \" \" ) ; var h = 0 ; var b = 0 ; for ( var j = 0 ; j < 4 ; j ++ ) { if ( x [ j ] == y [ j ] ) { h ++ ; } else if ( y . indexOf ( x [ j ] ) != - 1 ) { b ++ ; } } console . log ( h + \" \" + b ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var NM = Arr . shift ( ) ; if ( NM == \" 0 0 \" ) break ; var nm = NM . split ( \" \" ) . map ( Number ) ; var m = nm [ 1 ] ; var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; arr . sort ( function ( a , b ) { return b - a ; } ) ; var sum = 0 ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( ( i + 1 ) % m != 0 ) sum += arr [ i ] ; } console . log ( sum ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) . map ( Number ) ; var SEG = [ [ 1 , 1 , 1 , 1 , 1 , 1 , 0 ] . reverse ( ) , [ 0 , 1 , 1 , 0 , 0 , 0 , 0 ] . reverse ( ) , [ 1 , 1 , 0 , 1 , 1 , 0 , 1 ] . reverse ( ) , [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] . reverse ( ) , [ 0 , 1 , 1 , 0 , 0 , 1 , 1 ] . reverse ( ) , [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] . reverse ( ) , [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] . reverse ( ) , [ 1 , 1 , 1 , 0 , 0 , 1 , 0 ] . reverse ( ) , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] . reverse ( ) , [ 1 , 1 , 1 , 1 , 0 , 1 , 1 ] . reverse ( ) ] ; var n = Arr [ 0 ] ; var seg = [ ] ; for ( var i = 1 ; i < Arr . length ; i ++ ) { if ( n == 0 ) { if ( i == 0 ) continue ; var arr = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; seg . forEach ( function ( v ) { var V = SEG [ v ] ; var str = \" \" ; for ( var i = 0 ; i < 7 ; i ++ ) { str += ( V [ i ] == arr [ i ] ) ? \" 0 \" : \" 1 \" ; } console . log ( str ) ; arr = V . slice ( ) ; } ) ; if ( Arr [ i ] == - 1 ) break ; seg = [ ] ; n = Arr [ i ] ; } else { n -- ; seg . push ( Arr [ i ] ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var BR = Arr . shift ( ) ; if ( BR == \" 0 0 0 0 0 0 \" ) break ; var br = BR . split ( \" \" ) . map ( Number ) ; var b = br [ 0 ] ; var r = br [ 1 ] ; var g = br [ 2 ] ; var c = br [ 3 ] ; var s = br [ 4 ] ; var t = br [ 5 ] ; var sum = 100 ; sum += b * 15 ; sum += r * 15 ; sum += ( b * 5 + r * 3 ) * 15 ; sum += g * 7 ; sum += c * 2 ; sum -= ( b * 5 + r * 3 ) * 2 ; sum -= ( t - s - ( b * 5 + r * 3 ) ) * 3 ; console . log ( sum ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var N = Arr . shift ( ) - 0 ; if ( N == 0 ) break ; var pm = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var m = arr [ 0 ] ; var a = arr [ 1 ] ; var b = arr [ 2 ] ; pm . push ( [ a , m ] ) ; pm . push ( [ b - 0.1 , - 1 * m ] ) ; } pm . sort ( function ( a , b ) { a = a [ 0 ] ; b = b [ 0 ] ; return a - b ; } ) ; var flag = \" OK \" ; var sum = 0 ; for ( var i = 0 ; i < pm . length ; i ++ ) { sum += pm [ i ] [ 1 ] ; if ( sum > 150 ) { flag = \" NG \" ; break ; } } console . log ( flag ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var t = Arr . shift ( ) - 0 ; if ( t == 0 ) break ; var n = Arr . shift ( ) - 0 ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; sum += arr [ 1 ] - arr [ 0 ] ; } console . log ( ( t <= sum ) ? \" OK \" : t - sum ) ; }",
    "label": 2
  },
  {
    "code": "let input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; let d = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( 1 ) { let t = d . shift ( ) - 0 ; if ( t == 0 ) break ; let n = d . shift ( ) - 0 ; let sum = 0 ; for ( i = 0 ; i < n ; ++ i ) { var arr = ( d . shift ( ) ) . split ( \" \" ) . map ( Number ) ; sum += arr [ 1 ] - arr [ 0 ] ; } ans = t <= sum ? \" OK \" : t - sum ; console . log ( ans ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var N = Arr . shift ( ) - 0 ; if ( N == 0 ) break ; var arr = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { var ipqr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; arr . push ( ipqr ) ; } var PQRC = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var result = [ ] ; arr . forEach ( function ( v ) { var bad = 0 ; if ( PQRC [ 0 ] < v [ 1 ] ) bad ++ ; if ( PQRC [ 1 ] < v [ 2 ] ) bad ++ ; if ( PQRC [ 2 ] < v [ 3 ] ) bad ++ ; if ( PQRC [ 3 ] < 4 * ( v [ 1 ] + v [ 3 ] ) + ( 9 * v [ 2 ] ) ) bad ++ ; if ( bad == 0 ) result . push ( v [ 0 ] ) ; } ) ; console . log ( ( result . length == 0 ) ? \" NA \" : result . join ( \" \\n \" ) ) ; }",
    "label": 2
  },
  {
    "code": "\" use strict \" ; function * getDatasets ( cin ) { const lines = cin . split ( \" \\n \" ) ; let sp = 0 ; while ( lines [ sp ] !== \" 0 \" ) { const n = parseInt ( lines [ sp ++ ] ) ; const table = lines . slice ( sp , sp + n ) . map ( elt => elt . split ( \" \" ) . map ( e => parseInt ( e ) ) ) ; sp += n ; const constraint = lines [ sp ++ ] . split ( \" \" ) . map ( elt => parseInt ( elt ) ) ; yield [ table , constraint ] ; } } new Promise ( function ( resolve , reject ) { let content = \" \" ; process . stdin . on ( \" data \" , chunk => { content += chunk ; } ) process . stdin . on ( \" end \" , ( ) => { resolve ( [ content , process . stdout ] ) ; } ) ; } ) . then ( function ( [ cin , cout ] ) { for ( const [ d , [ P , Q , R , C ] ] of getDatasets ( cin ) ) { const result = d . filter ( elt => elt [ 1 ] <= P ) . filter ( elt => elt [ 2 ] <= Q ) . filter ( elt => elt [ 3 ] <= R ) . filter ( elt => 4 * elt [ 1 ] + 9 * elt [ 2 ] + 4 * elt [ 3 ] <= C ) . map ( elt => elt [ 0 ] ) ; if ( result . length > 0 ) { cout . write ( ` ${ result . join ( \" \\n \" ) } \\n ` ) ; } else { cout . write ( \" NA \\n \" ) ; } } } ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var N = Arr . shift ( ) - 0 ; if ( N == 0 ) break ; for ( var I = 0 ; I < N ; I ++ ) { var A = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var x1 = A [ 0 ] ; var y1 = A [ 1 ] ; var z1 = A [ 2 ] ; var w1 = A [ 3 ] ; var x2 = A [ 4 ] ; var y2 = A [ 5 ] ; var z2 = A [ 6 ] ; var w2 = A [ 7 ] ; var a = x1 * x2 ; var i = x1 * y2 ; var j = x1 * z2 ; var k = x1 * w2 ; i += y1 * x2 ; a -= y1 * y2 ; k += y1 * z2 ; j -= y1 * w2 ; j += z1 * x2 ; k -= z1 * y2 ; a -= z1 * z2 ; i += z1 * w2 ; k += w1 * x2 ; j += w1 * y2 ; i -= w1 * z2 ; a -= w1 * w2 ; console . log ( a + \" \" + i + \" \" + j + \" \" + k ) ; } }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . replace ( / \\n$ / , \" \" ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var str = \" \" ; for ( var i = 0 ; i < n ; i ++ ) str += Arr . shift ( ) + \" \" ; var arr = ( str . trim ( ) ) . split ( \" \" ) ; var s = Arr . shift ( ) ; var f = arr . filter ( function ( v ) { return v [ 0 ] == s ; } ) ; f . sort ( ) ; var F = [ ] ; var memo = \" \" ; for ( var i = 0 ; i < f . length ; i ++ ) { if ( memo == f [ i ] ) { F [ F . length - 1 ] = [ f [ i ] , F [ F . length - 1 ] [ 1 ] + 1 ] ; } else { F . push ( [ f [ i ] , 1 ] ) ; memo = f [ i ] ; } } F . sort ( function ( a , b ) { if ( a [ 1 ] == b [ 1 ] ) return a [ 0 ] > b [ 0 ] ; else return b [ 1 ] - a [ 1 ] ; } ) ; var ans = [ ] ; for ( var i = 0 ; i < 5 ; i ++ ) { if ( F . length > i ) ans . push ( F [ i ] [ 0 ] ) ; } console . log ( ( ans . length > 0 ) ? ans . join ( \" \" ) : \" NA \" ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var str = input . trim ( ) ; if ( str == \" 1 0 0 \" ) console . log ( \" Close \" ) ; if ( str == \" 0 1 0 \" ) console . log ( \" Close \" ) ; if ( str == \" 1 1 0 \" ) console . log ( \" Open \" ) ; if ( str == \" 0 0 1 \" ) console . log ( \" Open \" ) ; if ( str == \" 0 0 0 \" ) console . log ( \" Close \" ) ;",
    "label": 2
  },
  {
    "code": "function Main ( input ) { a = input . split ( ' \\n ' ) [ 0 ] . split ( ' ' ) . join ( ' ' ) ; console . log ( ( ( a == ' 110 ' || a == ' 001 ' ) ? ' Open ' : ' Close ' ) ) ; } Main ( require ( \" fs \" ) . readFileSync ( \" /dev/stdin \" , \" utf8 \" ) ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) ; if ( n == \" 0000 \" ) break ; if ( n == \" 1111 \" || n == \" 2222 \" || n == \" 3333 \" || n == \" 4444 \" || n == \" 5555 \" ) { console . log ( \" NA \" ) ; continue ; } if ( n == \" 6666 \" || n == \" 7777 \" || n == \" 8888 \" || n == \" 9999 \" ) { console . log ( \" NA \" ) ; continue ; } var i = 0 ; while ( true ) { if ( n == \" 6174 \" ) break ; i ++ ; var arr = n . split ( \" \" ) . map ( Number ) ; arr . sort ( function ( a , b ) { return b - a ; } ) ; var L = parseInt ( \" \" + arr [ 0 ] + arr [ 1 ] + arr [ 2 ] + arr [ 3 ] , 10 ) ; var S = parseInt ( \" \" + arr [ 3 ] + arr [ 2 ] + arr [ 1 ] + arr [ 0 ] , 10 ) ; n = ( \" 0000 \" + ( L - S ) ) . slice ( - 4 ) ; } console . log ( i ) ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var p = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var j = Arr . shift ( ) . split ( \" \" ) . map ( Number ) ; var sum = p . reduce ( function ( a , b ) { return a + b ; } ) ; j . sort ( function ( a , b ) { return b - a ; } ) ; var max = sum * n ; while ( true ) { if ( j . length == 0 ) break ; n -- ; sum += j . shift ( ) ; max = Math . max ( max , sum * n ) ; } console . log ( max ) ; }",
    "label": 2
  },
  {
    "code": "var input = ' ' ; process . stdin . resume ( ) ; process . stdin . setEncoding ( ' utf8 ' ) ; process . stdin . on ( ' data ' , function ( chunk ) { input += chunk ; } ) process . stdin . on ( ' end ' , function ( ) { main ( input . split ( ' \\n ' ) ) ; } ) ; function main ( input ) { var max , n ; var i ; while ( ( max = input . shift ( ) - 0 ) !== 0 ) { var d = [ ] ; n = input . shift ( ) - 0 ; d [ 0 ] = 0 ; d [ n + 1 ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) { d [ i ] = input . shift ( ) - 0 ; } console . log ( solve ( max , n , d ) ? ' OK ' : ' NG ' ) ; } } function makeGraph ( n ) { var i , j , g ; g = [ ] ; for ( i = 0 ; i < n ; i ++ ) { g [ i ] = [ ] ; for ( j = 0 ; j < n ; j ++ ) { g [ i ] [ j ] = i === j ? 0 : Infinity ; } } return g ; } function warshall_floyd ( d ) { var i , j , k , n = d . length ; for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = d [ i ] [ j ] > d [ i ] [ k ] + d [ k ] [ j ] ? d [ i ] [ k ] + d [ k ] [ j ] : d [ i ] [ j ] ; } } } return d ; } function solve ( max , n , d ) { var g = makeGraph ( n + 2 ) ; var i , j ; var pos ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 1 ; j <= max ; j ++ ) { pos = i + j + ( i + j < n + 1 ? d [ i + j ] : 0 ) ; pos = Math . min ( Math . max ( pos , 0 ) , n + 1 ) ; if ( pos !== i ) { g [ i ] [ pos ] = 1 ; } } } warshall_floyd ( g ) ; for ( i = 0 ; i <= n ; i ++ ) { if ( g [ 0 ] [ i ] < Infinity && g [ i ] [ n + 1 ] === Infinity ) { return false ; } } return true ; }",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; while ( true ) { var n = Arr . shift ( ) - 0 ; if ( n == 0 ) break ; var arr = ( Arr . shift ( ) ) . split ( \" \" ) . map ( Number ) ; var cnt = 0 ; while ( true ) { var flag = arr . every ( function ( v , i ) { return ( i + 1 == v ) ; } ) ; if ( flag ) break ; var L = arr . length ; arr = arr . map ( function ( v ) { return v - 1 ; } ) ; arr = arr . filter ( function ( v ) { return ( v != 0 ) ; } ) ; arr . push ( L ) ; cnt ++ ; if ( cnt == 10000 ) { cnt = - 1 ; break ; } } console . log ( cnt ) ; }",
    "label": 2
  },
  {
    "code": "\" use strict \" ; var global_context = global ? global : window ; ( function DefineUnderScore ( ) { var ArrayProto = Array . prototype ; var slice = ArrayProto . slice ; this . _ = { } ; _ . each = function ( obj , iterator , context ) { Object . keys ( obj ) . forEach ( function ( key ) { if ( iterator . call ( context , obj [ key ] , key , obj ) === true ) return true ; } ) ; } ; _ . extend = function ( obj ) { _ . each ( slice . call ( arguments , 1 ) , function ( source ) { Object . keys ( source ) . forEach ( function ( key ) { obj [ key ] = source [ key ] ; } ) ; } ) ; } ; } ) . call ( global_context ) ; function Deferred ( ) { var queue = [ ] ; var obj = { done : function ( func , context ) { if ( func instanceof Function ) queue . push ( { callback : func , context : context } ) ; return this ; } , call : function ( ) { var args = arguments ; setTimeout ( function ( ) { queue . forEach ( function ( obj ) { obj . callback . apply ( obj . context , args ) ; } ) ; } , 0 ) ; } } ; return obj ; } function RawInput ( ) { var deferred = new Deferred ( ) ; var stdin = process . stdin ; stdin . resume ( ) ; stdin . setEncoding ( ' ascii ' ) ; var buffer = ' ' ; stdin . on ( ' data ' , function ( chunk ) { buffer += chunk . toString ( ) ; } ) ; stdin . on ( ' end ' , function ( ) { deferred . call ( buffer ) ; } ) ; return deferred ; } ( function DefineSolution ( namespace ) { var Solution = function ( ) { this . input_list = [ ] ; } ; Solution . prototype = { input : function ( ) { if ( this . separator instanceof Function ) this . input_list = this . separator . call ( this , this . raw_data ) ; else this . input_list . push ( this . raw_data ) ; } , run : function ( raw_data ) { this . raw_data = raw_data ; this . input ( ) ; while ( this . has_next ( ) ) this . solve ( this . next ( ) ) . output ( ) ; } , read_line : function ( ) { return this . input_list . splice ( 0 , 1 ) [ 0 ] ; } , read_number : function ( ) { var line = this . read_line ( ) ; return parseInt ( line ) ; } , read_numbers : function ( ) { var line = this . read_line ( ) ; var terms = line . split ( ' ' ) ; return terms . map ( function ( term ) { return parseInt ( term ) ; } ) ; } , check_eof : function ( ) { return ! this . input_list . length ; } , has_next : function ( ) { return ! this . check_eof ( ) ; } } ; this [ namespace ] = Solution ; } ) . call ( global_context , ' Solution ' ) ; ( function ExtendSolution ( namespace ) { var NONE = - 1 ; var n , A ; function check_goal ( ) { for ( var i = 0 ; i < n ; ++ i ) { if ( i + 1 !== A [ i ] ) return false ; } return true ; } function move ( ) { A = A . map ( function ( a ) { return a - 1 ; } ) . filter ( function ( a ) { return a > 0 ; } ) ; A . push ( n ) ; n = A . length ; } _ . extend ( Solution . prototype , { separator : function ( data ) { var res = data . split ( ' \\n ' ) ; return res ; } , check_eof : function ( ) { return parseInt ( this . input_list [ 0 ] ) === 0 ; } , next : function ( ) { var n = this . read_number ( ) ; var A = this . read_numbers ( ) ; return { n : n , A : A } ; } , solve : function ( options ) { n = options . n ; A = options . A ; for ( var i = 0 ; i < 10000 ; ++ i ) { if ( check_goal ( ) ) { this . result = i ; return this ; } move ( ) ; } this . result = NONE ; return this ; } , output : function ( ) { console . log ( this . result ) ; } } ) ; } ) ( ) ; var solution = new Solution ; RawInput . call ( global_context ) . done ( solution . run , solution ) ;",
    "label": 2
  },
  {
    "code": "var input = require ( ' fs ' ) . readFileSync ( ' /dev/stdin ' , ' utf8 ' ) ; var Arr = ( input . trim ( ) ) . split ( \" \\n \" ) ; for ( var i = 0 ; i < 7 ; i ++ ) { var arr = Arr [ i ] . split ( \" \" ) . map ( Number ) ; console . log ( arr [ 0 ] - arr [ 1 ] ) ; }",
    "label": 2
  },
  {
    "code": "<?php $ t = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ t [ $ i ] ) ; } rsort ( $ t ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ t [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ hills = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ hills [ ] = intval ( fgets ( STDIN ) ) ; } rsort ( $ hills ) ; echo $ hills [ 0 ] . \" \\n \" ; echo $ hills [ 1 ] . \" \\n \" ; echo $ hills [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , ' %d ' , $ n ) ; $ arr [ ] = $ n ; } rsort ( $ arr ) ; printf ( \" %d \\n %d \\n %d \\n \" , $ arr [ 0 ] , $ arr [ 1 ] , $ arr [ 2 ] ) ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ var [ ] ) ; } rsort ( $ var ) ; print $ var [ 0 ] . \" \\n \" ; print $ var [ 1 ] . \" \\n \" ; print $ var [ 2 ] . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ data = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ data [ $ i ] = readline ( ) ; } rsort ( $ data ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ data [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ inputs = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ inputs [ ] = trim ( fgets ( STDIN ) ) ; } sort ( $ inputs ) ; echo ( \" { $ inputs [ 9 ] } \\n { $ inputs [ 8 ] } \\n { $ inputs [ 7 ] } \\n \" ) ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ row [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ row ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { if ( $ i < 2 ) { echo $ row [ $ i ] . \" \\n \" ; } else { echo $ row [ $ i ] ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( $ input = trim ( fgets ( STDIN ) ) ) { $ mount [ ] = $ input ; } rsort ( $ mount ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ mount [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ num [ ] = $ line ; } sort ( $ num , SORT_NUMERIC ) ; $ num = array_reverse ( $ num ) ; foreach ( range ( 1 , 3 ) as $ ele ) { echo array_shift ( $ num ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { fscanf ( STDIN , \" %d \" , $ a ) ; if ( feof ( STDIN ) ) break ; $ c [ ] = $ a ; } rsort ( $ c , SORT_NUMERIC ) ; foreach ( array_slice ( $ c , 0 , 3 ) as $ d ) { echo $ d , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = array ( ) ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ n [ ] = intval ( $ line ) ; } rsort ( $ n ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ n [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ data = [ ] ; $ input = trim ( fgets ( STDIN ) ) ; do { $ data [ ] = $ input ; $ input = trim ( fgets ( STDIN ) ) ; } while ( $ input !== \" \" ) ; rsort ( $ data ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo \" $ { data [ $ i ] } \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ a1 = 0 ; $ a2 = 0 ; $ a3 = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \\n \" , $ x ) ; if ( $ x > $ a3 ) { $ a3 = $ x ; } if ( $ x > $ a2 ) { $ a3 = $ a2 ; $ a2 = $ x ; } if ( $ x > $ a1 ) { $ a2 = $ a1 ; $ a1 = $ x ; } } printf ( \" %d \\n %d \\n %d \\n \" , $ a1 , $ a2 , $ a3 ) ;",
    "label": 3
  },
  {
    "code": "<?php $ a1 = 0 ; $ a2 = 0 ; $ a3 = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ x ) ; if ( $ x > $ a3 ) { $ a3 = $ x ; } if ( $ x > $ a2 ) { $ a3 = $ a2 ; $ a2 = $ x ; } if ( $ x > $ a1 ) { $ a2 = $ a1 ; $ a1 = $ x ; } } printf ( \" %d \\n %d \\n %d \\n \" , $ a1 , $ a2 , $ a3 ) ;",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ arr [ $ i ] ) ; } rsort ( $ arr ) ; $ count = 0 ; foreach ( $ arr as $ row ) { echo $ row . \" \\n \" ; $ count ++ ; if ( $ count >= 3 ) { break ; } }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ h [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ h ) ; echo $ h [ 0 ] . \" \\n \" . $ h [ 1 ] . \" \\n \" . $ h [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php const MAX = 10 ; const ANS = 3 ; $ mt = array ( ) ; for ( $ i = 0 ; $ i < MAX ; $ i ++ ) { $ mt [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ mt ) ; for ( $ i = 0 ; $ i < ANS ; $ i ++ ) { echo $ mt [ $ i ] , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ mountains [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ mountains ) ; for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { echo $ mountains [ $ j ] , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ mountains = array_fill ( 0 , 10 , 0 ) ; $ cnt = 0 ; while ( list ( $ a ) = fscanf ( STDIN , \" %d \" ) ) { $ mountains [ $ cnt ] = $ a ; ++ $ cnt ; } rsort ( $ mountains ) ; echo $ mountains [ 0 ] , PHP_EOL ; echo $ mountains [ 1 ] , PHP_EOL ; echo $ mountains [ 2 ] , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ t1 = 0 ; $ t2 = 0 ; $ t3 = 0 ; while ( $ i = ( int ) fgets ( STDIN ) ) { if ( $ i > $ t3 ) { if ( $ i > $ t2 ) { if ( $ i > $ t1 ) { $ t3 = $ t2 ; $ t2 = $ t1 ; $ t1 = $ i ; } else { $ t3 = $ t2 ; $ t2 = $ i ; } } else { $ t3 = $ i ; } } } echo $ t1 . \" \\n \" ; echo $ t2 . \" \\n \" ; echo $ t3 . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t1 = 0 ; $ t2 = 0 ; $ t3 = 0 ; while ( $ i = ( int ) fgets ( STDIN ) ) { if ( $ i > $ t3 ) { if ( $ i > $ t2 ) { if ( $ i > $ t1 ) { $ t3 = $ t2 ; $ t2 = $ t1 ; $ t1 = $ i ; } else { $ t3 = $ t2 ; $ t2 = $ i ; } } else { $ t3 = $ i ; } } } echo $ t1 . \" \\n \" ; echo $ t2 . \" \\n \" ; echo $ t3 . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t1 = 0 ; $ t2 = 0 ; $ t3 = 0 ; while ( $ i = ( int ) fgets ( STDIN ) ) { if ( $ i > $ t3 ) { if ( $ i > $ t2 ) { if ( $ i > $ t1 ) { $ t3 = $ t2 ; $ t2 = $ t1 ; $ t1 = $ i ; } else { $ t3 = $ t2 ; $ t2 = $ i ; } } else { $ t3 = $ i ; } } } echo $ t1 . \" \\n \" . $ t2 . \" \\n \" . $ t3 . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ j = ( int ) fgets ( STDIN ) ; if ( $ j > $ t [ 2 ] ) { if ( $ j > $ t [ 1 ] ) { if ( $ j > $ t [ 0 ] ) { $ t [ 2 ] = $ t [ 1 ] ; $ t [ 1 ] = $ t [ 0 ] ; $ t [ 0 ] = $ j ; } else { $ t [ 2 ] = $ t [ 1 ] ; $ t [ 1 ] = $ j ; } } else { $ t [ 2 ] = $ j ; } } } echo $ t [ 0 ] . \" \\n \" . $ t [ 1 ] . \" \\n \" . $ t [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ t [ $ i ] = ( int ) fgets ( STDIN ) ; rsort ( $ t ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) echo $ t [ $ i ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ t [ $ i ] = ( int ) fgets ( STDIN ) ; rsort ( $ t ) ; echo $ t [ 0 ] . \" \\n \" . $ t [ 1 ] . \" \\n \" . $ t [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t = array_map ( function ( $ n ) { return ( int ) fgets ( STDIN ) ; } , array_fill ( 0 , 10 , 0 ) ) ; rsort ( $ t ) ; echo $ t [ 0 ] . \" \\n \" . $ t [ 1 ] . \" \\n \" . $ t [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ t = array_map ( function ( $ n ) { return ( int ) fgets ( STDIN ) ; } , array_fill ( 0 , 10 , 0 ) ) ; rsort ( $ t ) ; echo $ t [ 0 ] . \" \\n \" . $ t [ 1 ] . \" \\n \" . $ t [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ heights = array ( ) ; while ( $ line = fgets ( STDIN ) ) { rtrim ( $ line , \" \\n \" ) ; array_push ( $ heights , ( int ) $ line ) ; } rsort ( $ heights ) ; echo $ heights [ 0 ] . \" \\n \" ; echo $ heights [ 1 ] . \" \\n \" ; echo $ heights [ 2 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ D = [ ] ; $ D [ 0 ] = trim ( fgets ( STDIN ) ) ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { $ d = trim ( fgets ( STDIN ) ) ; if ( $ D [ 0 ] < $ d ) { $ D [ $ i ] = $ D [ 0 ] ; $ D [ 0 ] = $ d ; } else { $ D [ $ i ] = $ d ; } } for ( $ j = 1 ; $ j < 3 ; $ j ++ ) { for ( $ i = $ j + 1 ; $ i < 10 ; $ i ++ ) { if ( $ D [ $ j ] < $ D [ $ i ] ) { $ d = $ D [ $ i ] ; $ D [ $ i ] = $ D [ $ j ] ; $ D [ $ j ] = $ d ; } } } echo $ D [ 0 ] , PHP_EOL , $ D [ 1 ] , PHP_EOL , $ D [ 2 ] ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ D = [ ] ; $ D [ 0 ] = ( int ) trim ( fgets ( STDIN ) ) ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { $ d = ( int ) trim ( fgets ( STDIN ) ) ; if ( $ D [ 0 ] < $ d ) { $ D [ $ i ] = $ D [ 0 ] ; $ D [ 0 ] = $ d ; } else { $ D [ $ i ] = $ d ; } } for ( $ j = 1 ; $ j < 3 ; $ j ++ ) { for ( $ i = $ j + 1 ; $ i < 10 ; $ i ++ ) { if ( $ D [ $ j ] < $ D [ $ i ] ) { $ d = $ D [ $ i ] ; $ D [ $ i ] = $ D [ $ j ] ; $ D [ $ j ] = $ d ; } } } echo $ D [ 0 ] , PHP_EOL , $ D [ 1 ] , PHP_EOL , $ D [ 2 ] ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ r1 = ( int ) trim ( fgets ( STDIN ) ) ; $ r2 = $ r3 = 0 ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { $ d = ( int ) trim ( fgets ( STDIN ) ) ; if ( $ r1 < $ d ) { $ r3 = $ r2 ; $ r2 = $ r1 ; $ r1 = $ d ; } elseif ( $ r2 < $ d ) { $ r3 = $ r2 ; $ r2 = $ d ; } elseif ( $ r3 < $ d ) { $ r3 = $ d ; } } echo $ r1 , PHP_EOL , $ r2 , PHP_EOL , $ r3 ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ r1 = trim ( fgets ( STDIN ) ) ; $ r2 = $ r3 = 0 ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { $ d = trim ( fgets ( STDIN ) ) ; if ( $ r1 < $ d ) { $ r3 = $ r2 ; $ r2 = $ r1 ; $ r1 = $ d ; } elseif ( $ r2 < $ d ) { $ r3 = $ r2 ; $ r2 = $ d ; } elseif ( $ r3 < $ d ) { $ r3 = $ d ; } } echo $ r1 , PHP_EOL , $ r2 , PHP_EOL , $ r3 ; ?>",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ l = fscanf ( STDIN , \" %d \" , $ data [ $ i ] ) ; } rsort ( $ data ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { print $ data [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ data [ $ i ] ) ; } rsort ( $ data ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ data [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ x [ $ i ] ) ; } rsort ( $ x ) ; for ( $ r = 0 ; $ r < 3 ; $ r ++ ) { echo $ x [ $ r ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ count = 0 ; $ mountList = array ( ) ; while ( $ count < 10 ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( 0 <= $ stdin && $ stdin <= 10000 ) { $ mountList [ ] = $ stdin ; $ count ++ ; } } rsort ( $ mountList ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ mountList [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ count = 0 ; $ mountList = array ( ) ; while ( $ count < 10 ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( 0 <= $ stdin && $ stdin <= 10000 ) { $ mountList [ ] = $ stdin ; $ count ++ ; } } for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { for ( $ j = 9 ; $ j > $ i ; $ j -- ) { if ( $ mountList [ $ j ] > $ mountList [ $ j - 1 ] ) { $ tmp = $ mountList [ $ j ] ; $ mountList [ $ j ] = $ mountList [ $ j - 1 ] ; $ mountList [ $ j - 1 ] = $ tmp ; } } } for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ mountList [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ inArray = [ ] ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ inArray [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ inArray ) ; echo $ inArray [ 0 ] . PHP_EOL ; echo $ inArray [ 1 ] . PHP_EOL ; echo $ inArray [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ math_ary = array ( ) ; $ tmp ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ math_ary [ ] = $ line ; } for ( $ i = 0 ; $ i < count ( $ math_ary ) - 1 ; $ i ++ ) { for ( $ j = $ i ; $ j < count ( $ math_ary ) ; $ j ++ ) { if ( $ math_ary [ $ i ] < $ math_ary [ $ j ] ) { $ tmp = $ math_ary [ $ i ] ; $ math_ary [ $ i ] = $ math_ary [ $ j ] ; $ math_ary [ $ j ] = $ tmp ; } } } for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ math_ary [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ input = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ input [ ] = ( int ) fgets ( STDIN ) ; } rsort ( $ input ) ; echo $ input [ 0 ] . PHP_EOL ; echo $ input [ 1 ] . PHP_EOL ; echo $ input [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ heights = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ heights [ ] = ( int ) fgets ( STDIN ) ; } rsort ( $ heights ) ; echo $ heights [ 0 ] . PHP_EOL ; echo $ heights [ 1 ] . PHP_EOL ; echo $ heights [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ top3 = array ( ) ; $ top3 = array_pad ( $ top3 , 3 , 0 ) ; $ heights = array ( ) ; $ result = array ( ) ; $ fp = fopen ( ' php: while (feof($fp) == false) { $line = (int)fgets($fp); array_push($heights, $line); } fclose($fp); for ($i=0; $i<count($heights); $i++) { if ($top3[min_index()] < $heights[$i]) { $top3[min_index()] = $heights[$i]; } } for ($i=0; $i<3; $i++) { $result[2-$i] = $top3[min_index()]; $top3[min_index()] = 10001; } for ($i=0; $i<3; $i++) { echo $result[$i].\"\\n\"; } function min_index() { global $top3; $min_value = 10001; $min_index = 0; for ($i=0; $i<count($top3); $i++) { if ($top3[$i] < $min_value) { $min_value = $top3[$i]; $min_index = $i; } } return $min_index; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) fscanf ( STDIN , \" %d \" , $ ar [ ] ) ; $ a = 0 ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ ar [ $ i ] > $ a ) { $ c = $ b ; $ b = $ a ; $ a = $ ar [ $ i ] ; } else if ( $ ar [ $ i ] > $ b ) { $ c = $ b ; $ b = $ ar [ $ i ] ; } else if ( $ ar [ $ i ] > $ c ) { $ c = $ ar [ $ i ] ; } } print \" $ a \\n $ b \\n $ c \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ hs = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ hs [ ] ) ; } rsort ( $ hs ) ; echo ( string ) $ hs [ 0 ] . PHP_EOL ; echo ( string ) $ hs [ 1 ] . PHP_EOL ; echo ( string ) $ hs [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ hs = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ hs [ ] ) ; } rsort ( $ hs ) ; echo ( string ) $ hs [ 0 ] . PHP_EOL ; echo ( string ) $ hs [ 1 ] . PHP_EOL ; echo ( string ) $ hs [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ hs = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ hs [ ] ) ; } rsort ( $ hs ) ; echo ( string ) $ hs [ 0 ] . PHP_EOL ; echo ( string ) $ hs [ 1 ] . PHP_EOL ; echo ( string ) $ hs [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , ' %d ' , $ a [ ] ) ; } rsort ( $ a ) ; echo $ a [ 0 ] . PHP_EOL ; echo $ a [ 1 ] . PHP_EOL ; echo $ a [ 2 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) fscanf ( STDIN , \" %d \" , $ a [ $ i ] ) ; rsort ( $ a ) ; echo $ a [ 0 ] , \" \\n \" , $ a [ 1 ] , \" \\n \" , $ a [ 2 ] , \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: $top1=0; $top2=0; $top3=0; for($i=1; $i<=10; ++$i){ $stdin = trim(fgets($file_handle)); if ( $top1===0 || $top1 < $stdin ) { $temp1 = $top1; $top1 = $stdin; $temp2 = $top2; $top2 = $temp1; $top3 = $temp2; } else if ( $top2===0 || $top2 < $stdin ) { $temp2 = $top2; $top2 = $stdin; $top3 = $temp2; } else if ( $top3===0 || $top3 < $stdin ) { $top3 = $stdin; } } echo $top1.PHP_EOL; echo $top2.PHP_EOL; echo $top3.PHP_EOL;",
    "label": 3
  },
  {
    "code": "<?php $ data = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ data [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ data ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ data [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ rank1 = $ rank2 = $ rank3 = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ line = readline ( ) ; readline_add_history ( $ line ) ; $ x = intval ( $ line ) ; if ( $ x > $ rank1 ) { $ rank3 = $ rank2 ; $ rank2 = $ rank1 ; $ rank1 = $ x ; } else if ( $ x > $ rank2 ) { $ rank3 = $ rank2 ; $ rank2 = $ x ; } else if ( $ x > $ rank3 ) { $ rank3 = $ x ; } } echo \" { $ rank1 } \\n { $ rank2 } \\n { $ rank3 } \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ hi = fopen ( ' php: $ho = fopen( ' php : #  $arr = array(); #  for($i = 0; $i < 10; $i++) { fscanf($hi, \"%d\", $arr[]); } #  rsort($arr); #  for($i = 0; $i < 3; $i++) { fwrite($ho, sprintf(\"%d\\n\", $arr[$i])); } fclose($ho); fclose($hi);",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( \" php: $ container =array(); $ n =10; while( $ n >0){ $ h =trim(fgets( $ fp )); array_push( $ container , $ h ); $ n --; } rsort( $ container ); echo $ container [ 0 ] . \" \\ n \" ; echo $ container [ 1 ] . \" \\ n \" ; echo $ container [ 2 ] . \" \\ n \" ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ data [ $ i ] ) ; } rsort ( $ data ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { print $ data [ $ i ] . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ t = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ t [ $ i ] ) ; } rsort ( $ t ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo trim ( $ t [ $ i ] ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ mountains = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ mountains [ $ i ] ) ; } rsort ( $ mountains ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo $ mountains [ $ i ] . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ arr [ $ i ] ) ; } rsort ( $ arr ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { echo \" { $ arr [ $ i ] } \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ array = [ 10 ] ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ array [ $ i ] = trim ( fgets ( STDIN ) ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { for ( $ j = 9 ; $ j > $ i ; $ j -- ) { if ( $ array [ $ j ] > $ array [ $ j - 1 ] ) { $ temp = $ array [ $ j ] ; $ array [ $ j ] = $ array [ $ j - 1 ] ; $ array [ $ j - 1 ] = $ temp ; } } } echo $ array [ 0 ] , \" \\n \" ; echo $ array [ 1 ] , \" \\n \" ; echo $ array [ 2 ] , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ array [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ array ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) echo $ array [ $ i ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ T ) ; while ( $ T -- > 0 ) { fscanf ( STDIN , \" %d %d %d \" , $ a , $ b , $ c ) ; $ a *= $ a ; $ b *= $ b ; $ c *= $ c ; if ( $ a + $ b == $ c || $ a + $ c == $ b || $ b + $ c == $ a ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ count = intval ( fgets ( STDIN ) ) ; $ nums = array ( ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ nums [ $ i ] = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; } foreach ( $ nums as $ val ) { $ n1 = intval ( $ val [ 0 ] ) ; $ n2 = intval ( $ val [ 1 ] ) ; $ n3 = intval ( $ val [ 2 ] ) ; if ( ( $ n1 * $ n1 ) + ( $ n2 * $ n2 ) == ( $ n3 * $ n3 ) || ( $ n1 * $ n1 ) + ( $ n3 * $ n3 ) == ( $ n2 * $ n2 ) || ( $ n2 * $ n2 ) + ( $ n3 * $ n3 ) == ( $ n1 * $ n1 ) ) echo \" YES \\n \" ; else echo \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , ' %d %d %d ' , $ a , $ b , $ c ) ; $ a2 = pow ( $ a , 2 ) ; $ b2 = pow ( $ b , 2 ) ; $ c2 = pow ( $ c , 2 ) ; if ( $ a2 + $ b2 === $ c2 || $ a2 + $ c2 === $ b2 || $ b2 + $ c2 === $ a2 ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ stdin = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; sort ( $ stdin ) ; if ( $ stdin [ 0 ] * $ stdin [ 0 ] + $ stdin [ 1 ] * $ stdin [ 1 ] == $ stdin [ 2 ] * $ stdin [ 2 ] ) { echo \" YES \" . PHP_EOL ; } else { echo \" NO \" . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ inputs = array ( ) ; $ inputs [ ] = explode ( ' ' , trim ( $ line ) ) ; sort ( $ inputs [ 0 ] ) ; if ( ( $ inputs [ 0 ] [ 0 ] * $ inputs [ 0 ] [ 0 ] + $ inputs [ 0 ] [ 1 ] * $ inputs [ 0 ] [ 1 ] ) == $ inputs [ 0 ] [ 2 ] * $ inputs [ 0 ] [ 2 ] ) { echo ( \" YES \\n \" ) ; } else { echo ( \" NO \\n \" ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; rsort ( $ line ) ; if ( $ line [ 0 ] ** 2 == $ line [ 1 ] ** 2 + $ line [ 2 ] ** 2 ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ line = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ line ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ a = $ a * $ a ; $ b = $ b * $ b ; $ c = $ c * $ c ; if ( $ a + $ b == $ c || $ a + $ c == $ b || $ b + $ c == $ a ) { echo \" YES \" . \" \\n \" ; } else { echo \" NO \" . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ inputs = array ( ) ; $ inputs [ ] = explode ( ' ' , trim ( $ line ) ) ; sort ( $ inputs [ 0 ] ) ; if ( ( $ inputs [ 0 ] [ 0 ] * $ inputs [ 0 ] [ 0 ] + $ inputs [ 0 ] [ 1 ] * $ inputs [ 0 ] [ 1 ] ) == $ inputs [ 0 ] [ 2 ] * $ inputs [ 0 ] [ 2 ] ) { echo ( \" YES \\n \" ) ; } else { echo ( \" NO \\n \" ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ rest = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ rest ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ num [ ] = trim ( $ line ) ; } foreach ( $ num as $ ele2 ) { $ trinum = explode ( \" \" , $ ele2 ) ; $ maxnum = max ( $ trinum ) ; $ key = array_search ( $ maxnum , $ trinum ) ; unset ( $ trinum [ $ key ] ) ; $ sum = 0 ; if ( ! count ( $ trinum ) == 2 ) { echo \" NO \\n \" ; break ; } foreach ( $ trinum as $ ele ) { $ sum += pow ( $ ele , 2 ) ; } if ( $ sum == pow ( ( int ) $ maxnum , 2 ) ) echo \" YES \\n \" ; else echo \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ rest = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ rest ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ num [ ] = trim ( $ line ) ; } foreach ( $ num as $ ele2 ) { $ trinum = explode ( \" \" , $ ele2 ) ; $ maxnum = max ( $ trinum ) ; $ key = array_search ( $ maxnum , $ trinum ) ; unset ( $ trinum [ $ key ] ) ; $ sum = 0 ; foreach ( $ trinum as $ ele ) { $ sum += pow ( $ ele , 2 ) ; } if ( $ sum == pow ( ( int ) $ maxnum , 2 ) ) echo \" YES \\n \" ; else echo \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ rest = trim ( fgets ( STDIN ) ) ; while ( $ line = fgets ( STDIN ) ) { $ num [ ] = trim ( $ line ) ; } foreach ( $ num as $ ele2 ) { $ trinum = explode ( \" \" , $ ele2 ) ; $ maxnum = max ( $ trinum ) ; $ key = array_search ( $ maxnum , $ trinum ) ; unset ( $ trinum [ $ key ] ) ; $ sum = 0 ; foreach ( $ trinum as $ ele ) { $ sum += pow ( $ ele , 2 ) ; } if ( $ sum == pow ( ( int ) $ maxnum , 2 ) ) echo \" YES \\n \" ; else echo \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ rest = fgets ( STDIN ) ; while ( $ line = fgets ( STDIN ) ) { $ num [ ] = trim ( $ line ) ; } foreach ( $ num as $ ele2 ) { $ trinum = explode ( \" \" , $ ele2 ) ; $ maxnum = max ( $ trinum ) ; $ key = array_search ( $ maxnum , $ trinum ) ; unset ( $ trinum [ $ key ] ) ; $ sum = 0 ; foreach ( $ trinum as $ ele ) { $ sum += pow ( $ ele , 2 ) ; } if ( $ sum == pow ( ( int ) $ maxnum , 2 ) ) echo \" YES \\n \" ; else echo \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; for ( $ m = 0 ; $ m < $ n ; $ m ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ a [ 0 ] , $ a [ 1 ] , $ a [ 2 ] ) ; rsort ( $ a ) ; echo ( $ a [ 0 ] * $ a [ 0 ] ) === ( $ a [ 1 ] * $ a [ 1 ] ) + ( $ a [ 2 ] * $ a [ 2 ] ) ? \" YES \" : \" NO \" , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ input = trim ( fgets ( STDIN ) ) ; $ data = explode ( \" \" , $ input ) ; $ data = array_map ( function ( $ v ) { return $ v * $ v ; } , $ data ) ; sort ( $ data ) ; if ( ( $ data [ 0 ] + $ data [ 1 ] ) == $ data [ 2 ] ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php for ( $ n = trim ( fgets ( STDIN ) ) ; $ n -- ; ) { $ ary = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; sort ( $ ary ) ; list ( $ x , $ y , $ z ) = $ ary ; echo $ x ** 2 + $ y ** 2 - $ z ** 2 ? \" NO \" : \" YES \" , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ inputs = array ( ) ; $ inputs [ ] = explode ( ' ' , trim ( $ line ) ) ; sort ( $ inputs [ 0 ] ) ; if ( ( $ inputs [ 0 ] [ 0 ] * $ inputs [ 0 ] [ 0 ] + $ inputs [ 0 ] [ 1 ] * $ inputs [ 0 ] [ 1 ] ) == $ inputs [ 0 ] [ 2 ] * $ inputs [ 0 ] [ 2 ] ) { echo ( \" YES \\n \" ) ; } else { echo ( \" NO \\n \" ) ; } }",
    "label": 3
  },
  {
    "code": "<?php function to_i ( $ e ) { return ( int ) $ e ; } $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < ( int ) $ n ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ a = explode ( \" \" , $ line ) ; $ a = array_map ( \" to_i \" , $ a ) ; rsort ( $ a ) ; if ( $ a [ 0 ] > $ a [ 1 ] && $ a [ 0 ] > $ a [ 2 ] && $ a [ 0 ] * $ a [ 0 ] == $ a [ 1 ] * $ a [ 1 ] + $ a [ 2 ] * $ a [ 2 ] ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( ' ' , fgets ( STDIN ) ) ; $ a *= $ a ; $ b *= $ b ; $ c *= $ c ; if ( $ a + $ b == $ c ) { echo ' YES ' , PHP_EOL ; continue ; } if ( $ a + $ c == $ b ) { echo ' YES ' , PHP_EOL ; continue ; } if ( $ b + $ c == $ a ) { echo ' YES ' , PHP_EOL ; continue ; } echo ' NO ' , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ b < $ a ) { $ d = $ a ; $ a = $ b ; $ b = $ d ; } if ( $ c < $ b ) { $ d = $ b ; $ b = $ c ; $ c = $ d ; } $ a *= $ a ; $ b *= $ b ; $ c *= $ c ; echo ( $ a + $ b == $ c ) ? ' YES ' : ' NO ' , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ b < $ a ) { $ d = $ a ; $ a = $ b ; $ b = $ d ; } if ( $ c < $ b ) { $ d = $ b ; $ b = $ c ; $ c = $ d ; } $ e = $ a * $ a + $ b * $ b - $ c * $ c ; echo ( ! $ e ) ? ' YES ' : ' NO ' , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ b < $ a ) { $ d = $ a ; $ a = $ b ; $ b = $ d ; } if ( $ c < $ b ) { $ d = $ b ; $ b = $ c ; $ c = $ d ; } $ e = $ a * $ a + $ b * $ b ; $ f = $ c * $ c ; echo ( $ e == $ f ) ? ' YES ' : ' NO ' , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ count ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ a , $ b , $ c ) ; if ( $ b < $ a ) list ( $ b , $ a ) = [ $ a , $ b ] ; #a,b??????????b if( $c < $b ) list( $c, $b ) = [ $b, $c ];#a,b,c??????????c $answer = ( $a * $a + $b * $b == $c * $c ) ? 'YES' : 'NO'; printf(\"%s\\n\",$answer); }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ count ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ; rsort ( $ data ) ; $ long = $ data [ 0 ] * $ data [ 0 ] ; $ other = $ data [ 1 ] * $ data [ 1 ] + $ data [ 2 ] * $ data [ 2 ] ; if ( $ long == $ other ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %d %d %d ' , $ r [ 0 ] , $ r [ 1 ] , $ r [ 2 ] ) ; sort ( $ r ) ; if ( pow ( $ r [ 0 ] , 2 ) + pow ( $ r [ 1 ] , 2 ) === pow ( $ r [ 2 ] , 2 ) ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ lines = array ( ) ; $ ary = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ ary [ ] = $ line ; } $ maxline = $ ary [ 0 ] ; for ( $ i = 1 ; $ i <= $ maxline ; $ i ++ ) { $ lines = explode ( \" \" , $ ary [ $ i ] ) ; for ( $ j = 1 ; $ j < count ( $ lines ) ; $ j ++ ) { if ( $ lines [ 0 ] < $ lines [ $ j ] ) { $ tmp = $ lines [ 0 ] ; $ lines [ 0 ] = $ lines [ $ j ] ; $ lines [ $ j ] = $ tmp ; } } if ( $ lines [ 0 ] * $ lines [ 0 ] == $ lines [ 1 ] * $ lines [ 1 ] + $ lines [ 2 ] * $ lines [ 2 ] ) { echo \" YES \\n \" ; } else { echo \" NO \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( ' php: $num = 1; $first = true; while (feof($fp) == false) { $line = fgets($fp); if ($first == true) { $first = false; continue; } if ($line == \"\") break; $nums = explode( ' ' , $ line ) ; $ nums [ 2 ] = trim ( $ nums [ 2 ] ) ; $ max_num = max ( $ nums ) ; $ sum = 0 ; $ igindex = array_search ( $ max_num , $ nums ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { if ( $ igindex == $ i ) { continue ; } $ sum += pow ( $ nums [ $ i ] , 2 ) ; } if ( pow ( $ max_num , 2 ) == $ sum ) { echo \" YES \" . PHP_EOL ; } else { echo \" NO \" . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ es = fscanf ( STDIN , \" %d %d %d \" ) ; sort ( $ es ) ; $ isRight = $ es [ 0 ] * $ es [ 0 ] + $ es [ 1 ] * $ es [ 1 ] === $ es [ 2 ] * $ es [ 2 ] ; echo $ isRight ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ a = fscanf ( STDIN , ' %d %d %d ' ) ; sort ( $ a ) ; echo ( $ a [ 0 ] * $ a [ 0 ] + $ a [ 1 ] * $ a [ 1 ] ) === $ a [ 2 ] * $ a [ 2 ] ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d = array ( ) ; fscanf ( STDIN , \" %d %d %d \" , $ d [ 0 ] , $ d [ 1 ] , $ d [ 2 ] ) ; sort ( $ d ) ; list ( $ a , $ b , $ c ) = $ d ; echo $ a * $ a + $ b * $ b == $ c * $ c ? \" YES \" : \" NO \" , \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ num = fscanf ( STDIN , ' %d %d %d ' ) ; sort ( $ num ) ; if ( pow ( $ num [ 0 ] , 2 ) + pow ( $ num [ 1 ] , 2 ) === pow ( $ num [ 2 ] , 2 ) ) { echo ' YES ' ; } else { echo ' NO ' ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ numData = trim ( fgets ( STDIN ) ) ; $ count = 0 ; while ( $ count < $ numData ) { $ data = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; echo ( isRightTriangle ( $ data ) ? \" YES \" : \" NO \" ) . \" \\n \" ; $ count ++ ; } function isRightTriangle ( $ data ) { sort ( $ data ) ; list ( $ a , $ b , $ c ) = $ data ; return $ a * $ a + $ b * $ b == $ c * $ c ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ arr [ 0 ] , $ arr [ 1 ] , $ arr [ 2 ] ) ; sort ( $ arr ) ; if ( ( $ arr [ 0 ] * $ arr [ 0 ] + $ arr [ 1 ] * $ arr [ 1 ] ) == ( $ arr [ 2 ] * $ arr [ 2 ] ) ) { print \" YES \\n \" ; } else { print \" NO \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ count = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( \" \" , fgets ( STDIN ) ) ; if ( pow ( intval ( $ a ) , 2 ) + pow ( intval ( $ b ) , 2 ) === pow ( intval ( $ c ) , 2 ) || pow ( intval ( $ b ) , 2 ) + pow ( intval ( $ c ) , 2 ) === pow ( intval ( $ a ) , 2 ) || pow ( intval ( $ c ) , 2 ) + pow ( intval ( $ a ) , 2 ) === pow ( intval ( $ b ) , 2 ) ) { echo \" YES \" . PHP_EOL ; } else { echo \" NO \" . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ b , $ c ) = explode ( \" \" , fgets ( STDIN ) ) ; $ a *= $ a ; $ b *= $ b ; $ c *= $ c ; echo ( $ a + $ b === $ c | $ a + $ c === $ b | $ b + $ c === $ a ) ? \" YES \\n \" : \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ num = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ num ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ date [ 0 ] , $ date [ 1 ] , $ date [ 2 ] ) ; sort ( $ date ) ; $ slop = sqrt ( ( $ date [ 0 ] ** 2 + $ date [ 1 ] ** 2 ) ) ; if ( $ slop == $ date [ 2 ] ) echo \" YES \" . \" \\n \" ; else echo \" NO \" . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %f %f %f %f %f %f \" , $ a , $ b , $ p , $ c , $ d , $ q ) ) { $ tmp = $ a * $ d - $ b * $ c ; $ x = ( $ d * $ p - $ b * $ q ) / $ tmp ; $ y = ( $ a * $ q - $ c * $ p ) / $ tmp ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %lf %lf %lf %lf %lf %lf \" , $ a , $ b , $ c , $ d , $ e , $ f ) ) { $ x = ( $ c * $ e - $ b * $ f ) / ( $ a * $ e - $ b * $ d ) ; $ y = ( $ c * $ d - $ a * $ f ) / ( $ b * $ d - $ a * $ e ) ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %f %f %f %f %f %f ' , $ a , $ b , $ c , $ d , $ e , $ f ) ; $ arr = array ( array ( $ a , $ b , $ c ) , array ( $ d , $ e , $ f ) ) ; for ( $ i = 0 ; $ i < 2 ; $ i ++ ) { $ n = $ arr [ $ i ] [ $ i ] ; foreach ( $ arr [ $ i ] as $ j => $ m ) { $ arr [ $ i ] [ $ j ] /= $ n ; } for ( $ j = 0 ; $ j < 2 ; $ j ++ ) { if ( $ i === $ j ) { continue ; } $ m = $ arr [ $ j ] [ $ i ] ; foreach ( $ arr [ $ j ] as $ k => $ l ) { $ arr [ $ j ] [ $ k ] -= $ arr [ $ i ] [ $ k ] * $ m ; } } } $ c = round ( $ arr [ 0 ] [ 2 ] * 1000 ) / 1000 ; $ f = round ( $ arr [ 1 ] [ 2 ] * 1000 ) / 1000 ; printf ( \" %.3f %.3f \\n \" , $ c , $ f ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ result_x = array ( ) ; $ result_y = array ( ) ; $ num = 0 ; while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin == ' ' ) { for ( $ i = 0 ; $ i < $ num ; $ i ++ ) { echo number_format ( $ result_x [ $ i ] , 3 ) . ' ' . number_format ( $ result_y [ $ i ] , 3 ) . \" \\n \" ; } return ; } $ input = explode ( ' ' , $ stdin ) ; $ a = intval ( $ input [ 0 ] ) ; $ b = intval ( $ input [ 1 ] ) ; $ c = intval ( $ input [ 2 ] ) ; $ d = intval ( $ input [ 3 ] ) ; $ e = intval ( $ input [ 4 ] ) ; $ f = intval ( $ input [ 5 ] ) ; $ result_x [ ] = ( $ c * $ e - $ f * $ b ) / ( $ a * $ e - $ d * $ b ) ; $ result_y [ ] = ( $ a * $ f - $ d * $ c ) / ( $ a * $ e - $ d * $ b ) ; $ num ++ ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ input = trim ( fgets ( STDIN ) ) ) { list ( $ a , $ b , $ c , $ d , $ e , $ f ) = explode ( \" \" , $ input ) ; $ x = ( $ b * $ f - $ c * $ e ) / ( $ b * $ d - $ a * $ e ) ; $ y = ( $ a * $ f - $ c * $ d ) / ( $ a * $ e - $ b * $ d ) ; echo number_format ( $ x , 3 ) . \" \" . number_format ( $ y , 3 ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ abcdef = explode ( \" \" , $ line ) ; $ x = ( double ) ( $ abcdef [ 2 ] * $ abcdef [ 4 ] - $ abcdef [ 1 ] * $ abcdef [ 5 ] ) / ( double ) ( $ abcdef [ 0 ] * $ abcdef [ 4 ] - $ abcdef [ 3 ] * $ abcdef [ 1 ] ) ; $ y = ( double ) ( $ abcdef [ 0 ] * $ abcdef [ 5 ] - $ abcdef [ 2 ] * $ abcdef [ 3 ] ) / ( double ) ( $ abcdef [ 0 ] * $ abcdef [ 4 ] - $ abcdef [ 1 ] * $ abcdef [ 3 ] ) ; echo sprintf ( \" %.3f \" , round ( $ x , 3 ) ) . \" \" ; echo sprintf ( \" %.3f \" , round ( $ y , 3 ) ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function x ( $ a , $ b , $ c , $ y ) { return ( $ c - ( $ b * $ y ) ) / $ a ; } function y ( $ a , $ b , $ c , $ d , $ e , $ f ) { return ( ( $ c * $ d ) - ( $ a * $ f ) ) / ( ( $ b * $ d ) - ( $ a * $ e ) ) ; } for ( ; fscanf ( STDIN , \" %d %d %d %d %d %d \" , $ a , $ b , $ c , $ d , $ e , $ f ) ; ) { $ y = y ( $ a , $ b , $ c , $ d , $ e , $ f ) ; $ x = x ( $ a , $ b , $ c , $ y ) ; printf ( \" %.03f %.03f \" . PHP_EOL , $ x , $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ fp = STDIN ; while ( ( $ input = fgets ( $ fp ) ) !== false ) { list ( $ a , $ b , $ c , $ d , $ e , $ f ) = explode ( ' ' , trim ( $ input ) ) ; $ x = ( $ e * $ c - $ b * $ f ) / ( $ a * $ e - $ b * $ d ) ; $ y = ( $ a * $ f - $ d * $ c ) / ( $ a * $ e - $ b * $ d ) ; $ roundedX = round ( $ x , 3 ) ; $ roundedY = round ( $ y , 3 ) ; printf ( \" %.3f %.3f \\n \" , $ roundedX , $ roundedY ) ; }",
    "label": 3
  },
  {
    "code": "<?php function to_f ( $ e ) { return ( float ) $ e ; } while ( $ line = fgets ( STDIN ) ) { $ a = explode ( \" \" , $ line ) ; $ a = array_map ( \" to_f \" , $ a ) ; $ x = ( $ a [ 2 ] * $ a [ 4 ] - $ a [ 1 ] * $ a [ 5 ] ) / ( $ a [ 0 ] * $ a [ 4 ] - $ a [ 3 ] * $ a [ 1 ] ) ; $ y = ( $ a [ 2 ] * $ a [ 3 ] - $ a [ 0 ] * $ a [ 5 ] ) / ( $ a [ 1 ] * $ a [ 3 ] - $ a [ 0 ] * $ a [ 4 ] ) ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %f %f %f %f %f %f \" , $ a , $ b , $ c , $ d , $ e , $ f ) ) { $ x = ( $ e * $ c - $ b * $ f ) / ( $ e * $ a - $ b * $ d ) ; $ y = ( $ d * $ c - $ a * $ f ) / ( $ d * $ b - $ a * $ e ) ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d %d %d %d \" , $ a , $ b , $ c , $ d , $ e , $ f ) ) { $ x = ( $ b * $ f - $ c * $ e ) / ( $ b * $ d - $ a * $ e ) ; $ y = ( $ c - $ a * $ x ) / $ b ; echo sprintf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( ' php: while (feof($fp) == false) { $line = fgets($fp); if ($line == \"\") break; $n = explode( ' ' , $ line ) ; $ x = ( $ n [ 2 ] * $ n [ 4 ] - $ n [ 1 ] * $ n [ 5 ] ) / ( $ n [ 0 ] * $ n [ 4 ] - $ n [ 1 ] * $ n [ 3 ] ) ; $ y = ( $ n [ 0 ] * $ n [ 5 ] - $ n [ 2 ] * $ n [ 3 ] ) / ( $ n [ 0 ] * $ n [ 4 ] - $ n [ 1 ] * $ n [ 3 ] ) ; echo number_format ( $ x , 3 ) . \" \" . number_format ( $ y , 3 ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { fscanf ( STDIN , \" %f %f %f %f %f %f \" , $ a , $ b , $ c , $ d , $ e , $ f ) ; if ( feof ( STDIN ) ) { break ; } $ matrix = array ( array ( $ a , $ b , $ c ) , array ( $ d , $ e , $ f ) ) ; $ a = solve ( $ matrix ) ; echo sprintf ( ' %.3f %.3f ' , round ( $ a [ 0 ] [ 2 ] , 3 ) , round ( $ a [ 1 ] [ 2 ] , 3 ) ) ; echo PHP_EOL ; } function solve ( $ matrix ) { $ div = $ matrix [ 0 ] [ 0 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ matrix [ 0 ] [ $ i ] /= $ div ; } $ times = $ matrix [ 1 ] [ 0 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ matrix [ 1 ] [ $ i ] -= $ times * $ matrix [ 0 ] [ $ i ] ; } $ rev = 1 / $ matrix [ 1 ] [ 1 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ matrix [ 1 ] [ $ i ] *= $ rev ; } $ times = $ matrix [ 0 ] [ 1 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ matrix [ 0 ] [ $ i ] -= $ times * $ matrix [ 1 ] [ $ i ] ; } return $ matrix ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ a = array ( ) ; $ b = array ( ) ; fscanf ( STDIN , ' %f %f %f %f %f %f ' , $ a [ ] , $ a [ ] , $ a [ ] , $ b [ ] , $ b [ ] , $ b [ ] ) ; if ( feof ( STDIN ) ) { break ; } if ( $ a [ 0 ] === 0.0 ) { $ tmp = $ a ; $ a = $ b ; $ b = $ tmp ; } $ div = $ a [ 0 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ a [ $ i ] /= $ div ; } $ t = $ b [ 0 ] / $ a [ 0 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ b [ $ i ] -= $ a [ $ i ] * $ t ; } $ div = $ b [ 1 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ b [ $ i ] /= $ div ; } $ t = $ a [ 1 ] / $ b [ 1 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ a [ $ i ] -= $ b [ $ i ] * $ t ; } echo sprintf ( ' %.3f %.3f ' , round ( $ a [ 2 ] , 4 ) , round ( $ b [ 2 ] , 4 ) ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d %d %d %d \" , $ a , $ b , $ c , $ d , $ e , $ f ) ) { $ x = ( $ e * $ c - $ b * $ f ) / ( $ a * $ e - $ b * $ d ) ; $ y = ( - $ d * $ c + $ a * $ f ) / ( $ a * $ e - $ b * $ d ) ; if ( $ x == 0 ) $ x = 0 ; if ( $ y == 0 ) $ y = 0 ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ count = 2 ; $ value = array ( ) ; while ( 1 ) { $ res = fscanf ( STDIN , ' %d %d %d %d %d %d ' , $ a , $ b , $ c , $ d , $ e , $ f ) ; if ( $ res == 0 ) break ; $ value [ 0 ] [ 0 ] = $ a ; $ value [ 0 ] [ 1 ] = $ b ; $ value [ 0 ] [ 2 ] = $ c ; $ value [ 1 ] [ 0 ] = $ d ; $ value [ 1 ] [ 1 ] = $ e ; $ value [ 1 ] [ 2 ] = $ f ; if ( $ a === 0 && $ e === 0 ) { $ y = $ c / $ b ; $ x = $ f / $ d ; $ x = round ( $ x , 3 ) ; $ y = round ( $ y , 3 ) ; $ x = sprintf ( ' %.3f ' , $ x ) ; $ y = sprintf ( ' %.3f ' , $ y ) ; echo $ x . ' ' . $ y . PHP_EOL ; continue ; } else if ( $ a === 0 || $ e === 0 ) { $ value [ 0 ] [ 0 ] = $ d ; $ value [ 0 ] [ 1 ] = $ e ; $ value [ 0 ] [ 2 ] = $ f ; $ value [ 1 ] [ 0 ] = $ a ; $ value [ 1 ] [ 1 ] = $ b ; $ value [ 1 ] [ 2 ] = $ c ; } for ( $ i = 0 ; $ i < $ count ; ++ $ i ) { $ a = $ value [ $ i ] [ $ i ] ; for ( $ j = $ i ; $ j <= $ count ; ++ $ j ) { $ value [ $ i ] [ $ j ] = $ value [ $ i ] [ $ j ] / $ a ; } for ( $ j = 0 ; $ j < $ count ; ++ $ j ) { if ( $ j === $ i ) continue ; $ tmp = $ value [ $ j ] [ $ i ] ; for ( $ k = 0 ; $ k <= $ count ; ++ $ k ) { $ value [ $ j ] [ $ k ] = $ value [ $ j ] [ $ k ] - $ tmp * $ value [ $ i ] [ $ k ] ; } } } $ x = $ value [ 0 ] [ 2 ] ; $ y = $ value [ 1 ] [ 2 ] ; $ x = round ( $ x , 3 ) ; $ y = round ( $ y , 3 ) ; $ x = sprintf ( ' %.3f ' , $ x ) ; $ y = sprintf ( ' %.3f ' , $ y ) ; echo $ x . ' ' . $ y . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ count = 2 ; $ value = array ( ) ; while ( 1 ) { $ res = fscanf ( STDIN , ' %d %d %d %d %d %d ' , $ a , $ b , $ c , $ d , $ e , $ f ) ; if ( $ res == 0 ) break ; $ value [ 0 ] [ 0 ] = $ a ; $ value [ 0 ] [ 1 ] = $ b ; $ value [ 0 ] [ 2 ] = $ c ; $ value [ 1 ] [ 0 ] = $ d ; $ value [ 1 ] [ 1 ] = $ e ; $ value [ 1 ] [ 2 ] = $ f ; if ( $ a === 0 || $ e === 0 ) { $ value [ 0 ] [ 0 ] = $ d ; $ value [ 0 ] [ 1 ] = $ e ; $ value [ 0 ] [ 2 ] = $ f ; $ value [ 1 ] [ 0 ] = $ a ; $ value [ 1 ] [ 1 ] = $ b ; $ value [ 1 ] [ 2 ] = $ c ; } for ( $ i = 0 ; $ i < $ count ; ++ $ i ) { $ a = $ value [ $ i ] [ $ i ] ; for ( $ j = $ i ; $ j <= $ count ; ++ $ j ) { $ value [ $ i ] [ $ j ] = $ value [ $ i ] [ $ j ] / $ a ; } for ( $ j = 0 ; $ j < $ count ; ++ $ j ) { if ( $ j === $ i ) continue ; $ tmp = $ value [ $ j ] [ $ i ] ; for ( $ k = 0 ; $ k <= $ count ; ++ $ k ) { $ value [ $ j ] [ $ k ] = $ value [ $ j ] [ $ k ] - $ tmp * $ value [ $ i ] [ $ k ] ; } } } $ x = $ value [ 0 ] [ 2 ] ; $ y = $ value [ 1 ] [ 2 ] ; $ x = round ( $ x , 3 ) ; $ y = round ( $ y , 3 ) ; $ x = sprintf ( ' %.3f ' , $ x ) ; $ y = sprintf ( ' %.3f ' , $ y ) ; echo $ x . ' ' . $ y . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ count = 2 ; $ value = array ( ) ; while ( 1 ) { $ res = fscanf ( STDIN , ' %d %d %d %d %d %d ' , $ a , $ b , $ c , $ d , $ e , $ f ) ; if ( $ res == 0 ) break ; $ value [ 0 ] [ 0 ] = $ a ; $ value [ 0 ] [ 1 ] = $ b ; $ value [ 0 ] [ 2 ] = $ c ; $ value [ 1 ] [ 0 ] = $ d ; $ value [ 1 ] [ 1 ] = $ e ; $ value [ 1 ] [ 2 ] = $ f ; for ( $ i = 0 ; $ i < $ count ; ++ $ i ) { $ a = $ value [ $ i ] [ $ i ] ; for ( $ j = $ i ; $ j <= $ count ; ++ $ j ) { $ value [ $ i ] [ $ j ] = $ value [ $ i ] [ $ j ] / $ a ; } for ( $ j = 0 ; $ j < $ count ; ++ $ j ) { if ( $ j === $ i ) continue ; $ tmp = $ value [ $ j ] [ $ i ] ; for ( $ k = 0 ; $ k <= $ count ; ++ $ k ) { $ value [ $ j ] [ $ k ] = $ value [ $ j ] [ $ k ] - $ tmp * $ value [ $ i ] [ $ k ] ; } } } $ x = $ value [ 0 ] [ 2 ] ; $ y = $ value [ 1 ] [ 2 ] ; $ x = round ( $ x , 3 ) ; $ y = round ( $ y , 3 ) ; $ x = sprintf ( ' %.3f ' , $ x ) ; $ y = sprintf ( ' %.3f ' , $ y ) ; echo $ x . ' ' . $ y . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php main ( ) ; function main ( ) { while ( true ) { $ input = getInput ( ) ; if ( empty ( $ input ) ) { break ; } list ( $ x , $ y ) = solveArray ( $ input ) ; printSolution ( $ x , $ y ) ; } } function printSolution ( $ x , $ y ) { $ x = round ( $ x , 3 ) ; $ y = round ( $ y , 3 ) ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; } function getInput ( ) { $ line = trim ( fgets ( STDIN ) ) ; if ( empty ( $ line ) ) { return array ( ) ; } return explode ( ' ' , $ line ) ; } function solveArray ( array $ data ) { if ( count ( $ data ) != 6 ) { return null ; } return solve ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] , $ data [ 3 ] , $ data [ 4 ] , $ data [ 5 ] ) ; } function solve ( $ a , $ b , $ c , $ d , $ e , $ f ) { $ x = det2 ( $ c , $ b , $ f , $ e ) / det2 ( $ a , $ b , $ d , $ e ) ; $ y = det2 ( $ a , $ c , $ d , $ f ) / det2 ( $ a , $ b , $ d , $ e ) ; return array ( $ x , $ y ) ; } function det2 ( $ a , $ b , $ c , $ d ) { return $ a * $ d - $ b * $ c ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %lf %lf %lf %lf %lf %lf \" , $ a , $ b , $ c , $ d , $ e , $ f ) ) { $ x = ( $ c * $ e - $ b * $ f ) / ( $ a * $ e - $ b * $ d ) ; $ y = ( $ c * $ d - $ a * $ f ) / ( $ b * $ d - $ a * $ e ) ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d %d %d %d \" , $ a , $ b , $ c , $ d , $ e , $ f ) ) { $ den = $ a * $ e - $ b * $ d ; $ x = ( $ c * $ e - $ b * $ f ) / $ den ; $ y = ( $ a * $ f - $ d * $ c ) / $ den ; printf ( \" %.3f %.3f \\n \" , $ x , $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ x , $ y ) { if ( $ x < $ y ) list ( $ x , $ y ) = array ( $ y , $ x ) ; while ( true ) { if ( $ y == 0 ) { return $ x ; } $ pre_y = $ y ; $ y = $ x % $ y ; $ x = $ pre_y ; } } while ( fscanf ( STDIN , \" %d%d \" , $ a , $ b ) ) { $ g = gcd ( $ a , $ b ) ; $ l = $ a * $ b / $ g ; echo $ g . \" \" . $ l . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d %d ' , $ a , $ b ) ; printf ( \" %d %d \\n \" , gcd ( $ a , $ b ) , lcm ( $ a , $ b ) ) ; } function gcd ( $ a , $ b ) { if ( $ a < $ b ) { list ( $ a , $ b ) = array ( $ b , $ a ) ; } while ( $ b > 0 ) { list ( $ a , $ b ) = array ( $ b , $ a % $ b ) ; } return $ a ; } function lcm ( $ a , $ b ) { return $ a * $ b / gcd ( $ a , $ b ) ; }",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } while ( $ tmp = trim ( fgets ( STDIN ) ) ) { $ list = explode ( \" \" , $ tmp ) ; $ a = gcd ( $ list [ 0 ] , $ list [ 1 ] ) ; $ b = ( $ list [ 1 ] / $ a ) * $ list [ 0 ] ; echo $ a . \" \" . $ b . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ i , $ j ) { if ( $ j === 0 ) { return $ i ; } else { return gcd ( $ j , $ i % $ j ) ; } } while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { $ x = gcd ( max ( $ a , $ b ) , min ( $ a , $ b ) ) ; $ y = $ a * $ b / $ x ; echo $ x . \" \" . $ y . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ gcds = array ( ) ; $ lcms = array ( ) ; function gcd ( $ m , $ n ) { if ( $ m > $ n ) { list ( $ m , $ n ) = array ( $ n , $ m ) ; } $ gcd_a = $ m ; $ gcd_b = $ n ; while ( ( $ surplus = $ gcd_a % $ gcd_b ) !== 0 ) { $ gcd_a = $ gcd_b ; $ gcd_b = $ surplus ; } return $ gcd_b ; } function lcm ( $ m , $ n ) { return $ m * $ n / gcd ( $ m , $ n ) ; } while ( ( $ stdin = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ input = explode ( ' ' , $ stdin ) ; $ a = intval ( $ input [ 0 ] ) ; $ b = intval ( $ input [ 1 ] ) ; $ answers [ ] = gcd ( $ a , $ b ) . ' ' . lcm ( $ a , $ b ) . \" \\n \" ; } foreach ( $ answers as $ ans ) { echo $ ans ; }",
    "label": 3
  },
  {
    "code": "<?php $ gcds = array ( ) ; $ lcms = array ( ) ; function gcd ( $ a , $ b ) { if ( $ a > $ b ) { list ( $ a , $ b ) = array ( $ b , $ a ) ; } $ gcd_a = $ a ; $ gcd_b = $ b ; while ( ( $ surplus = $ gcd_a % $ gcd_b ) !== 0 ) { $ gcd_a = $ gcd_b ; $ gcd_b = $ surplus ; } return $ gcd_b ; } function lcm ( $ a , $ b ) { return $ a * $ b / gcd ( $ a , $ b ) ; } while ( ( $ stdin = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ input = explode ( ' ' , $ stdin ) ; $ a = intval ( $ input [ 0 ] ) ; $ b = intval ( $ input [ 1 ] ) ; $ answers [ ] = gcd ( $ a , $ b ) . ' ' . lcm ( $ a , $ b ) . \" \\n \" ; } foreach ( $ answers as $ ans ) { echo $ ans ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ ab = explode ( \" \" , $ line ) ; $ _1st = $ ab ; while ( ( $ amari = $ ab [ 0 ] % $ ab [ 1 ] ) != 0 ) { $ ab [ 0 ] = $ ab [ 1 ] ; $ ab [ 1 ] = $ amari ; } echo $ ab [ 1 ] . \" \" ; echo $ _1st [ 0 ] * $ _1st [ 1 ] / $ ab [ 1 ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php for ( ; fscanf ( STDIN , ' %d %d ' , $ a , $ b ) ; ) { echo gcd ( $ a , $ b ) , ' ' , lcm ( $ a , $ b ) , PHP_EOL ; } function lcm ( $ a , $ b ) { $ g = gcd ( $ a , $ b ) ; return $ g * ( $ a / $ g ) * ( $ b / $ g ) ; } function gcd ( $ a , $ b ) { while ( true ) { $ mod = $ a % $ b ; if ( $ mod === 0 ) { $ g = $ b ; break ; } $ a = $ b ; $ b = $ mod ; } return $ g ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { $ gcd = $ a > $ b ? euclid ( $ a , $ b ) : euclid ( $ b , $ a ) ; echo $ gcd , \" \" , $ a / $ gcd * $ b , PHP_EOL ; } function euclid ( $ a , $ b ) { return $ a % $ b ? euclid ( $ b , $ a % $ b ) : $ b ; }",
    "label": 3
  },
  {
    "code": "<?php function to_i ( $ e ) { return ( int ) $ e ; } function calc_gcd ( $ a , $ b ) { if ( $ b > 0 ) { return calc_gcd ( $ b , $ a % $ b ) ; } else { return $ a ; } } function calc_lcm ( $ a , $ b ) { return ( ( $ a / calc_gcd ( $ a , $ b ) ) * $ b ) ; } while ( $ f = fgets ( STDIN ) ) { $ arr = explode ( \" \" , $ f ) ; $ arr = array_map ( \" to_i \" , $ arr ) ; $ gcd = calc_gcd ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ lcm = calc_lcm ( $ arr [ 0 ] , $ arr [ 1 ] ) ; echo $ gcd . \" \" . $ lcm . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { list ( $ x , $ y ) = ( $ a > $ b ) ? [ $ a , $ b ] : [ $ b , $ a ] ; #x>y, ab????????? while( $y ) list( $x, $y ) = [ $y, $x % $y ]; #x:gcd, b:0????????????????? $gcd = $x; $lcm = $a / $gcd * $b; printf( \"%d %d\\n\", $gcd, $lcm ); }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { $ x = GCD ( $ a , $ b ) ; $ y = LCM ( $ a , $ b ) ; echo $ x . \" \" . $ y . \" \\n \" ; } function GCD ( $ m , $ n ) { while ( $ m % $ n != 0 ) { $ temp = $ n ; $ n = $ m % $ n ; $ m = $ temp ; } return $ n ; } function LCM ( $ l , $ k ) { return $ l * $ k / GCD ( $ l , $ k ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ tmp_line = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ tmp_line [ ] = $ line ; } foreach ( $ tmp_line as $ val ) { $ math = explode ( \" \" , $ val ) ; $ koyaku ; $ kobaisu ; if ( $ math [ 0 ] > $ math [ 1 ] ) { $ tmp = $ math [ 0 ] - $ math [ 1 ] ; $ tmp2 = $ math [ 1 ] ; while ( $ tmp != $ tmp2 ) { if ( $ tmp > $ tmp2 ) { $ tmp = $ tmp - $ tmp2 ; } else { $ tmp2 = $ tmp2 - $ tmp ; } } $ koyaku = $ tmp ; } else if ( $ math [ 0 ] < $ math [ 1 ] ) { $ tmp = $ math [ 1 ] - $ math [ 0 ] ; $ tmp2 = $ math [ 0 ] ; while ( $ tmp != $ tmp2 ) { if ( $ tmp > $ tmp2 ) { $ tmp = $ tmp - $ tmp2 ; } else { $ tmp2 = $ tmp2 - $ tmp ; } } $ koyaku = $ tmp ; } else { $ koyaku = $ math [ 0 ] ; } $ kobaisu = ( $ math [ 0 ] * $ math [ 1 ] ) / $ koyaku ; echo $ koyaku . \" \" . $ kobaisu . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ a , $ b ) { return $ b == 0 ? $ a : gcd ( $ b , $ a % $ b ) ; } while ( true ) { $ input = fgets ( STDIN , 255 ) ; if ( ! $ input ) break ; $ input = explode ( ' ' , $ input ) ; $ a = intVal ( $ input [ 0 ] ) ; $ b = intVal ( $ input [ 1 ] ) ; $ c = gcd ( $ a , $ b ) ; echo sprintf ( \" %d %d \\n \" , $ c , $ a * $ b / $ c ) ; } flush ( ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( ' php: while (feof($fp) == false) { $line = fgets($fp); if ($line == \"\") continue; $nums = explode( ' ' , $ line ) ; $ min_k = array_search ( min ( $ nums ) , $ nums ) ; $ max_k = $ min_k == 0 ? 1 : 0 ; for ( $ i = 1 ; $ i <= min ( $ nums ) ; $ i ++ ) { if ( $ nums [ $ min_k ] % $ i == 0 ) { if ( $ nums [ $ max_k ] % ( $ nums [ $ min_k ] / $ i ) == 0 ) { echo $ nums [ $ min_k ] / $ i . ' ' ; break ; } } } $ n = 1 ; while ( true ) { if ( ( $ nums [ $ max_k ] * $ n ) % $ nums [ $ min_k ] == 0 ) { echo $ nums [ $ max_k ] * $ n . PHP_EOL ; break ; } $ n ++ ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ; if ( feof ( STDIN ) ) { break ; } $ gcd = gcd ( $ a , $ b ) ; $ lcm = $ a * $ b / $ gcd ; echo sprintf ( ' %d %d ' , $ gcd , $ lcm ) ; echo PHP_EOL ; } function gcd ( $ a , $ b ) { while ( $ a !== $ b ) { if ( $ a > $ b ) { $ a -= $ b ; } else { $ b -= $ a ; } } return $ a ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , ' %d %d ' , $ a , $ b ) ; if ( feof ( STDIN ) ) { break ; } $ gcd = gcd ( $ a , $ b ) ; $ lcm = $ gcd * ( $ a / $ gcd ) * ( $ b / $ gcd ) ; echo \" $ gcd $ lcm \" ; echo PHP_EOL ; } function gcd ( $ a , $ b ) { while ( $ a !== $ b ) { if ( $ a > $ b ) { $ a = $ a - $ b ; } else { $ b = $ b - $ a ; } } return $ a ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { $ gcd = $ a > $ b ? gcd ( $ a , $ b ) : gcd ( $ b , $ a ) ; echo $ gcd . \" \" . $ a * $ b / $ gcd . \" \\n \" ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: while(1){ $res = fscanf($file_handle, ' % d % d ' , $ a , $ b ) ; if ( $ res == 0 ) break ; if ( $ a < $ b ) { $ tmp = $ a ; $ a = $ b ; $ b = $ tmp ; } $ da = $ a ; $ db = $ b ; while ( 1 ) { $ r = $ a % $ b ; if ( $ r == 0 ) { break ; } $ a = $ b ; $ b = $ r ; } $ gcd = $ b ; $ lcm = $ da * $ db / $ gcd ; echo $ gcd . ' ' . $ lcm . PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php while ( $ input = fgets ( STDIN ) ) { list ( $ a , $ b ) = explode ( ' ' , trim ( $ input ) ) ; $ gcd = gcd ( $ a , $ b ) ; $ lcm = $ a / $ gcd * $ b ; echo $ gcd . \" \" . $ lcm . \" \\n \" ; } function gcd ( $ m , $ n ) { while ( $ m % $ n != 0 ) { $ temp = $ n ; $ n = $ m % $ n ; $ m = $ temp ; } return $ n ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { $ gcd = _gcd ( $ a , $ b ) ; $ lcm = $ a / $ gcd * $ b ; print $ gcd . \" \" . $ lcm . \" \\n \" ; } function _gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return _gcd ( $ b , $ a % $ b ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ x , $ y ) { if ( $ y === 0 ) { return $ x ; } return gcd ( $ y , $ x % $ y ) ; } function lcm ( $ x , $ y ) { return $ x * $ y / gcd ( $ x , $ y ) ; } while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { echo gcd ( $ a , $ b ) . \" \" . lcm ( $ a , $ b ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { $ gcd = gcd ( $ a , $ b ) ; $ lcm = ( $ a * $ b ) / $ gcd ; printf ( \" %d %d \\n \" , $ gcd , $ lcm ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %s \" , $ s ) ) { echo strrev ( $ s ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %s ' , $ str ) ; for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) { echo $ str [ $ i ] ; } echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; $ str = strrev ( $ str ) ; echo $ str . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ original = trim ( fgets ( STDIN ) ) ; $ reverse = strrev ( $ original ) ; echo $ reverse . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { echo strrev ( $ line ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ a ) ; for ( $ i = ( strlen ( $ a ) - 1 ) ; $ i > - 1 ; $ i -- ) { print substr ( $ a , $ i , 1 ) ; } echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?= strrev ( trim ( fgets ( STDIN ) ) ) ?>",
    "label": 3
  },
  {
    "code": "<?php $ line = trim ( fgets ( STDIN ) ) ; echo strrev ( $ line ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ chaine = trim ( fgets ( STDIN ) ) ; $ newchaine = \" \" ; for ( $ j = strlen ( $ chaine ) ; $ j > 0 ; $ j -- ) { $ newchaine .= $ chaine [ $ j - 1 ] ; } echo $ newchaine ; ?>",
    "label": 3
  },
  {
    "code": "<?php echo strrev ( trim ( fgets ( STDIN ) ) ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ str = trim ( fgets ( STDIN ) ) ; echo strrev ( $ str ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ str = trim ( fgets ( STDIN ) ) ; echo strrev ( $ str ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ f = fgets ( STDIN ) ; $ f = rtrim ( $ f ) ; echo strrev ( $ f ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ str [ $ len - $ i - 1 ] ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; for ( $ i = strlen ( $ str ) - 1 ; 0 <= $ i ; $ i -- ) echo $ str [ $ i ] ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; $ rev = ' ' ; for ( $ i = strlen ( $ str ) - 1 ; 0 <= $ i ; $ i -- ) $ rev .= $ str [ $ i ] ; echo $ rev ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; $ len = strlen ( $ str ) ; $ last = $ len - 1 ; $ middle = $ len >> 1 ; for ( $ i = 0 ; $ i < $ middle ; $ i ++ ) { $ j = $ last - $ i ; list ( $ str [ $ j ] , $ str [ $ i ] ) = [ $ str [ $ i ] , $ str [ $ j ] ] ; } printf ( \" %s \\n \" , $ str ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; echo strrev ( $ str ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ data ) ; $ data2 = strrev ( $ data ) ; echo $ data2 . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ line = str_split ( trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < count ( $ line ) ; $ i ++ ) { echo $ line [ count ( $ line ) - 1 - $ i ] ; } echo \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( ' php: $line = trim(fgets($fp)); $chars = str_split($line, 1); for ($i=0; $i<count($chars); $i++) { echo $chars[count($chars)-1-$i]; } echo PHP_EOL;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ word ) ; $ word = str_split ( $ word ) ; $ rev = array_reverse ( $ word ) ; echo implode ( ' ' , $ rev ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %s ' , $ s ) ; $ s = str_split ( $ s ) ; $ s = array_reverse ( $ s ) ; echo implode ( ' ' , $ s ) ; echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php echo strrev ( trim ( fgets ( STDIN ) ) ) , \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ str = trim ( fgets ( STDIN ) ) ; $ rstr = ' ' ; $ strlen = strlen ( $ str ) ; for ( $ i = $ strlen - 1 ; $ i >= 0 ; $ i -- ) { $ rstr = $ rstr . $ str [ $ i ] ; } echo $ rstr . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php while ( $ input = fgets ( STDIN ) ) { echo strrev ( trim ( $ input ) ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ str ) ; $ str = strrev ( $ str ) ; print $ str . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ a = trim ( fgets ( STDIN ) ) ; $ aa = str_split ( $ a ) ; $ b = count ( $ aa ) - 1 ; for ( $ i = $ b ; $ i >= 0 ; $ i -- ) { $ d [ ] = $ aa [ $ i ] ; } $ ans = implode ( $ d ) ; echo $ ans . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php echo strrev ( trim ( fgets ( STDIN ) ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ input = trim ( fgets ( STDIN ) ) ; echo strrev ( $ input ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) ) { $ ans = 100000 ; while ( $ n -- > 0 ) { $ ans *= 1.05 ; $ rem = $ ans % 1000 ; if ( $ rem > 0 ) { $ ans = $ ans - $ rem + 1000 ; } } echo $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ debt = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ debt += $ debt * 0.05 ; $ debt = ceil ( $ debt / 1000 ) * 1000 ; } echo $ debt , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ debt = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ debt = ceil ( ( $ debt * 1.05 ) / 1000 ) * 1000 ; } echo $ debt . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ total = 100000 ; $ digit = 1000 ; $ term = intval ( trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ term ; $ i ++ ) { $ total += $ total * 0.05 ; $ total = ceil ( $ total / $ digit ) * $ digit ; } echo $ total . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ g = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ g = ceil ( ( $ g * 1.05 ) / 1000 ) * 1000 ; } print ( $ g . \" \\n \" ) ;",
    "label": 3
  },
  {
    "code": "<?php $ total = 100000 ; $ digit = 1000 ; $ term = intval ( trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ term ; $ i ++ ) { $ total += $ total * 0.05 ; $ total = ceil ( $ total / $ digit ) * $ digit ; } echo $ total . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ sum = 100000 ; while ( $ line = trim ( fgets ( STDIN ) ) ) { foreach ( array_fill ( 0 , $ line , \" \" ) as $ hoge ) { $ sum = ceil ( 1.05 * $ sum / 1000 ) * 1000 ; } echo $ sum . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ s = 100000 ; $ n = intval ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s = $ s * 1.05 ; $ r = $ s % 1000 ; if ( $ r > 0 ) { $ s = $ s - $ r + 1000 ; } } echo $ s . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , \" %d \" , $ w ) ; if ( feof ( STDIN ) ) break ; $ b = 100000 ; for ( $ i = 0 ; $ i < $ w ; $ i ++ ) { $ b = $ b * 1.05 ; $ c = 1000 * ceil ( $ b / 1000 ) ; $ b = $ c ; } printf ( \" %d \" , $ b ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ weeks = trim ( fgets ( STDIN ) ) ; $ tot = 100000 ; for ( $ i = 0 ; $ i < $ weeks ; $ i ++ ) { $ tot = ceil ( ( $ tot * 1.05 ) / 1000 ) * 1000 ; } echo $ tot ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ debt = 100 ; for ( fscanf ( STDIN , \" %d \" , $ n ) ; $ n -- ; ) { $ debt = ceil ( $ debt * 1.05 ) ; } echo $ debt * 1000 , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; $ debt = 100000.0 ; for ( $ i = 0 ; $ i < ( int ) $ n ; $ i ++ ) { $ debt *= 1.05 ; if ( $ debt % 1000 != 0 ) { $ debt = ( ( int ) ( $ debt / 1000 ) + 1 ) * 1000 ; } else { $ debt = ( ( int ) ( $ debt / 1000 ) ) * 1000 ; } } echo $ debt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %s \" , $ week ) ; $ gold = 100000 ; for ( $ i = 0 ; $ i < $ week ; $ i ++ ) $ gold = ceil ( $ gold * 1.05 / 1000 ) * 1000 ; echo $ gold ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ kane = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ kane = 1.05 * $ kane ; $ high = pow ( 10 , - 3 ) ; $ kane = ceil ( $ kane * $ high ) / $ high ; } echo sprintf ( \" %d \\n \" , $ kane ) ;",
    "label": 3
  },
  {
    "code": "<?php $ week = trim ( fgets ( STDIN ) ) ; $ money = 100 ; for ( $ i = 0 ; $ i < $ week ; $ i ++ ) { $ money = ceil ( $ money * 1.05 ) ; } echo ( $ money * 1000 ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( ' php: $week = fgets($fp); $debt = 100000; for ($i=0; $i<$week; $i++) { $debt *= 1.05; $debt = (int)$debt; if (substr($debt, -3, 3) != 0) { $debt = (int)($debt / 1000) * 1000 + 1000; } } echo $debt.PHP_EOL;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ N ) ; $ debt = 100.0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ debt *= 1.05 ; $ debt = ceil ( $ debt ) ; } $ debt *= 1000 ; echo ( string ) $ debt . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ d = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d *= 1.05 ; if ( $ d % 1000 !== 0 ) { $ d += 1000 - $ d % 1000 ; } } echo $ d . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ debt = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ debt = $ debt * 1.05 ; $ debt = ceil ( $ debt / 1000 ) * 1000 ; } echo $ debt . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php define ( ' INTEREST ' , 5 ) ; main ( ) ; function main ( ) { $ p = 100000 ; $ w = trim ( fgets ( STDIN ) ) ; echo debt ( $ p , $ w ) . \" \\n \" ; } function debt ( $ p , $ w ) { for ( $ i = 0 ; $ i < $ w ; $ i ++ ) { $ p += INTEREST * $ p / 100 ; $ p = roundUp ( $ p ) ; } return $ p ; } function roundUp ( $ n ) { return ceil ( $ n / 1000 ) * 1000 ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ ans = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ ans *= 1.05 ; if ( $ ans % 1000 ) { $ ans -= $ ans % 1000 ; $ ans += 1000 ; } } print $ ans . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ a = trim ( fgets ( STDIN ) ) ; $ q = 100000 ; for ( $ i = 0 ; $ i < $ a ; $ i ++ ) { $ q = ceil ( $ q * 1.05 / 1000 ) * 1000 ; } echo $ q . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ x = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = ceil ( ( $ x * 1.05 ) / 1000 ) * 1000 ; } echo $ x . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php const DEBT = 100000 ; const INTEREST = 0.05 ; $ targetWeek = trim ( fgets ( STDIN ) ) ; if ( $ targetWeek < 0 || 100 < $ targetWeek ) { echo ' out of range ' ; exit ( 1 ) ; } $ nowDebt = DEBT ; for ( $ week = 0 ; $ week < $ targetWeek ; $ week ++ ) { $ nowDebt = ceil ( ( $ nowDebt * ( 1 + INTEREST ) ) / 1000 ) * 1000 ; } echo $ nowDebt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ yen = 100000 ; $ rate = 0.05 ; $ week = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ week ; $ i ++ ) { $ yen += $ yen * $ rate ; $ yen = ceil ( $ yen / 1000 ) * 1000 ; } echo $ yen . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ w = trim ( fgets ( STDIN ) ) ; $ m = 100000 ; for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { $ m *= 1.05 ; if ( $ m % 1000 == 0 ) { $ m = floor ( $ m / 1000 ) * 1000 ; } else { $ m = floor ( $ m / 1000 ) * 1000 + 1000 ; } } echo $ m . \" \\n \" ; ;",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; $ debt = 100000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ debt += $ debt / 20 ; if ( $ debt % 1000 ) { $ debt += 1000 - $ debt % 1000 ; } } echo $ debt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ week = trim ( fgets ( STDIN ) ) ; $ money = 100000 ; for ( $ i = 0 ; $ i < $ week ; $ i ++ ) { $ money = ceil ( $ money * 1.05 / 1000 ) * 1000 ; } echo $ money . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' memory_limit ' , ' 512M ' ) ; $ p = array_fill ( 0 , 1000000 , true ) ; $ p [ 0 ] = $ p [ 1 ] = false ; for ( $ i = 2 ; $ i * $ i < 1000000 ; $ i ++ ) { if ( ! $ p [ $ i ] ) continue ; for ( $ j = $ i * $ i ; $ j < 1000000 ; $ j += $ i ) { $ p [ $ j ] = false ; } } $ sum = array_fill ( 0 , 1000000 , 0 ) ; for ( $ i = 1 ; $ i < 1000000 ; $ i ++ ) { $ sum [ $ i ] += $ sum [ $ i - 1 ] ; if ( $ p [ $ i ] ) $ sum [ $ i ] ++ ; } while ( fscanf ( STDIN , \" %d \" , $ n ) ) { echo $ sum [ $ n ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ p = array_fill ( 0 , 1000000 , true ) ; $ p [ 0 ] = $ p [ 1 ] = false ; for ( $ i = 2 ; $ i * $ i < 1000000 ; $ i ++ ) { if ( ! $ p [ $ i ] ) continue ; for ( $ j = $ i * $ i ; $ j < 1000000 ; $ j += $ i ) { $ p [ $ j ] = false ; } } $ sum = array_fill ( 0 , 1000000 , 0 ) ; for ( $ i = 1 ; $ i < 1000000 ; $ i ++ ) { $ sum [ $ i ] += $ sum [ $ i - 1 ] ; if ( $ p [ $ i ] ) $ sum [ $ i ] ++ ; } while ( fscanf ( STDIN , \" %d \" , $ n ) ) { echo $ sum [ $ n ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ million = pow ( 10 , 6 ) ; $ arr = array ( 0 , 0 ) + array_fill ( 2 , $ million - 1 , 1 ) ; for ( $ i = 2 , $ len = sqrt ( $ million ) ; $ i <= $ len ; $ i ++ ) { if ( ! $ arr [ $ i ] ) { continue ; } for ( $ j = $ i , $ len2 = $ million / $ i ; $ j <= $ len2 ; $ j ++ ) { $ arr [ $ i * $ j ] = 0 ; } } $ primes = array_keys ( array_filter ( $ arr , function ( $ val ) { return $ val ; } ) ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d ' , $ n ) ; $ cnt = 0 ; foreach ( $ primes as $ i => $ m ) { if ( $ n < $ m ) { break ; } $ cnt ++ ; } echo $ cnt , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' memory_limit ' , ' 1G ' ) ; $ count = 0 ; $ prime = array ( ) ; for ( $ i = 2 ; $ i <= 999999 ; $ i ++ ) { $ prime [ $ i ] = 1 ; } for ( $ i = 2 ; $ i <= 999999 ; $ i ++ ) { if ( $ prime [ $ i ] == 1 ) { $ count ++ ; for ( $ j = $ i * 2 ; $ j <= 999999 ; $ j += $ i ) { $ prime [ $ j ] = 0 ; } } } while ( $ line = trim ( fgets ( STDIN ) ) ) { $ count = 0 ; for ( $ i = 2 ; $ i <= ( int ) $ line ; $ i ++ ) { if ( $ prime [ $ i ] == 1 ) $ count ++ ; } echo $ count . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ max = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ count = 0 ; $ tmp = 1 ; $ max = intval ( $ max ) ; if ( $ max === 1 ) { echo 0 . \" \\n \" ; continue ; } $ str = str_repeat ( ' 01 ' , $ max / 2 + 1 ) ; $ loopmax = ceil ( sqrt ( $ max ) ) ; for ( $ i = 3 ; $ i <= $ loopmax ; $ i += 2 ) { if ( $ str [ $ i ] === ' 0 ' ) { continue ; } $ loop = 2 ; $ now = $ i * 2 ; while ( $ now <= $ max ) { $ str [ $ now ] = ' 0 ' ; $ loop ++ ; $ now = $ i * $ loop ; } } $ prime_count = 1 ; for ( $ i = 3 ; $ i <= $ max ; $ i += 2 ) { if ( $ str [ $ i ] === ' 1 ' ) { $ prime_count ++ ; } } echo $ prime_count . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function eratosthenes5 ( $ max ) { $ sqrt = floor ( sqrt ( $ max ) ) ; $ lists = array_fill ( 2 , $ max - 1 , true ) ; for ( $ i = 2 ; $ i <= $ sqrt ; $ i ++ ) { if ( isset ( $ lists [ $ i ] ) ) { for ( $ j = $ i * 2 ; $ j <= $ max ; $ j += $ i ) { unset ( $ lists [ $ j ] ) ; } } } return array_keys ( $ lists ) ; } while ( ( $ max = trim ( fgets ( STDIN ) ) ) !== ' ' ) { echo count ( eratosthenes5 ( $ max ) ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ max = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ max = intval ( $ max ) ; if ( $ max === 1 ) { echo 0 . \" \\n \" ; continue ; } $ prime_list = array_fill ( 2 , $ max - 1 , true ) ; for ( $ i = 2 ; $ i * $ i <= $ max ; $ i ++ ) { if ( isset ( $ prime_list [ $ i ] ) ) { for ( $ j = $ i * 2 ; $ j <= $ max ; $ j += $ i ) { unset ( $ prime_list [ $ j ] ) ; } } } echo count ( $ prime_list ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ not_prime = new SplFixedArray ( 1000000 ) ; for ( $ i = 0 ; $ i < 1000000 ; $ i ++ ) { $ not_prime [ $ i ] = 0 ; } for ( $ i = 2 ; $ i < 1000000 ; $ i ++ ) { if ( $ not_prime [ $ i ] == 1 ) { continue ; } for ( $ j = $ i * $ i ; $ j < 1000000 ; $ j += $ i ) { $ not_prime [ $ j ] = 1 ; } } while ( $ n = fgets ( STDIN ) ) { $ count_prime = 0 ; for ( $ i = 2 ; $ i <= ( int ) $ n ; $ i ++ ) { if ( $ not_prime [ $ i ] == 0 ) { $ count_prime ++ ; } } echo $ count_prime . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = 1000000 ; $ t = new SplFixedArray ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ t [ $ i ] = 1 ; } $ t [ 0 ] = $ t [ 1 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ t [ $ i ] === 1 ) { for ( $ j = $ i * $ i ; $ j < $ n ; $ j += $ i ) { $ t [ $ j ] = 0 ; } } } for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ t [ $ i ] += $ t [ $ i - 1 ] ; } while ( TRUE ) { fscanf ( STDIN , \" %d \" , $ n ) ; if ( feof ( STDIN ) ) { break ; } $ c = $ t [ $ n ] ; echo ( string ) $ c . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' MAX ' , 1000000 ) ; $ table = new SplFixedArray ( MAX ) ; $ table [ 0 ] = 0 ; $ table [ 1 ] = 0 ; $ i = 2 ; while ( $ i < MAX ) { $ table [ $ i ] = $ table [ $ i - 1 ] + 1 ; for ( $ j = $ i * 2 ; $ j < MAX ; $ j += $ i ) { $ table [ $ j ] = - 1 ; } $ i ++ ; while ( $ i < MAX && $ table [ $ i ] === - 1 ) { $ table [ $ i ] = $ table [ $ i - 1 ] ; $ i ++ ; } } while ( true ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( feof ( STDIN ) ) { break ; } echo $ table [ $ n ] ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ max = 1000000 ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { $ array [ $ i ] = 1 ; } $ array [ 1 ] = 0 ; for ( $ i = 2 ; $ i < $ max ; $ i ++ ) { if ( $ array [ $ i ] === 0 ) continue ; else for ( $ j = $ i * 2 ; $ j < $ max ; $ j += $ i ) { $ array [ $ j ] = 0 ; } } for ( $ i = 2 ; $ i < $ max ; $ i ++ ) { $ array [ $ i ] += $ array [ $ i - 1 ] ; } while ( 1 ) { $ res = fscanf ( STDIN , ' %d ' , $ n ) ; if ( $ res == 0 ) break ; $ cnt = $ array [ $ n ] ; echo $ cnt . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ max = 1000000 ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { $ array [ $ i ] = 1 ; } $ array [ 1 ] = 0 ; for ( $ i = 2 ; $ i < $ max ; $ i ++ ) { if ( $ array [ $ i ] === 0 ) continue ; else for ( $ j = $ i * $ i ; $ j < $ max ; $ j += $ i ) { $ array [ $ j ] = 0 ; } } for ( $ i = 2 ; $ i < $ max ; $ i ++ ) { $ array [ $ i ] += $ array [ $ i - 1 ] ; } while ( 1 ) { $ res = fscanf ( STDIN , ' %d ' , $ n ) ; if ( $ res == 0 ) break ; $ cnt = $ array [ $ n ] ; echo $ cnt . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 1000000 ; $ i ++ ) { $ isPrime [ $ i ] = true ; } $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i < 1000000 ; $ i ++ ) { if ( ! $ isPrime [ $ i ] ) continue ; for ( $ j = 2 * $ i ; $ j < 1000000 ; $ j += $ i ) { $ isPrime [ $ j ] = false ; } } $ num [ 0 ] = 0 ; for ( $ i = 1 ; $ i < 1000000 ; $ i ++ ) { $ num [ $ i ] = $ num [ $ i - 1 ] ; if ( $ isPrime [ $ i ] ) $ num [ $ i ] ++ ; } while ( fscanf ( STDIN , \" %d \" , $ n ) ) { print $ num [ $ n ] . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ isPrime = new SplFixedArray ( 1000000 ) ; $ cntPrime = new SplFixedArray ( 1000000 ) ; for ( $ i = 0 ; $ i < 1000000 ; $ i ++ ) { $ isPrime [ $ i ] = true ; } $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i < 1000 + 1 ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { for ( $ j = $ i * $ i ; $ j < 1000000 ; $ j += $ i ) { $ isPrime [ $ j ] = false ; } } } $ cnt = 0 ; for ( $ i = 1 ; $ i < 1000000 ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { $ cnt ++ ; } $ cntPrime [ $ i ] = $ cnt ; } while ( $ n = ( int ) trim ( fgets ( STDIN ) ) ) { echo $ cntPrime [ $ n ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ prime = new SplFixedArray ( 1000000 ) ; for ( $ i = 0 ; $ i < 1000000 ; $ i ++ ) $ prime [ $ i ] = 0 ; for ( $ i = 2 ; $ i < 1000000 ; $ i ++ ) { if ( $ prime [ $ i ] == 1 ) continue ; for ( $ j = $ i * $ i ; $ j < 1000000 ; $ j += $ i ) $ prime [ $ j ] = 1 ; } while ( $ stdin = trim ( fgets ( STDIN ) ) ) { $ count = 0 ; for ( $ i = 2 ; $ i <= ( int ) $ stdin ; $ i ++ ) if ( $ prime [ $ i ] == 0 ) $ count ++ ; echo $ count . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php function to_d ( $ e ) { return ( double ) $ e ; } $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < ( double ) $ n ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ a = explode ( \" \" , $ line ) ; $ a = array_map ( \" to_d \" , $ a ) ; $ a1 = 2 * ( $ a [ 2 ] - $ a [ 0 ] ) ; $ a2 = 2 * ( $ a [ 4 ] - $ a [ 0 ] ) ; $ b1 = 2 * ( $ a [ 3 ] - $ a [ 1 ] ) ; $ b2 = 2 * ( $ a [ 5 ] - $ a [ 1 ] ) ; $ c1 = $ a [ 0 ] * $ a [ 0 ] - $ a [ 2 ] * $ a [ 2 ] + $ a [ 1 ] * $ a [ 1 ] - $ a [ 3 ] * $ a [ 3 ] ; $ c2 = $ a [ 0 ] * $ a [ 0 ] - $ a [ 4 ] * $ a [ 4 ] + $ a [ 1 ] * $ a [ 1 ] - $ a [ 5 ] * $ a [ 5 ] ; $ xp = ( $ b1 * $ c2 - $ b2 * $ c1 ) / ( $ a1 * $ b2 - $ a2 * $ b1 ) ; $ yp = ( $ c1 * $ a2 - $ c2 * $ a1 ) / ( $ a1 * $ b2 - $ a2 * $ b1 ) ; $ r = sqrt ( ( $ xp - $ a [ 0 ] ) * ( $ xp - $ a [ 0 ] ) + ( $ yp - $ a [ 1 ] ) * ( $ yp - $ a [ 1 ] ) ) ; printf ( \" %.3f %.3f %.3f \\n \" , $ xp , $ yp , $ r ) ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { fscanf ( STDIN , ' %f %f %f %f %f %f ' , $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ a = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; $ b = sqrt ( ( $ x3 - $ x2 ) * ( $ x3 - $ x2 ) + ( $ y3 - $ y2 ) * ( $ y3 - $ y2 ) ) ; $ c = sqrt ( ( $ x1 - $ x3 ) * ( $ x1 - $ x3 ) + ( $ y1 - $ y3 ) * ( $ y1 - $ y3 ) ) ; $ R = $ a * $ b * $ c / sqrt ( ( $ a + $ b + $ c ) * ( - $ a + $ b + $ c ) * ( $ a - $ b + $ c ) * ( $ a + $ b - $ c ) ) ; $ s = array ( ) ; $ s [ ] = $ x2 - $ x1 ; $ s [ ] = $ y2 - $ y1 ; $ s [ ] = ( $ x2 * $ x2 - $ x1 * $ x1 + $ y2 * $ y2 - $ y1 * $ y1 ) / 2 ; $ t = array ( ) ; $ t [ ] = $ x3 - $ x1 ; $ t [ ] = $ y3 - $ y1 ; $ t [ ] = ( $ x3 * $ x3 - $ x1 * $ x1 + $ y3 * $ y3 - $ y1 * $ y1 ) / 2 ; if ( $ s [ 0 ] === 0.0 ) { $ tmp = $ s ; $ s = $ t ; $ t = $ tmp ; } $ div = $ s [ 0 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ s [ $ i ] /= $ div ; } $ times = $ t [ 0 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ t [ $ i ] -= $ s [ $ i ] * $ times ; } $ div = $ t [ 1 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ t [ $ i ] /= $ div ; } $ times = $ s [ 1 ] ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ s [ $ i ] -= $ t [ $ i ] * $ times ; } echo sprintf ( ' %.3f %.3f %.3f ' , round ( $ s [ 2 ] , 3 ) , round ( $ t [ 2 ] , 3 ) , round ( $ R , 3 ) ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: fscanf($file_handle, ' % d ' , $ n ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { fscanf ( $ file_handle , ' %f %f %f %f %f %f ' , $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; if ( ( $ x1 - $ x2 ) == 0 ) { $ a1 = false ; $ ra1 = 0 ; } else if ( ( $ y1 - $ y2 ) == 0 ) { $ a1 = 0 ; $ ra1 = false ; } else { $ a1 = ( $ y1 - $ y2 ) / ( $ x1 - $ x2 ) ; $ ra1 = - 1 / $ a1 ; } if ( ( $ x2 - $ x3 ) == 0 ) { $ a2 = false ; $ ra2 = 0 ; } else if ( ( $ y2 - $ y3 ) == 0 ) { $ a2 = 0 ; $ ra2 = false ; } else { $ a2 = ( $ y2 - $ y3 ) / ( $ x2 - $ x3 ) ; $ ra2 = - 1 / $ a2 ; } if ( ( $ x3 - $ x1 ) == 0 ) { $ a3 = false ; $ ra3 = 0 ; } else if ( ( $ y3 - $ y1 ) == 0 ) { $ a3 = 0 ; $ ra3 = false ; } else { $ a3 = ( $ y3 - $ y1 ) / ( $ x3 - $ x1 ) ; $ ra3 = - 1 / $ a3 ; } $ mx1 = ( $ x1 + $ x2 ) / 2 ; $ my1 = ( $ y1 + $ y2 ) / 2 ; $ mx2 = ( $ x2 + $ x3 ) / 2 ; $ my2 = ( $ y2 + $ y3 ) / 2 ; $ mx3 = ( $ x3 + $ x1 ) / 2 ; $ my3 = ( $ y3 + $ y1 ) / 2 ; $ rb1 = $ my1 - $ ra1 * $ mx1 ; $ rb2 = $ my2 - $ ra2 * $ mx2 ; $ rb3 = $ my3 - $ ra3 * $ mx3 ; if ( $ ra1 !== false && $ ra2 !== false ) { $ px = ( $ rb2 - $ rb1 ) / ( $ ra1 - $ ra2 ) ; $ py = $ ra1 * $ px + $ rb1 ; } else if ( $ ra2 !== false && $ ra3 !== false ) { $ px = ( $ rb3 - $ rb2 ) / ( $ ra2 - $ ra3 ) ; $ py = $ ra2 * $ px + $ rb2 ; } else if ( $ ra3 !== false && $ ra1 !== false ) { $ px = ( $ rb1 - $ rb3 ) / ( $ ra3 - $ ra1 ) ; $ py = $ ra3 * $ px + $ rb3 ; } $ sqr = pow ( $ px - $ x1 , 2 ) + pow ( $ py - $ y1 , 2 ) ; $ r = sqrt ( $ sqr ) ; $ px = round ( $ px , 3 ) ; $ px = sprintf ( ' %.3f ' , $ px ) ; $ py = round ( $ py , 3 ) ; $ py = sprintf ( ' %.3f ' , $ py ) ; $ r = round ( $ r , 3 ) ; $ r = sprintf ( ' %.3f ' , $ r ) ; echo $ px . ' ' . $ py . ' ' . $ r . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ DEBUG_LEVEL = 0 ; main ( ) ; function main ( ) { $ numSets = trim ( fgets ( STDIN ) ) ; $ count = 0 ; while ( $ count < $ numSets ) { $ data = getPoints ( ) ; $ adjusted = adjustAlignment ( $ data ) ; $ result = calc ( $ adjusted ) ; printf ( \" %.3f %.3f %.3f \\n \" , round ( $ result [ 0 ] , 3 ) , round ( $ result [ 1 ] , 3 ) , round ( $ result [ 2 ] , 3 ) ) ; $ count ++ ; } } function getPoints ( ) { $ input = trim ( fgets ( STDIN ) ) ; list ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) = explode ( ' ' , $ input ) ; $ a = new Point ( $ x1 , $ y1 ) ; $ b = new Point ( $ x2 , $ y2 ) ; $ c = new Point ( $ x3 , $ y3 ) ; return array ( $ a , $ b , $ c ) ; } function adjustAlignment ( $ points ) { $ minKey = 0 ; $ min = $ points [ $ minKey ] ; foreach ( $ points as $ k => $ p ) { if ( $ min -> x > $ p -> x ) { $ min = $ p ; $ minKey = $ k ; } } unset ( $ points [ $ minKey ] ) ; $ bottom = reset ( $ points ) ; $ bottomKey = key ( $ points ) ; foreach ( $ points as $ k => $ p ) { if ( $ bottom -> y > $ p -> y ) { $ bottom = $ p ; $ bottomKey = $ k ; } } unset ( $ points [ $ bottomKey ] ) ; $ top = reset ( $ points ) ; $ return = array ( $ min , $ bottom , $ top ) ; debug ( $ return ) ; return $ return ; } function calc ( $ points ) { $ min = $ points [ 0 ] ; $ a = new Point ( 0 , 0 ) ; $ b = $ points [ 1 ] -> shift ( - 1 * $ min -> x , - 1 * $ min -> y ) ; $ c = $ points [ 2 ] -> shift ( - 1 * $ min -> x , - 1 * $ min -> y ) ; debug ( $ a . $ b . $ c ) ; $ theta = abs ( $ b -> x ) > 0.00001 ? atan ( $ b -> y / $ b -> x ) : - 3.1415926535 / 2 ; debug ( \" theta = $ theta \" ) ; $ b -> rotate ( - $ theta ) ; $ c -> rotate ( - $ theta ) ; debug ( $ a . $ b . $ c ) ; $ scale = abs ( 1 / $ b -> x ) ; $ b -> scale ( $ scale ) ; $ c -> scale ( $ scale ) ; $ x0 = $ c -> x ; $ y0 = $ c -> y ; $ gx = 1 / 2 ; $ gy = ( - $ x0 + $ x0 * $ x0 + $ y0 * $ y0 ) / ( 2 * $ y0 ) ; $ g = new Point ( $ gx , $ gy ) ; $ r = sqrt ( $ g -> y * $ g -> y + 0.5 * 0.5 ) ; $ r *= 1 / $ scale ; $ g -> scale ( 1 / $ scale ) ; $ g -> rotate ( $ theta ) ; $ g -> shift ( $ min -> x , $ min -> y ) ; return array ( $ g -> x , $ g -> y , $ r ) ; } class Point { public $ x ; public $ y ; function __construct ( $ x , $ y ) { $ this -> x = $ x ; $ this -> y = $ y ; } function scale ( $ k ) { $ this -> x *= $ k ; $ this -> y *= $ k ; return $ this ; } function rotate ( $ theta ) { $ x = $ this -> x ; $ y = $ this -> y ; $ this -> x = $ x * cos ( $ theta ) - $ y * sin ( $ theta ) ; $ this -> y = $ x * sin ( $ theta ) + $ y * cos ( $ theta ) ; return $ this ; } function shift ( $ x , $ y ) { $ this -> x += $ x ; $ this -> y += $ y ; return $ this ; } function __toString ( ) { return sprintf ( \" x = %.3f, y = %.3f \\n \" , round ( $ this -> x , 3 ) , round ( $ this -> y , 3 ) ) ; } } function debug ( $ out ) { global $ DEBUG_LEVEL ; if ( ! isset ( $ DEBUG_LEVEL ) || $ DEBUG_LEVEL <= 0 ) { return null ; } if ( is_string ( $ out ) ) { echo $ out . \" \\n \" ; } else { var_dump ( $ out ) ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %lf %lf %lf %lf %lf %lf \" , $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ a1 = 2 * ( $ x2 - $ x1 ) ; $ b1 = 2 * ( $ y2 - $ y1 ) ; $ c1 = $ x1 * $ x1 - $ x2 * $ x2 + $ y1 * $ y1 - $ y2 * $ y2 ; $ a2 = 2 * ( $ x3 - $ x1 ) ; $ b2 = 2 * ( $ y3 - $ y1 ) ; $ c2 = $ x1 * $ x1 - $ x3 * $ x3 + $ y1 * $ y1 - $ y3 * $ y3 ; $ x = ( $ b1 * $ c2 - $ b2 * $ c1 ) / ( $ a1 * $ b2 - $ a2 * $ b1 ) ; $ y = ( $ c1 * $ a2 - $ c2 * $ a1 ) / ( $ a1 * $ b2 - $ a2 * $ b1 ) ; $ r = sqrt ( ( $ x - $ x1 ) * ( $ x - $ x1 ) + ( $ y - $ y1 ) * ( $ y - $ y1 ) ) ; printf ( \" %.3f %.3f %.3f \\n \" , $ x , $ y , $ r ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) ) { fscanf ( STDIN , \" %d \" , $ m ) ; $ t = range ( 1 , $ n ) ; while ( $ m -- > 0 ) { fscanf ( STDIN , \" %d,%d \" , $ a , $ b ) ; $ a -- ; $ b -- ; list ( $ t [ $ a ] , $ t [ $ b ] ) = array ( $ t [ $ b ] , $ t [ $ a ] ) ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ t [ $ i ] . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php #  # fscanf(STDIN, \"%d %d\", $a, $b); #  # fscanf(STDIN, \"%s\", $s); #  # echo ($a+$b).\" \".$s.\"\\n\"; fscanf(STDIN, \"%d\", $w); fscanf(STDIN, \"%d\", $n); $amida = range(1, $w); for($i = 0; $i < $n; $i++){ fscanf(STDIN, \"%d,%d\", $a, $b); $tmp = $amida[$a-1]; $amida[$a-1] = $amida[$b-1]; $amida[$b-1] = $tmp; } for($i = 0; $i < $w; $i++){ print $amida[$i].\"\\n\"; } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ w ) ; fscanf ( STDIN , ' %d ' , $ n ) ; $ arr = range ( 1 , $ w ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; sscanf ( $ line , ' %d,%d ' , $ a , $ b ) ; $ tmp = $ arr [ $ a - 1 ] ; $ arr [ $ a - 1 ] = $ arr [ $ b - 1 ] ; $ arr [ $ b - 1 ] = $ tmp ; } echo implode ( PHP_EOL , $ arr ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ w = trim ( fgets ( STDIN ) ) ; $ value = array ( ) ; for ( $ i = 1 ; $ i < $ w + 1 ; $ i ++ ) { $ value [ $ i ] = $ i ; } $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ b ) = explode ( \" , \" , trim ( fgets ( STDIN ) ) ) ; $ tmp = $ value [ $ a ] ; $ value [ $ a ] = $ value [ $ b ] ; $ value [ $ b ] = $ tmp ; } foreach ( $ value as $ hoge ) { echo $ hoge . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ w = intval ( fgets ( STDIN ) ) ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { $ arr [ $ i ] = $ i ; } $ n = intval ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d,%d \" , $ a , $ b ) ; $ tmp = $ arr [ $ a ] ; $ arr [ $ a ] = $ arr [ $ b ] ; $ arr [ $ b ] = $ tmp ; } for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { echo $ arr [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ y_lines = intval ( trim ( fgets ( STDIN ) ) ) ; for ( $ i = 1 ; $ i <= $ y_lines ; $ i ++ ) { $ order [ $ i ] = $ i ; } $ x_lines = intval ( trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ x_lines ; $ i ++ ) { $ shuffle_nums = explode ( ' , ' , trim ( fgets ( STDIN ) ) ) ; $ shuffle_num_a = intval ( $ shuffle_nums [ 0 ] ) ; $ shuffle_num_b = intval ( $ shuffle_nums [ 1 ] ) ; $ tmp_1 = $ order [ $ shuffle_num_a ] ; $ tmp_2 = $ order [ $ shuffle_num_b ] ; $ order [ $ shuffle_num_a ] = $ tmp_2 ; $ order [ $ shuffle_num_b ] = $ tmp_1 ; } foreach ( $ order as $ num ) { echo $ num . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function to_i ( $ e ) { return ( int ) $ e ; } $ w = ( int ) fgets ( STDIN ) ; $ numbers = array ( ) ; for ( $ i = 0 ; $ i <= $ w ; $ i ++ ) { array_push ( $ numbers , $ i ) ; } $ n = ( int ) fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = rtrim ( fgets ( STDIN ) , \" \\n \" ) ; list ( $ a , $ b ) = array_map ( \" to_i \" , explode ( \" , \" , $ line ) ) ; list ( $ numbers [ $ a ] , $ numbers [ $ b ] ) = array ( $ numbers [ $ b ] , $ numbers [ $ a ] ) ; } for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { echo $ numbers [ $ i ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ w ) ; $ g = new G ( ) ; $ a = array ( ) ; for ( $ i = 0 ; $ i < $ w ; $ i ++ ) { $ a [ $ i + 1 ] = 0 ; $ g -> lines [ $ i + 1 ] = new Line ( $ i + 1 ) ; } fscanf ( STDIN , \" %d \" , $ n ) ; $ bars = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %s \" , $ bar ) ; $ bar = explode ( ' , ' , $ bar ) ; $ line = $ g -> getLine ( ( int ) $ bar [ 0 ] ) ; $ line -> edges [ $ i ] = $ bar [ 1 ] ; $ line = $ g -> getLine ( ( int ) $ bar [ 1 ] ) ; $ line -> edges [ $ i ] = $ bar [ 0 ] ; } for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { $ l = $ i ; $ t = 0 ; while ( TRUE ) { $ line = $ g -> getLine ( $ l ) ; $ next = $ line -> nextLine ( $ t ) ; if ( $ next === NULL ) { $ a [ $ l ] = $ i ; break ; } $ t = $ next [ 0 ] + 1 ; $ l = $ next [ 1 ] ; } } foreach ( $ a as $ v ) { echo ( string ) $ v ; echo PHP_EOL ; } class Line { public $ index ; public $ edges = array ( ) ; public function __construct ( $ index ) { $ this -> index = $ index ; } public function nextLine ( $ t ) { foreach ( $ this -> edges as $ key => $ value ) { if ( $ key >= $ t ) { return array ( $ key , $ value ) ; } } return NULL ; } } class G { public $ lines = array ( ) ; public function getLine ( $ index ) { return $ this -> lines [ $ index ] ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ w ) ; fscanf ( STDIN , ' %d ' , $ n ) ; $ bs = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ bs [ ] = fscanf ( STDIN , ' %d,%d ' ) ; } $ g = array ( ) ; for ( $ i = 0 ; $ i < $ w ; $ i ++ ) { $ g [ $ i ] = null ; } for ( $ i = 0 ; $ i < $ w ; $ i ++ ) { $ p = $ i + 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ bs [ $ j ] [ 0 ] === $ p ) { $ p = $ bs [ $ j ] [ 1 ] ; } elseif ( $ bs [ $ j ] [ 1 ] === $ p ) { $ p = $ bs [ $ j ] [ 0 ] ; } } $ g [ $ p - 1 ] = $ i + 1 ; } foreach ( $ g as $ v ) { echo $ v . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ w ) ; fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { $ line [ $ i ] = $ i ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { fscanf ( STDIN , ' %d,%d ' , $ a , $ b ) ; $ tmp = $ line [ $ a ] ; $ line [ $ a ] = $ line [ $ b ] ; $ line [ $ b ] = $ tmp ; } foreach ( $ line as $ l ) { echo $ l . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ w ) ; fscanf ( STDIN , \" %d \" , $ n ) ; for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { $ arr [ $ i ] = $ i ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d,%d \" , $ a , $ b ) ; $ arr [ $ a ] ^= $ arr [ $ b ] ; $ arr [ $ b ] ^= $ arr [ $ a ] ; $ arr [ $ a ] ^= $ arr [ $ b ] ; } for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { print $ arr [ $ i ] . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ numbers = fgets ( STDIN ) ; $ w = intval ( $ numbers ) ; $ numbers = fgets ( STDIN ) ; $ n = intval ( $ numbers ) ; $ line = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ x = intval ( $ numbers [ 0 ] ) ; $ y = intval ( $ numbers [ 1 ] ) ; $ line [ ] = [ $ x , $ y ] ; } for ( $ i = 1 ; $ i <= $ w ; $ i ++ ) { $ num = $ i ; for ( $ j = $ n - 1 ; $ j >= 0 ; $ j -- ) { if ( $ num == $ line [ $ j ] [ 0 ] ) { $ num = $ line [ $ j ] [ 1 ] ; } else if ( ( $ num == $ line [ $ j ] [ 1 ] ) ) { $ num = $ line [ $ j ] [ 0 ] ; } } print $ num ; print PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ w ) ; fscanf ( STDIN , ' %d ' , $ n ) ; $ ary = array ( ) ; for ( $ i = 0 ; $ i < $ w ; $ i += 1 ) { array_push ( $ ary , $ i + 1 ) ; } for ( $ i = 0 ; $ i < $ n ; $ i += 1 ) { $ a = array_map ( function ( $ arg ) { return $ arg - 1 ; } , fscanf ( STDIN , ' %d,%d ' ) ) ; $ temp = $ ary [ $ a [ 0 ] ] ; $ ary [ $ a [ 0 ] ] = $ ary [ $ a [ 1 ] ] ; $ ary [ $ a [ 1 ] ] = $ temp ; } foreach ( $ ary as $ value ) { echo $ value , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ st = array ( ) ; while ( fscanf ( STDIN , \" %d \" , $ x ) ) { if ( $ x == 0 ) { echo array_pop ( $ st ) . \" \\n \" ; } else { array_push ( $ st , $ x ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ stack = new \\ SplStack ( ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ n = ( int ) $ line ; if ( $ n === 0 ) { echo $ stack -> pop ( ) , PHP_EOL ; } else { $ stack -> push ( $ n ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ array = array ( ) ; while ( fscanf ( STDIN , \" %d \" , $ a ) ) { if ( $ a === 0 ) { echo array_pop ( $ array ) . \" \\n \" ; } else { array_push ( $ array , $ a ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ in = intval ( $ line ) ; if ( $ in == 0 ) { $ x = array_pop ( $ arr ) ; echo $ x . \" \\n \" ; } else { array_push ( $ arr , $ in ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ stack = array ( ) ; while ( ! feof ( STDIN ) ) { $ inVal = trim ( fgets ( STDIN ) ) ; if ( $ inVal == 0 ) { $ disp = array_pop ( $ stack ) ; if ( ! is_null ( $ disp ) ) { echo $ disp . PHP_EOL ; } } else { $ stack [ ] = $ inVal ; } }",
    "label": 3
  },
  {
    "code": "<?php $ railway = array ( ) ; while ( fscanf ( STDIN , \" %d \" , $ railroad_car ) ) { if ( $ railroad_car == 0 ) { echo array_pop ( $ railway ) . PHP_EOL ; } else { array_push ( $ railway , $ railroad_car ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ stack = array ( ) ; $ result = array ( ) ; while ( ! feof ( STDIN ) ) { $ input = rtrim ( fgets ( STDIN ) ) ; if ( ' 0 ' === $ input ) { $ result [ ] = array_pop ( $ stack ) ; } else { $ stack [ ] = $ input ; } } foreach ( $ result as $ key => $ value ) { printf ( \" %d \\n \" , $ value ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ! feof ( STDIN ) ) { $ num [ ] = trim ( fgets ( STDIN ) ) ; } for ( $ i = 0 ; $ i < count ( $ num ) ; $ i ++ ) { if ( $ num [ $ i ] == 0 ) { $ a = $ i - 1 ; echo $ num [ $ a ] . \" \\n \" ; unset ( $ num [ $ i ] ) ; unset ( $ num [ $ a ] ) ; $ num = array_values ( $ num ) ; $ i = 0 ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ stack = array ( ) ; while ( TRUE ) { fscanf ( STDIN , \" %d \" , $ i ) ; if ( feof ( STDIN ) ) { break ; } if ( $ i === 0 ) { if ( ! count ( $ stack ) ) { break ; } echo ( string ) array_pop ( $ stack ) ; echo PHP_EOL ; } else { $ stack [ ] = $ i ; } }",
    "label": 3
  },
  {
    "code": "<?php $ stack = array ( ) ; while ( ! feof ( STDIN ) ) { fscanf ( STDIN , ' %d ' , $ num ) ; if ( ! is_int ( $ num ) || feof ( STDIN ) ) { break ; } if ( $ num === 0 ) { if ( ! count ( $ stack ) ) { break ; } echo array_pop ( $ stack ) ; echo PHP_EOL ; continue ; } $ stack [ ] = $ num ; }",
    "label": 3
  },
  {
    "code": "<?php $ stack = array ( ) ; while ( 1 ) { $ res = fscanf ( STDIN , ' %d ' , $ n ) ; if ( $ res == 0 ) break ; if ( $ n === 0 ) { $ end = array_pop ( $ stack ) ; echo $ end . PHP_EOL ; } else { array_push ( $ stack , $ n ) ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ a ) ) { if ( $ a == 0 ) { echo end ( $ d ) . PHP_EOL ; array_pop ( $ d ) ; } else { $ d [ ] = $ a ; } }",
    "label": 3
  },
  {
    "code": "<?php function setZero ( & $ x ) { while ( strlen ( $ x ) < 80 ) { $ x = \" 0 \" . $ x ; } if ( strlen ( $ x ) > 80 ) return false ; return true ; } fscanf ( STDIN , \" %d \" , $ T ) ; while ( $ T -- > 0 ) { fscanf ( STDIN , \" %s \" , $ a ) ; fscanf ( STDIN , \" %s \" , $ b ) ; if ( ! setZero ( $ a ) || ! setZero ( $ b ) ) { echo \" overflow \\n \" ; continue ; } $ ans = \" \" ; $ up = 0 ; for ( $ i = 79 ; $ i >= 0 ; $ i -- ) { $ sum = ( int ) ( $ a [ $ i ] - ' 0 ' ) + ( int ) ( $ b [ $ i ] - ' 0 ' ) + $ up ; $ ans = ( string ) ( $ sum % 10 + ' 0 ' ) . $ ans ; $ up = ( int ) ( $ sum / 10 ) ; } if ( $ up != 0 ) { echo \" overflow \\n \" ; continue ; } $ i = 0 ; while ( $ i < 79 && $ ans [ $ i ] == ' 0 ' ) $ i ++ ; while ( $ i < 80 ) { echo $ ans [ $ i ] ; $ i ++ ; } echo \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , ' %s ' , $ a ) ; fscanf ( STDIN , ' %s ' , $ b ) ; if ( max ( strlen ( $ a ) , strlen ( $ b ) ) > 80 ) { echo \" overflow \\n \" ; continue ; } $ arr = array_fill ( 0 , 81 , 0 ) ; $ a = sprintf ( ' %081s ' , $ a ) ; $ b = sprintf ( ' %081s ' , $ b ) ; for ( $ j = 80 ; $ j > 0 ; $ j -- ) { $ n = $ arr [ $ j ] + $ a [ $ j ] + $ b [ $ j ] ; if ( $ n >= 10 ) { $ arr [ $ j ] = substr ( $ n , 1 ) ; $ arr [ $ j - 1 ] += 1 ; } else { $ arr [ $ j ] = $ n ; } } $ result = preg_replace ( ' /^0+(\\d+)$/ ' , ' $1 ' , implode ( ' ' , $ arr ) ) ; if ( strlen ( $ result ) > 80 ) { echo \" overflow \\n \" ; } else { echo $ result , PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , \" %s \" , $ a ) ; fscanf ( STDIN , \" %s \" , $ b ) ; $ x = new BigInt ( ) ; if ( ! $ x -> setNum ( $ a ) ) { echo ' overflow ' . PHP_EOL ; continue ; } $ y = new BigInt ( ) ; if ( ! $ y -> setNum ( $ b ) ) { echo ' overflow ' . PHP_EOL ; continue ; } $ total = $ x -> add ( $ y ) ; if ( $ total === NULL ) { echo ' overflow ' . PHP_EOL ; continue ; } echo $ total ; echo PHP_EOL ; } class BigInt { const PLACE = 18 ; public $ num = array ( ) ; public $ maxLen ; private $ zero ; public function __construct ( $ maxLen = 80 ) { $ this -> maxLen = $ maxLen ; $ n = ceil ( $ maxLen / self :: PLACE ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ this -> num [ ] = ' ' ; } $ this -> zero = implode ( array_fill ( 0 , self :: PLACE , ' 0 ' ) ) ; } public function setNum ( $ num ) { if ( strlen ( $ num ) > $ this -> maxLen ) { return FALSE ; } $ n = ceil ( $ this -> maxLen / self :: PLACE ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( strlen ( $ num ) <= self :: PLACE ) { $ this -> num [ $ i ] = implode ( array_fill ( 0 , self :: PLACE - strlen ( $ num ) , ' 0 ' ) ) . $ num ; break ; } $ this -> num [ $ i ] = substr ( $ num , - self :: PLACE ) ; $ num = substr ( $ num , 0 , strlen ( $ num ) - self :: PLACE ) ; } return TRUE ; } public function add ( BigInt $ a ) { $ num = $ this -> num ; $ n = ceil ( $ this -> maxLen / self :: PLACE ) ; $ up = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num [ $ i ] = ( int ) $ num [ $ i ] + ( int ) $ a -> num [ $ i ] + $ up ; if ( $ num [ $ i ] > 0 ) { $ num [ $ i ] = ( string ) $ num [ $ i ] ; } else { $ num [ $ i ] = $ this -> zero ; } if ( strlen ( $ num [ $ i ] ) > self :: PLACE ) { $ num [ $ i ] = substr ( $ num [ $ i ] , - self :: PLACE ) ; $ up = 1 ; } elseif ( strlen ( $ num [ $ i ] ) < self :: PLACE ) { $ num [ $ i ] = implode ( array_fill ( 0 , self :: PLACE - strlen ( $ num [ $ i ] ) , ' 0 ' ) ) . $ num [ $ i ] ; $ up = 0 ; } } $ total = ' ' ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ total .= $ num [ $ i ] ; } $ total = preg_replace ( ' /^0*/ ' , ' ' , $ total ) ; if ( $ total === ' ' ) { $ total = ' 0 ' ; } if ( strlen ( $ total ) > $ this -> maxLen ) { return NULL ; } return $ total ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d %d %d %d %d ' , $ a , $ b , $ c , $ d , $ e ) ; $ arr = array ( $ a , $ b , $ c , $ d , $ e ) ; rsort ( $ arr ) ; echo implode ( ' ' , $ arr ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; rsort ( $ a ) ; echo implode ( ' ' , $ a ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( \" \" , $ line ) ; rsort ( $ arr ) ; echo implode ( \" \" , $ arr ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; rsort ( $ a ) ; printf ( \" %d \" , $ a [ 0 ] ) ; unset ( $ a [ 0 ] ) ; foreach ( $ a as $ ans ) { printf ( \" %d \" , $ ans ) ; } printf ( \" \\n \" ) ;",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; $ sortArray = preg_split ( \" /[\\s]+/ \" , $ stdin ) ; rsort ( $ sortArray ) ; echo implode ( \" \" , $ sortArray ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ a = fscanf ( STDIN , ' %d %d %d %d %d ' ) ; rsort ( $ a ) ; echo implode ( ' ' , $ a ) ; echo \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; $ nums = explode ( \" \" , $ stdin ) ; rsort ( $ nums ) ; echo implode ( ' ' , $ nums ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ inputs = trim ( fgets ( STDIN ) ) ; $ values = explode ( ' ' , $ inputs ) ; rsort ( $ values ) ; echo implode ( ' ' , $ values ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; $ words = preg_split ( \" /[\\s]/ \" , $ stdin ) ; rsort ( $ words ) ; print implode ( ' ' , $ words ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = trim ( fgets ( STDIN ) ) ; $ a = explode ( ' ' , $ a ) ; arsort ( $ a ) ; echo implode ( ' ' , $ a ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; rsort ( $ a ) ; echo implode ( ' ' , $ a ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; rsort ( $ a ) ; echo implode ( ' ' , $ a ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; rsort ( $ a ) ; echo trim ( implode ( ' ' , $ a ) ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = fscanf ( STDIN , \" %d %d %d %d %d \" ) ; rsort ( $ a ) ; echo implode ( ' ' , $ a ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = fscanf ( STDIN , ' %d %d %d %d %d ' ) ; rsort ( $ a ) ; echo implode ( ' ' , $ a ) ; echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = array ( 0 , 0 , 0 , 0 , 0 ) ; fscanf ( STDIN , \" %d %d %d %d %d \" , $ a [ 0 ] , $ a [ 1 ] , $ a [ 2 ] , $ a [ 3 ] , $ a [ 4 ] ) ; rsort ( $ a ) ; fprintf ( STDOUT , \" %d %d %d %d %d \\n \" , $ a [ 0 ] , $ a [ 1 ] , $ a [ 2 ] , $ a [ 3 ] , $ a [ 4 ] ) ;",
    "label": 3
  },
  {
    "code": "<?php $ num = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; rsort ( $ num ) ; $ rrr = implode ( \" \" , $ num ) ; echo $ rrr . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ str = trim ( fgets ( STDIN ) ) ; echo strtoupper ( $ str ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ s = fgets ( STDIN ) ; echo strtoupper ( $ s ) ;",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; echo strtoupper ( $ stdin ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ s = rtrim ( fgets ( STDIN ) ) ; echo strtoupper ( $ s ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ s = rtrim ( fgets ( STDIN ) ) ; echo toUpper ( $ s ) . PHP_EOL ; function toUpper ( $ str ) { $ diff = ord ( ' a ' ) - ord ( ' A ' ) ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] < ' a ' || $ str [ $ i ] > ' z ' ) { continue ; } $ str [ $ i ] = chr ( ord ( $ str [ $ i ] ) - $ diff ) ; } return $ str ; }",
    "label": 3
  },
  {
    "code": "<?php $ s = rtrim ( fgets ( STDIN ) ) ; echo strtoupper ( $ s ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php echo strtoupper ( fgets ( STDIN ) ) ;",
    "label": 3
  },
  {
    "code": "<?php $ num = trim ( fgets ( STDIN ) ) ; echo strtoupper ( $ num ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , \" %f %f %f %f %f %f %f %f \" , $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) ; $ abx = $ x2 - $ x1 ; $ aby = $ y2 - $ y1 ; $ cdx = $ x4 - $ x3 ; $ cdy = $ y4 - $ y3 ; if ( $ abx === 0.0 || $ cdx === 0.0 ) { echo $ abx === $ cdx ? ' YES ' : ' NO ' ; echo PHP_EOL ; continue ; } $ ab = $ aby / $ abx ; $ cd = $ cdy / $ cdx ; echo $ ab === $ cd ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %f %f %f %f %f %f %f %f ' , $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) ; $ ab = INF ; if ( $ x2 - $ x1 !== 0.0 ) { $ ab = ( $ y2 - $ y1 ) / ( $ x2 - $ x1 ) ; } $ cd = INF ; if ( $ x4 - $ x3 !== 0.0 ) { $ cd = ( $ y4 - $ y3 ) / ( $ x4 - $ x3 ) ; } echo $ ab === $ cd ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = intval ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %lf %lf %lf %lf %lf %lf \" , $ xa , $ ya , $ ra , $ xb , $ yb , $ rb ) ; $ r = sqrt ( ( $ xb - $ xa ) * ( $ xb - $ xa ) + ( $ yb - $ ya ) * ( $ yb - $ ya ) ) ; if ( $ r + $ ra < $ rb ) { echo \" -2 \\n \" ; continue ; } if ( $ r + $ rb < $ ra ) { echo \" 2 \\n \" ; continue ; } if ( $ r <= $ ra + $ rb ) { echo \" 1 \\n \" ; continue ; } echo \" 0 \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = $ b = array ( ) ; fscanf ( STDIN , ' %f %f %f %f %f %f ' , $ a [ ] , $ a [ ] , $ a [ ] , $ b [ ] , $ b [ ] , $ b [ ] ) ; $ ab = TRUE ; if ( $ a [ 2 ] < $ b [ 2 ] ) { $ ab = FALSE ; $ tmp = $ a ; $ a = $ b ; $ b = $ tmp ; } $ d = sqrt ( ( $ a [ 0 ] - $ b [ 0 ] ) * ( $ a [ 0 ] - $ b [ 0 ] ) + ( $ a [ 1 ] - $ b [ 1 ] ) * ( $ a [ 1 ] - $ b [ 1 ] ) ) ; if ( $ a [ 2 ] + $ b [ 2 ] < $ d ) { echo 0 ; } elseif ( $ d + $ b [ 2 ] >= $ a [ 2 ] ) { echo 1 ; } else { echo $ ab ? 2 : - 2 ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %f ' , $ v ) ; $ t = $ v / 9.8 ; $ y = 4.9 * pow ( $ t , 2 ) ; $ N = 1 ; while ( ( $ n = 5 * $ N - 5 ) < $ y ) { $ N ++ ; } echo $ N , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ minV = floatval ( $ line ) ; $ s = $ minV * $ minV / 19.6 ; $ n = ceil ( $ s / 5.0 ) + 1 ; echo $ n . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { fscanf ( STDIN , ' %f ' , $ v ) ; if ( feof ( STDIN ) ) { break ; } $ minT = $ v / 9.8 ; $ minY = 4.9 * $ minT * $ minT ; $ N = ceil ( $ minY / 5 ) + 1 ; echo ( string ) $ N ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { fscanf ( STDIN , ' %f ' , $ v ) ; if ( feof ( STDIN ) ) { break ; } $ t = $ v / 9.8 ; $ h = 4.9 * $ t * $ t ; $ N = ceil ( $ h / 5 ) + 1 ; echo sprintf ( ' %d ' , $ N ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d %d %d %d ' , $ a1 , $ a2 , $ a3 , $ a4 ) ; fscanf ( STDIN , ' %d %d %d %d ' , $ b1 , $ b2 , $ b3 , $ b4 ) ; $ arr1 = array ( $ a1 , $ a2 , $ a3 , $ a4 ) ; $ arr2 = array ( $ b1 , $ b2 , $ b3 , $ b4 ) ; $ hit = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ arr1 [ $ i ] === $ arr2 [ $ i ] ) { $ hit ++ ; unset ( $ arr1 [ $ i ] , $ arr2 [ $ i ] ) ; } } $ blow = count ( array_intersect ( $ arr1 , $ arr2 ) ) ; printf ( \" %d %d \\n \" , $ hit , $ blow ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ arrA = explode ( \" \" , trim ( $ line ) ) ; $ line = fgets ( STDIN ) ; $ arrB = explode ( \" \" , trim ( $ line ) ) ; $ hit = 0 ; $ brow = 0 ; for ( $ i = 0 ; $ i < count ( $ arrA ) ; $ i ++ ) { if ( $ arrA [ $ i ] == $ arrB [ $ i ] ) { $ hit ++ ; } for ( $ j = 0 ; $ j < count ( $ arrB ) ; $ j ++ ) { if ( $ arrA [ $ i ] == $ arrB [ $ j ] ) { $ brow ++ ; } } } $ brow -= $ hit ; echo \" { $ hit } { $ brow } \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ arrA = explode ( \" \" , trim ( $ line ) ) ; $ line = fgets ( STDIN ) ; $ arrB = explode ( \" \" , trim ( $ line ) ) ; $ hit = 0 ; $ brow = 0 ; for ( $ i = 0 ; $ i < count ( $ arrA ) ; $ i ++ ) { if ( $ arrA [ $ i ] == $ arrB [ $ i ] ) { $ hit ++ ; } for ( $ j = 0 ; $ j < count ( $ arrB ) ; $ j ++ ) { if ( $ arrA [ $ i ] == $ arrB [ $ j ] ) { $ brow ++ ; } } } $ brow -= $ hit ; echo \" { $ hit } { $ brow } \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { $ a = fscanf ( STDIN , ' %d %d %d %d ' ) ; $ b = fscanf ( STDIN , ' %d %d %d %d ' ) ; if ( ! $ a ) { break ; } $ hit = 0 ; $ blow = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { for ( $ j = 0 ; $ j < 4 ; $ j ++ ) { if ( $ a [ $ i ] !== $ b [ $ j ] ) { continue ; } if ( $ i === $ j ) { $ hit ++ ; } else { $ blow ++ ; } } } echo sprintf ( ' %d %d ' , $ hit , $ blow ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { $ a = fscanf ( STDIN , ' %d %d %d %d ' ) ; if ( feof ( STDIN ) ) { break ; } $ b = fscanf ( STDIN , ' %d %d %d %d ' ) ; $ hit = 0 ; $ blow = 0 ; $ h = array ( ) ; foreach ( $ a as $ v ) { $ h [ $ v ] = TRUE ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ a [ $ i ] === $ b [ $ i ] ) { $ hit ++ ; continue ; } if ( isset ( $ h [ $ b [ $ i ] ] ) ) { $ blow ++ ; } } echo sprintf ( ' %d %d ' , $ hit , $ blow ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ a = fscanf ( STDIN , ' %d %d %d %d ' ) ; if ( feof ( STDIN ) ) { break ; } $ b = fscanf ( STDIN , ' %d %d %d %d ' ) ; $ hit = 0 ; $ blow = 0 ; $ h = array ( ) ; foreach ( $ a as $ v ) { $ h [ $ v ] = true ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ a [ $ i ] == $ b [ $ i ] ) { $ hit ++ ; continue ; } if ( isset ( $ h [ $ b [ $ i ] ] ) ) { $ blow ++ ; } } echo sprintf ( ' %d %d ' , $ hit , $ blow ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ map = array_fill ( 0 , 10 , array_fill ( 0 , 10 , 0 ) ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d,%d,%d ' , $ x , $ y , $ size ) ; if ( $ size === 1 ) { isset ( $ map [ $ y - 1 ] ) && $ map [ $ y - 1 ] [ $ x ] ++ ; isset ( $ map [ $ y + 1 ] ) && $ map [ $ y + 1 ] [ $ x ] ++ ; isset ( $ map [ $ y ] [ $ x - 1 ] ) && $ map [ $ y ] [ $ x - 1 ] ++ ; isset ( $ map [ $ y ] [ $ x + 1 ] ) && $ map [ $ y ] [ $ x + 1 ] ++ ; $ map [ $ y ] [ $ x ] ++ ; continue ; } if ( $ size === 3 ) { isset ( $ map [ $ y - 2 ] ) && $ map [ $ y - 2 ] [ $ x ] ++ ; isset ( $ map [ $ y + 2 ] ) && $ map [ $ y + 2 ] [ $ x ] ++ ; isset ( $ map [ $ y ] [ $ x - 2 ] ) && $ map [ $ y ] [ $ x - 2 ] ++ ; isset ( $ map [ $ y ] [ $ x + 2 ] ) && $ map [ $ y ] [ $ x + 2 ] ++ ; } for ( $ y2 = $ y - 1 ; $ y2 <= $ y + 1 ; $ y2 ++ ) { if ( $ y2 < 0 || $ y2 > 9 ) { continue ; } for ( $ x2 = $ x - 1 ; $ x2 <= $ x + 1 ; $ x2 ++ ) { if ( $ x2 >= 0 && $ x2 < 10 ) { $ map [ $ y2 ] [ $ x2 ] ++ ; } } } } $ cnt = 0 ; $ max = 0 ; for ( $ y = 0 ; $ y < 10 ; $ y ++ ) { for ( $ x = 0 ; $ x < 10 ; $ x ++ ) { $ n = $ map [ $ y ] [ $ x ] ; $ max = max ( $ max , $ n ) ; ! $ n && $ cnt ++ ; } } printf ( \" %d \\n %d \\n \" , $ cnt , $ max ) ;",
    "label": 3
  },
  {
    "code": "<?php $ m = array ( ) ; for ( $ i = - 5 ; $ i < 15 ; $ i ++ ) { $ m [ $ i ] = array ( ) ; for ( $ j = - 5 ; $ j < 15 ; $ j ++ ) { $ m [ $ i ] [ $ j ] = 0 ; } } while ( $ line = fgets ( STDIN ) ) { $ arr = explode ( \" , \" , trim ( $ line ) ) ; $ x = intval ( $ arr [ 0 ] ) ; $ y = intval ( $ arr [ 1 ] ) ; $ s = intval ( $ arr [ 2 ] ) ; $ m [ $ x ] [ $ y - 1 ] ++ ; $ m [ $ x - 1 ] [ $ y ] ++ ; $ m [ $ x ] [ $ y ] ++ ; $ m [ $ x + 1 ] [ $ y ] ++ ; $ m [ $ x ] [ $ y + 1 ] ++ ; if ( $ s >= 2 ) { $ m [ $ x - 1 ] [ $ y - 1 ] ++ ; $ m [ $ x + 1 ] [ $ y - 1 ] ++ ; $ m [ $ x - 1 ] [ $ y + 1 ] ++ ; $ m [ $ x + 1 ] [ $ y + 1 ] ++ ; } if ( $ s >= 3 ) { $ m [ $ x ] [ $ y - 2 ] ++ ; $ m [ $ x - 2 ] [ $ y ] ++ ; $ m [ $ x + 2 ] [ $ y ] ++ ; $ m [ $ x ] [ $ y + 2 ] ++ ; } } $ w = 0 ; $ max = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { for ( $ j = 0 ; $ j < 10 ; $ j ++ ) { if ( $ m [ $ i ] [ $ j ] == 0 ) { $ w ++ ; } if ( $ max < $ m [ $ i ] [ $ j ] ) { $ max = $ m [ $ i ] [ $ j ] ; } } } echo $ w . \" \\n \" ; echo $ max . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ field = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ field [ ] = array ( ) ; for ( $ j = 0 ; $ j < 10 ; $ j ++ ) { $ field [ $ i ] [ ] = 0 ; } } $ dx = array ( array ( 1 , - 1 , 0 , 0 ) , array ( 1 , 1 , - 1 , - 1 ) , array ( 2 , - 2 , 0 , 0 ) , ) ; $ dy = array ( array ( 0 , 0 , 1 , - 1 ) , array ( 1 , - 1 , 1 , - 1 ) , array ( 0 , 0 , 2 , - 2 ) , ) ; while ( TRUE ) { fscanf ( STDIN , ' %d,%d,%d ' , $ x , $ y , $ size ) ; if ( feof ( STDIN ) ) { break ; } drop ( $ x , $ y , $ size ) ; } $ max = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { for ( $ j = 0 ; $ j < 10 ; $ j ++ ) { if ( $ field [ $ i ] [ $ j ] > $ max ) { $ max = $ field [ $ i ] [ $ j ] ; } elseif ( $ field [ $ i ] [ $ j ] === 0 ) { $ c ++ ; } } } echo $ c . PHP_EOL ; echo $ max . PHP_EOL ; function drop ( $ x , $ y , $ size ) { global $ field , $ dx , $ dy ; $ field [ $ y ] [ $ x ] ++ ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = 0 ; $ j < 4 ; $ j ++ ) { $ nx = $ x + $ dx [ $ i ] [ $ j ] ; $ ny = $ y + $ dy [ $ i ] [ $ j ] ; if ( isset ( $ field [ $ ny ] [ $ nx ] ) ) { $ field [ $ ny ] [ $ nx ] ++ ; } } } }",
    "label": 3
  },
  {
    "code": "<?php $ mp = array_fill ( 0 , 10 , array_fill ( 0 , 10 , 0 ) ) ; $ updateRange = [ ] ; $ updateRange [ 1 ] = [ [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] ] ; $ updateRange [ 2 ] = [ [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] ] ; $ updateRange [ 3 ] = [ [ 2 , 0 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 2 , 0 ] ] ; function drop ( $ x , $ y , $ size ) { global $ updateRange ; foreach ( $ updateRange [ $ size ] as $ point ) { list ( $ dx , $ dy ) = $ point ; $ nx = $ x + $ dx ; $ ny = $ y + $ dy ; update ( $ nx , $ ny ) ; } } function update ( $ nx , $ ny ) { global $ mp ; if ( ( 0 <= $ nx ) and ( $ nx < 10 ) and ( 0 <= $ ny ) and ( $ ny < 10 ) ) { $ mp [ $ ny ] [ $ nx ] ++ ; } } while ( fscanf ( STDIN , \" %d,%d,%d \" , $ x , $ y , $ s ) ) { drop ( $ x , $ y , $ s , $ updateRange , $ mp ) ; } $ cnt = 0 ; $ score = 0 ; for ( $ y = 0 ; $ y < 10 ; $ y ++ ) { for ( $ x = 0 ; $ x < 10 ; $ x ++ ) { if ( $ mp [ $ y ] [ $ x ] == 0 ) { $ cnt ++ ; } if ( $ mp [ $ y ] [ $ x ] > $ score ) { $ score = $ mp [ $ y ] [ $ x ] ; } } } echo $ cnt . \" \\n \" ; echo $ score . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ days = explode ( ' , ' , ' 0,31,60,91,121,152,182,213,244,274,305,335 ' ) ; $ format = explode ( ' , ' , ' Wednesday,Thursday,Friday,Saturday,Sunday,Monday,Tuesday ' ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d %d ' , $ m , $ d ) ; if ( $ m === 0 ) { break ; } $ n = $ days [ $ m - 1 ] + $ d ; $ today = $ format [ $ n % 7 ] ; echo $ today , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ day = array ( ' Wednesday ' , ' Thursday ' , ' Friday ' , ' Saturday ' , ' Sunday ' , ' Monday ' , ' Tuesday ' ) ; $ days = array ( 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ) ; $ sum = array ( 0 ) ; for ( $ i = 1 ; $ i < 12 ; $ i ++ ) { $ sum [ $ i ] = $ sum [ $ i - 1 ] + $ days [ $ i - 1 ] ; } while ( TRUE ) { fscanf ( STDIN , ' %d %d ' , $ m , $ d ) ; if ( $ m === 0 ) { break ; } $ d = ( $ sum [ $ m - 1 ] + $ d ) % 7 ; echo $ day [ $ d ] ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ days = explode ( ' , ' , ' 0,31,60,91,121,152,182,213,244,274,305,335 ' ) ; $ format = explode ( ' , ' , ' Wednesday,Thursday,Friday,Saturday,Sunday,Monday,Tuesday ' ) ; while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ) { if ( $ a == 0 ) { break ; } $ n = $ days [ $ a - 1 ] + $ b ; echo $ format [ $ n % 7 ] . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ) ; for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { $ arr [ $ i ] = 0 ; } while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d ' , $ n ) ; $ arr [ $ n ] ++ ; } $ max = max ( $ arr ) ; foreach ( $ arr as $ n => $ m ) { if ( $ m === $ max ) { echo $ n , PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ arr = array_fill ( 0 , 101 , 0 ) ; $ max = 0 ; while ( $ line = fgets ( STDIN ) ) { $ n = intval ( $ line ) ; $ arr [ $ n ] ++ ; if ( $ arr [ $ n ] > $ max ) { $ max = $ arr [ $ n ] ; } } for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { if ( $ arr [ $ i ] == $ max ) { echo $ i . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ list = array ( ) ; while ( true ) { $ list = trim ( fgets ( STDIN ) ) ; if ( $ list === ' ' ) { break ; } $ array [ ] = $ list ; } $ list = $ array ; $ count = array_count_values ( $ list ) ; $ max = max ( $ count ) ; $ num = array_keys ( $ count , $ max ) ; $ getans = array ( ) ; foreach ( $ num as $ value ) { $ getans [ ] = $ value ; } asort ( $ getans ) ; $ ans = implode ( \" \\n \" , $ getans ) ; echo $ ans ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ countList = array ( ) ; for ( $ i = 0 ; $ i <= 100 ; $ i ++ ) { $ countList [ $ i ] = 0 ; } for ( $ i = 0 ; $ i <= 100 ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line != \" \" ) { $ countList [ ( int ) $ line ] ++ ; } } $ maxNum = max ( $ countList ) ; foreach ( $ countList as $ num => $ count ) { if ( $ maxNum == $ count ) { echo $ num . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ N = array_fill ( 1 , 100 , \" \" ) ; for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { $ N [ $ i ] = trim ( fgets ( STDIN ) ) ; } $ count_num = array_count_values ( $ N ) ; unset ( $ count_num [ \" \" ] ) ; $ max_num = max ( $ count_num ) ; for ( $ i = 1 ; $ i <= count ( $ count_num ) ; $ i ++ ) { if ( in_array ( $ max_num , $ count_num ) ) { $ ans_num = array_search ( $ max_num , $ count_num ) ; unset ( $ count_num [ $ ans_num ] ) ; $ answer [ ] = $ ans_num ; } } sort ( $ answer ) ; foreach ( $ answer as $ value ) { echo ( $ value ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ hoge = array ( ) ; while ( $ hoge [ ] = trim ( fgets ( STDIN ) ) ) { } $ hage = array_count_values ( $ hoge ) ; $ max = max ( $ hage ) ; $ koge = array_keys ( $ hage , $ max ) ; sort ( $ koge , SORT_ASC ) ; foreach ( $ koge as $ val ) { echo $ val . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ list = array ( ) ; for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { $ list [ $ i ] = 0 ; } while ( TRUE ) { fscanf ( STDIN , ' %d ' , $ d ) ; if ( feof ( STDIN ) ) { break ; } $ list [ $ d ] ++ ; } $ mode = 0 ; for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { if ( $ list [ $ i ] > $ mode ) { $ mode = $ list [ $ i ] ; } } for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { if ( $ list [ $ i ] === $ mode ) { echo $ i ; echo PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ b = array_fill ( 1 , 100 , 0 ) ; while ( fscanf ( STDIN , ' %d ' , $ a ) ) { if ( is_null ( $ a ) ) { break ; } $ b [ $ a ] ++ ; } $ max = max ( $ b ) ; foreach ( $ b as $ c => $ d ) { if ( $ max === $ d ) { echo $ c . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ ary = [ ] ; for ( $ i = 0 ; $ i <= 100 ; $ i ++ ) { $ ary [ ] = 0 ; } while ( ! feof ( STDIN ) ) { $ a = intval ( fgets ( STDIN ) ) ; $ ary [ $ a ] ++ ; } $ max = max ( $ ary ) ; for ( $ i = 1 ; $ i <= 100 ; $ i ++ ) { if ( $ ary [ $ i ] == $ max ) { print $ i ; print PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ ary = array_fill ( 1 , 100 , 0 ) ; $ cnt = 0 ; while ( fscanf ( STDIN , ' %d ' , $ a ) ) { if ( is_null ( $ a ) ) { break ; } $ ary [ $ a ] ++ ; $ a = null ; } $ max = max ( $ ary ) ; foreach ( $ ary as $ n => $ m ) { if ( $ m === $ max ) { echo $ n , PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ str = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ str ) ; $ arr2 = array_count_values ( $ arr ) ; $ word1 = array_search ( max ( $ arr2 ) , $ arr2 ) ; $ word2 = ' ' ; foreach ( $ arr as $ s ) { if ( strlen ( $ s ) > strlen ( $ word2 ) ) { $ word2 = $ s ; } } printf ( \" %s %s \\n \" , $ word1 , $ word2 ) ;",
    "label": 3
  },
  {
    "code": "<?php $ max = \" \" ; $ strs = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; foreach ( $ strs as $ str ) { strlen ( $ max ) < strlen ( $ str ) && $ max = $ str ; } $ cnts = array_count_values ( $ strs ) ; arsort ( $ cnts ) ; echo key ( $ cnts ) , \" \" , $ max , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line === \" \" ) { break ; } $ words = explode ( \" \" , $ line ) ; $ wordsInfo = [ ] ; foreach ( $ words as $ word ) { if ( array_key_exists ( $ word , $ wordsInfo ) ) { $ wordsInfo [ $ word ] ++ ; } else { $ wordsInfo [ $ word ] = 1 ; } } $ maxCount = 0 ; $ maxCountWord = \" \" ; $ maxLengthWord = \" \" ; foreach ( $ words as $ word ) { if ( strlen ( $ maxLengthWord ) < strlen ( $ word ) ) { $ maxLengthWord = $ word ; } if ( $ maxCount < $ wordsInfo [ $ word ] ) { $ maxCount = $ wordsInfo [ $ word ] ; $ maxCountWord = $ word ; } } echo $ maxCountWord . \" \" . $ maxLengthWord . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ s = rtrim ( fgets ( STDIN ) ) ; $ s = explode ( ' ' , $ s ) ; $ hash = array ( ) ; $ max = ' ' ; $ mode = $ s [ 0 ] ; foreach ( $ s as $ w ) { if ( ! isset ( $ hash [ $ w ] ) ) { $ hash [ $ w ] = 0 ; } $ hash [ $ w ] ++ ; if ( $ hash [ $ w ] > $ hash [ $ mode ] ) { $ mode = $ w ; } if ( strlen ( $ w ) > strlen ( $ max ) ) { $ max = $ w ; } } echo sprintf ( ' %s %s ' , $ mode , $ max ) ; echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ list = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ list2 = $ list ; $ list3 = array ( ) ; for ( $ i = 0 ; $ i < count ( $ list ) ; $ i ++ ) { $ list3 [ $ list [ $ i ] ] = 0 ; } for ( $ i = 0 ; $ i < count ( $ list3 ) ; $ i ++ ) { $ list3 [ $ list [ $ i ] ] ++ ; } $ max = max ( $ list3 ) ; echo array_keys ( $ list3 , $ max ) [ 0 ] . \" \" ; array_multisort ( array_map ( \" strlen \" , $ list2 ) , SORT_DESC , $ list2 ) ; echo $ list2 [ 0 ] . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ line = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ res = array ( ) ; foreach ( $ line as $ val ) { if ( array_key_exists ( $ val , $ res ) ) { $ res [ $ val ] ++ ; } else { $ res [ $ val ] = 1 ; } } $ mastr ; $ maxstr ; $ ma = $ maxlen = 0 ; foreach ( $ res as $ key => $ val ) { if ( strlen ( $ key ) > $ maxlen ) { $ maxlen = strlen ( $ key ) ; $ maxstr = $ key ; } if ( $ val > $ ma ) { $ mastr = $ key ; $ ma = $ val ; } } echo $ mastr . ' ' . $ maxstr . PHP_EOL ; ?>",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { fscanf ( STDIN , ' %d %d ' , $ n , $ s ) ; if ( $ n === 0 && $ s === 0 ) { break ; } $ stack = array ( array ( 0 , 0 , - 1 ) ) ; $ c = 0 ; while ( count ( $ stack ) ) { $ node = array_pop ( $ stack ) ; if ( $ node [ 1 ] === $ n ) { if ( $ node [ 0 ] === $ s ) { $ c ++ ; } continue ; } for ( $ i = $ node [ 2 ] + 1 ; $ i <= 9 ; $ i ++ ) { $ stack [ ] = array ( $ node [ 0 ] + $ i , $ node [ 1 ] + 1 , $ i ) ; } } echo $ c . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ a = array ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; function dfs ( $ i , $ n , $ s , $ sum , $ stack ) { global $ a ; global $ ans ; if ( $ i == count ( $ a ) ) { if ( $ sum == $ s && count ( $ stack ) == $ n ) { $ ans [ ] = array_slice ( $ stack , 0 ) ; } return ; } dfs ( $ i + 1 , $ n , $ s , $ sum , $ stack ) ; array_push ( $ stack , $ a [ $ i ] ) ; dfs ( $ i + 1 , $ n , $ s , $ sum + $ a [ $ i ] , $ stack ) ; array_pop ( $ stack ) ; } while ( 1 ) { fscanf ( STDIN , ' %d %d ' , $ n , $ s ) ; $ i = 0 ; $ sum = 0 ; $ stack = array ( ) ; $ ans = array ( ) ; if ( $ n == 0 && $ s == 0 ) { break ; } dfs ( $ i , $ n , $ s , $ sum , $ stack ) ; $ len_ans = count ( $ ans ) ; echo $ len_ans ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d ' , $ weight ) ; $ bin = decbin ( $ weight ) ; $ arr = array_filter ( array_reverse ( str_split ( $ bin ) ) , function ( $ n ) { return ( int ) $ n === 1 ; } ) ; $ arr = array_map ( function ( $ n ) { return pow ( 2 , $ n ) ; } , array_keys ( $ arr ) ) ; echo implode ( ' ' , $ arr ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ ret = array ( ) ; $ g = intval ( $ line ) ; $ m = 1 ; while ( $ g > 0 ) { if ( ( $ g & 1 ) == 1 ) { $ ret [ ] = $ m ; } $ g = $ g >> 1 ; $ m = $ m << 1 ; } echo implode ( \" \" , $ ret ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php const W = array ( 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ) ; while ( $ n = ( int ) fgets ( STDIN ) ) echo implode ( ' ' , array_filter ( W , function ( $ v ) use ( & $ n ) { return ( $ v & $ n ) ; } ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ w = array ( 512 , 256 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ) ; while ( TRUE ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( feof ( STDIN ) ) { break ; } $ list = array ( ) ; foreach ( $ w as $ v ) { if ( $ n >= $ v ) { $ list [ ] = $ v ; $ n -= $ v ; } } $ list = array_reverse ( $ list ) ; echo implode ( ' ' , $ list ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ w = array ( 512 , 256 , 128 , 64 , 32 , 16 , 8 , 4 , 2 , 1 ) ; while ( TRUE ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( feof ( STDIN ) ) { break ; } $ list = array ( ) ; foreach ( $ w as $ v ) { if ( $ n >= $ v ) { $ list [ ] = $ v ; $ n -= $ v ; } } $ list = array_reverse ( $ list ) ; echo implode ( ' ' , $ list ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ count1 = 0 ; $ count2 = 0 ; while ( fscanf ( STDIN , \" %d,%d,%d \" , $ a , $ b , $ c ) ) { if ( $ a * $ a + $ b * $ b == $ c * $ c ) { $ count1 ++ ; } if ( $ a == $ b ) { $ count2 ++ ; } } echo $ count1 . \" \\n \" . $ count2 . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ rectangle = 0 ; $ rhombus = 0 ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d,%d,%d ' , $ a , $ b , $ c ) ; if ( $ a === $ b ) { $ rhombus ++ ; } elseif ( pow ( $ a , 2 ) + pow ( $ b , 2 ) === pow ( $ c , 2 ) ) { $ rectangle ++ ; } } printf ( \" %d \\n %d \\n \" , $ rectangle , $ rhombus ) ;",
    "label": 3
  },
  {
    "code": "<?php $ rect = 0 ; $ dia = 0 ; while ( $ line = fgets ( STDIN ) ) { $ arr = explode ( \" , \" , $ line ) ; $ l1 = intval ( $ arr [ 0 ] ) ; $ l2 = intval ( $ arr [ 1 ] ) ; $ r = intval ( $ arr [ 2 ] ) ; if ( $ l1 == $ l2 ) { $ dia ++ ; } else if ( $ l1 * $ l1 + $ l2 * $ l2 == $ r * $ r ) { $ rect ++ ; } } echo $ rect . \" \\n \" ; echo $ dia . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ l = 0 ; $ r = 0 ; while ( list ( $ a , $ b , $ c ) = fscanf ( STDIN , \" %d,%d,%d \\n \" ) ) { if ( $ a == $ b ) $ l ++ ; else if ( $ a * $ a + $ b * $ b == $ c * $ c ) $ r ++ ; } echo $ r . \" \\n \" . $ l . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ rec = 0 ; $ dia = 0 ; while ( TRUE ) { fscanf ( STDIN , ' %d,%d,%d ' , $ e1 , $ e2 , $ di ) ; if ( feof ( STDIN ) ) { break ; } if ( $ e1 * $ e1 + $ e2 * $ e2 === $ di * $ di ) { $ rec ++ ; } if ( $ e1 === $ e2 ) { $ dia ++ ; } } echo $ rec . PHP_EOL ; echo $ dia . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ x = 0 ; $ y = 0 ; while ( ! feof ( STDIN ) ) { fscanf ( STDIN , \" %d,%d,%d \" , $ a , $ b , $ c ) ; if ( $ a * $ a + $ b * $ b == $ c * $ c ) $ x ++ ; if ( $ a === $ b ) $ y ++ ; } echo $ x . \" \\n \" . $ y . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; $ B = 0 ; $ C = 0 ; $ bool = true ; foreach ( explode ( ' ' , $ line ) as $ ball ) { $ diff1 = $ ball - $ B ; $ diff2 = $ ball - $ C ; if ( $ diff1 < 0 && $ diff2 < 0 ) { $ bool = false ; break ; } elseif ( $ diff1 < 0 ) { $ C = $ ball ; } elseif ( $ diff2 < 0 ) { $ B = $ ball ; } else { if ( $ diff1 < $ diff2 ) { $ B = $ ball ; } else { $ C = $ ball ; } } } echo $ bool ? \" YES \\n \" : \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ b = $ c = 0 ; $ r = \" YES \" ; foreach ( $ a as $ vs ) { $ v = ( int ) $ vs ; if ( $ b < $ v ) $ b = $ v ; else if ( $ c < $ v ) $ c = $ v ; else { $ r = \" NO \" ; break ; } } echo $ r . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ b = $ c = 0 ; $ r = \" YES \" ; foreach ( $ a as $ vs ) { $ v = ( int ) $ vs ; if ( $ b < $ v ) $ b = $ v ; else if ( $ c < $ v ) $ c = $ v ; else { $ r = \" NO \" ; break ; } } echo $ r . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ rowcnt ) ; for ( $ row = 0 ; $ row < $ rowcnt ; $ row ++ ) { $ dataset = explode ( ' ' , rtrim ( fgets ( STDIN ) ) ) ; $ result = pushBall ( $ dataset ) ; if ( $ result ) { echo \" YES \" ; } else { echo \" NO \" ; } echo PHP_EOL ; } function pushBall ( $ dataset ) { $ b = new Tube ( ) ; $ c = new Tube ( ) ; foreach ( $ dataset as $ n ) { if ( $ b -> isPushable ( $ n ) && $ c -> isPushable ( $ n ) ) { if ( $ b -> peek ( ) < $ c -> peek ( ) ) { $ c -> push ( $ n ) ; } else { $ b -> push ( $ n ) ; } } else if ( $ b -> isPushable ( $ n ) ) { $ b -> push ( $ n ) ; } else if ( $ c -> isPushable ( $ n ) ) { $ c -> push ( $ n ) ; } else { return false ; } } return true ; } class Tube { private $ tube = [ ] ; public function __construct ( ) { $ this -> tube [ ] = 0 ; } public function isPushable ( $ n ) { if ( $ this -> peek ( ) < $ n ) { return true ; } else { return false ; } } public function push ( $ n ) { $ this -> tube [ ] = $ n ; } public function peek ( ) { $ idxLast = count ( $ this -> tube ) - 1 ; return $ this -> tube [ $ idxLast ] ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = 0 ; $ b = 0 ; $ f = 0 ; fscanf ( STDIN , \" %d %d %d %d %d %d %d %d %d %d \" , $ ar [ 0 ] , $ ar [ 1 ] , $ ar [ 2 ] , $ ar [ 3 ] , $ ar [ 4 ] , $ ar [ 5 ] , $ ar [ 6 ] , $ ar [ 7 ] , $ ar [ 8 ] , $ ar [ 9 ] ) ; for ( $ j = 0 ; $ j < 10 ; $ j ++ ) { if ( $ ar [ $ j ] > $ a && $ ar [ $ j ] > $ b ) { if ( $ a > $ b ) $ a = $ ar [ $ j ] ; else $ b = $ ar [ $ j ] ; } else if ( $ ar [ $ j ] > $ a ) $ a = $ ar [ $ j ] ; else if ( $ ar [ $ j ] > $ b ) $ b = $ ar [ $ j ] ; else $ f = 1 ; } if ( $ f == 1 ) print \" NO \\n \" ; else print \" YES \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , rtrim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ a [ $ i ] > $ b ) { $ b = $ a [ $ i ] ; } elseif ( $ a [ $ i ] > $ c ) { $ c = $ a [ $ i ] ; if ( $ c > $ b ) { $ tmp = $ b ; $ b = $ c ; $ c - $ tmp ; } } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , rtrim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ a [ $ i ] > $ b ) { $ b = $ a [ $ i ] ; } elseif ( $ a [ $ i ] > $ c ) { $ c = $ a [ $ i ] ; if ( $ c > $ b ) { $ tmp = $ b ; $ b = $ c ; $ c = $ tmp ; } } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ a [ $ i ] > $ b ) { $ b = $ a [ $ i ] ; } elseif ( $ a [ $ i ] > $ c ) { $ c = $ a [ $ i ] ; if ( $ c > $ b ) { $ tmp = $ b ; $ b = $ c ; $ c = $ tmp ; } } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ a [ $ i ] > $ b ) { $ b = $ a [ $ i ] ; } elseif ( $ a [ $ i ] > $ c ) { $ c = $ a [ $ i ] ; } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ a [ $ i ] > $ b ) { $ b = $ a [ $ i ] ; } elseif ( $ a [ $ i ] > $ c ) { $ c = $ a [ $ i ] ; } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ diff_ab = $ a [ $ i ] - $ b ; $ diff_ac = $ a [ $ i ] - $ c ; if ( $ diff_ab > 0 && $ diff_ac > 0 ) { if ( $ diff_ab <= $ diff_ac ) { $ b = $ a [ $ i ] ; } else { $ c = $ a [ $ i ] ; } } else if ( $ diff_ab > 0 ) { $ b = $ a [ $ i ] ; } else if ( $ diff_ac > 0 ) { $ c = $ a [ $ i ] ; } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ count = 0 ; $ count < $ n ; $ count ++ ) { $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ b = 0 ; $ c = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ diff_ab = $ a [ $ i ] - $ b ; $ diff_ac = $ a [ $ i ] - $ c ; if ( $ diff_ab > 0 && $ diff_ac > 0 ) { if ( $ diff_ab <= $ diff_ac ) { $ b = $ a [ $ i ] ; } else { $ c = $ a [ $ i ] ; } } else if ( $ diff_ab > 0 ) { $ b = $ a [ $ i ] ; } else if ( $ diff_ac > 0 ) { $ c = $ a [ $ i ] ; } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ t ) ; for ( $ j = 0 ; $ j < $ t ; $ j ++ ) { $ list = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ list [ $ i ] > $ a ) { $ a = $ list [ $ i ] ; } else if ( $ list [ $ i ] > $ b ) { $ b = $ list [ $ i ] ; } else { break ; } } echo $ i === 10 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ arr = explode ( ' , ' , $ line ) ; $ v2 = array_pop ( $ arr ) ; $ v1 = array_pop ( $ arr ) ; $ sp = $ v1 + $ v2 ; $ distance = array_sum ( $ arr ) ; $ n = $ v1 * $ distance / $ sp ; $ sum = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ sum >= $ n ) { echo $ i + 1 , PHP_EOL ; break ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ rect = 0 ; $ dia = 0 ; while ( $ line = fgets ( STDIN ) ) { $ arr = explode ( \" , \" , $ line ) ; $ v1 = intval ( $ arr [ 10 ] ) ; $ v2 = intval ( $ arr [ 11 ] ) ; $ s = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ s += intval ( $ arr [ $ i ] ) ; } $ x = $ v1 * $ s / ( $ v1 + $ v2 ) ; $ s = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ s += $ arr [ $ i ] ; if ( $ x <= $ s ) { break ; } } $ i ++ ; echo $ i . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { $ a = fscanf ( STDIN , ' %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d ' ) ; if ( feof ( STDIN ) ) { break ; } $ v = array ( $ a [ 10 ] , $ a [ 11 ] ) ; $ l = array ( 0 ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ l [ $ i + 1 ] = $ l [ $ i ] + $ a [ $ i ] ; $ sum += $ a [ $ i ] ; } $ m = $ sum * $ v [ 0 ] / ( $ v [ 0 ] + $ v [ 1 ] ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ m > $ l [ $ i ] && $ m <= $ l [ $ i + 1 ] ) { echo $ i + 1 ; echo PHP_EOL ; break ; } } }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , ' %s ' , $ in ) ) { $ ary = preg_split ( ' /,/ ' , $ in ) ; $ l_ary = array_map ( ' intval ' , array_slice ( $ ary , 0 , 10 ) ) ; $ v_ary = array_map ( ' intval ' , array_slice ( $ ary , - 2 , 2 ) ) ; $ sum = array_sum ( $ l_ary ) ; $ pass_by_point = $ sum * $ v_ary [ 0 ] / array_sum ( $ v_ary ) ; $ move_value = 0 ; $ division_cnt = 0 ; while ( $ move_value < $ pass_by_point ) { $ move_value += $ l_ary [ $ division_cnt ] ; $ division_cnt ++ ; } echo $ division_cnt . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ map = array ( ) ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line === ' ' ) { break 2 ; } $ map [ $ i ] = str_split ( $ line ) ; } foreach ( $ map as $ y => $ arr ) { foreach ( $ arr as $ x => $ n ) { if ( $ n !== ' 1 ' ) { continue ; } echo search ( $ map , $ x , $ y ) , PHP_EOL ; break 2 ; } } fgets ( STDIN ) ; } function search ( $ map , $ x , $ y ) { $ right = isset ( $ map [ $ y ] [ $ x + 1 ] ) && $ map [ $ y ] [ $ x + 1 ] === ' 1 ' ; $ bottomRight = isset ( $ map [ $ y + 1 ] [ $ x + 1 ] ) && $ map [ $ y + 1 ] [ $ x + 1 ] === ' 1 ' ; $ bottom = isset ( $ map [ $ y + 1 ] [ $ x ] ) && $ map [ $ y + 1 ] [ $ x ] === ' 1 ' ; $ bottomLeft = isset ( $ map [ $ y + 1 ] [ $ x - 1 ] ) && $ map [ $ y + 1 ] [ $ x - 1 ] === ' 1 ' ; if ( $ right && $ bottomRight && $ bottom ) { return ' A ' ; } elseif ( $ right && $ bottomRight ) { return ' E ' ; } elseif ( $ right && $ bottom ) { return ' G ' ; } elseif ( $ bottomRight && $ bottom ) { return ' F ' ; } elseif ( $ right ) { return ' C ' ; } elseif ( $ bottomLeft ) { return ' D ' ; } else { return ' B ' ; } }",
    "label": 3
  },
  {
    "code": "<?php $ string_tmp = array ( ) ; $ ans_set = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ tmp [ ] = trim ( $ line ) ; } $ max_lenge = 8 ; foreach ( $ tmp as $ val ) { $ max_lenge -- ; if ( preg_match ( ' /1/ ' , $ val ) ) { $ string_tmp [ ] = $ val ; } if ( $ max_lenge < 0 ) { $ tmp_length = count ( $ string_tmp ) ; if ( $ tmp_length == 4 ) { $ ans_set [ ] = \" B \" ; } elseif ( $ tmp_length == 1 ) { $ ans_set [ ] = \" C \" ; } elseif ( $ tmp_length == 2 ) { $ ans_set [ ] = judge_line2 ( $ string_tmp ) ; } elseif ( $ tmp_length == 3 ) { $ ans_set [ ] = judge_line3 ( $ string_tmp ) ; } $ string_tmp = array ( ) ; $ max_lenge = 8 ; } } $ ans_set [ ] = judge ( $ string_tmp ) ; foreach ( $ ans_set as $ val ) { echo $ val . \" \\n \" ; } function judge ( $ string_tmp ) { $ ans ; $ tmp_length = count ( $ string_tmp ) ; if ( $ tmp_length == 4 ) { $ ans = \" B \" ; } elseif ( $ tmp_length == 1 ) { $ ans = \" C \" ; } elseif ( $ tmp_length == 2 ) { $ ans = judge_line2 ( $ string_tmp ) ; } elseif ( $ tmp_length == 3 ) { $ ans = judge_line3 ( $ string_tmp ) ; } return $ ans ; } function judge_line2 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos == $ pos2 ) { return \" A \" ; } elseif ( $ pos < $ pos2 ) { return \" E \" ; } else { return \" G \" ; } } function judge_line3 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos > $ pos2 ) { return \" D \" ; } else { return \" F \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ string_tmp = array ( ) ; $ ans_set = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ tmp [ ] = trim ( $ line ) ; } $ max_lenge = 8 ; foreach ( $ tmp as $ val ) { $ max_lenge -- ; if ( preg_match ( ' /1/ ' , $ val ) ) { $ string_tmp [ ] = $ val ; } if ( $ max_lenge < 0 ) { $ ans_set [ ] = judge ( $ string_tmp ) ; $ string_tmp = array ( ) ; $ max_lenge = 8 ; } } $ ans_set [ ] = judge ( $ string_tmp ) ; foreach ( $ ans_set as $ val ) { echo $ val . \" \\n \" ; } function judge ( $ string_tmp ) { $ ans ; $ tmp_length = count ( $ string_tmp ) ; if ( $ tmp_length == 4 ) { $ ans = \" B \" ; } elseif ( $ tmp_length == 1 ) { $ ans = \" C \" ; } elseif ( $ tmp_length == 2 ) { $ ans = judge_line2 ( $ string_tmp ) ; } elseif ( $ tmp_length == 3 ) { $ ans = judge_line3 ( $ string_tmp ) ; } return $ ans ; } function judge_line2 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos == $ pos2 ) { return \" A \" ; } elseif ( $ pos < $ pos2 ) { return \" E \" ; } else { return \" G \" ; } } function judge_line3 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos > $ pos2 ) { return \" D \" ; } else { return \" F \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ string_tmp = array ( ) ; $ ans_set = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ tmp [ ] = trim ( $ line ) ; } $ max_lenge = 8 ; foreach ( $ tmp as $ val ) { $ max_lenge -- ; if ( preg_match ( ' /1/ ' , $ val ) ) { $ string_tmp [ ] = $ val ; } if ( $ max_lenge < 0 ) { $ ans_set [ ] = judge ( $ string_tmp ) ; $ string_tmp = array ( ) ; $ max_lenge = 8 ; } } $ ans_set [ ] = judge ( $ string_tmp ) ; foreach ( $ ans_set as $ val ) { echo $ val . \" \\n \" ; } function judge ( $ string_tmp ) { $ ans ; $ tmp_length = count ( $ string_tmp ) ; if ( $ tmp_length == 4 ) { $ ans = \" B \" ; } elseif ( $ tmp_length == 1 ) { $ ans = \" C \" ; } elseif ( $ tmp_length == 2 ) { $ ans = judge_line2 ( $ string_tmp ) ; } elseif ( $ tmp_length == 3 ) { $ ans = judge_line3 ( $ string_tmp ) ; } return $ ans ; } function judge_line2 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos == $ pos2 ) { return \" A \" ; } elseif ( $ pos < $ pos2 ) { return \" E \" ; } else { return \" G \" ; } } function judge_line3 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos > $ pos2 ) { return \" D \" ; } else { return \" F \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ string_tmp = array ( ) ; $ ans_set = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ tmp [ ] = trim ( $ line ) ; } $ max_lenge = 8 ; foreach ( $ tmp as $ val ) { $ max_lenge -- ; if ( preg_match ( ' /1/ ' , $ val ) ) { $ string_tmp [ ] = $ val ; } if ( $ max_lenge < 0 ) { $ ans_set [ ] = judge ( $ string_tmp ) ; $ string_tmp = array ( ) ; $ max_lenge = 8 ; } } $ ans_set [ ] = judge ( $ string_tmp ) ; foreach ( $ ans_set as $ val ) { echo $ val . \" \\n \" ; } function judge ( $ string_tmp ) { $ ans ; $ tmp_length = count ( $ string_tmp ) ; if ( $ tmp_length == 4 ) { $ ans = \" B \" ; } elseif ( $ tmp_length == 1 ) { $ ans = \" C \" ; } elseif ( $ tmp_length == 2 ) { $ ans = judge_line2 ( $ string_tmp ) ; } elseif ( $ tmp_length == 3 ) { $ ans = judge_line3 ( $ string_tmp ) ; } return $ ans ; } function judge_line2 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos == $ pos2 ) { return \" A \" ; } elseif ( $ pos < $ pos2 ) { return \" E \" ; } else { return \" G \" ; } } function judge_line3 ( $ string_tmp ) { $ pos = strpos ( $ string_tmp [ 0 ] , \" 1 \" ) ; $ pos2 = strpos ( $ string_tmp [ 1 ] , \" 1 \" ) ; if ( $ pos > $ pos2 ) { return \" D \" ; } else { return \" F \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { $ field = array ( ) ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { $ field [ ] = str_split ( rtrim ( fgets ( STDIN ) ) ) ; } if ( feof ( STDIN ) ) { break ; } for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { for ( $ j = 0 ; $ j < 8 ; $ j ++ ) { if ( $ field [ $ i ] [ $ j ] === ' 1 ' ) { break 2 ; } } } $ f = ' A ' ; if ( isset ( $ field [ $ i + 3 ] [ $ j ] ) && $ field [ $ i + 3 ] [ $ j ] === ' 1 ' ) { $ f = ' B ' ; } elseif ( isset ( $ field [ $ i ] [ $ j + 3 ] ) && $ field [ $ i ] [ $ j + 3 ] === ' 1 ' ) { $ f = ' C ' ; } elseif ( isset ( $ field [ $ i + 2 ] [ $ j - 1 ] ) && $ field [ $ i + 2 ] [ $ j - 1 ] === ' 1 ' ) { $ f = ' D ' ; } elseif ( isset ( $ field [ $ i + 1 ] [ $ j + 2 ] ) && $ field [ $ i + 1 ] [ $ j + 2 ] === ' 1 ' ) { $ f = ' E ' ; } elseif ( isset ( $ field [ $ i + 2 ] [ $ j + 1 ] ) && $ field [ $ i + 2 ] [ $ j + 1 ] === ' 1 ' ) { $ f = ' F ' ; } elseif ( isset ( $ field [ $ i + 1 ] [ $ j - 1 ] ) && $ field [ $ i + 1 ] [ $ j - 1 ] ) { $ f = ' G ' ; } echo $ f . PHP_EOL ; fscanf ( STDIN , ' ' ) ; }",
    "label": 3
  },
  {
    "code": "<?php const DIRS = array ( ' R ' , ' D ' , ' L ' , ' U ' ) ; $ p = array ( 1 , 0 , 0 ) ; $ path = ' R ' ; $ step = array ( array ( 1 , 0 ) , array ( 0 , 1 ) , array ( - 1 , 0 ) , array ( 0 , - 1 ) ) ; function frontIsClear ( $ p , $ l ) { list ( $ x , $ y , $ d ) = $ p ; return ( $ d == 0 && ( $ y > 0 ? ! $ l [ 2 * $ y - 1 ] [ $ x ] : 1 ) ) || ( $ d == 1 && ( $ x < 4 ? ! $ l [ 2 * $ y ] [ $ x ] : 1 ) ) || ( $ d == 2 && ( $ y < 4 ? ! $ l [ 2 * $ y + 1 ] [ $ x ] : 1 ) ) || ( $ d == 3 && ( $ x > 0 ? ! $ l [ 2 * $ y ] [ $ x - 1 ] : 1 ) ) ; } function canMove ( $ p , $ l ) { list ( $ x , $ y , $ d ) = $ p ; switch ( $ p [ 2 ] ) { case 0 : return $ x != 4 && $ l [ 2 * $ y ] [ $ x ] ; case 1 : return $ y != 4 && $ l [ 2 * $ y + 1 ] [ $ x ] ; case 2 : return $ x != 0 && $ l [ 2 * $ y ] [ $ x - 1 ] ; case 3 : return $ y != 0 && $ l [ 2 * $ y - 1 ] [ $ x ] ; } } function move ( & $ p , $ step ) { $ p [ 0 ] = $ p [ 0 ] + $ step [ $ p [ 2 ] ] [ 0 ] ; $ p [ 1 ] = $ p [ 1 ] + $ step [ $ p [ 2 ] ] [ 1 ] ; } for ( $ i = 0 ; $ i < 9 ; $ i ++ ) $ l [ ] = trim ( fgets ( STDIN ) ) ; while ( true ) { if ( ! frontIsClear ( $ p , $ l ) ) { $ p [ 2 ] = ( $ p [ 2 ] + 3 ) % 4 ; } else { while ( ! canMove ( $ p , $ l ) ) { $ p [ 2 ] = ( $ p [ 2 ] + 1 ) % 4 ; } } if ( $ p == array ( 0 , 0 , 0 ) ) break ; move ( $ p , $ step ) ; $ path .= DIRS [ $ p [ 2 ] ] ; } echo $ path . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = array ( ' R ' , ' D ' , ' L ' , ' U ' ) ; $ p = array ( 1 , 0 , 0 ) ; $ path = ' R ' ; $ step = array ( array ( 1 , 0 ) , array ( 0 , 1 ) , array ( - 1 , 0 ) , array ( 0 , - 1 ) ) ; function frontIsClear ( $ p , $ l ) { list ( $ x , $ y , $ d ) = $ p ; return ( $ d == 0 && ( $ y > 0 ? ! $ l [ 2 * $ y - 1 ] [ $ x ] : 1 ) ) || ( $ d == 1 && ( $ x < 4 ? ! $ l [ 2 * $ y ] [ $ x ] : 1 ) ) || ( $ d == 2 && ( $ y < 4 ? ! $ l [ 2 * $ y + 1 ] [ $ x ] : 1 ) ) || ( $ d == 3 && ( $ x > 0 ? ! $ l [ 2 * $ y ] [ $ x - 1 ] : 1 ) ) ; } function canMove ( $ p , $ l ) { list ( $ x , $ y , $ d ) = $ p ; switch ( $ p [ 2 ] ) { case 0 : return $ x != 4 && $ l [ 2 * $ y ] [ $ x ] ; case 1 : return $ y != 4 && $ l [ 2 * $ y + 1 ] [ $ x ] ; case 2 : return $ x != 0 && $ l [ 2 * $ y ] [ $ x - 1 ] ; case 3 : return $ y != 0 && $ l [ 2 * $ y - 1 ] [ $ x ] ; } } function move ( & $ p , $ step ) { $ p [ 0 ] = $ p [ 0 ] + $ step [ $ p [ 2 ] ] [ 0 ] ; $ p [ 1 ] = $ p [ 1 ] + $ step [ $ p [ 2 ] ] [ 1 ] ; } for ( $ i = 0 ; $ i < 9 ; $ i ++ ) $ l [ ] = trim ( fgets ( STDIN ) ) ; while ( true ) { if ( ! frontIsClear ( $ p , $ l ) ) { $ p [ 2 ] = ( $ p [ 2 ] + 3 ) % 4 ; } else { while ( ! canMove ( $ p , $ l ) ) { $ p [ 2 ] = ( $ p [ 2 ] + 1 ) % 4 ; } } if ( $ p == array ( 0 , 0 , 0 ) ) break ; move ( $ p , $ step ) ; $ path .= DIRS [ $ p [ 2 ] ] ; } echo $ path . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ p = array ( 1 , 0 , 0 ) ; $ path = array ( ' R ' ) ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; function frontIsClear ( $ x , $ y , $ d , $ l ) { return ( $ d == 0 && ( $ y > 0 ? ! $ l [ 2 * $ y - 1 ] [ $ x ] : 1 ) ) || ( $ d == 1 && ( $ x < 4 ? ! $ l [ 2 * $ y ] [ $ x ] : 1 ) ) || ( $ d == 2 && ( $ y < 4 ? ! $ l [ 2 * $ y + 1 ] [ $ x ] : 1 ) ) || ( $ d == 3 && ( $ x > 0 ? ! $ l [ 2 * $ y ] [ $ x - 1 ] : 1 ) ) ; } function canMove ( $ x , $ y , $ d , $ l ) { return ( $ d == 0 && $ x != 4 && $ l [ 2 * $ y ] [ $ x ] ) || ( $ d == 1 && $ y != 4 && $ l [ 2 * $ y + 1 ] [ $ x ] ) || ( $ d == 2 && $ x != 0 && $ l [ 2 * $ y ] [ $ x - 1 ] ) || ( $ d == 3 && $ y != 0 && $ l [ 2 * $ y - 1 ] [ $ x ] ) ; } function move ( & $ p , $ stepx , $ stepy ) { if ( $ p [ 2 ] == 0 || $ p [ 2 ] == 2 ) $ p [ 0 ] = $ p [ 0 ] + $ stepx [ $ p [ 2 ] ] ; else $ p [ 1 ] = $ p [ 1 ] + $ stepy [ $ p [ 2 ] ] ; } for ( $ i = 0 ; $ i < 9 ; $ i ++ ) $ l [ ] = trim ( fgets ( STDIN ) ) ; while ( true ) { if ( ! frontIsClear ( $ p [ 0 ] , $ p [ 1 ] , $ p [ 2 ] , $ l ) ) { $ p [ 2 ] = ( $ p [ 2 ] + 3 ) % 4 ; } else { while ( ! canMove ( $ p [ 0 ] , $ p [ 1 ] , $ p [ 2 ] , $ l ) ) $ p [ 2 ] = ( $ p [ 2 ] + 1 ) % 4 ; } if ( $ p == array ( 0 , 0 , 0 ) ) break ; move ( $ p , $ stepx , $ stepy ) ; $ path [ ] = DIRS [ $ p [ 2 ] ] ; } echo implode ( ' ' , $ path ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ p = array ( 1 , 0 , 0 ) ; $ path = array ( ' R ' ) ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; function frontIsClear ( $ x , $ y , $ d , $ l ) { return ( $ d == 0 && ( $ y > 0 ? ! $ l [ 2 * $ y - 1 ] [ $ x ] : 1 ) ) || ( $ d == 1 && ( $ x < 4 ? ! $ l [ 2 * $ y ] [ $ x ] : 1 ) ) || ( $ d == 2 && ( $ y < 4 ? ! $ l [ 2 * $ y + 1 ] [ $ x ] : 1 ) ) || ( $ d == 3 && ( $ x > 0 ? ! $ l [ 2 * $ y ] [ $ x - 1 ] : 1 ) ) ; } function canMove ( $ x , $ y , $ d , $ l ) { return ( $ d == 0 && $ x != 4 && $ l [ 2 * $ y ] [ $ x ] ) || ( $ d == 1 && $ y != 4 && $ l [ 2 * $ y + 1 ] [ $ x ] ) || ( $ d == 2 && $ x != 0 && $ l [ 2 * $ y ] [ $ x - 1 ] ) || ( $ d == 3 && $ y != 0 && $ l [ 2 * $ y - 1 ] [ $ x ] ) ; } function move ( & $ p , $ stepx , $ stepy ) { if ( $ p [ 2 ] == 0 || $ p [ 2 ] == 2 ) $ p [ 0 ] = $ p [ 0 ] + $ stepx [ $ p [ 2 ] ] ; else $ p [ 1 ] = $ p [ 1 ] + $ stepy [ $ p [ 2 ] ] ; } for ( $ i = 0 ; $ i < 9 ; $ i ++ ) $ l [ ] = trim ( fgets ( STDIN ) ) ; while ( true ) { if ( ! frontIsClear ( $ p [ 0 ] , $ p [ 1 ] , $ p [ 2 ] , $ l ) ) { $ p [ 2 ] = ( $ p [ 2 ] + 3 ) % 4 ; } else { while ( ! canMove ( $ p [ 0 ] , $ p [ 1 ] , $ p [ 2 ] , $ l ) ) $ p [ 2 ] = ( $ p [ 2 ] + 1 ) % 4 ; } if ( $ p == array ( 0 , 0 , 0 ) ) break ; move ( $ p , $ stepx , $ stepy ) ; $ path [ ] = DIRS [ $ p [ 2 ] ] ; } echo implode ( ' ' , $ path ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ p = array ( 2 , 1 , 0 ) ; $ path = array ( ' R ' ) ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; function check ( $ x , $ y , $ j , $ v , $ h ) { return ( $ j == 0 && $ v [ $ y - 1 ] [ $ x ] ) || ( $ j == 1 && $ h [ $ y ] [ $ x ] ) || ( $ j == 2 && $ v [ $ y ] [ $ x ] ) || ( $ j == 3 && $ h [ $ y ] [ $ x - 1 ] ) ; } while ( ! ( $ p [ 0 ] == 1 && $ p [ 1 ] == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ p [ 2 ] + $ i ) % 4 ; if ( check ( $ p [ 0 ] , $ p [ 1 ] , $ d , $ v , $ h ) == 1 ) { $ p [ 0 ] += $ stepx [ ( $ d + 3 ) % 4 ] ; $ p [ 1 ] += $ stepy [ ( $ d + 3 ) % 4 ] ; $ p [ 2 ] = ( $ d + 3 ) % 4 ; break ; } } $ path [ ] = DIRS [ $ p [ 2 ] ] ; } echo implode ( ' ' , $ path ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ p = array ( 2 , 1 , 0 ) ; $ path = array ( ' R ' ) ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; function check ( $ x , $ y , $ j , $ v , $ h ) { return ( $ j == 0 && $ v [ $ y - 1 ] [ $ x ] ) || ( $ j == 1 && $ h [ $ y ] [ $ x ] ) || ( $ j == 2 && $ v [ $ y ] [ $ x ] ) || ( $ j == 3 && $ h [ $ y ] [ $ x - 1 ] ) ; } while ( ! ( $ p [ 0 ] == 1 && $ p [ 1 ] == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ p [ 2 ] + $ i ) % 4 ; if ( check ( $ p [ 0 ] , $ p [ 1 ] , $ d , $ v , $ h ) == 1 ) { $ p [ 0 ] += $ stepx [ ( $ d + 3 ) % 4 ] ; $ p [ 1 ] += $ stepy [ ( $ d + 3 ) % 4 ] ; $ p [ 2 ] = ( $ d + 3 ) % 4 ; break ; } } $ path [ ] = DIRS [ $ p [ 2 ] ] ; } echo implode ( ' ' , $ path ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ p = array ( 2 , 1 , 0 ) ; $ path = ' R ' ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; while ( ! ( $ p [ 0 ] == 1 && $ p [ 1 ] == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ p [ 2 ] + $ i ) % 4 ; $ d2 = ( $ d + 3 ) % 4 ; if ( ( $ d == 0 && $ v [ $ p [ 1 ] - 1 ] [ $ p [ 0 ] ] ) || ( $ d == 1 && $ h [ $ p [ 1 ] ] [ $ p [ 0 ] ] ) || ( $ d == 2 && $ v [ $ p [ 1 ] ] [ $ p [ 0 ] ] ) || ( $ d == 3 && $ h [ $ p [ 1 ] ] [ $ p [ 0 ] - 1 ] ) ) { $ p [ 0 ] += $ stepx [ $ d2 ] ; $ p [ 1 ] += $ stepy [ $ d2 ] ; $ p [ 2 ] = $ d2 ; break ; } } $ path .= DIRS [ $ p [ 2 ] ] ; } echo $ path . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ x = 2 ; $ y = 1 ; $ dir = 0 ; $ path = ' R ' ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; while ( ! ( $ x == 1 && $ y == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ dir + $ i ) % 4 ; $ d2 = ( $ d + 3 ) % 4 ; if ( ( $ d == 0 && $ v [ $ y - 1 ] [ $ x ] ) || ( $ d == 1 && $ h [ $ y ] [ $ x ] ) || ( $ d == 2 && $ v [ $ y ] [ $ x ] ) || ( $ d == 3 && $ h [ $ y ] [ $ x - 1 ] ) ) { $ x += $ stepx [ $ d2 ] ; $ y += $ stepy [ $ d2 ] ; $ dir = $ d2 ; break ; } } $ path .= DIRS [ $ dir ] ; } echo $ path . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ x = 2 ; $ y = 1 ; $ dir = 0 ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; echo ' R ' ; while ( ! ( $ x == 1 && $ y == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ dir + $ i ) % 4 ; $ d2 = ( $ d + 3 ) % 4 ; if ( ( $ d == 0 && $ v [ $ y - 1 ] [ $ x ] ) || ( $ d == 1 && $ h [ $ y ] [ $ x ] ) || ( $ d == 2 && $ v [ $ y ] [ $ x ] ) || ( $ d == 3 && $ h [ $ y ] [ $ x - 1 ] ) ) { $ x += $ stepx [ $ d2 ] ; $ y += $ stepy [ $ d2 ] ; $ dir = $ d2 ; break ; } } echo DIRS [ $ dir ] ; } echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ x = 2 ; $ y = 1 ; $ dir = 0 ; $ p = ' R ' ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; while ( ! ( $ x == 1 && $ y == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ dir + $ i ) % 4 ; if ( ( $ d == 0 && $ v [ $ y - 1 ] [ $ x ] ) || ( $ d == 1 && $ h [ $ y ] [ $ x ] ) || ( $ d == 2 && $ v [ $ y ] [ $ x ] ) || ( $ d == 3 && $ h [ $ y ] [ $ x - 1 ] ) ) { $ d2 = ( $ d + 3 ) % 4 ; $ x += $ stepx [ $ d2 ] ; $ y += $ stepy [ $ d2 ] ; $ dir = $ d2 ; break ; } } $ p .= DIRS [ $ dir ] ; } echo $ p . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php const DIRS = \" RDLU \" ; $ h [ ] = \" 000000 \" ; $ v [ ] = \" 0000000 \" ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; } $ h [ ] = \" 0 \" . trim ( fgets ( STDIN ) ) . \" 0 \" ; $ v [ ] = $ v [ 0 ] ; $ h [ ] = $ h [ 0 ] ; $ x = 2 ; $ y = 1 ; $ dir = 0 ; $ p = ' R ' ; $ stepx = array ( 1 , 0 , - 1 , 0 ) ; $ stepy = array ( 0 , 1 , 0 , - 1 ) ; while ( ! ( $ x == 1 && $ y == 1 ) ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ d = ( $ dir + $ i + 3 ) % 4 ; if ( ( $ d == 3 && $ v [ $ y - 1 ] [ $ x ] ) || ( $ d == 0 && $ h [ $ y ] [ $ x ] ) || ( $ d == 1 && $ v [ $ y ] [ $ x ] ) || ( $ d == 2 && $ h [ $ y ] [ $ x - 1 ] ) ) { $ x += $ stepx [ $ d ] ; $ y += $ stepy [ $ d ] ; $ dir = $ d ; break ; } } $ p .= DIRS [ $ dir ] ; } echo $ p . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' display_errors ' , 1 ) ; $ ud = array ( ) ; $ side = array ( ) ; $ direction = array ( ' R ' , ' L ' , ' D ' , ' U ' ) ; $ cood = array ( array ( 0 , 1 ) , array ( 0 , - 1 ) , array ( 1 , 0 ) , array ( - 1 , 0 ) ) ; $ ud [ ] = str_split ( rtrim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ side [ ] = str_split ( rtrim ( fgets ( STDIN ) ) ) ; $ ud [ ] = str_split ( rtrim ( fgets ( STDIN ) ) ) ; } $ field = array_fill ( 0 , 5 , array_fill ( 0 , 5 , array_fill ( 0 , 4 , 0 ) ) ) ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { for ( $ j = 0 ; $ j < 5 ; $ j ++ ) { if ( isset ( $ side [ $ i - 1 ] [ $ j ] ) && $ side [ $ i - 1 ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 0 ] = 3 ; } elseif ( isset ( $ ud [ $ i ] [ $ j ] ) && $ ud [ $ i ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 0 ] = 0 ; } elseif ( isset ( $ side [ $ i ] [ $ j ] ) && $ side [ $ i ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 0 ] = 2 ; } else { $ field [ $ i ] [ $ j ] [ 0 ] = 1 ; } if ( isset ( $ side [ $ i ] [ $ j ] ) && $ side [ $ i ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 1 ] = 2 ; } elseif ( isset ( $ ud [ $ i ] [ $ j - 1 ] ) && $ ud [ $ i ] [ $ j - 1 ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 1 ] = 1 ; } elseif ( isset ( $ side [ $ i - 1 ] [ $ j ] ) && $ side [ $ i - 1 ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 1 ] = 3 ; } else { $ field [ $ i ] [ $ j ] [ 1 ] = 0 ; } if ( isset ( $ ud [ $ i ] [ $ j ] ) && $ ud [ $ i ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 2 ] = 0 ; } elseif ( isset ( $ side [ $ i ] [ $ j ] ) && $ side [ $ i ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 2 ] = 2 ; } elseif ( isset ( $ ud [ $ i ] [ $ j - 1 ] ) && $ ud [ $ i ] [ $ j - 1 ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 2 ] = 1 ; } else { $ field [ $ i ] [ $ j ] [ 2 ] = 3 ; } if ( isset ( $ ud [ $ i ] [ $ j - 1 ] ) && $ ud [ $ i ] [ $ j - 1 ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 3 ] = 1 ; } elseif ( isset ( $ side [ $ i - 1 ] [ $ j ] ) && $ side [ $ i - 1 ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 3 ] = 3 ; } elseif ( isset ( $ ud [ $ i ] [ $ j ] ) && $ ud [ $ i ] [ $ j ] === ' 1 ' ) { $ field [ $ i ] [ $ j ] [ 3 ] = 0 ; } else { $ field [ $ i ] [ $ j ] [ 3 ] = 2 ; } } } $ p = array ( 0 , 0 ) ; $ d = 0 ; $ trace = array ( ) ; while ( true ) { $ trace [ ] = $ direction [ $ d ] ; $ p [ 0 ] += $ cood [ $ d ] [ 0 ] ; $ p [ 1 ] += $ cood [ $ d ] [ 1 ] ; $ d = $ field [ $ p [ 0 ] ] [ $ p [ 1 ] ] [ $ d ] ; if ( $ p [ 0 ] === 0 && $ p [ 1 ] === 0 ) { break ; } } echo implode ( ' ' , $ trace ) ; echo PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ hand = explode ( ' , ' , $ line ) ; sort ( $ hand ) ; $ group = array ( ) ; foreach ( $ hand as $ n ) { $ group [ $ n ] = isset ( $ group [ $ n ] ) ? $ group [ $ n ] + 1 : 1 ; } sort ( $ group ) ; $ max = max ( $ group ) ; if ( isFourCard ( $ max ) ) { echo \" four card \\n \" ; continue ; } if ( isFullHouse ( $ group ) ) { echo \" full house \\n \" ; continue ; } if ( isStraight ( $ hand ) ) { echo \" straight \\n \" ; continue ; } if ( isThreeCard ( $ max ) ) { echo \" three card \\n \" ; continue ; } if ( isTwoPair ( $ group ) ) { echo \" two pair \\n \" ; continue ; } if ( isOnePair ( $ group ) ) { echo \" one pair \\n \" ; continue ; } echo \" null \\n \" ; } function isFourCard ( $ max ) { return $ max == 4 ; } function isThreeCard ( $ max ) { return $ max == 3 ; } function isFullHouse ( $ group ) { $ c = count ( $ group ) ; return ( $ group [ $ c - 1 ] == 3 ) && ( $ group [ $ c - 2 ] == 2 ) ; } function isTwoPair ( $ group ) { $ c = count ( $ group ) ; return ( $ group [ $ c - 1 ] == 2 ) && ( $ group [ $ c - 2 ] == 2 ) ; } function isOnePair ( $ group ) { $ c = count ( $ group ) ; return ( $ group [ $ c - 1 ] == 2 ) && ( $ group [ $ c - 2 ] < 2 ) ; } function isStraight ( $ hand ) { $ min = $ hand [ 0 ] ; if ( $ min == 1 && ! in_array ( 2 , $ hand ) ) { for ( $ i = 10 ; $ i <= 13 ; $ i ++ ) { if ( ! in_array ( $ i , $ hand ) ) { return false ; } } return true ; } for ( $ i = $ min + 1 ; $ i < $ min + 5 ; $ i ++ ) { if ( ! in_array ( $ i , $ hand ) ) { return false ; } } return true ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ card = array_fill ( 1 , 13 , 0 ) ; foreach ( explode ( ' , ' , $ line ) as $ c ) { $ card [ ( int ) $ c ] ++ ; } $ card = array_filter ( $ card , function ( $ n ) { return $ n ; } ) ; $ pair = max ( $ card ) ; $ cnt = count ( $ card ) ; if ( $ pair === 4 ) { echo \" four card \\n \" ; } elseif ( $ pair === 3 && $ cnt === 2 ) { echo \" full house \\n \" ; } elseif ( $ cnt === 5 ) { $ min = min ( array_keys ( $ card ) ) ; $ check = 0 ; for ( $ i = $ min + 1 ; $ i < $ min + 5 ; $ i ++ ) { isset ( $ card [ $ i ] ) && $ check ++ ; } if ( $ check !== 4 && $ min === 1 ) { $ check = 0 ; for ( $ i = 10 ; $ i <= 13 ; $ i ++ ) { isset ( $ card [ $ i ] ) && $ check ++ ; } } echo $ check === 4 ? \" straight \\n \" : \" null \\n \" ; } elseif ( $ pair === 3 ) { echo \" three card \\n \" ; } elseif ( $ pair === 2 ) { echo $ cnt === 3 ? \" two pair \\n \" : \" one pair \\n \" ; } else { echo \" null \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( ! feof ( STDIN ) ) { $ stdin = trim ( fgets ( STDIN ) ) ; $ values = explode ( ' , ' , $ stdin ) ; if ( count ( $ values ) != 5 ) { } else { $ temp = array ( ) ; foreach ( $ values as $ value ) { if ( ! isset ( $ temp [ $ value ] ) ) { $ temp [ $ value ] = 1 ; } else { $ temp [ $ value ] ++ ; } } ksort ( $ temp ) ; $ ret = ' null ' ; foreach ( $ temp as $ t ) { if ( $ t == 4 ) { $ ret = ' four card ' ; } elseif ( $ t == 3 ) { if ( $ ret == ' one pair ' ) { $ ret = ' full house ' ; } else { $ ret = ' three card ' ; } } elseif ( $ t == 2 ) { if ( $ ret == ' one pair ' ) { $ ret = ' two pair ' ; } elseif ( $ ret == ' three card ' ) { $ ret = ' full house ' ; } else { $ ret = ' one pair ' ; } } } $ temp = array_keys ( $ temp ) ; if ( count ( $ temp ) == 5 && $ temp [ 4 ] - $ temp [ 0 ] == 4 ) { $ ret = ' straight ' ; } $ temp2 = array ( ) ; foreach ( $ temp as $ t ) { if ( $ t == 1 ) { $ temp2 [ ] = 14 ; } else { $ temp2 [ ] = $ t ; } } sort ( $ temp2 ) ; if ( count ( $ temp2 ) == 5 && $ temp2 [ 4 ] - $ temp2 [ 0 ] == 4 ) { $ ret = ' straight ' ; } echo $ ret . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( TRUE ) { $ c = fscanf ( STDIN , ' %d,%d,%d,%d,%d ' ) ; if ( feof ( STDIN ) ) { break ; } sort ( $ c ) ; $ hash = array ( ) ; $ max = 0 ; foreach ( $ c as $ v ) { if ( ! isset ( $ hash [ $ v ] ) ) { $ hash [ $ v ] = 0 ; } $ hash [ $ v ] ++ ; $ max = $ hash [ $ v ] > $ max ? $ hash [ $ v ] : $ max ; } arsort ( $ hash ) ; $ combo = ' null ' ; if ( $ max >= 2 ) { $ combo = ' one pair ' ; } if ( $ max >= 2 && count ( $ hash ) <= 3 ) { $ combo = ' two pair ' ; } if ( $ max >= 3 ) { $ combo = ' three card ' ; } if ( count ( $ hash ) === 5 && isStraight ( $ c ) ) { $ combo = ' straight ' ; } if ( $ max >= 3 && count ( $ hash ) <= 2 ) { $ combo = ' full house ' ; } if ( $ max >= 4 ) { $ combo = ' four card ' ; } echo $ combo . PHP_EOL ; } function isStraight ( $ cards ) { if ( max ( $ cards ) - min ( $ cards ) === 4 ) { return true ; } if ( $ cards [ 0 ] === 1 && $ cards [ 1 ] === 10 && $ cards [ 4 ] === 13 ) { return true ; } return false ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ! feof ( STDIN ) ) { $ stdin = trim ( fgets ( STDIN ) ) ; $ values = explode ( ' , ' , $ stdin ) ; if ( count ( $ values ) != 5 ) { } else { $ temp = array ( ) ; foreach ( $ values as $ value ) { if ( ! isset ( $ temp [ $ value ] ) ) { $ temp [ $ value ] = 1 ; } else { $ temp [ $ value ] ++ ; } } ksort ( $ temp ) ; $ ret = ' null ' ; foreach ( $ temp as $ t ) { if ( $ t == 4 ) { $ ret = ' four card ' ; } elseif ( $ t == 3 ) { if ( $ ret == ' one pair ' ) { $ ret = ' full house ' ; } else { $ ret = ' three card ' ; } } elseif ( $ t == 2 ) { if ( $ ret == ' one pair ' ) { $ ret = ' two pair ' ; } elseif ( $ ret == ' three card ' ) { $ ret = ' full house ' ; } else { $ ret = ' one pair ' ; } } } $ temp = array_keys ( $ temp ) ; if ( count ( $ temp ) == 5 && $ temp [ 4 ] - $ temp [ 0 ] == 4 ) { $ ret = ' straight ' ; } $ temp2 = array ( ) ; foreach ( $ temp as $ t ) { if ( $ t == 1 ) { $ temp2 [ ] = 14 ; } else { $ temp2 [ ] = $ t ; } } sort ( $ temp2 ) ; if ( count ( $ temp2 ) == 5 && $ temp2 [ 4 ] - $ temp2 [ 0 ] == 4 ) { $ ret = ' straight ' ; } echo $ ret . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ map = array ( ' a ' => 0 , ' b ' => 1 , ' c ' => 2 , ' d ' => 3 , ' e ' => 4 , ' f ' => 5 , ' g ' => 6 , ' h ' => 7 , ' i ' => 8 , ' j ' => 9 , ' k ' => 10 , ' l ' => 11 , ' m ' => 12 , ' n ' => 13 , ' o ' => 14 , ' p ' => 15 , ' q ' => 16 , ' r ' => 17 , ' s ' => 18 , ' t ' => 19 , ' u ' => 20 , ' v ' => 21 , ' w ' => 22 , ' x ' => 23 , ' y ' => 24 , ' z ' => 25 , ) ; $ rev_map = array_flip ( $ map ) ; $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; echo solve ( $ line ) . \" \\n \" ; } function solve ( $ line ) { $ words = explode ( ' ' , $ line ) ; foreach ( $ words as $ w ) { if ( strlen ( $ w ) != 4 ) { continue ; } for ( $ a = 1 ; $ a < 26 ; $ a ++ ) { for ( $ b = 0 ; $ b < 26 ; $ b ++ ) { if ( encrypt ( $ a , $ b , ' that ' ) == $ w || encrypt ( $ a , $ b , ' this ' ) == $ w ) { return decrypt ( $ a , $ b , $ line ) ; } } } } } function decrypt ( $ a , $ b , $ line ) { $ decrypt_map = generate_decrypt_map ( $ a , $ b ) ; $ dec = ' ' ; for ( $ i = 0 ; $ i < strlen ( $ line ) ; $ i ++ ) { $ char = $ line [ $ i ] ; if ( preg_match ( ' /[a-z]/ ' , $ char ) ) { $ dec .= $ decrypt_map [ $ char ] ; } else { $ dec .= $ char ; } } return $ dec ; } function generate_decrypt_map ( $ a , $ b ) { global $ map ; $ result = array ( ) ; foreach ( $ map as $ k => $ c ) { $ result [ $ k ] = encrypt_char ( $ a , $ b , $ k ) ; } return array_flip ( $ result ) ; } function encrypt ( $ a , $ b , $ w ) { $ result = ' ' ; for ( $ i = 0 ; $ i < strlen ( $ w ) ; $ i ++ ) { $ result .= encrypt_char ( $ a , $ b , $ w [ $ i ] ) ; } return $ result ; } function encrypt_char ( $ a , $ b , $ char ) { global $ map , $ rev_map ; $ g = $ map [ $ char ] ; $ enc = ( $ a * $ g + $ b ) % 26 ; return $ rev_map [ $ enc ] ; }",
    "label": 3
  },
  {
    "code": "<?php $ alphabet = range ( ' a ' , ' z ' ) ; $ arr = array ( 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ) ; fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ str = trim ( fgets ( STDIN ) ) ; foreach ( $ arr as $ a ) { for ( $ b = 0 ; $ b < 26 ; $ b ++ ) { $ encode = array ( ) ; foreach ( $ alphabet as $ m => $ ch ) { $ encode [ $ ch ] = $ alphabet [ ( $ a * $ m + $ b ) % 26 ] ; } $ word1 = $ encode [ ' t ' ] . $ encode [ ' h ' ] . $ encode [ ' i ' ] . $ encode [ ' s ' ] ; $ word2 = $ encode [ ' t ' ] . $ encode [ ' h ' ] . $ encode [ ' a ' ] . $ encode [ ' t ' ] ; $ format = \" /\\b( { $ word1 } | { $ word2 } )\\b/ \" ; if ( preg_match ( $ format , $ str ) ) { $ decode = array_flip ( $ encode ) ; break 2 ; } } } for ( $ j = 0 , $ len = strlen ( $ str ) ; $ j < $ len ; $ j ++ ) { $ ch = $ str [ $ j ] ; echo ctype_alpha ( $ ch ) ? $ decode [ $ ch ] : $ ch ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ coprime = array ( ) ; for ( $ i = 1 ; $ i < 26 ; $ i ++ ) { if ( gcd ( $ i , 26 ) === 1 ) { $ coprime [ ] = $ i ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s = explode ( ' ' , rtrim ( fgets ( STDIN ) ) ) ; $ f = false ; foreach ( $ coprime as $ a ) { for ( $ b = 0 ; $ b < 26 ; $ b ++ ) { $ tmp = $ s ; foreach ( $ s as $ k => $ w ) { $ s [ $ k ] = dec ( $ w , $ a , $ b ) ; if ( $ s [ $ k ] === ' that ' || $ s [ $ k ] === ' this ' ) { $ f = true ; } } if ( $ f ) { break 2 ; } $ s = $ tmp ; } } echo implode ( ' ' , $ s ) . PHP_EOL ; } function gcd ( $ a , $ b ) { if ( $ a === $ b ) { return $ a ; } return $ a > $ b ? gcd ( $ a - $ b , $ b ) : gcd ( $ a , $ b - $ a ) ; } function dec ( $ w , $ a , $ b ) { $ w = str_split ( $ w ) ; for ( $ i = 0 ; $ i < count ( $ w ) ; $ i ++ ) { $ asc = ord ( $ w [ $ i ] ) - ord ( ' a ' ) ; $ w [ $ i ] = chr ( ord ( ' a ' ) + ( $ a * $ asc + $ b ) % 26 ) ; } return implode ( ' ' , $ w ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { echo largest ( $ n ) . ' ' . smallest ( $ n ) . \" \\n \" ; } function largest ( $ n ) { while ( $ n > 2 ) { $ n -- ; if ( isPrime ( $ n ) ) { return $ n ; } } return $ n ; } function smallest ( $ n ) { while ( true ) { $ n ++ ; if ( isPrime ( $ n ) ) { return $ n ; } } } function isPrime ( $ n ) { if ( $ n == 2 || $ n == 3 ) { return true ; } if ( $ n < 2 || $ n % 2 == 0 ) { return false ; } if ( $ n < 9 ) { return true ; } if ( $ n % 3 == 0 ) { return false ; } $ r = intval ( sqrt ( $ n ) ) ; $ f = 5 ; while ( $ f <= $ r ) { if ( $ n % $ f == 0 || $ n % ( $ f + 2 ) == 0 ) { return false ; } else { $ f += 6 ; } } return true ; }",
    "label": 3
  },
  {
    "code": "<?php $ max = 51000 ; $ arr = new \\ SplFixedArray ( $ max + 1 ) ; for ( $ i = 2 ; $ i <= $ max ; $ i ++ ) { $ arr [ $ i ] = 1 ; } for ( $ i = 2 , $ len = sqrt ( $ max ) ; $ i <= $ len ; $ i ++ ) { if ( ! $ arr [ $ i ] ) { continue ; } for ( $ j = $ i , $ len2 = $ max / $ i ; $ j <= $ len2 ; $ j ++ ) { $ arr [ $ i * $ j ] = 0 ; } } while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d ' , $ n ) ; for ( $ i = $ n - 1 ; $ i >= 2 ; $ i -- ) { if ( $ arr [ $ i ] ) { echo \" $ i \" ; break ; } } for ( $ i = $ n + 1 ; $ i < $ max ; $ i ++ ) { if ( $ arr [ $ i ] ) { echo \" $ i \\n \" ; break ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ table = new SplFixedArray ( 100000 ) ; $ table [ 0 ] = 0 ; $ table [ 1 ] = 0 ; for ( $ i = 2 ; $ i < 100000 ; $ i ++ ) { if ( $ table [ $ i ] === - 1 ) { $ table [ $ i ] = $ table [ $ i - 1 ] ; continue ; } $ table [ $ i ] = $ i ; for ( $ j = $ i * 2 ; $ j < 100000 ; $ j += $ i ) { $ table [ $ j ] = - 1 ; } } $ bigger = new SplFixedArray ( 100000 ) ; $ p = $ table [ 99999 ] + 1 ; for ( $ i = 99998 ; $ i > 0 ; $ i -- ) { if ( $ table [ $ i ] < $ table [ $ i + 1 ] ) { $ p = $ table [ $ i + 1 ] ; } $ bigger [ $ i ] = $ p ; } while ( true ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( feof ( STDIN ) ) { break ; } echo sprintf ( ' %d %d ' , $ table [ $ n - 1 ] , $ bigger [ $ n ] ) ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ data = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ p , $ n ) = explode ( ' , ' , $ line ) ; $ data [ ] = array ( $ p , $ n ) ; } $ sum = 0 ; $ avg = 0 ; foreach ( $ data as $ d ) { $ sum += $ d [ 0 ] * $ d [ 1 ] ; $ avg += $ d [ 1 ] ; } echo $ sum . \" \\n \" ; echo round ( $ avg / count ( $ data ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ sum = 0 ; $ total = 0 ; $ cnt = 0 ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d,%d ' , $ n , $ m ) ; $ sum += $ n * $ m ; $ total += $ m ; $ cnt ++ ; } printf ( \" %d \\n %d \\n \" , $ sum , round ( $ total / $ cnt ) ) ;",
    "label": 3
  },
  {
    "code": "<?php $ sum = 0 ; $ N = 0 ; $ i = 0 ; while ( true ) { fscanf ( STDIN , ' %d,%d ' , $ v , $ n ) ; if ( feof ( STDIN ) ) { break ; } $ i ++ ; $ sum += $ v * $ n ; $ N += $ n ; } echo $ sum . PHP_EOL ; echo round ( $ N / $ i ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ cup = array ( ' A ' => 1 , ' B ' => 0 , ' C ' => 0 ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { list ( $ from , $ to ) = explode ( ' , ' , $ line ) ; $ tmp = $ cup [ $ from ] ; $ cup [ $ from ] = $ cup [ $ to ] ; $ cup [ $ to ] = $ tmp ; } echo array_search ( 1 , $ cup ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ cup = array ( \" A \" => 1 , \" B \" => 0 , \" C \" => 0 ) ; while ( $ line = fgets ( STDIN ) ) { $ line = trim ( $ line ) ; list ( $ x , $ y ) = explode ( \" , \" , $ line ) ; $ wk = $ cup [ $ x ] ; $ cup [ $ x ] = $ cup [ $ y ] ; $ cup [ $ y ] = $ wk ; } if ( $ cup [ \" A \" ] == 1 ) { echo \" A \\n \" ; } else if ( $ cup [ \" B \" ] == 1 ) { echo \" B \\n \" ; } else { echo \" C \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ cup = array ( \" A \" => 1 , \" B \" => 0 , \" C \" => 0 ) ; while ( $ line = fgets ( STDIN ) ) { $ change = explode ( \" , \" , $ line ) ; $ change [ 0 ] = trim ( $ change [ 0 ] ) ; $ change [ 1 ] = trim ( $ change [ 1 ] ) ; $ taihi = $ cup [ $ change [ 0 ] ] ; $ cup [ $ change [ 0 ] ] = $ cup [ $ change [ 1 ] ] ; $ cup [ $ change [ 1 ] ] = $ taihi ; } echo array_search ( 1 , $ cup ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ ans = \" A \" ; while ( $ item = fgets ( STDIN ) ) { $ item = trim ( $ item ) ; $ array = split ( \" , \" , $ item ) ; if ( $ array [ 0 ] == $ ans ) { $ ans = $ array [ 1 ] ; } else if ( $ array [ 1 ] == $ ans ) { $ ans = $ array [ 0 ] ; } } echo $ ans . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ cups = array ( ' A ' => true , ' B ' => false , ' C ' => false ) ; while ( true ) { $ t = explode ( ' , ' , rtrim ( fgets ( STDIN ) ) ) ; if ( feof ( STDIN ) ) { break ; } $ tmp = $ cups [ $ t [ 0 ] ] ; $ cups [ $ t [ 0 ] ] = $ cups [ $ t [ 1 ] ] ; $ cups [ $ t [ 1 ] ] = $ tmp ; } foreach ( $ cups as $ k => $ v ) { if ( $ v ) { echo $ k . PHP_EOL ; break ; } }",
    "label": 3
  },
  {
    "code": "<?php main ( ) ; function main ( ) { $ c = array ( ' A ' => 1 , ' B ' => 0 , ' C ' => 0 ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ i , $ j ) = explode ( ' , ' , $ line ) ; swap ( $ c , $ i , $ j ) ; } foreach ( $ c as $ k => $ v ) { if ( $ v == 1 ) { echo $ k . \" \\n \" ; break ; } } } function swap ( & $ c , $ i , $ j ) { $ tmp = $ c [ $ i ] ; $ c [ $ i ] = $ c [ $ j ] ; $ c [ $ j ] = $ tmp ; }",
    "label": 3
  },
  {
    "code": "<?php $ weight = array ( 91 , 81 , 75 , 69 , 64 , 60 , 57 , 54 , 51 , 48 ) ; $ class = explode ( ' , ' , ' heavy,light heavy,middle,light middle,welter,light welter,light,feather,bantam,fly ' ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ n = ( int ) ceil ( $ line * 100 ) ; $ str = ' light fly ' ; foreach ( $ weight as $ i => $ w ) { if ( $ n > $ w * 100 ) { $ str = $ class [ $ i ] ; break ; } } echo $ str , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ classes = array ( ' light fly ' => 0.0 , ' fly ' => 48.0 , ' bantam ' => 51.00 , ' feather ' => 54.0 , ' light ' => 57.0 , ' light welter ' => 60.0 , ' welter ' => 64.0 , ' light middle ' => 69.0 , ' middle ' => 75.0 , ' light heavy ' => 81.0 , ' heavy ' => 91.0 ) ; while ( true ) { fscanf ( STDIN , ' %f ' , $ w ) ; if ( feof ( STDIN ) ) { break ; } $ class = ' ' ; foreach ( $ classes as $ c => $ v ) { if ( $ w > $ v ) { $ class = $ c ; } } echo $ class . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ table = array ( 48.0 => \" light fly \" , 51.0 => \" fly \" , 54.0 => \" bantam \" , 57.0 => \" feather \" , 60.0 => \" light \" , 64.0 => \" light welter \" , 69.0 => \" welter \" , 75.0 => \" light middle \" , 81.0 => \" middle \" , 91.0 => \" light heavy \" , PHP_INT_MAX => \" heavy \" , ) ; main ( ) ; function main ( ) { while ( $ line = trim ( fgets ( STDIN ) ) ) { echo judgeClass ( $ line ) . \" \\n \" ; } } function judgeClass ( $ w ) { global $ table ; foreach ( $ table as $ boundary => $ name ) { if ( $ w <= $ boundary ) { return $ name ; } } return \" heavy \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { if ( $ n > 91 ) $ a = ' heavy ' ; else if ( $ n > 81 ) $ a = ' light heavy ' ; else if ( $ n > 75 ) $ a = ' middle ' ; else if ( $ n > 69 ) $ a = ' light middle ' ; else if ( $ n > 64 ) $ a = ' welter ' ; else if ( $ n > 60 ) $ a = ' light welter ' ; else if ( $ n > 57 ) $ a = ' light ' ; else if ( $ n > 54 ) $ a = ' feather ' ; else if ( $ n > 51 ) $ a = ' bantam ' ; else if ( $ n > 48 ) $ a = ' fly ' ; else $ a = ' light fly ' ; echo $ a . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , ' %f ' , $ w ) ) { if ( $ w <= 48.0 ) { echo ' light fly ' . PHP_EOL ; } elseif ( $ w <= 51.0 ) { echo ' fly ' . PHP_EOL ; } elseif ( $ w <= 54.0 ) { echo ' bantam ' . PHP_EOL ; } elseif ( $ w <= 57.0 ) { echo ' feather ' . PHP_EOL ; } elseif ( $ w <= 60.0 ) { echo ' light ' . PHP_EOL ; } elseif ( $ w <= 64.0 ) { echo ' light welter ' . PHP_EOL ; } elseif ( $ w <= 69.0 ) { echo ' welter ' . PHP_EOL ; } elseif ( $ w <= 75.0 ) { echo ' light middle ' . PHP_EOL ; } elseif ( $ w <= 81.0 ) { echo ' middle ' . PHP_EOL ; } elseif ( $ w <= 91.0 ) { echo ' light heavy ' . PHP_EOL ; } else { echo ' heavy ' . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ group = array_fill_keys ( explode ( ' , ' , ' A,B,AB,O ' ) , 0 ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d,%s ' , $ n , $ type ) ; $ group [ $ type ] ++ ; } printf ( \" %d \\n %d \\n %d \\n %d \\n \" , $ group [ ' A ' ] , $ group [ ' B ' ] , $ group [ ' AB ' ] , $ group [ ' O ' ] ) ;",
    "label": 3
  },
  {
    "code": "<?php $ dict = array ( ' A ' => 0 , ' B ' => 0 , ' AB ' => 0 , ' O ' => 0 ) ; while ( true ) { $ a = explode ( ' , ' , rtrim ( fgets ( STDIN ) ) ) ; if ( feof ( STDIN ) ) { break ; } $ dict [ $ a [ 1 ] ] ++ ; } foreach ( $ dict as $ v ) { echo $ v . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php main ( ) ; function main ( ) { $ counts = array ( ' A ' => 0 , ' B ' => 0 , ' AB ' => 0 , ' O ' => 0 , ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( , $ blood ) = explode ( ' , ' , $ line ) ; if ( ! isset ( $ counts [ $ blood ] ) ) { continue ; } $ counts [ $ blood ] ++ ; } foreach ( $ counts as $ c ) { echo \" $ c \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { if ( feof ( STDIN ) ) { break ; } $ a = trim ( fgets ( STDIN ) ) ; $ ff = explode ( \" , \" , trim ( $ a ) ) ; if ( isset ( $ ff [ 1 ] ) ) { $ m [ ] = $ ff [ 1 ] ; } } $ bb = array ( \" A \" => 0 , \" B \" => 0 , \" AB \" => 0 , \" O \" => 0 , ) ; foreach ( $ m as $ v ) { $ bb [ $ v ] ++ ; } foreach ( $ bb as $ k => $ v ) { echo $ v . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ converter = array ( ' A ' => 0 , ' B ' => 1 , ' AB ' => 2 , ' 0 ' => 3 , ) ; $ type_cnt = array ( 0 , 0 , 0 , 0 ) ; while ( fscanf ( STDIN , ' %d,%s ' , $ i , $ type ) ) { $ type_cnt [ $ converter [ $ type ] ] ++ ; } ; foreach ( $ type_cnt as $ cnt ) { echo $ cnt . PHP_EOL ; } ;",
    "label": 3
  },
  {
    "code": "<?php $ s = trim ( fgets ( STDIN ) ) ; $ c = str_replace ( array ( \" apple \" , \" peach \" ) , array ( \" pea1ch \" , \" app1le \" ) , $ s ) ; $ s = str_replace ( array ( \" app1le \" , \" pea1ch \" ) , array ( \" apple \" , \" peach \" ) , $ c ) ; echo $ s . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ str = trim ( fgets ( STDIN ) ) ; $ str = str_replace ( array ( ' apple ' , ' peach ' ) , array ( ' @pple ' , ' apple ' ) , $ str ) ; echo str_replace ( ' @pple ' , ' peach ' , $ str ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ s = rtrim ( fgets ( STDIN ) ) ; $ s = str_replace ( array ( ' apple ' , ' peach ' , ' ', '   ) , array(' ' , ' , 'peach', ' a p le'), $s); e c h $s . P H _ EOL;",
    "label": 3
  },
  {
    "code": "<?php $ line = trim ( fgets ( STDIN ) ) ; $ line = str_replace ( ' apple ' , ' ', $li n e ; $li n e = str r place('peac h ' , 'ap p l ' , $li n e ; $li n e = str r place('' , 'peach', $ l n e); e c h $lin e \"\\n ;",
    "label": 3
  },
  {
    "code": "<?php $ s = rtrim ( fgets ( STDIN ) ) ; $ s = str_replace ( array ( ' apple ' , ' peach ' , ' ', '   ) , array(' ' , ' , 'peach', ' a p le'), $s); e c h $s . P H _ EOL;",
    "label": 3
  },
  {
    "code": "<?php $ text = fgets ( STDIN ) ; $ text = str_replace ( array ( ' apple ' , ' peach ' ) , array ( ' ppeeaacchh ' , ' aappppllee ' ) , $ text ) ; $ text = str_replace ( array ( ' aappppllee ' , ' ppeeaacchh ' ) , array ( ' apple ' , ' peach ' ) , $ text ) ; echo $ text ;",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( 5 , 25 , 125 , 625 , 3125 , 15625 ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 ' ) { $ n = ( int ) $ line ; $ cnt = 0 ; foreach ( $ arr as $ m ) { $ cnt += ( int ) ( $ n / $ m ) ; } echo $ cnt , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) != 0 ) { $ n = intval ( $ line ) ; $ mul5 = 0 ; $ mul2 = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ target = $ i ; while ( $ target % 2 == 0 ) { $ mul2 ++ ; $ target /= 2 ; } while ( $ target % 5 == 0 ) { $ mul5 ++ ; $ target /= 5 ; } } echo min ( $ mul5 , $ mul2 ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) != 0 ) { $ n = intval ( $ line ) ; $ mul5 = 0 ; $ mul2 = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ target = $ i ; while ( $ target % 2 == 0 ) { $ mul2 ++ ; $ target /= 2 ; } while ( $ target % 5 == 0 ) { $ mul5 ++ ; $ target /= 5 ; } } $ res = 1 ; for ( $ i = ( int ) $ line ; $ i > 1 ; $ i -- ) { $ res *= $ i ; } $ tmpArray = str_split ( $ res ) ; for ( $ i = count ( $ tmpArray ) ; $ i > 0 ; $ i -- ) { if ( $ tmpArray [ $ i - 1 ] == ' 0 ' ) { $ zero [ ] = true ; } else { break ; } } echo min ( $ mul5 , $ mul2 ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( $ n === 0 ) { break ; } $ c = 0 ; for ( $ i = 5 ; $ i <= $ n ; $ i *= 5 ) { $ c += ( int ) ( $ n / $ i ) ; } echo $ c . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) != 0 ) { $ n = intval ( $ line ) ; $ mul5 = 0 ; $ mul2 = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ target = $ i ; while ( $ target % 2 == 0 ) { $ mul2 ++ ; $ target /= 2 ; } while ( $ target % 5 == 0 ) { $ mul5 ++ ; $ target /= 5 ; } } echo min ( $ mul5 , $ mul2 ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = intval ( fgets ( STDIN ) ) ; while ( $ n !== 0 ) { $ number = 1 ; $ count = 0 ; for ( $ j = $ n ; $ j >= 1 ; $ j -- ) { $ number *= $ j ; while ( $ number % 10 == 0 ) { $ number /= 10 ; $ count ++ ; } if ( $ number > 100000 ) { $ number = $ number - floor ( $ number / 10000 ) * 10000 ; } } $ n = intval ( fgets ( STDIN ) ) ; echo $ count ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d %d %d ' , $ a , $ b , $ n ) ; $ s = 0 ; $ tmp = $ a % $ b ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s += ( int ) ( $ tmp * 10 / $ b ) ; $ tmp = $ tmp * 10 % $ b ; } echo $ s , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , ' %d %d %d ' , $ a , $ b , $ n ) ; if ( feof ( STDIN ) ) { break ; } $ s = 0 ; $ mod = $ a >= $ b ? $ a % $ b : $ a ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ mod *= 10 ; $ s += ( int ) ( $ mod / $ b ) ; $ mod = $ mod >= $ b ? $ mod % $ b : $ mod ; } echo $ s . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php main ( ) ; function main ( ) { while ( $ input = trim ( fgets ( STDIN ) ) ) { list ( $ a , $ b , $ n ) = explode ( ' ' , $ input ) ; $ array = decimalPlaces ( $ a , $ b , $ n ) ; echo array_sum ( $ array ) . \" \\n \" ; } } function decimalPlaces ( $ a , $ b , $ n ) { $ i = 0 ; $ result = array ( ) ; $ a = $ a % $ b ; while ( $ i < $ n ) { $ a *= 10 ; $ result [ ] = ( int ) ( $ a / $ b ) ; $ a %= $ b ; $ i ++ ; } return $ result ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %f \" , $ i ) ) { $ j = $ i * 211 / 27 ; echo $ j . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ arr = array ( ( float ) $ line ) ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { $ prev = $ arr [ $ i - 1 ] ; if ( $ i % 2 === 1 ) { $ arr [ $ i ] = $ prev * 2 ; } else { $ arr [ $ i ] = $ prev / 3 ; } } echo array_sum ( $ arr ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ x = floatval ( $ line ) ; $ s = $ x ; for ( $ i = 2 ; $ i <= 10 ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ x = $ x * 2.0 ; } else { $ x = $ x / 3.0 ; } $ s += $ x ; } echo $ s . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ s = floatval ( $ line ) ; $ total = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ s = $ s * 2 ; } elseif ( $ i != 1 ) { $ s = $ s / 3 ; } $ total += $ s ; } echo $ total . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , ' %f ' , $ a ) ; if ( feof ( STDIN ) ) { break ; } $ s = $ a ; for ( $ i = 2 ; $ i <= 10 ; $ i ++ ) { if ( $ i % 2 === 0 ) { $ a *= 2 ; } else { $ a /= 3 ; } $ s += $ a ; } echo $ s . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ first = trim ( fgets ( STDIN ) ) ) { seq_sum ( $ first ) ; } function seq_sum ( $ first ) { $ sum = $ first ; $ prev = $ first ; for ( $ i = 2 ; $ i <= 10 ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ prev *= 2 ; } else { $ prev /= 3 ; } $ sum += $ prev ; } echo $ sum . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' MAX ' , 50001 ) ; define ( ' COUNT ' , 5133 ) ; $ table = new SplFixedArray ( MAX ) ; $ table [ 0 ] = $ table [ 1 ] = false ; $ primes = new SplFixedArray ( COUNT ) ; $ p_i = 0 ; $ i = 2 ; while ( $ i < MAX ) { $ primes [ $ p_i ++ ] = $ i ; $ table [ $ i ] = true ; for ( $ j = $ i * 2 ; $ j < MAX ; $ j += $ i ) { $ table [ $ j ] = false ; } while ( ++ $ i < MAX && $ table [ $ i ] === false ) ; } while ( true ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( $ n === 0 ) { break ; } $ c = 0 ; for ( $ i = 0 ; $ i < COUNT ; $ i ++ ) { if ( $ primes [ $ i ] > $ n / 2 ) { break ; } if ( $ table [ $ n - $ primes [ $ i ] ] ) { $ c ++ ; } } echo $ c . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { echo $ n * ( $ n - 1 ) / 2 + $ n + 1 . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ n = ( int ) $ line ; $ result = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ result += $ i ; } echo $ result , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ a = ( int ) $ line ; $ temp = 2 ; for ( $ i = 2 ; $ i <= $ a ; $ i ++ ) { $ temp += $ i ; } echo $ temp , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , ' %d ' , $ n ) ; if ( feof ( STDIN ) ) { break ; } $ d = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ d += $ i ; } echo $ d . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' EPS ' , 1e-8 ) ; while ( true ) { $ a = fscanf ( STDIN , ' %f %f %f %f %f %f %f %f ' ) ; if ( feof ( STDIN ) ) { break ; } $ line = array ( ) ; $ line [ ] = $ a [ 1 ] - $ a [ 3 ] === 0.0 ? INF : ( $ a [ 0 ] - $ a [ 2 ] ) / ( $ a [ 1 ] - $ a [ 3 ] ) ; $ line [ ] = $ a [ 5 ] - $ a [ 7 ] === 0.0 ? INF : ( $ a [ 4 ] - $ a [ 6 ] ) / ( $ a [ 5 ] - $ a [ 7 ] ) ; if ( max ( $ line ) === INF && min ( $ line ) === 0 || abs ( $ line [ 0 ] * $ line [ 1 ] + 1.0 ) < EPS ) { echo ' YES ' ; } else { echo ' NO ' ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' EPS ' , 1e-8 ) ; while ( true ) { $ a = fscanf ( STDIN , ' %f %f %f %f %f %f %f %f ' ) ; if ( feof ( STDIN ) ) { break ; } $ line = array ( ) ; $ line [ ] = $ a [ 1 ] - $ a [ 3 ] === 0.0 ? INF : ( $ a [ 0 ] - $ a [ 2 ] ) / ( $ a [ 1 ] - $ a [ 3 ] ) ; $ line [ ] = $ a [ 5 ] - $ a [ 7 ] === 0.0 ? INF : ( $ a [ 4 ] - $ a [ 6 ] ) / ( $ a [ 5 ] - $ a [ 7 ] ) ; if ( max ( $ line ) === INF && min ( $ line ) === 0 || abs ( $ line [ 0 ] * $ line [ 1 ] + 1.0 ) < EPS ) { echo ' YES ' ; } else { echo ' NO ' ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , ' %f %f %f %f %f %f %f %f ' , $ xa1 , $ ya1 , $ xa2 , $ ya2 , $ xb1 , $ yb1 , $ xb2 , $ yb2 ) ; if ( feof ( STDIN ) ) { break ; } if ( $ xb2 < $ xa1 || $ xb1 > $ xa2 || $ yb2 < $ ya1 || $ yb1 > $ ya2 ) { echo ' NO ' ; } else { echo ' YES ' ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ deck = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; list ( $ c1 , $ c2 , $ c3 ) = explode ( ' ' , $ line ) ; unset ( $ deck [ $ c1 - 1 ] ) ; unset ( $ deck [ $ c2 - 1 ] ) ; unset ( $ deck [ $ c3 - 1 ] ) ; $ now = $ c1 + $ c2 ; $ diff = 20 - $ now ; $ safe = 0 ; foreach ( $ deck as $ card ) { if ( $ card <= $ diff ) { $ safe ++ ; } } echo ( $ safe >= count ( $ deck ) - $ safe ) ? \" YES \\n \" : \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d %d %d ' , $ c1 , $ c2 , $ c3 ) ; $ card = array_fill ( 1 , 10 , 0 ) ; $ sum = $ c1 + $ c2 ; $ diff = 20 - $ sum ; ++ $ card [ $ c1 ] && ++ $ card [ $ c2 ] && ++ $ card [ $ c3 ] ; $ n = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ i <= $ diff && ! $ card [ $ i ] && $ n ++ ; } echo $ n / 7 * 100 >= 50 ? \" YES \\n \" : \" NO \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ c = fscanf ( STDIN , ' %d %d %d ' ) ; if ( feof ( STDIN ) ) { break ; } $ rest = 20 - $ c [ 0 ] - $ c [ 1 ] ; $ over = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( $ i === $ c [ 0 ] || $ i === $ c [ 1 ] || $ i === $ c [ 2 ] ) { continue ; } if ( $ i > $ rest ) { $ over ++ ; } } echo $ over <= 3 ? ' YES ' : ' NO ' ; echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ g = rtrim ( fgets ( STDIN ) ) ) { $ a = preg_split ( \" /[\\s,]+/ \" , $ g ) ; $ player_sum = $ a [ 0 ] + $ a [ 1 ] ; $ player_left = 20 - $ player_sum ; $ opponent_card = $ a [ 2 ] ; $ card_all = [ ] ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( $ i == $ a [ 0 ] ) { $ card_all [ ] = 0 ; } else if ( $ i == $ a [ 1 ] ) { $ card_all [ ] = 0 ; } else if ( $ i == $ a [ 2 ] ) { $ card_all [ ] = 0 ; } else { $ card_all [ ] = $ i ; } } $ count = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ card_all [ $ i ] <= $ player_left && $ card_all [ $ i ] !== 0 ) { $ count ++ ; } } if ( $ count >= 4 ) { print ' YES ' ; } else { print ' NO ' ; } print PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ result = array ( ) ; $ score_list = array ( ) ; while ( TRUE ) { $ line = trim ( fgets ( STDIN ) ) ; list ( $ ind , $ score ) = explode ( ' , ' , $ line ) ; if ( $ ind == 0 && $ score == 0 ) { break ; } $ result [ $ ind ] = $ score ; $ score_list [ ] = $ score ; } $ score_list = array_unique ( $ score_list ) ; rsort ( $ score_list ) ; $ order_list = array_flip ( $ score_list ) ; while ( $ i = trim ( fgets ( STDIN ) ) ) { $ score = $ result [ $ i ] ; $ order = $ order_list [ $ score ] + 1 ; echo $ order . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ rank = array ( ) ; $ team = array ( ) ; $ q = false ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { if ( $ line === ' 0,0 ' ) { rsort ( $ rank ) ; $ q = true ; continue ; } if ( $ q ) { $ i = ( int ) $ line ; echo array_search ( $ team [ $ i ] , $ rank ) + 1 , PHP_EOL ; } else { sscanf ( $ line , ' %d,%d ' , $ i , $ n ) ; $ team [ $ i ] = $ n ; if ( ! in_array ( $ n , $ rank ) ) { $ rank [ ] = $ n ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ rank = new SplPriorityQueue ( ) ; $ rank -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; while ( true ) { fscanf ( STDIN , ' %d,%d ' , $ t , $ v ) ; if ( $ t === 0 && $ v === 0 ) { break ; } $ rank -> insert ( $ t , $ v ) ; } $ hash = array ( ) ; $ i = 0 ; $ v = 40 ; while ( ! $ rank -> isEmpty ( ) ) { $ node = $ rank -> extract ( ) ; if ( $ node [ ' priority ' ] < $ v ) { $ i ++ ; $ v = $ node [ ' priority ' ] ; } $ hash [ $ node [ ' data ' ] ] = $ i ; } while ( true ) { fscanf ( STDIN , ' %d ' , $ t ) ; if ( feof ( STDIN ) ) { break ; } echo $ hash [ $ t ] . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ g = rtrim ( fgets ( STDIN ) ) ; $ a = preg_split ( \" /[\\s,]+/ \" , $ g ) ; $ ranking = [ ] ; while ( $ a [ 0 ] != 0 ) { $ ranking [ ] = [ ' team ' => $ a [ 0 ] , ' point ' => $ a [ 1 ] ] ; $ g = rtrim ( fgets ( STDIN ) ) ; $ a = preg_split ( \" /[\\s,]+/ \" , $ g ) ; } foreach ( $ ranking as $ key => $ value ) { $ point [ $ key ] = $ value [ ' point ' ] ; } array_multisort ( $ point , SORT_DESC , $ ranking ) ; $ rank = 1 ; $ temp_point = $ ranking [ 0 ] [ ' point ' ] ; for ( $ i = 0 ; $ i < count ( $ ranking ) ; $ i ++ ) { if ( $ temp_point !== $ ranking [ $ i ] [ ' point ' ] ) { $ rank ++ ; $ temp_point = $ ranking [ $ i ] [ ' point ' ] ; } $ ranking [ $ i ] [ ' rank ' ] = $ rank ; } while ( $ g = rtrim ( fgets ( STDIN ) ) ) { $ keyIndex = array_search ( $ g , array_column ( $ ranking , ' team ' ) ) ; $ result = $ ranking [ $ keyIndex ] ; print $ result [ ' rank ' ] ; print PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ count = 0 ; while ( $ line = trim ( fgets ( STDIN ) ) ) { if ( $ line == strrev ( $ line ) ) { $ count ++ ; } } echo $ count . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ count = 0 ; while ( $ s1 = trim ( fgets ( STDIN ) ) ) { $ s2 = strrev ( $ s1 ) ; $ count += ( $ s1 == $ s2 ) ; } echo $ count . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ cnt = 0 ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ len = strlen ( $ line ) ; if ( $ len === 1 ) { $ cnt ++ ; continue ; } $ mid = ( int ) ( $ len / 2 ) ; $ str = substr ( $ line , 0 , $ mid ) ; $ str = implode ( ' ' , array_reverse ( str_split ( $ str ) ) ) ; $ i = $ len % 2 === 0 ? $ mid : $ mid + 1 ; $ str === substr ( $ line , $ i ) && $ cnt ++ ; } echo $ cnt , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ c = 0 ; while ( true ) { fscanf ( STDIN , ' %s ' , $ s ) ; if ( feof ( STDIN ) ) { break ; } if ( $ s === strrev ( $ s ) ) { $ c ++ ; } } echo $ c . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ a = 0 ; while ( ! feof ( STDIN ) ) { $ s = \" \" ; fscanf ( STDIN , \" %s \" , $ s ) ; if ( $ s == \" \" ) break ; $ b = true ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ strlen ( $ s ) - $ i - 1 ] ) $ b = false ; } if ( $ b ) $ a ++ ; } echo $ a . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ count_answer = 0 ; while ( $ word = rtrim ( fgets ( STDIN ) ) ) { $ count = 0 ; for ( $ i = 0 ; $ i < floor ( strlen ( $ word ) / 2 ) ; $ i ++ ) { if ( substr ( $ word , $ i , 1 ) == substr ( $ word , - ( 1 + $ i ) , 1 ) ) { $ count ++ ; } } if ( $ count == floor ( strlen ( $ word ) / 2 ) ) { $ count_answer ++ ; } } print $ count_answer ; print PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ sum = 0 ; while ( true ) { $ s = rtrim ( fgets ( STDIN ) ) ; if ( feof ( STDIN ) ) { break ; } if ( preg_match_all ( ' /[0-9]+/ ' , $ s , $ a ) ) { foreach ( $ a [ 0 ] as $ v ) { $ sum += ( int ) $ v ; } } } echo $ sum . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ current = array ( ) ; $ prev = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ ind , $ date ) = explode ( ' , ' , $ line ) ; if ( isset ( $ prev [ $ ind ] ) ) { $ prev [ $ ind ] ++ ; } else { $ prev [ $ ind ] = 1 ; } } while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ ind , $ date ) = explode ( ' , ' , $ line ) ; if ( isset ( $ current [ $ ind ] ) ) { $ current [ $ ind ] ++ ; } else { $ current [ $ ind ] = 1 ; } } ksort ( $ current ) ; foreach ( $ current as $ ind => $ cnt ) { if ( isset ( $ prev [ $ ind ] ) ) { printf ( \" %d %d \\n \" , $ ind , $ cnt + $ prev [ $ ind ] ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ bool = true ; $ prev = array ( ) ; $ current = array ( ) ; $ keys = array ( ) ; while ( true ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line === ' ' ) { if ( $ bool ) { $ bool = false ; continue ; } break ; } sscanf ( $ line , ' %d,%d ' , $ n , $ m ) ; if ( ! in_array ( $ n , $ keys ) ) { $ keys [ ] = $ n ; } if ( $ bool ) { $ prev [ $ n ] = empty ( $ prev [ $ n ] ) ? 1 : $ prev [ $ n ] + 1 ; } else { $ current [ $ n ] = empty ( $ current [ $ n ] ) ? 1 : $ current [ $ n ] + 1 ; } } sort ( $ keys ) ; foreach ( $ keys as $ key ) { if ( isset ( $ prev [ $ key ] , $ current [ $ key ] ) ) { printf ( \" %d %d \\n \" , $ key , $ prev [ $ key ] + $ current [ $ key ] ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ x = array ( ) ; while ( true ) { $ a = rtrim ( fgets ( STDIN ) ) ; if ( $ a === ' ' ) { break ; } list ( $ n , $ d ) = explode ( ' , ' , $ a ) ; if ( ! isset ( $ x [ $ n ] ) ) { $ x [ $ n ] = 0 ; } $ x [ $ n ] ++ ; } $ y = array ( ) ; while ( true ) { $ a = rtrim ( fgets ( STDIN ) ) ; if ( $ a === ' ' ) { break ; } list ( $ n , $ d ) = explode ( ' , ' , $ a ) ; if ( ! isset ( $ x [ $ n ] ) ) { continue ; } if ( ! isset ( $ y [ $ n ] ) ) { $ y [ $ n ] = $ x [ $ n ] ; } $ y [ $ n ] ++ ; } ksort ( $ y ) ; foreach ( $ y as $ k => $ v ) { echo sprintf ( ' %d %d ' , $ k , $ v ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ dirs = array ( array ( 1 , 0 ) , array ( - 1 , 0 ) , array ( 0 , 1 ) , array ( 0 , - 1 ) ) ; while ( TRUE ) { $ map = array ( ) ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; $ map [ ] = $ line ; } $ count = 0 ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { for ( $ j = 0 ; $ j < 12 ; $ j ++ ) { if ( $ map [ $ i ] [ $ j ] == 1 ) { $ count ++ ; bfs ( $ i , $ j ) ; } } } echo $ count . \" \\n \" ; $ line = fgets ( STDIN ) ; if ( $ line === false ) { break ; } } function bfs ( $ i , $ j ) { global $ map , $ dirs ; $ que = array ( array ( $ i , $ j ) ) ; while ( ! empty ( $ que ) ) { $ point = array_shift ( $ que ) ; $ x = $ point [ 0 ] ; $ y = $ point [ 1 ] ; $ map [ $ x ] [ $ y ] = 0 ; foreach ( $ dirs as $ d ) { $ dx = $ d [ 0 ] ; $ dy = $ d [ 1 ] ; if ( isset ( $ map [ $ i + $ dy ] [ $ j + $ dx ] ) && $ map [ $ i + $ dy ] [ $ j + $ dx ] == 1 ) { $ que [ ] = array ( $ i + $ dy , $ j + $ dx ) ; bfs ( $ i + $ dy , $ j + $ dx ) ; } } } }",
    "label": 3
  },
  {
    "code": "<?php $ dirs = array ( array ( 1 , 0 ) , array ( - 1 , 0 ) , array ( 0 , 1 ) , array ( 0 , - 1 ) ) ; while ( TRUE ) { $ map = array ( ) ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; $ map [ ] = $ line ; } $ count = 0 ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { for ( $ j = 0 ; $ j < 12 ; $ j ++ ) { if ( $ map [ $ i ] [ $ j ] == 1 ) { $ count ++ ; bfs ( $ i , $ j ) ; } } } echo $ count . \" \\n \" ; $ line = fgets ( STDIN ) ; if ( $ line === false ) { break ; } } function bfs ( $ i , $ j ) { global $ map , $ dirs ; $ que = array ( array ( $ i , $ j ) ) ; while ( ! empty ( $ que ) ) { $ point = array_shift ( $ que ) ; $ x = $ point [ 0 ] ; $ y = $ point [ 1 ] ; $ map [ $ x ] [ $ y ] = 0 ; foreach ( $ dirs as $ d ) { $ dx = $ d [ 0 ] ; $ dy = $ d [ 1 ] ; if ( isset ( $ map [ $ x + $ dy ] [ $ y + $ dx ] ) && $ map [ $ x + $ dy ] [ $ y + $ dx ] == 1 ) { $ map [ $ x + $ dy ] [ $ y + $ dx ] = 0 ; $ que [ ] = array ( $ x + $ dy , $ y + $ dx ) ; } } } }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { if ( feof ( STDIN ) ) { break ; } $ field = array ( ) ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { $ field [ ] = str_split ( rtrim ( fgets ( STDIN ) ) ) ; } fscanf ( STDIN , ' ' ) ; $ c = 0 ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { for ( $ j = 0 ; $ j < 12 ; $ j ++ ) { if ( $ field [ $ i ] [ $ j ] === ' 1 ' ) { dfs ( $ field , array ( $ i , $ j ) ) ; $ c ++ ; } } } echo $ c . PHP_EOL ; } function dfs ( & $ field , $ s ) { $ stack = array ( $ s ) ; $ dx = array ( 1 , - 1 , 0 , 0 ) ; $ dy = array ( 0 , 0 , 1 , - 1 ) ; while ( count ( $ stack ) ) { $ node = array_pop ( $ stack ) ; $ field [ $ node [ 0 ] ] [ $ node [ 1 ] ] = ' 0 ' ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ nx = $ node [ 1 ] + $ dx [ $ i ] ; $ ny = $ node [ 0 ] + $ dy [ $ i ] ; if ( ! isset ( $ field [ $ ny ] [ $ nx ] ) || $ field [ $ ny ] [ $ nx ] === ' 0 ' ) { continue ; } $ stack [ ] = array ( $ ny , $ nx ) ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: $move = array(array(1,0),array(0,1),array(-1,0),array(0,-1)); function dfs($y, $x){ global $move; global $map; $map[$y][$x] = 0; for ($i=0; $i<=3; $i++){ $y2 = $y + $move[$i][1]; $x2 = $x + $move[$i][0]; if (!empty($map[$y2][$x2]) && $map[$y2][$x2]==1){ dfs($y2, $x2); } } return; } do { $num_island = 0; $map = array(); for($y=0; $y<=11; $y++){ $stdin = trim(fgets($file_handle)); $map[$y] = str_split($stdin); } for($y=0; $y<=11; $y++){ for($x=0; $x<=11; $x++){ if ($map[$y][$x] == 1){ dfs($y, $x); $num_island++; } } } echo $num_island; echo PHP_EOL; $stdin = fgets($file_handle); $flag = ($stdin == PHP_EOL) ? 1 : 0; } while ($flag === 1); fclose($file_handle);",
    "label": 3
  },
  {
    "code": "<?php $ vectors = [ [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] ] ; function solve ( ) { $ mp = [ ] ; for ( $ i = 0 ; $ i < 12 ; $ i ++ ) { $ mp [ $ i ] = trim ( fgets ( STDIN ) ) ; } $ visited = array_fill ( 0 , 12 , array_fill ( 0 , 12 , false ) ) ; $ cnt = 0 ; for ( $ y = 0 ; $ y < 12 ; $ y ++ ) { for ( $ x = 0 ; $ x < 12 ; $ x ++ ) { if ( ! $ visited [ $ y ] [ $ x ] and $ mp [ $ y ] [ $ x ] === \" 1 \" ) { $ cnt ++ ; $ visited [ $ y ] [ $ x ] = true ; search ( $ x , $ y , $ mp , $ visited ) ; } } } return [ $ cnt , fgets ( STDIN ) ] ; } function search ( $ x , $ y , & $ mp , & $ visited ) { global $ vectors ; foreach ( $ vectors as $ vector ) { list ( $ dx , $ dy ) = $ vector ; $ nx = $ x + $ dx ; $ ny = $ y + $ dy ; if ( ( 0 <= $ nx and $ nx < 12 and 0 <= $ ny and $ ny < 12 ) and ( $ mp [ $ ny ] [ $ nx ] === \" 1 \" and ! $ visited [ $ ny ] [ $ nx ] ) ) { $ visited [ $ ny ] [ $ nx ] = true ; search ( $ nx , $ ny , $ mp , $ visited ) ; } } } while ( true ) { list ( $ cnt , $ ok ) = solve ( ) ; echo $ cnt . \" \\n \" ; if ( ! $ ok ) { break ; } }",
    "label": 3
  },
  {
    "code": "<?php function work ( & $ A , $ x , $ y ) { $ A [ $ x ] [ $ y ] = 0 ; for ( $ i = - 3 ; $ i <= 3 ; $ i ++ ) { for ( $ j = - 3 ; $ j <= 3 ; $ j ++ ) { if ( 0 <= $ x + $ i && $ x + $ i < 8 && 0 <= $ y + $ j && $ y + $ j < 8 && ( $ i == 0 || $ j == 0 ) ) { if ( $ A [ $ x + $ i ] [ $ y + $ j ] == 1 ) { work ( $ A , $ x + $ i , $ y + $ j ) ; } } } } } fscanf ( STDIN , \" %d \" , $ data_num ) ; for ( $ c = 1 ; $ c <= $ data_num ; $ c ++ ) { fscanf ( STDIN , \" %d \" , $ a ) ; $ array = array ( ) ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ a ) ; $ a = str_pad ( $ a , 8 , \" 0 \" , STR_PAD_LEFT ) ; array_push ( $ array , $ a ) ; } fscanf ( STDIN , \" %d \" , $ x ) ; fscanf ( STDIN , \" %d \" , $ y ) ; work ( $ array , $ y - 1 , $ x - 1 ) ; print \" Data \" . $ c . \" : \\n \" ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { print $ array [ $ i ] . \" \\n \" ; } unset ( $ array ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function bomber ( $ data , $ x , $ y ) { if ( $ x > 0 && $ y > 0 && $ x < 9 && $ y < 9 && $ data [ $ y ] [ $ x ] > 0 ) { $ data [ $ y ] [ $ x ] = 0 ; for ( $ i = 1 ; $ i <= 3 ; $ i ++ ) { $ data = bomber ( $ data , $ x - $ i , $ y ) ; $ data = bomber ( $ data , $ x + $ i , $ y ) ; $ data = bomber ( $ data , $ x , $ y - $ i ) ; $ data = bomber ( $ data , $ x , $ y + $ i ) ; } } return $ data ; } $ count = intval ( fgets ( STDIN ) ) ; $ dataset = array ( ) ; $ total = 11 * $ count ; $ now = 0 ; while ( $ line = fgets ( STDIN ) ) { $ line = trim ( $ line ) ; if ( $ line == \" \" ) { $ now ++ ; $ dataset [ $ now ] = array ( ) ; $ col = 1 ; } else { if ( $ col == 10 ) { $ dataset [ $ now ] [ \" y \" ] = intval ( $ line ) ; } else if ( $ col == 9 ) { $ dataset [ $ now ] [ \" x \" ] = intval ( $ line ) ; $ col ++ ; } else { $ dataset [ $ now ] [ $ col ] = array ( ) ; for ( $ row = 1 ; $ row <= 8 ; $ row ++ ) { $ dataset [ $ now ] [ $ col ] [ $ row ] = intval ( substr ( $ line , $ row - 1 , 1 ) ) ; } $ col ++ ; } } $ total -- ; if ( $ total < 1 ) break ; } foreach ( $ dataset as $ key => $ data ) { $ x = $ data [ \" x \" ] ; $ y = $ data [ \" y \" ] ; unset ( $ data [ \" x \" ] ) ; unset ( $ data [ \" y \" ] ) ; $ data = bomber ( $ data , $ x , $ y ) ; echo \" Data { $ key } : \\n \" ; foreach ( $ data as $ row ) { echo implode ( $ row ) . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php define ( \" BOX_SIZE \" , 8 ) ; define ( \" BOMB_POWER \" , 3 ) ; $ datasetnum = fgets ( STDIN ) ; for ( $ i = 1 ; $ i <= $ datasetnum ; $ i ++ ) { $ line = fgets ( STDIN ) ; $ arr = array ( ) ; for ( $ j = 0 ; $ j < BOX_SIZE ; $ j ++ ) { $ arr [ $ j ] = trim ( fgets ( STDIN ) ) ; } $ x = intval ( fgets ( STDIN ) ) ; $ y = intval ( fgets ( STDIN ) ) ; explosion ( $ arr , $ x - 1 , $ y - 1 ) ; echo \" Data { $ i } : \\n \" ; for ( $ j = 0 ; $ j < 8 ; $ j ++ ) { echo $ arr [ $ j ] . \" \\n \" ; } } function explosion ( & $ arr , $ x , $ y ) { if ( $ x < 0 || BOX_SIZE <= $ x || $ y < 0 || BOX_SIZE <= $ y ) { return ; } if ( $ arr [ $ y ] [ $ x ] == \" 0 \" ) { return ; } $ arr [ $ y ] [ $ x ] = \" 0 \" ; for ( $ i = 1 ; $ i <= BOMB_POWER ; $ i ++ ) { explosion ( $ arr , $ x , $ y - $ i ) ; } for ( $ i = 1 ; $ i <= BOMB_POWER ; $ i ++ ) { explosion ( $ arr , $ x + $ i , $ y ) ; } for ( $ i = 1 ; $ i <= BOMB_POWER ; $ i ++ ) { explosion ( $ arr , $ x , $ y + $ i ) ; } for ( $ i = 1 ; $ i <= BOMB_POWER ; $ i ++ ) { explosion ( $ arr , $ x - $ i , $ y ) ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { fscanf ( STDIN , \" %d \" , $ n ) ; if ( $ n == 0 ) break ; fscanf ( STDIN , \" %d \" , $ m ) ; $ input = array ( array ( ) , array ( ) , array ( ) , array ( ) , ) ; for ( $ i = 0 ; $ m > $ i ; $ i ++ ) { fscanf ( STDIN , \" %d,%d,%d \" , $ a , $ b , $ d ) ; $ input [ $ a ] [ $ b ] = $ d ; $ input [ $ b ] [ $ a ] = $ d ; } $ already = array_pad ( array ( ) , $ n , false ) ; $ already [ 0 ] = true ; $ result = 0 ; while ( true ) { $ f = false ; foreach ( $ already as $ k => $ flg ) { if ( ! $ flg ) { $ f = true ; } } if ( ! $ f ) break ; $ index = 0 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! $ already [ $ i ] ) continue ; foreach ( $ input [ $ i ] as $ key => $ val ) { if ( $ tmp > $ val && ! $ already [ $ key ] ) { $ index = $ key ; $ tmp = $ val ; } } } $ already [ $ index ] = true ; $ result += $ tmp ; } echo ( ( $ result - ( ( $ n - 1 ) * 100 ) ) / 100 ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php main ( ) ; function main ( ) { while ( ( $ n = trim ( fgets ( STDIN ) ) ) != - 1 ) { $ hunter = new TreasureHunter ( 1 , 0 ) ; $ hunter -> findTreasure ( $ n ) ; } } class TreasureHunter { public $ p ; public function __construct ( $ x , $ y ) { $ this -> p = new Point ( $ x , $ y ) ; } public function step ( ) { $ this -> p -> toWill ( ) ; $ this -> p -> rotateR ( ) ; $ this -> p -> move ( ) ; } public function findTreasure ( $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ this -> step ( ) ; } $ this -> sayPosition ( ) ; } public function sayPosition ( ) { echo $ this -> p -> x . \" \\n \" ; echo $ this -> p -> y . \" \\n \" ; } } class Point { public $ x ; public $ y ; public $ vx ; public $ vy ; public function __construct ( $ x , $ y ) { $ this -> x = $ x ; $ this -> y = $ y ; } public function rotateR ( ) { $ vx = $ this -> vx ; $ vy = $ this -> vy ; $ this -> vx = $ vy ; $ this -> vy = - $ vx ; } public function toWill ( ) { $ this -> vx = - $ this -> x ; $ this -> vy = - $ this -> y ; $ this -> normalize ( ) ; } public function move ( ) { $ this -> x += $ this -> vx ; $ this -> y += $ this -> vy ; } private function normalize ( ) { $ v = $ this -> v ( ) ; if ( $ v == 0 ) { $ this -> vx = 1 ; $ this -> vy = 0 ; return ; } $ this -> vx /= $ v ; $ this -> vy /= $ v ; } private function v ( ) { return sqrt ( $ this -> vx * $ this -> vx + $ this -> vy * $ this -> vy ) ; } public function __toString ( ) { return \" (x, y, vx, vy) = ( { $ this -> x } , { $ this -> y } , { $ this -> vx } , { $ this -> vy } ) \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php main ( ) ; function main ( ) { $ points = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ x , $ y ) = explode ( ' , ' , $ line ) ; $ points [ ] = new Point ( $ x , $ y ) ; } $ sum = 0 ; $ o = $ points [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ points ) - 1 ; $ i ++ ) { $ p1 = $ points [ $ i ] ; $ p2 = $ points [ $ i + 1 ] ; $ T = new Triangle ( $ o , $ p1 , $ p2 ) ; $ sum += $ T -> getArea ( ) ; } echo $ sum . \" \\n \" ; } class Triangle { public $ A , $ B , $ C ; public $ a , $ b , $ c ; public function __construct ( Point $ A , Point $ B , Point $ C ) { $ this -> A = $ A ; $ this -> B = $ B ; $ this -> C = $ C ; $ this -> a = $ B -> distanceFrom ( $ C ) ; $ this -> b = $ C -> distanceFrom ( $ A ) ; $ this -> c = $ A -> distanceFrom ( $ B ) ; } public function getArea ( ) { $ z = ( $ this -> a + $ this -> b + $ this -> c ) / 2 ; return sqrt ( $ z * ( $ z - $ this -> a ) * ( $ z - $ this -> b ) * ( $ z - $ this -> c ) ) ; } } class Point { public $ x , $ y ; public function __construct ( $ x , $ y ) { $ this -> x = $ x ; $ this -> y = $ y ; } public function distanceFrom ( Point $ p ) { $ dx = $ this -> x - $ p -> x ; $ dy = $ this -> y - $ p -> y ; return sqrt ( $ dx * $ dx + $ dy * $ dy ) ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { fscanf ( STDIN , \" %d \" , $ q ) ; if ( $ q == - 1 ) break ; $ x = $ q / 2 ; while ( abs ( pow ( $ x , 3 ) - $ q ) >= 0.00001 * $ q ) { $ x -= ( pow ( $ x , 3 ) - $ q ) / ( 3 * $ x * $ x ) ; } echo $ x . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' -1 ' ) { sscanf ( $ line , ' %f ' , $ q ) ; $ epsilon = 0.00001 ; $ x = $ q / 2 ; while ( abs ( pow ( $ x , 3 ) - $ q ) >= $ epsilon * $ q ) { $ x -= ( pow ( $ x , 3 ) - $ q ) / ( 3 * pow ( $ x , 2 ) ) ; } echo $ x , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { $ q = intval ( $ line ) ; if ( $ q < 0 ) { break ; } if ( $ q == 0 ) { echo \" 0 \\n \" ; continue ; } $ x = $ q / 2.0 ; while ( true ) { $ d = $ x * $ x * $ x - $ q ; if ( abs ( $ d ) < 0.00001 * $ q ) { break ; } $ x = $ x - $ d / ( 3.0 * $ x * $ x ) ; } echo $ x . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ' meiji ' => 18680907 , ' taisho ' => 19120729 , ' showa ' => 19261224 , ' heisei ' => 19890107 ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %d %d %d ' , $ y , $ m , $ d ) ; $ n = ( int ) sprintf ( ' %04d%02d%02d ' , $ y , $ m , $ d ) ; $ result = ' pre-meiji ' ; foreach ( $ arr as $ k => $ v ) { if ( $ n > $ v ) { $ y2 = $ y - ( int ) substr ( $ v , 0 , 4 ) + 1 ; $ result = sprintf ( ' %s %d %d %d ' , $ k , $ y2 , $ m , $ d ) ; } } echo $ result , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" date.timezone \" , \" Asia/Tokyo \" ) ; function printDate ( $ start , $ date ) { list ( $ ys , , ) = explode ( \" - \" , $ start ) ; list ( $ yd , $ md , $ dd ) = explode ( \" - \" , $ date ) ; $ year = $ yd - $ ys + 1 ; return \" $ year $ md $ dd \" ; } function main ( ) { $ MEIJI = \" 1868-09-08 \" ; $ TAISHO = \" 1912-07-30 \" ; $ SHOWA = \" 1926-12-25 \" ; $ HEISEI = \" 1989-01-08 \" ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ y , $ m , $ d ) = explode ( ' ' , $ line ) ; $ date = \" $ y - $ m - $ d \" ; if ( strtotime ( $ date ) < strtotime ( $ MEIJI ) ) { echo \" pre-meiji \\n \" ; } elseif ( strtotime ( $ date ) < strtotime ( $ TAISHO ) ) { echo \" meiji \" . printDate ( $ MEIJI , $ date ) . \" \\n \" ; } elseif ( strtotime ( $ date ) < strtotime ( $ SHOWA ) ) { echo \" taisho \" . printDate ( $ TAISHO , $ date ) . \" \\n \" ; } elseif ( strtotime ( $ date ) < strtotime ( $ HEISEI ) ) { echo \" showa \" . printDate ( $ SHOWA , $ date ) . \" \\n \" ; } else { echo \" heisei \" . printDate ( $ HEISEI , $ date ) . \" \\n \" ; } } } main ( ) ;",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 0 ' ) { sscanf ( $ line , ' %d %d ' , $ n , $ m ) ; $ arr = array_fill ( 0 , $ n , 1 ) ; $ cnt = 0 ; $ i = $ n - 1 ; while ( $ cnt < $ n - 1 ) { for ( $ j = 0 ; $ j < $ m ; ) { $ i = $ i + 1 === $ n ? 0 : $ i + 1 ; if ( $ arr [ $ i ] ) { $ j ++ ; } } $ arr [ $ i ] = 0 ; $ cnt ++ ; } echo array_search ( 1 , $ arr ) + 1 , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ tokens = explode ( ' ' , $ line ) ; $ stack = array ( ) ; foreach ( $ tokens as $ t ) { switch ( $ t ) { case ' + ' : $ a = array_pop ( $ stack ) ; $ b = array_pop ( $ stack ) ; array_push ( $ stack , $ b + $ a ) ; break ; case ' - ' : $ a = array_pop ( $ stack ) ; $ b = array_pop ( $ stack ) ; array_push ( $ stack , $ b - $ a ) ; break ; case ' * ' : $ a = array_pop ( $ stack ) ; $ b = array_pop ( $ stack ) ; array_push ( $ stack , $ b * $ a ) ; break ; case ' / ' : $ a = array_pop ( $ stack ) ; $ b = array_pop ( $ stack ) ; array_push ( $ stack , $ b / $ a ) ; break ; default : array_push ( $ stack , $ t ) ; } } echo array_pop ( $ stack ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ ope = explode ( ' , ' , ' +,-,*,/ ' ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { $ stack = new \\ SplStack ( ) ; foreach ( explode ( ' ' , $ line ) as $ v ) { if ( ! in_array ( $ v , $ ope ) ) { $ stack [ ] = ( float ) $ v ; continue ; } $ b = $ stack -> pop ( ) ; $ a = $ stack -> pop ( ) ; if ( $ v === $ ope [ 0 ] ) { $ stack [ ] = $ a + $ b ; } elseif ( $ v === $ ope [ 1 ] ) { $ stack [ ] = $ a - $ b ; } elseif ( $ v === $ ope [ 2 ] ) { $ stack [ ] = $ a * $ b ; } else { $ stack [ ] = $ a / $ b ; } } printf ( \" %f \\n \" , $ stack -> pop ( ) ) ; }",
    "label": 3
  },
  {
    "code": "<?php class Node { public $ left ; public $ right ; public $ value ; public $ largest ; public function __construct ( $ value ) { $ this -> value = $ value ; } public function max_value ( ) { if ( $ this -> largest !== null ) { return $ this -> largest ; } if ( is_null ( $ this -> left ) && is_null ( $ this -> right ) ) { return $ this -> value ; } $ left = is_null ( $ this -> left ) ? - 1 : $ this -> left -> max_value ( ) ; $ right = is_null ( $ this -> right ) ? - 1 : $ this -> right -> max_value ( ) ; return $ this -> largest = $ this -> value + max ( $ left , $ right ) ; } } $ diamond = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ diamond [ ] = explode ( ' , ' , $ line ) ; } $ nodes = array ( ) ; for ( $ i = 0 ; $ i < count ( $ diamond ) ; $ i ++ ) { for ( $ j = 0 ; $ j < count ( $ diamond [ $ i ] ) ; $ j ++ ) { $ nodes [ $ i ] [ $ j ] = new Node ( $ diamond [ $ i ] [ $ j ] ) ; } } for ( $ i = 0 ; $ i < count ( $ nodes ) ; $ i ++ ) { for ( $ j = 0 ; $ j < count ( $ nodes [ $ i ] ) ; $ j ++ ) { $ n = $ nodes [ $ i ] [ $ j ] ; if ( $ i < count ( $ diamond ) / 2 - 1 ) { $ n -> left = isset ( $ nodes [ $ i + 1 ] [ $ j ] ) ? $ nodes [ $ i + 1 ] [ $ j ] : null ; $ n -> right = isset ( $ nodes [ $ i + 1 ] [ $ j + 1 ] ) ? $ nodes [ $ i + 1 ] [ $ j + 1 ] : null ; } else { $ n -> left = isset ( $ nodes [ $ i + 1 ] [ $ j - 1 ] ) ? $ nodes [ $ i + 1 ] [ $ j - 1 ] : null ; $ n -> right = isset ( $ nodes [ $ i + 1 ] [ $ j ] ) ? $ nodes [ $ i + 1 ] [ $ j ] : null ; } } } $ top = $ nodes [ 0 ] [ 0 ] ; echo $ top -> max_value ( ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ q = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ q [ ] = explode ( \" , \" , $ line ) ; } $ a = array ( ) ; $ arr_len = count ( $ q ) ; $ old_len = 0 ; for ( $ i = 0 ; $ i < $ arr_len ; $ i ++ ) { $ len = count ( $ q [ $ i ] ) ; $ a [ $ i ] = array ( ) ; if ( $ i == 0 ) { $ a [ $ i ] [ 0 ] = $ q [ $ i ] [ 0 ] ; } else { for ( $ j = 0 ; $ j < $ len ; $ j ++ ) { if ( $ len > $ old_len ) { if ( $ j <= 0 ) { $ o1 = 0 ; } else { $ o1 = $ a [ $ i - 1 ] [ $ j - 1 ] + $ q [ $ i ] [ $ j ] ; } if ( $ j >= $ len - 1 ) { $ o2 = 0 ; } else { $ o2 = $ a [ $ i - 1 ] [ $ j ] + $ q [ $ i ] [ $ j ] ; } } else { $ o1 = $ a [ $ i - 1 ] [ $ j ] + $ q [ $ i ] [ $ j ] ; $ o2 = $ a [ $ i - 1 ] [ $ j + 1 ] + $ q [ $ i ] [ $ j ] ; } if ( $ o1 > $ o2 ) { $ a [ $ i ] [ $ j ] = $ o1 ; } else { $ a [ $ i ] [ $ j ] = $ o2 ; } } } $ old_len = $ len ; } echo $ a [ $ arr_len - 1 ] [ 0 ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ first = true ; while ( TRUE ) { list ( $ a , $ b ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ a == 0 && $ b == 0 ) { break ; } if ( ! $ first ) { echo \" \\n \" ; } $ first = false ; $ found = false ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { if ( isLeapYear ( $ i ) ) { $ found = true ; echo $ i . \" \\n \" ; } } if ( ! $ found ) { echo \" NA \\n \" ; } } function isLeapYear ( $ y ) { if ( $ y % 4 == 0 ) { if ( $ y % 100 == 0 ) { if ( $ y % 400 == 0 ) { return true ; } else { return false ; } } else { return true ; } } else { return false ; } }",
    "label": 3
  },
  {
    "code": "<?php $ f = 0 ; while ( 1 ) { fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ; if ( $ a == 0 && $ b == 0 ) { return 0 ; } if ( $ f != 0 ) { echo \" \\n \" ; } $ f ++ ; $ flag = 1 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { if ( checkdate ( 2 , 29 , $ i ) ) { echo $ i . \" \\n \" ; $ flag = 0 ; } } if ( $ flag ) { echo \" NA \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ result = array ( ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 0 ' ) { sscanf ( $ line , ' %d %d ' , $ a , $ b ) ; $ arr = array ( ) ; for ( ; $ a <= $ b ; $ a ++ ) { if ( ( $ a % 4 === 0 && $ a % 100 !== 0 ) || $ a % 400 === 0 ) { $ arr [ ] = $ a ; } } $ result [ ] = count ( $ arr ) > 0 ? implode ( PHP_EOL , $ arr ) : ' NA ' ; } echo implode ( PHP_EOL . PHP_EOL , $ result ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ first = true ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ a , $ b ) = explode ( ' ' , $ line ) ; if ( $ a == 0 && $ b == 0 ) { break ; } if ( $ first ) { $ first = false ; } else { echo \" \\n \" ; } $ na = true ; for ( $ y = $ a ; $ y <= $ b ; ++ $ y ) { $ uruu = false ; if ( $ y % 4 == 0 ) { $ uruu = true ; if ( $ y % 100 == 0 ) { $ uruu = false ; } if ( $ y % 400 == 0 ) { $ uruu = true ; } } if ( $ uruu ) { $ na = false ; echo \" $ y \\n \" ; } } if ( $ na ) { echo \" NA \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ fst = true ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ years = explode ( ' ' , $ line ) ; if ( $ years [ 0 ] == 0 && $ years [ 1 ] == 0 ) { return ; } if ( $ years [ 0 ] > $ years [ 1 ] ) { return ; } if ( $ years [ 0 ] <= 0 ) { return ; } if ( $ years [ 1 ] >= 3000 ) { return ; } if ( $ fst ) { $ fst = false ; } else { echo PHP_EOL ; } $ naFlag = true ; for ( $ i = $ years [ 0 ] ; $ i <= $ years [ 1 ] ; $ i ++ ) { $ retLeap = leap ( $ i ) ; if ( $ retLeap ) { echo $ i . PHP_EOL ; $ naFlag = false ; } } if ( $ naFlag ) { echo ' NA ' . PHP_EOL ; } } function leap ( $ year ) { if ( $ year % 4 == 0 ) { if ( $ year % 100 == 0 ) { if ( $ year % 400 == 0 ) { $ leap = true ; } else { $ leap = false ; } } else { $ leap = true ; } } else { $ leap = false ; } return $ leap ; }",
    "label": 3
  },
  {
    "code": "<?php $ inputArray = array ( ) ; while ( ! feof ( STDIN ) ) { $ input = trim ( fgets ( STDIN ) ) ; if ( empty ( $ input ) ) { break ; } array_push ( $ inputArray , $ input ) ; } $ loopcount = 0 ; foreach ( $ inputArray as $ years ) { $ delimiter = ' ' ; $ aryInputs = explode ( $ delimiter , $ years ) ; $ startYear = $ aryInputs [ 0 ] ; $ endYear = $ aryInputs [ 1 ] ; if ( ! $ startYear || ! $ endYear ) { break ; } if ( $ loopcount ++ ) { echo \" \\n \" ; } $ count = 0 ; for ( $ year = $ startYear ; $ year <= $ endYear ; $ year ++ ) { if ( ( ! ( $ year % 4 ) && $ year % 100 ) || ! ( $ year % 400 ) ) { echo $ year . \" \\n \" ; $ count ++ ; } } if ( ! $ count ) { echo ' NA ' . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ result = [ ] ; while ( $ d = trim ( fgets ( STDIN ) ) ) { $ s = explode ( ' ' , $ d ) ; $ l_year = $ s [ 0 ] ; $ r_year = $ s [ 1 ] ; $ leap_count = 0 ; if ( $ s [ 0 ] == 0 && $ s [ 1 ] == 0 ) { break ; } for ( $ l_year ; $ l_year <= $ r_year ; $ l_year ++ ) { $ leap_flag = false ; if ( $ l_year % 4 == 0 ) $ leap_flag = true ; if ( $ l_year % 100 == 0 ) $ leap_flag = false ; if ( $ l_year % 400 == 0 ) $ leap_flag = true ; if ( $ leap_flag ) { $ leap_count ++ ; array_push ( $ result , $ l_year . \" \\n \" ) ; } } if ( $ leap_count == 0 ) { array_push ( $ result , ' NA ' . \" \\n \" ) ; } array_push ( $ result , \" \\n \" ) ; } print trim ( implode ( \" \" , $ result ) ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ i = 0 ; while ( true ) { $ cnt = 0 ; $ stdin = trim ( fgets ( STDIN ) ) ; $ years = explode ( ' ' , $ stdin ) ; if ( $ years [ 0 ] == 0 && $ years [ 1 ] == 0 ) { break ; } if ( $ i !== 0 ) { echo \" \\n \" ; } for ( $ i = $ years [ 0 ] ; $ i <= $ years [ 1 ] ; $ i ++ ) { if ( $ i % 4 === 0 && $ i % 100 !== 0 || $ i % 400 === 0 ) { echo $ i . \" \\n \" ; $ cnt ++ ; } } if ( $ cnt == 0 ) { echo \" NA \\n \" ; } $ i ++ ; }",
    "label": 3
  },
  {
    "code": "<?php list ( $ a , $ b ) = fscanf ( STDIN , \" %d %d \" ) ; echo $ a * $ b / 3.305785 . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d %d ' , $ a , $ b ) ; echo $ a * $ b / 3.305785 , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ in = trim ( fgets ( STDIN ) ) ; $ in = explode ( \" \" , $ in ) ; print ( $ in [ 0 ] * $ in [ 1 ] / 3.305785 ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f%f \" , $ a , $ b ) ; print ( ( $ a * $ b ) / 3.305785 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ tsubo = 3.305785 ; $ data = explode ( ' ' , fgets ( STDIN ) ) ; echo ( $ data [ 0 ] * $ data [ 1 ] ) / $ tsubo ;",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ list = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a , $ v ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ list [ $ a ] = $ v ; } $ max = max ( $ list ) ; $ top_tie = array_filter ( $ list , function ( $ e ) use ( $ max ) { return $ e == $ max ; } ) ; ksort ( $ top_tie ) ; reset ( $ top_tie ) ; echo key ( $ top_tie ) . \" \" . current ( $ top_tie ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ arr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %d %d ' , $ a , $ v ) ; $ arr [ $ a ] = $ v ; } ksort ( $ arr ) ; $ v = max ( $ arr ) ; $ a = array_search ( $ v , $ arr ) ; echo \" $ a $ v \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ x = array_fill ( 0 , 1001 , 1 ) ; $ y = array_fill ( 0 , 2001 , 0 ) ; for ( $ i = 0 ; $ i <= 1000 ; $ i ++ ) { for ( $ j = 0 ; $ j <= 1000 ; $ j ++ ) { $ y [ $ i + $ j ] += $ x [ $ i ] ; } } $ x = $ y ; $ y = array_fill ( 0 , 3001 , 0 ) ; for ( $ i = 0 ; $ i <= 1000 ; $ i ++ ) { for ( $ j = 0 ; $ j <= 2000 ; $ j ++ ) { $ y [ $ i + $ j ] += $ x [ $ j ] ; } } $ x = $ y ; $ y = array_fill ( 0 , 4001 , 0 ) ; for ( $ i = 0 ; $ i <= 1000 ; $ i ++ ) { for ( $ j = 0 ; $ j <= 3000 ; $ j ++ ) { $ y [ $ i + $ j ] += $ x [ $ j ] ; } } while ( $ line = fgets ( STDIN ) ) { $ n = intval ( $ line ) ; echo $ y [ $ n ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ y = array_fill ( 0 , 2001 , 0 ) ; for ( $ b = 0 ; $ b <= 1000 ; $ b ++ ) { for ( $ a = 0 ; $ a <= 1000 ; $ a ++ ) { $ y [ $ a + $ b ] ++ ; } } $ x = $ y ; $ y = array_fill ( 0 , 3001 , 0 ) ; for ( $ c = 0 ; $ c <= 1000 ; $ c ++ ) { for ( $ i = 0 ; $ i <= 2000 ; $ i ++ ) { $ y [ $ i + $ c ] += $ x [ $ i ] ; } } $ x = $ y ; $ y = array_fill ( 0 , 4001 , 0 ) ; for ( $ d = 0 ; $ d <= 1000 ; $ d ++ ) { for ( $ i = 0 ; $ i <= 3000 ; $ i ++ ) { $ y [ $ i + $ d ] += $ x [ $ i ] ; } } while ( $ line = fgets ( STDIN ) ) { $ n = intval ( $ line ) ; echo $ y [ $ n ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ numData = trim ( fgets ( STDIN ) ) ; if ( $ numData == 0 ) { break ; } $ data = array ( ) ; for ( $ i = 0 ; $ i < $ numData ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; list ( $ ind , $ unit , $ quantity ) = explode ( ' ' , $ line ) ; if ( isset ( $ data [ $ ind ] ) ) { $ data [ $ ind ] += $ unit * $ quantity ; } else { $ data [ $ ind ] = $ unit * $ quantity ; } } $ found = false ; foreach ( $ data as $ ind => $ total ) { if ( $ total >= 1000000 ) { echo \" $ ind \\n \" ; $ found = true ; } } if ( ! $ found ) { echo \" NA \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ dataCount = trim ( fgets ( STDIN ) ) ; if ( $ dataCount == 0 ) { return ; } for ( $ i = 0 ; $ i < $ dataCount ; $ i ++ ) { list ( $ employeeNum , $ ratio , $ sale ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( empty ( $ dataSet [ $ employeeNum ] ) ) { $ dataSet [ $ employeeNum ] = $ ratio * $ sale ; } else { $ dataSet [ $ employeeNum ] += $ ratio * $ sale ; } } foreach ( $ dataSet as $ key => $ value ) { if ( $ value >= 1000000 ) { $ okEmployee [ ] = $ key ; } } if ( empty ( $ okEmployee ) ) { echo ' NA ' , PHP_EOL ; } else { echo implode ( PHP_EOL , $ okEmployee ) , PHP_EOL ; } unset ( $ i ) ; unset ( $ dataSet ) ; unset ( $ okEmployee ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ dataCount = trim ( fgets ( STDIN ) ) ; if ( $ dataCount == 0 ) { return ; } $ dataSet = [ ] ; for ( $ i = 0 ; $ i < $ dataCount ; $ i ++ ) { list ( $ employeeNum , $ ratio , $ sale ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( empty ( $ dataSet [ $ employeeNum ] ) ) { $ dataSet [ $ employeeNum ] = $ ratio * $ sale ; } else { $ dataSet [ $ employeeNum ] += $ ratio * $ sale ; } } $ result = [ ] ; foreach ( $ dataSet as $ key => $ value ) { if ( $ value >= 1000000 ) { $ result [ ] = $ key ; } } if ( empty ( $ result ) ) { $ result [ ] = ' NA ' ; } echo implode ( PHP_EOL , $ result ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ employeeCount = getStdin ( ) ; if ( $ employeeCount == 0 ) { break ; } $ passedEmployees = [ ] ; $ sums = [ ] ; for ( $ i = 0 ; $ i < $ employeeCount ; $ i ++ ) { list ( $ employeeNumber , $ price , $ salesNumber ) = explodeStdin ( ) ; if ( ! empty ( $ sums [ $ employeeNumber ] ) ) { $ sums [ $ employeeNumber ] += $ price * $ salesNumber ; } else { $ sums [ $ employeeNumber ] = $ price * $ salesNumber ; } } foreach ( $ sums as $ number => $ sum ) { if ( $ sum >= 1000000 ) { $ passedEmployees [ ] = $ number ; } } $ results [ ] = ( count ( $ passedEmployees ) > 0 ) ? ( $ passedEmployees ) : [ ' NA ' ] ; } foreach ( $ results as $ result ) { echo implode ( PHP_EOL , $ result ) , PHP_EOL ; } function getStdin ( ) { return trim ( fgets ( STDIN ) ) ; } function explodeStdin ( ) { return explode ( ' ' , getStdin ( ) ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( \" php: while(true) { $ n = fgets( $ fp ); if( $ n == 0) break; $ data = new Data(); for( $ i = 0; $ i < $ n ; $ i ++) { $ buf = fgets( $ fp ); $ splited = explode( \" \" , $ buf ) ; $ data -> update ( $ splited [ 0 ] , $ splited [ 1 ] * $ splited [ 2 ] ) ; } $ data -> countGoodEmployee ( ) ; } Class Data { private $ _employee ; public function __construct ( ) { $ this -> _employee = array ( ) ; } public function update ( $ id , $ sales ) { for ( $ i = 0 ; $ i < count ( $ this -> _employee ) ; $ i ++ ) { if ( $ this -> _employee [ $ i ] -> getId ( ) == $ id ) { $ this -> _employee [ $ i ] -> addSales ( $ sales ) ; return ; } } $ new_employee = new Employee ( $ id , $ sales ) ; array_push ( $ this -> _employee , $ new_employee ) ; } public function countGoodEmployee ( ) { $ flg = true ; for ( $ i = 0 ; $ i < count ( $ this -> _employee ) ; $ i ++ ) { if ( $ this -> _employee [ $ i ] -> getSales ( ) >= 1000000 ) { echo $ this -> _employee [ $ i ] -> getId ( ) . \" \\n \" ; $ flg = false ; } } if ( $ flg ) echo \" NA \\n \" ; } } Class Employee { private $ _id ; private $ _sales ; public function __construct ( $ id , $ sales ) { $ this -> _id = $ id ; $ this -> _sales = $ sales ; } public function addSales ( $ sales ) { $ this -> _sales += $ sales ; } public function getId ( ) { return $ this -> _id ; } public function getSales ( ) { return $ this -> _sales ; } public function printEmployee ( ) { echo \" id: \" . $ this -> _id . \" , sales: \" . $ this -> _sales . \" \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) && ( $ n > 0 ) ) { $ prev = - 1 ; $ goukei = array ( ) ; $ next = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ sno , $ kosuu , $ tanka ) ; if ( empty ( $ goukei [ $ sno ] ) ) { $ goukei [ $ sno ] = $ kosuu * $ tanka ; if ( $ prev > 0 ) { $ next [ $ prev ] = $ sno ; $ next [ $ sno ] = 0 ; } else { $ start = $ sno ; $ next [ $ sno ] = 0 ; } $ prev = $ sno ; } else $ goukei [ $ sno ] += $ kosuu * $ tanka ; } $ p = $ start ; $ count = 0 ; while ( 1 ) { if ( $ goukei [ $ p ] >= 1000000 ) { fprintf ( STDOUT , \" %d \\n \" , $ p ) ; $ count ++ ; } if ( $ next [ $ p ] == 0 ) break ; $ p = $ next [ $ p ] ; } if ( $ count == 0 ) fprintf ( STDOUT , \" NA \\n \" ) ; } return ( 0 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = fgets ( STDIN ) ; echo str_replace ( \" Hoshino \" , \" Hoshina \" , $ line ) ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ str = fgets ( STDIN ) ; echo str_replace ( ' Hoshino ' , ' Hoshina ' , $ str ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ inputCount = getStdin ( ) ; for ( $ i = 0 ; $ i < $ inputCount ; $ i ++ ) { echo str_replace ( ' Hoshino ' , ' Hoshina ' , fgets ( STDIN ) ) ; } function getStdin ( ) { return trim ( fgets ( STDIN ) ) ; } function explodeStdin ( ) { return explode ( ' ' , getStdin ( ) ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( \" php: $ n = (int)fgets( $ fp ); for( $ i = 0; $ i < $ n ; $ i ++) { $ buf = rtrim(fgets( $ fp )); for( $ j = 0; $ j < strlen( $ buf )-6; $ j ++) { if(isHoshino( $ buf , $ j ) ) $ buf [ $ j + 6 ] = 'a'; } echo $ buf ; if( $ i < $ n - 1) echo \" \\ n \" ; } function isHoshino ( $ str , $ pos ) { if ( $ str [ $ pos ] != ' H ' ) { return false ; } if ( $ str [ $ pos + 1 ] != ' o ' ) { return false ; } if ( $ str [ $ pos + 2 ] != ' s ' ) { return false ; } if ( $ str [ $ pos + 3 ] != ' h ' ) { return false ; } if ( $ str [ $ pos + 4 ] != ' i ' ) { return false ; } if ( $ str [ $ pos + 5 ] != ' n ' ) { return false ; } if ( $ str [ $ pos + 6 ] != ' o ' ) { return false ; } return true ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ t = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ t ; $ i ++ ) { $ input_line = fgets ( STDIN ) ; echo str_replace ( \" Hoshino \" , \" Hoshina \" , $ input_line ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ t = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ t ; $ i ++ ) { $ input_line = fgets ( STDIN ) ; echo str_replace ( \" Hoshino \" , \" Hoshina \" , $ input_line ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ n = trim ( fgets ( STDIN ) ) ; if ( $ n == 0 ) { break ; } $ m = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ row = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ row [ ] = array_sum ( $ row ) ; $ m [ $ i ] = $ row ; } $ m [ $ n ] = array ( ) ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { $ m [ $ n ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ m [ $ n ] [ $ j ] += $ m [ $ i ] [ $ j ] ; } } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { printf ( \" %5d \" , $ m [ $ i ] [ $ j ] ) ; } echo \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 ' ) { $ n = ( int ) $ line ; $ arr = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; foreach ( explode ( ' ' , $ line ) as $ j => $ m ) { $ m = ( int ) $ m ; $ arr [ $ i ] [ $ j ] = $ m ; $ arr [ $ i ] [ $ n ] += $ m ; $ arr [ $ n ] [ $ j ] += $ m ; } } $ arr [ $ n ] [ $ n ] = array_sum ( $ arr [ $ n ] ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { printf ( ' %5d ' , $ arr [ $ i ] [ $ j ] ) ; } echo PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 ' ) { $ n = ( int ) $ line ; $ arr = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; foreach ( explode ( ' ' , $ line ) as $ j => $ m ) { $ m = ( int ) $ m ; $ arr [ $ i ] [ $ j ] = $ m ; $ arr [ $ i ] [ $ n ] += $ m ; $ arr [ $ n ] [ $ j ] += $ m ; } } $ arr [ $ n ] [ $ n ] = array_sum ( $ arr [ $ n ] ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { printf ( ' %5d ' , $ arr [ $ i ] [ $ j ] ) ; } echo PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ score = 0 ; $ out = 0 ; $ runners = array ( false , false , false ) ; $ inning = 0 ; $ n = trim ( fgets ( STDIN ) ) ; while ( $ inning < $ n ) { $ event = trim ( fgets ( STDIN ) ) ; switch ( $ event ) { case \" HIT \" : hit ( ) ; break ; case \" HOMERUN \" : homerun ( ) ; break ; case \" OUT \" : out ( ) ; break ; } } function hit ( ) { global $ score , $ runners ; if ( $ runners [ 2 ] ) { $ score ++ ; $ runners [ 2 ] = false ; } if ( $ runners [ 1 ] ) { $ runners [ 1 ] = false ; $ runners [ 2 ] = true ; } if ( $ runners [ 0 ] ) { $ runners [ 0 ] = false ; $ runners [ 1 ] = true ; } $ runners [ 0 ] = true ; } function homerun ( ) { global $ score , $ runners ; foreach ( $ runners as $ r ) { if ( $ r ) { $ score ++ ; } } $ score ++ ; $ runners = array ( false , false , false ) ; } function out ( ) { global $ score , $ out , $ runners , $ inning ; $ out ++ ; if ( $ out == 3 ) { echo $ score . \" \\n \" ; $ score = 0 ; $ runners = array ( false , false , false ) ; $ out = 0 ; $ inning ++ ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ score = 0 ; $ out = 0 ; $ runner = 0 ; while ( $ out !== 3 ) { switch ( trim ( fgets ( STDIN ) ) ) { case ' HIT ' : if ( $ runner === 3 ) { $ score ++ ; } else { $ runner ++ ; } break ; case ' HOMERUN ' : $ score += $ runner + 1 ; $ runner = 0 ; break ; case ' OUT ' : $ out ++ ; break ; } } echo $ score , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = intval ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ out = 0 ; $ score = 0 ; $ runner = 0 ; while ( $ out < 3 ) { $ action = trim ( fgets ( STDIN ) ) ; if ( $ action == \" OUT \" ) { $ out ++ ; } else if ( $ action == \" HIT \" ) { if ( $ runner >= 3 ) { $ score ++ ; } else { $ runner ++ ; } } else if ( $ action == \" HOMERUN \" ) { $ score += $ runner + 1 ; $ runner = 0 ; } } echo $ score . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ set = intval ( fgets ( STDIN ) ) ; $ ining = 1 ; $ out = 0 ; $ total = 0 ; $ first = false ; $ second = false ; $ third = false ; while ( $ line = trim ( fgets ( STDIN ) ) ) { if ( $ line == \" OUT \" ) { $ out ++ ; } else if ( $ line == \" HIT \" ) { if ( $ third ) { $ total ++ ; $ third = false ; } if ( $ second ) { $ third = $ second ; $ second = false ; } if ( $ first ) { $ second = $ first ; $ first = false ; } $ first = true ; } else if ( $ line == \" HOMERUN \" ) { if ( $ third ) { $ total ++ ; } if ( $ second ) { $ total ++ ; } if ( $ first ) { $ total ++ ; } $ total ++ ; $ first = false ; $ second = false ; $ third = false ; } if ( $ out >= 3 ) { echo $ total . \" \\n \" ; $ ining ++ ; $ out = 0 ; $ total = 0 ; $ first = false ; $ second = false ; $ third = false ; } if ( $ ining > $ set ) { exit ( ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ out_count = 0 ; $ run_count = 0 ; $ point = 0 ; while ( $ out_count < 3 ) { $ event = trim ( fgets ( STDIN ) ) ; if ( $ event == ' OUT ' ) { $ out_count ++ ; } else if ( $ event == ' HIT ' ) { if ( $ run_count == 3 ) { $ point ++ ; continue ; } $ run_count ++ ; } else { $ point += $ run_count + 1 ; $ run_count = 0 ; } } echo $ point . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ num = trim ( fgets ( STDIN ) ) ; $ num = explode ( \" \\n \" , $ num ) ; $ score = 0 ; $ hit = 0 ; $ out = 0 ; while ( $ line = fgets ( STDIN ) ) { $ line = explode ( \" \\n \" , $ line ) ; if ( $ line [ 0 ] == ' HIT ' ) { $ hit ++ ; if ( $ hit > 3 ) { $ hit = $ hit - 1 ; $ score += 1 ; } } else if ( $ line [ 0 ] == ' OUT ' ) { $ out ++ ; if ( $ out > 2 ) { $ out = 0 ; printf ( $ score . \" \\n \" ) ; $ score = 0 ; $ hit = 0 ; } } else if ( $ line [ 0 ] == ' HOMERUN ' ) { $ score = $ hit + 1 + $ score ; $ hit = 0 ; } }",
    "label": 3
  },
  {
    "code": "<?php $ inning = trim ( fgets ( STDIN ) ) ; $ outs = 0 ; $ bases = array ( 1 => 0 , 2 => 0 , 3 => 0 ) ; $ score = 0 ; while ( $ e = trim ( fgets ( STDIN ) ) ) { switch ( $ e ) { case ' HIT ' : if ( ! $ bases [ 1 ] ) $ bases [ 1 ] = 1 ; elseif ( ! $ bases [ 2 ] ) $ bases [ 2 ] = 1 ; elseif ( ! $ bases [ 3 ] ) $ bases [ 3 ] = 1 ; else ++ $ score ; break ; case ' HOMERUN ' : $ score += $ bases [ 1 ] + $ bases [ 2 ] + $ bases [ 3 ] + 1 ; $ bases [ 1 ] = $ bases [ 2 ] = $ bases [ 3 ] = 0 ; break ; case ' OUT ' : ++ $ outs ; if ( $ outs == 3 ) { echo $ score . \" \\n \" ; $ outs = $ score = $ bases [ 1 ] = $ bases [ 2 ] = $ bases [ 3 ] = 0 ; } break ; } }",
    "label": 3
  },
  {
    "code": "<?php $ dsCount = trim ( fgets ( STDIN ) ) ; $ stdin = array ( ) ; $ i = 0 ; $ outCount = 0 ; $ hitCount = 0 ; $ roopNo = 0 ; $ score = 0 ; $ scores = array ( $ dsCount ) ; while ( true ) { $ stdin [ $ i ] = trim ( fgets ( STDIN ) ) ; if ( $ stdin [ $ i ] == \" HIT \" ) { $ hitCount ++ ; if ( $ hitCount >= 4 ) { $ hitCount = 3 ; $ score += 1 ; } } elseif ( $ stdin [ $ i ] == \" OUT \" ) { $ outCount ++ ; } elseif ( $ stdin [ $ i ] == \" HOMERUN \" ) { $ score += ( $ hitCount + 1 ) ; $ hitCount = 0 ; } if ( $ outCount >= 3 ) { if ( $ roopNo >= ( $ dsCount - 1 ) ) { $ scores [ $ roopNo ] = $ score ; break ; } else { $ scores [ $ roopNo ] = $ score ; $ score = 0 ; $ hitCount = 0 ; $ outCount = 0 ; } $ roopNo ++ ; } } foreach ( $ scores as $ key => $ value ) { print $ value . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ inning = trim ( fgets ( STDIN ) ) ; $ scores = array ( ) ; for ( $ i = 0 ; $ i < $ inning ; ++ $ i ) { $ scores [ $ i ] = 0 ; } $ outcount = 0 ; $ base = 0 ; while ( true ) { $ turn = floor ( $ outcount / 3 ) ; $ key = trim ( fgets ( STDIN ) ) ; switch ( $ key ) { case ' HIT ' : $ scores [ $ turn ] += $ base & 1 ; $ base = ( $ base >> 1 ) | 4 ; break ; case ' OUT ' : if ( ++ $ outcount % 3 == 0 ) { $ base = 0 ; } break ; case ' HOMERUN ' : $ base |= 8 ; while ( $ base ) { $ scores [ $ turn ] += $ base & 1 ; $ base = $ base >> 1 ; } break ; } if ( $ outcount == 3 * $ inning ) { break ; } } foreach ( $ scores as $ score ) { echo $ score . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ inputArray = array ( ) ; while ( ! feof ( STDIN ) ) { $ input = trim ( fgets ( STDIN ) ) ; if ( empty ( $ input ) ) { break ; } array_push ( $ inputArray , $ input ) ; } $ ening = array_shift ( $ inputArray ) ; $ outcount = 0 ; $ diamond = 0 ; $ nowEning = 1 ; foreach ( $ inputArray as $ daseki ) { if ( $ daseki == \" HIT \" ) { $ diamond *= 2 ; $ diamond ++ ; } else if ( $ daseki == \" HOMERUN \" ) { $ diamond *= 16 ; $ diamond += 8 ; } else if ( $ daseki == \" OUT \" ) { $ outcount ++ ; if ( $ outcount > 2 ) { $ diamond /= 8 ; $ point = substr_count ( decbin ( $ diamond ) , ' 1 ' ) ; echo $ point . \" \\n \" ; $ diamond = 0 ; $ outcount = 0 ; $ nowEning ++ ; if ( $ ening < $ nowEning ) { break ; } } } }",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( \" php: $ inning = (int)fgets( $ fp ); $ out = 0; $ run = 0; $ onbase = 0; while( $ inning > 0) { $ batting = rtrim(fgets( $ fp )); if( $ batting === \" HIT \" ) { hit ( $ onbase , $ run ) ; } elseif ( $ batting === \" OUT \" ) { $ out ++ ; if ( $ out == 3 ) { echo \" $ run \" ; $ out = 0 ; $ run = 0 ; $ onbase = 0 ; $ inning -- ; if ( $ inning != 0 ) echo \" \\n \" ; } } elseif ( $ batting === \" HOMERUN \" ) { homerun ( $ onbase , $ run ) ; } } function hit ( & $ onbase , & $ run ) { $ onbase = ( $ onbase << 1 ) + 1 ; if ( $ onbase > 7 ) { $ run ++ ; $ onbase -= 8 ; } } function homerun ( & $ onbase , & $ run ) { $ run ++ ; if ( $ onbase & 1 ) $ run ++ ; if ( $ onbase & 2 ) $ run ++ ; if ( $ onbase & 4 ) $ run ++ ; $ onbase = 0 ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( \" php: $ T =trim(fgets( $ fp )); $ out =3; $ score =0; $ base =array(); while( $ T >0){ $ input =trim(fgets( $ fp )); if( $ input == \" HIT \" ) { if ( count ( $ base ) < 3 ) array_push ( $ base , \" x \" ) ; else if ( count ( $ base ) == 3 ) { $ score ++ ; array_shift ( $ base ) ; array_push ( $ base , \" x \" ) ; } } else if ( $ input == \" HOMERUN \" ) { $ score += ( count ( $ base ) + 1 ) ; $ base = array ( ) ; } if ( $ input == \" OUT \" ) $ out -- ; if ( $ out == 0 ) { echo $ score . \" \\n \" ; $ score = 0 ; $ T -- ; $ out = 3 ; $ base = array ( ) ; } } function Solve ( $ matrix ) { } ?>",
    "label": 3
  },
  {
    "code": "<?php $ count = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ out = 0 ; $ run = 0 ; $ score = 0 ; while ( 1 ) { $ r = trim ( fgets ( STDIN ) ) ; switch ( $ r ) { case ' OUT ' : $ out ++ ; break ; case ' HIT ' : $ run ++ ; break ; case ' HOMERUN ' : $ score += $ run + 1 ; $ run = 0 ; break ; } if ( $ out == 3 ) { break ; } else if ( $ run == 4 ) { $ score += 1 ; $ run -= 1 ; } } echo $ score . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ tokens = array ( ) ; $ cnt = 0 ; $ variables = array ( ) ; main ( ) ; function main ( ) { global $ tokens , $ cnt ; $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { try { $ cnt = 0 ; $ input = trim ( fgets ( STDIN ) ) ; $ tokens = tokenize ( $ input ) ; if ( is_assignment ( ) ) { assign ( ) ; } else { $ tree = expression ( ) ; echo $ tree -> evaluate ( ) . \" \\n \" ; } } catch ( SyntaxErrorException $ e ) { echo $ e -> getMessage ( ) . \" \\n \" ; $ tokens = array ( ) ; $ cnt = 0 ; } catch ( UndefinedVariableException $ e ) { echo $ e -> getMessage ( ) . \" \\n \" ; $ tokens = array ( ) ; $ cnt = 0 ; } } } function tokenize ( $ line ) { $ line = str_replace ( ' ' , ' ' , $ line ) ; preg_match_all ( \" @([0-9]+|\\+|\\-|\\*|/|\\(|\\))@ \" , $ line , $ tokens ) ; if ( ! is_array ( $ tokens ) ) { return array ( ) ; } return $ tokens [ 0 ] ; } function is_assignment ( ) { global $ tokens ; if ( count ( $ tokens ) < 3 ) { return false ; } $ t0 = $ tokens [ 0 ] ; $ t1 = $ tokens [ 1 ] ; if ( is_string ( $ t0 ) && $ t1 === ' = ' ) { return true ; } else { return false ; } } function assign ( ) { global $ variables , $ tokens , $ cnt ; $ var = $ tokens [ 0 ] ; $ cnt += 2 ; $ exp = expression ( ) ; $ variables [ $ var ] = is_object ( $ exp ) ? $ exp -> evaluate ( ) : null ; } function expression ( ) { global $ tokens , $ cnt ; if ( empty ( $ tokens ) ) { die ( \" tokens are empty \\n \" ) ; } $ node = term ( ) ; while ( true ) { if ( $ cnt >= count ( $ tokens ) ) { break ; } $ next = $ tokens [ $ cnt ] ; if ( $ next === ' + ' || $ next === ' - ' ) { $ cnt ++ ; $ node = new Node ( $ next , $ node , term ( ) ) ; } else { break ; } } return $ node ; } function term ( ) { global $ tokens , $ cnt ; $ node = factor ( ) ; while ( true ) { if ( $ cnt >= count ( $ tokens ) ) { break ; } $ next = $ tokens [ $ cnt ] ; if ( $ next === ' * ' || $ next === ' / ' ) { $ cnt ++ ; $ node = new Node ( $ next , $ node , factor ( ) ) ; } else { break ; } } return $ node ; } function factor ( ) { global $ variables , $ tokens , $ cnt ; $ next = $ tokens [ $ cnt ] ; if ( $ next === ' ( ' ) { $ cnt ++ ; $ node = expression ( ) ; if ( $ tokens [ $ cnt ++ ] !== ' ) ' ) { throw new SyntaxErrorException ( \" \"); } return $node; } e s if (is n umer i ( next)) { $cnt++; r e t urn n e o de( in t al($ne t)) } e l seif ( i s _str i n g $ ext)) if (isset ( $ vari a b e [$ e xt])) { $cnt++; r e turn n e o de( $v a iables $ne t]); } throw ne w Unde f i n d ariab eEx eption(\"Undefined variable : \" . $next); } else { h o w ne w y taxE r rExce tio (\"Syntax error 2.\\n\" ) ; } } class Node { p u l c $valu ; pu l c $lef ; publ i $righ ; pub l c func i on __ c nstruc ($value null, $lef t = nul , $rig h = nu l { $ t i s->va u = $ v l e ; $t hi s->le t = $lef t $thi s- >rig t = $ri g t ; } pu blic u c tion e a uate() { if (is numeric( $ t i -> a lue) || $t h i s->v al ue == = nu l ) { re turn ntv l($t h s >value ; } if ( $thi s- >left & th s - >rig ht ) { le t = $ th is->l e t > eval a e (); $r ight = $this-> r i g t ->eva u t e(); $ op = $t his->val u e ; s wi c ($op ) { cas e '+': r t u rn l ft + $ r i g t; cas '-': r t urn $ l ft - $ r i g t; cas '*': r t urn $ l ft * $ r i g t; cas '/': r t urn i n val( l e f t / $rig t); de f a ult: t r ow ne w yntaxEr r rExce tio (\"$op\"); } } t h row new SyntaxErrorEx c ep t i o ( e aluat :  \"); } public f unction show($depth = 0) { $return = \"\"; $ l f = is_ ($this-> eft, \" Node\" \" n . $thi - l e f - >sho ( dept h + 1) : $th i - >lef t ; $ i gh t = i s_a( $t his- >r ight , \"Node ) ? \\ \" . $ th is-> r g ht->s o ($de p t h + 1) : $t h s ->ri g h ; $ re t r .= $ th is->s pa ce($ d e pth) v a u = {$ th is->v a u e}\\n\"; $r t urn .= $thi s - >spac e $ e pth) . \" l e ft = { $left } \\n \" ; $ return .= $ this -> space ( $ depth ) . \" right = { $rig h t} \\ n ; retur $ e turn ; } pri v a te fu n t o n space( $ d epth) { $ s ace = \" ; for ( i = 0; $i < $depth * 4; $ i ++) { s a ce .= \" \" ; re u r n $ p a e ; } } clas y n a x Er r r x cepti n x t e n s Except o n {} c a s Undef nedVariableException extends RuntimeEx e p ion {",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php function process($s){ $bidx=strpos($s,'('); while($bidx!==FALSE){ $count=1; $eidx=$bidx+1; for(;$count;$eidx++){ if($s{$eidx}=='(')$count++; if($s{$eidx}==')')$count--; } $s=substr($s,0,$bidx).process(substr($s,$bidx+1,$eidx-1-($bidx+1))).substr($s,$eidx); $bidx=strpos($s,'('); } $matches=null; while(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){ if($matches[3]=='*') $s=$matches[1].($matches[2]*$matches[4]).$matches[5]; else $s=$matches[1].intval($matches[2]/$matches[4]).$matches[5]; } while(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){ if($matches[3]=='+') $s=$matches[1].($matches[2]+$matches[4]).$matches[5]; else $s=$matches[1].($matches[2]-$matches[4]).$matches[5]; } return $s; } for($n=fgets(STDIN)^0;$n;$n--){ $s=str_replace('-','Z',rtrim(fgets(STDIN))); echo process(substr($s,0,strlen($s)-1)).\"\\n\"; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 ' ) { $ n = ( int ) $ line ; $ arr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %d ' , $ m ) ; $ arr [ $ i ] = $ m ; } sort ( $ arr ) ; $ arr2 = array ( 0 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ arr2 [ ] = $ arr2 [ $ i - 1 ] + $ arr [ $ i - 1 ] ; } echo array_sum ( $ arr2 ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { list ( $ manCount ) = stdInput ( ) ; if ( $ manCount == 0 ) { exit ; } $ array = [ ] ; for ( $ i = 0 ; $ i < $ manCount ; $ i ++ ) { $ array = array_merge ( $ array , stdInput ( ) ) ; } sort ( $ array ) ; $ count = 0 ; $ answer = 0 ; $ countArray = [ ] ; for ( $ i = 0 ; $ i < $ manCount - 1 ; $ i ++ ) { $ count += $ array [ $ i ] ; $ answer += $ count ; } echo $ answer , PHP_EOL ; } function stdInput ( ) { return explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = fgets ( STDIN ) ) { list ( $ p , $ q ) = explode ( \" \" , trim ( $ line ) ) ; $ shou = array ( ) ; $ amari = array ( ) ; while ( true ) { $ amari [ ] = $ p ; $ p *= 10 ; $ s = intval ( $ p / $ q ) ; $ r = $ p % $ q ; $ shou [ ] = $ s ; if ( $ r == 0 ) { echo implode ( \" \" , $ shou ) . \" \\n \" ; break ; } $ i = array_search ( $ r , $ amari ) ; if ( $ i !== false ) { echo implode ( \" \" , $ shou ) . \" \\n \" ; echo str_repeat ( \" \" , $ i ) ; echo str_repeat ( \" ^ \" , count ( $ amari ) - $ i ) . \" \\n \" ; break ; } $ p = $ r ; } }",
    "label": 3
  },
  {
    "code": "<?php class PQ extends SplPriorityQueue { public function compare ( $ priority1 , $ priority2 ) { if ( $ priority1 === $ priority2 ) return 0 ; return $ priority1 > $ priority2 ? - 1 : 1 ; } } $ n = trim ( fgets ( STDIN ) ) ; $ m = trim ( fgets ( STDIN ) ) ; $ cost = [ ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { list ( $ a , $ b , $ c , $ d ) = explode ( ' , ' , trim ( fgets ( STDIN ) ) ) ; $ a -- ; $ b -- ; $ cost [ $ a ] [ $ b ] = $ c ; $ cost [ $ b ] [ $ a ] = $ d ; } list ( $ x1 , $ x2 , $ y1 , $ y2 ) = explode ( ' , ' , trim ( fgets ( STDIN ) ) ) ; $ x1 -- ; $ x2 -- ; $ y1 -= $ y2 ; $ que = new PQ ( ) ; $ que -> insert ( $ x1 , 0 ) ; $ expense = array_fill ( 0 , $ n , PHP_INT_MAX / 6 ) ; $ expense [ $ x1 ] = 0 ; while ( $ que -> count ( ) ) { $ now = $ que -> extract ( ) ; if ( $ now === $ x2 ) { break ; } foreach ( $ cost [ $ now ] as $ next => $ v ) { if ( $ expense [ $ next ] > $ expense [ $ now ] + $ cost [ $ now ] [ $ next ] ) { $ expense [ $ next ] = $ expense [ $ now ] + $ cost [ $ now ] [ $ next ] ; $ que -> insert ( $ next , $ expense [ $ next ] ) ; } } } $ y1 -= $ expense [ $ x2 ] ; $ que = new PQ ( ) ; $ que -> insert ( $ x2 , 0 ) ; $ expense = array_fill ( 0 , $ n , PHP_INT_MAX / 6 ) ; $ expense [ $ x2 ] = 0 ; while ( $ que -> count ( ) ) { $ now = $ que -> extract ( ) ; if ( $ now === $ x1 ) { break ; } foreach ( $ cost [ $ now ] as $ next => $ v ) { if ( $ expense [ $ next ] > $ expense [ $ now ] + $ cost [ $ now ] [ $ next ] ) { $ expense [ $ next ] = $ expense [ $ now ] + $ cost [ $ now ] [ $ next ] ; $ que -> insert ( $ next , $ expense [ $ next ] ) ; } } } $ y1 -= $ expense [ $ x1 ] ; echo $ y1 . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { $via_c = $cost[$j][$i] + $cost[$i][$k]; if ($via_c < $cost[$j][$k]) { $cost[$j][$k] = $via_c; } } } } return $cost; } $n = trim(fgets($file_handle)); for ($i=1; $i<=$n; ++$i){ for ($j=1; $j<=$n; ++$j){ if ($i === $j){ $cost[$i][$i] = 0; } else { $cost[$i][$j] = INF; } } } $m = trim(fgets($file_handle)); for ($i=1; $i<=$m; ++$i){ $info = trim(fgets($file_handle)); $explode = explode( ' , ' , $info); $a1 = $explode[0]; $b1 = $explode[1]; $c1 = $explode[2]; $d1 = $explode[3]; $cost[$a1][$b1] = $c1; $cost[$b1][$a1] = $d1; } $info2 = trim(fgets($file_handle)); $explode = explode( ' , ' , $info2); $start = $explode[0]; $goal = $explode[1]; $y1 = $explode[2]; $y2 = $explode[3]; $res = warshall_floyd($cost); $income = $y1; $expense = $res[$start][$goal] + $res[$goal][$start] + $y2; $output = $income - $expense; echo $output; echo PHP_EOL; fclose($file_handle);",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( array ( 3550 , 3750 , 4000 , 4300 , 5000 , 5500 , 7000 ) , array ( 7100 , 7700 , 8300 , 8900 , 10500 , 11600 , 14800 ) ) ; $ rank = explode ( ' , ' , ' AAA,AA,A,B,C,D,E,NA ' ) ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' ' ) { sscanf ( $ line , ' %f %f ' , $ a , $ b ) ; $ a = ( int ) ( $ a * 100 ) ; $ b = ( int ) ( $ b * 100 ) ; $ key = 7 ; for ( $ i = 0 ; $ i < 7 ; $ i ++ ) { if ( $ a < $ arr [ 0 ] [ $ i ] && $ b < $ arr [ 1 ] [ $ i ] ) { $ key = $ i ; break ; } } echo $ rank [ $ key ] , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr = array ( ) ; $ i = 0 ; while ( ( $ line = trim ( fgets ( STDIN ) ) ) !== ' 0 ' ) { $ n = ( int ) $ line ; $ result = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { fscanf ( STDIN , ' %s %d %d %d ' , $ team , $ win , $ lose , $ draw ) ; $ score = $ win * 3 + $ draw ; if ( ! isset ( $ result [ $ score ] ) ) { $ result [ $ score ] = array ( ) ; } $ result [ $ score ] [ ] = $ team ; } krsort ( $ result ) ; foreach ( $ result as $ score => $ arr2 ) { foreach ( $ arr2 as $ team ) { $ arr [ $ i ] [ ] = sprintf ( ' %s,%d%s ' , $ team , $ score , PHP_EOL ) ; } } $ arr [ $ i ] = implode ( ' ' , $ arr [ $ i ] ) ; $ i ++ ; } echo implode ( PHP_EOL , $ arr ) ;",
    "label": 3
  },
  {
    "code": "<?php $ c = trim ( fgets ( STDIN ) ) ; $ g = 0 ; for ( $ i = 0 ; $ i < $ c ; $ i ++ ) { $ ff = trim ( fgets ( STDIN ) ) ; $ g += $ ff ; } $ h = floor ( $ g / $ c ) ; echo $ h . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { list ( $ h , $ m ) = explode ( ' : ' , trim ( fgets ( STDIN ) ) ) ; $ dig_h = $ h * 30 + $ m * 0.5 ; $ dig_m = $ m * 6 ; if ( $ dig_h >= 360 ) { $ dig_h -= 360 ; } $ df = abs ( $ dig_h - $ dig_m ) ; if ( $ df > 180 ) { $ df = 360 - $ df ; } if ( $ df < 30 ) { echo \" alert \\n \" ; } else if ( $ df < 90 ) { echo \" warning \\n \" ; } else { echo \" safe \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php $ time = array ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 8 ; $ j ++ ) { list ( $ ind , $ t ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ time [ $ i ] [ ] = array ( ' index ' => $ ind , ' time ' => $ t ) ; } usort ( $ time [ $ i ] , function ( $ a , $ b ) { return $ a [ ' time ' ] >= $ b [ ' time ' ] ? 1 : - 1 ; } ) ; echo $ time [ $ i ] [ 0 ] [ ' index ' ] . \" \" . $ time [ $ i ] [ 0 ] [ ' time ' ] . \" \\n \" ; echo $ time [ $ i ] [ 1 ] [ ' index ' ] . \" \" . $ time [ $ i ] [ 1 ] [ ' time ' ] . \" \\n \" ; } $ rest = array ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { unset ( $ time [ $ i ] [ 0 ] ) ; unset ( $ time [ $ i ] [ 1 ] ) ; $ rest = array_merge ( $ rest , $ time [ $ i ] ) ; } usort ( $ rest , function ( $ a , $ b ) { return $ a [ ' time ' ] >= $ b [ ' time ' ] ? 1 : - 1 ; } ) ; echo $ rest [ 0 ] [ ' index ' ] . \" \" . $ rest [ 0 ] [ ' time ' ] . \" \\n \" ; echo $ rest [ 1 ] [ ' index ' ] . \" \" . $ rest [ 1 ] [ ' time ' ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ time = array ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 8 ; $ j ++ ) { list ( $ ind , $ t ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ time [ $ i ] [ ] = array ( ' index ' => $ ind , ' time ' => $ t ) ; } usort ( $ time [ $ i ] , function ( $ a , $ b ) { return $ a [ ' time ' ] >= $ b [ ' time ' ] ? 1 : - 1 ; } ) ; echo $ time [ $ i ] [ 0 ] [ ' index ' ] . \" \" . $ time [ $ i ] [ 0 ] [ ' time ' ] . \" \\n \" ; echo $ time [ $ i ] [ 1 ] [ ' index ' ] . \" \" . $ time [ $ i ] [ 1 ] [ ' time ' ] . \" \\n \" ; } $ rest = array ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { unset ( $ time [ $ i ] [ 0 ] ) ; unset ( $ time [ $ i ] [ 1 ] ) ; $ rest = array_merge ( $ rest , $ time [ $ i ] ) ; } usort ( $ rest , function ( $ a , $ b ) { return $ a [ ' time ' ] >= $ b [ ' time ' ] ? 1 : - 1 ; } ) ; echo $ rest [ 0 ] [ ' index ' ] . \" \" . $ rest [ 0 ] [ ' time ' ] . \" \\n \" ; echo $ rest [ 1 ] [ ' index ' ] . \" \" . $ rest [ 1 ] [ ' time ' ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ snake = trim ( fgets ( STDIN ) ) ; if ( preg_match ( \" /^>'(=+)# \\\\ 1~$/ \" , $ snake ) ) { echo \" A \\n \" ; } else if ( preg_match ( \" /^>\\^(Q=)+~~$/ \" , $ snake ) ) { echo \" B \\n \" ; } else { echo \" NA \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ n = trim ( fgets ( STDIN ) ) ; if ( $ n == 0 ) { break ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ x , $ y , $ h , $ w ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ s = $ x + $ y + $ h ; $ p1 = 0 ; $ p2 = 0 ; if ( $ s <= 60 ) { $ p1 = 600 ; } elseif ( $ s <= 80 ) { $ p1 = 800 ; } elseif ( $ s <= 100 ) { $ p1 = 1000 ; } elseif ( $ s <= 120 ) { $ p1 = 1200 ; } elseif ( $ s <= 140 ) { $ p1 = 1400 ; } elseif ( $ s <= 160 ) { $ p1 = 1600 ; } if ( $ w <= 2 ) { $ p2 = 600 ; } elseif ( $ w <= 5 ) { $ p2 = 800 ; } elseif ( $ w <= 10 ) { $ p2 = 1000 ; } elseif ( $ w <= 15 ) { $ p2 = 1200 ; } elseif ( $ w <= 20 ) { $ p2 = 1400 ; } elseif ( $ w <= 25 ) { $ p2 = 1600 ; } if ( $ p1 > 0 && $ p2 > 0 ) { $ sum += max ( $ p1 , $ p2 ) ; } } echo \" $ sum \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { $ c = trim ( fgets ( STDIN ) ) ; if ( $ c == 0 ) { break ; } $ aa = 0 ; $ r = 0 ; $ wr = 0 ; for ( $ i = 0 ; $ i < $ c ; $ i ++ ) { $ n = 0 ; $ w = 0 ; $ ww = trim ( fgets ( STDIN ) ) ; $ www = explode ( \" \" , trim ( $ ww ) ) ; if ( count ( $ www ) == 4 ) { $ n = $ www [ 0 ] + $ www [ 1 ] + $ www [ 2 ] ; $ w = $ www [ 3 ] ; switch ( $ n ) { case $ n <= 60 : $ r = 600 ; break ; case $ n <= 80 : $ r = 800 ; break ; case $ n <= 100 : $ r = 1000 ; break ; case $ n <= 120 : $ r = 1200 ; break ; case $ n <= 140 : $ r = 1400 ; break ; case $ n <= 160 : $ r = 1600 ; break ; case $ n > 160 : $ r = 666 ; break ; } switch ( $ w ) { case $ w <= 2 : $ wr = 600 ; break ; case $ w <= 5 : $ wr = 800 ; break ; case $ w <= 10 ; $ wr = 1000 ; break ; case $ w <= 15 : $ wr = 1200 ; break ; case $ w <= 20 ; $ wr = 1400 ; break ; case $ w <= 25 : $ wr = 1600 ; break ; case $ w > 25 : $ wr = 666 ; break ; } if ( $ r == 666 || $ wr == 666 ) { } elseif ( $ r < $ wr ) { $ aa += $ wr ; } else { $ aa += $ r ; } } } echo $ aa . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ n = trim ( fgets ( STDIN ) ) ; if ( $ n == 0 ) { break ; } $ result = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ c , $ m1 , $ s1 , $ m2 , $ s2 , $ m3 , $ s3 , $ m4 , $ s4 ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ result [ ] = array ( ' team ' => $ c , ' time ' => ( $ m1 + $ m2 + $ m3 + $ m4 ) * 60 + ( $ s1 + $ s2 + $ s3 + $ s4 ) ) ; } usort ( $ result , function ( $ a , $ b ) { return $ a [ ' time ' ] - $ b [ ' time ' ] ; } ) ; echo $ result [ 0 ] [ ' team ' ] . \" \\n \" ; echo $ result [ 1 ] [ ' team ' ] . \" \\n \" ; echo $ result [ count ( $ result ) - 2 ] [ ' team ' ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ _cache = array ( ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ m , $ n ) = explode ( ' ' , $ line ) ; $ count = 0 ; for ( $ i = $ m ; $ i <= $ n ; $ i ++ ) { if ( isHamming ( $ i ) ) { $ count ++ ; } } echo $ count . \" \\n \" ; } function isHamming ( $ i ) { global $ _cache ; if ( isset ( $ _cache [ $ i ] ) ) { return $ _cache [ $ i ] ; } if ( $ i < 1 ) { return false ; } if ( $ i == 0 ) { return true ; } $ num = $ i ; while ( $ num > 1 ) { if ( $ num % 2 == 0 ) { $ num /= 2 ; continue ; } if ( $ num % 3 == 0 ) { $ num /= 3 ; continue ; } if ( $ num % 5 == 0 ) { $ num /= 5 ; continue ; } $ _cache [ $ i ] = false ; return false ; } $ _cache [ $ i ] = true ; return true ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ rest = 32 ; $ i = 0 ; $ d = count ( $ a ) ; while ( true ) { $ rest -= ( $ rest - 1 ) % 5 ; echo $ rest . \" \\n \" ; if ( $ rest == 0 ) { break ; } $ rest -= min ( $ rest , $ a [ $ i ++ % $ d ] ) ; echo $ rest . \" \\n \" ; if ( $ rest == 0 ) { break ; } } }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) && $ n ) { $ a = array ( ) ; $ x = fgets ( STDIN ) ; $ a = explode ( \" \" , $ x ) ; $ yama = 32 ; $ turn = 0 ; $ yama -= 1 ; fprintf ( STDOUT , \" %d \\n \" , $ yama ) ; while ( $ yama > 0 ) { if ( $ a [ $ turn % $ n ] > $ yama ) $ tori = $ yama ; else $ tori = $ a [ $ turn % $ n ] ; $ yama -= $ tori ; if ( $ yama == 0 ) break ; fprintf ( STDOUT , \" %d \\n \" , $ yama ) ; $ tori = ( ( $ yama % 5 ) - 1 ) ; if ( $ tori < 0 ) $ tori += 5 ; $ yama -= $ tori ; fprintf ( STDOUT , \" %d \\n \" , $ yama ) ; $ turn ++ ; } fprintf ( STDOUT , \" %d \\n \" , 0 ) ; } return ( 0 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ data = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ data [ ] = trim ( fgets ( STDIN ) ) ; } $ sorted = $ n ; $ count = 0 ; while ( $ sorted > 1 ) { for ( $ j = 0 ; $ j < $ sorted - 1 ; $ j ++ ) { $ a = $ data [ $ j ] ; $ b = $ data [ $ j + 1 ] ; if ( $ a > $ b ) { $ data [ $ j + 1 ] = $ a ; $ data [ $ j ] = $ b ; $ count ++ ; } } $ sorted -- ; } echo $ count . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ pattern = step ( $ n ) ; echo ceil ( $ pattern / 3650 ) . \" \\n \" ; } function step ( $ n ) { static $ _cache = array ( 1 => 1 , 2 => 2 , 3 => 4 , ) ; if ( isset ( $ _cache [ $ n ] ) ) { return $ _cache [ $ n ] ; } if ( $ n == 1 ) { return 1 ; } if ( $ n == 2 ) { return 2 ; } if ( $ n == 3 ) { return 4 ; } return $ _cache [ $ n ] = step ( $ n - 1 ) + step ( $ n - 2 ) + step ( $ n - 3 ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { echo ceil ( step ( $ n ) / 3650 ) . PHP_EOL ; } function fact ( $ n ) { if ( $ n == 0 || $ n == 1 ) return 1 ; else return $ n * fact ( $ n - 1 ) ; } function step ( $ n ) { $ step = 0 ; static $ a = array ( ) ; if ( isset ( $ a [ $ n ] ) ) return $ a [ $ n ] ; if ( $ n <= 3 ) { for ( $ i = 0 ; $ i * 2 <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j * 3 + $ i * 2 <= $ n ; $ j ++ ) { $ s [ $ i ] [ $ j ] = ( $ n - $ i * 2 - $ j * 3 ) ; $ step += fact ( $ i + $ j + $ s [ $ i ] [ $ j ] ) / ( fact ( $ i ) * fact ( $ j ) * fact ( $ s [ $ i ] [ $ j ] ) ) ; } } return $ a [ $ n ] = $ step ; } else { return $ a [ $ n ] = step ( $ n - 1 ) + step ( $ n - 2 ) + step ( $ n - 3 ) ; } } ?>",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php $a=array(1,1,2); for($i=3;$i<31;$i++)array_push($a,$a[$i-1]+$a[$i-2]+$a[$i-3]); for(;$n=intval(fgets(STDIN));)echo intval(($a[$n]+3649)/3650).PHP_EOL; ?>",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ cards = explode ( ' ' , $ line ) ; rsort ( $ cards ) ; $ score = 0 ; $ eleven = false ; foreach ( $ cards as $ c ) { if ( 10 <= $ c && $ c <= 13 ) { $ score += 10 ; } elseif ( 2 <= $ c && $ c <= 9 ) { $ score += $ c ; } elseif ( $ c == 1 ) { if ( $ score + 11 <= 21 ) { $ score += 11 ; $ eleven = true ; } else { $ score += 1 ; } } } if ( $ score > 21 && $ eleven ) { $ score -= 10 ; } if ( $ score > 21 ) { $ score = 0 ; } echo $ score . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ stdins = array ( ) ; $ i = 0 ; while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin === ' ' ) { return ; } $ nums = explode ( ' ' , $ stdin ) ; rsort ( $ nums ) ; if ( array_sum ( $ nums ) == 0 ) { continue ; } $ result = 0 ; foreach ( $ nums as $ index => $ num ) { if ( $ num > 9 ) { $ result += 10 ; } else if ( $ num != 1 ) { $ result += $ num ; } else { if ( count ( $ nums ) != $ index + 1 || $ result > 10 ) { $ result += 1 ; } else { $ result += 11 ; } } } if ( $ result > 21 ) { echo \" 0 \" . \" \\n \" ; } else { echo $ result . \" \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { list ( $ name , $ morning , $ afternoon ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ sold = 200 * $ morning + 300 * $ afternoon ; $ total = $ morning + $ afternoon ; echo \" $ name $ total $ sold \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ ref = array ( ' black ' => array ( 0 , 0 , 0 ) , ' blue ' => array ( 0 , 0 , 255 ) , ' lime ' => array ( 0 , 255 , 0 ) , ' aqua ' => array ( 0 , 255 , 255 ) , ' red ' => array ( 255 , 0 , 0 ) , ' fuchsia ' => array ( 255 , 0 , 255 ) , ' yellow ' => array ( 255 , 255 , 0 ) , ' white ' => array ( 255 , 255 , 255 ) , ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ r = hexdec ( substr ( $ line , 1 , 2 ) ) ; $ g = hexdec ( substr ( $ line , 3 , 2 ) ) ; $ b = hexdec ( substr ( $ line , 5 , 2 ) ) ; $ d2 = PHP_INT_MAX ; $ color = ' ' ; foreach ( $ ref as $ name => $ c ) { $ dtmp = ( $ r - $ c [ 0 ] ) * ( $ r - $ c [ 0 ] ) + ( $ g - $ c [ 1 ] ) * ( $ g - $ c [ 1 ] ) + ( $ b - $ c [ 2 ] ) * ( $ b - $ c [ 2 ] ) ; if ( $ dtmp < $ d2 ) { $ color = $ name ; $ d2 = $ dtmp ; } } echo $ color . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ R = 6378.1 ; while ( true ) { list ( $ a , $ b , $ c , $ d ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ a == - 1 && $ b == - 1 && $ c == - 1 && $ d == - 1 ) { break ; } $ theta1 = ( 90 - $ a ) * 2 * pi ( ) / 360 ; $ phi1 = $ b * 2 * pi ( ) / 360 ; $ theta2 = ( 90 - $ c ) * 2 * pi ( ) / 360 ; $ phi2 = $ d * 2 * pi ( ) / 360 ; $ x1 = $ R * sin ( $ theta1 ) * cos ( $ phi1 ) ; $ y1 = $ R * sin ( $ theta1 ) * sin ( $ phi1 ) ; $ z1 = $ R * cos ( $ theta1 ) ; $ x2 = $ R * sin ( $ theta2 ) * cos ( $ phi2 ) ; $ y2 = $ R * sin ( $ theta2 ) * sin ( $ phi2 ) ; $ z2 = $ R * cos ( $ theta2 ) ; $ C = sqrt ( pow ( $ x1 - $ x2 , 2 ) + pow ( $ y1 - $ y2 , 2 ) + pow ( $ z1 - $ z2 , 2 ) ) ; $ theta = 2 * asin ( $ C / ( 2 * $ R ) ) ; $ d = round ( $ R * $ theta ) ; echo \" $ d \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function wfs() { global $cnt; global $sec; global $ary_start; global $goal_flag; global $queue; $queue[0] = $ary_start; $queue_size = count($queue[0]); $queue[0][ ' sec ' ] = 0 ; while ( ! empty ( $ queue ) ) { $ cur = array_shift ( $ queue ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ queue_size ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ 0 ] ) { break ; } $ cnt ++ ; } if ( $ cnt === $ queue_size ) { $ goal_flag = 1 ; $ sec = $ cur [ ' sec ' ] ; break ; } for ( $ i = 0 ; $ i < $ queue_size - 1 ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ $ i + 1 ] ) { $ new = $ cur ; $ new [ ' sec ' ] = $ cur [ ' sec ' ] + 1 ; if ( $ cur [ $ i ] !== ' r ' && $ cur [ $ i + 1 ] !== ' r ' ) { $ new [ $ i ] = ' r ' ; $ new [ $ i + 1 ] = ' r ' ; } else if ( $ cur [ $ i ] !== ' g ' && $ cur [ $ i + 1 ] !== ' g ' ) { $ new [ $ i ] = ' g ' ; $ new [ $ i + 1 ] = ' g ' ; } else { $ new [ $ i ] = ' b ' ; $ new [ $ i + 1 ] = ' b ' ; } $ str = toString ( $ new ) ; if ( empty ( $ visited [ $ str ] ) ) { array_push ( $ queue , $ new ) ; $ visited [ $ str ] = 1 ; } } } } } function toString ( $ ary ) { $ str = ' ' ; foreach ( $ ary as $ key => $ val ) { if ( is_numeric ( $ key ) ) { $ str = $ str . $ val ; } } return $ str ; } while ( 1 ) { $ cnt = 0 ; $ sec = 0 ; $ goal_flag = 0 ; $ queue = array ( ) ; $ stdin = trim ( fgets ( $ file_handle ) ) ; if ( $ stdin == ' 0 ' ) { break ; } $ ary_start = str_split ( $ stdin ) ; wfs ( ) ; if ( $ goal_flag === 1 ) { echo $ sec ; } else { echo ' NA ' ; } echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function wfs() { global $cnt; global $sec; global $ary_start; global $goal_flag; global $queue; $queue[0] = $ary_start; $queue_size = count($queue[0]); $queue[0][ ' sec ' ] = 0 ; while ( ! empty ( $ queue ) ) { $ cur = array_shift ( $ queue ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ queue_size ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ 0 ] ) { break ; } $ cnt ++ ; } if ( $ cnt === $ queue_size ) { $ goal_flag = 1 ; $ sec = $ cur [ ' sec ' ] ; break ; } for ( $ i = 0 ; $ i < $ queue_size - 1 ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ $ i + 1 ] ) { $ new = $ cur ; $ new [ ' sec ' ] = $ cur [ ' sec ' ] + 1 ; if ( $ cur [ $ i ] !== ' r ' && $ cur [ $ i + 1 ] !== ' r ' ) { $ new [ $ i ] = ' r ' ; $ new [ $ i + 1 ] = ' r ' ; } else if ( $ cur [ $ i ] !== ' g ' && $ cur [ $ i + 1 ] !== ' g ' ) { $ new [ $ i ] = ' g ' ; $ new [ $ i + 1 ] = ' g ' ; } else { $ new [ $ i ] = ' b ' ; $ new [ $ i + 1 ] = ' b ' ; } $ str = toString ( $ new ) ; if ( empty ( $ visited [ $ str ] ) ) { array_push ( $ queue , $ new ) ; $ visited [ $ str ] = 1 ; } } } } } function toString ( $ ary ) { $ str = ' ' ; foreach ( $ ary as $ key => $ val ) { if ( is_numeric ( $ key ) ) { $ str = $ str . $ val ; } } return $ str ; } while ( 1 ) { $ cnt = 0 ; $ sec = 0 ; $ goal_flag = 0 ; $ queue = array ( ) ; $ stdin = trim ( fgets ( $ file_handle ) ) ; if ( $ stdin == ' 0 ' ) { break ; } $ ary_start = str_split ( $ stdin ) ; wfs ( ) ; if ( $ goal_flag === 1 ) { echo $ sec ; } else { echo ' NA ' ; } echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function wfs() { global $cnt; global $sec; global $ary_start; global $goal_flag; $queue[0] = $ary_start; $queue_size = count($queue[0]); $queue[0][ ' sec ' ] = 0 ; while ( ! empty ( $ queue ) ) { $ cur = array_shift ( $ queue ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ queue_size ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ 0 ] ) { break ; } $ cnt ++ ; } if ( $ cnt === $ queue_size ) { $ goal_flag = 1 ; $ sec = $ cur [ ' sec ' ] ; break ; } for ( $ i = 0 ; $ i < $ queue_size - 1 ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ $ i + 1 ] ) { $ new = $ cur ; $ new [ ' sec ' ] = $ cur [ ' sec ' ] + 1 ; if ( $ cur [ $ i ] !== ' r ' && $ cur [ $ i + 1 ] !== ' r ' ) { $ new [ $ i ] = ' r ' ; $ new [ $ i + 1 ] = ' r ' ; } else if ( $ cur [ $ i ] !== ' g ' && $ cur [ $ i + 1 ] !== ' g ' ) { $ new [ $ i ] = ' g ' ; $ new [ $ i + 1 ] = ' g ' ; } else { $ new [ $ i ] = ' b ' ; $ new [ $ i + 1 ] = ' b ' ; } $ str = toString ( $ new ) ; if ( empty ( $ visited [ $ str ] ) ) { array_push ( $ queue , $ new ) ; $ visited [ $ str ] = 1 ; } } } } } function toString ( $ ary ) { $ str = ' ' ; foreach ( $ ary as $ key => $ val ) { if ( is_numeric ( $ key ) ) { $ str = $ str . $ val ; } } return $ str ; } while ( 1 ) { $ cnt = 0 ; $ sec = 0 ; $ goal_flag = 0 ; $ stdin = trim ( fgets ( $ file_handle ) ) ; if ( $ stdin == ' 0 ' ) { break ; } $ ary_start = str_split ( $ stdin ) ; wfs ( ) ; if ( $ goal_flag === 1 ) { echo $ sec ; } else { echo ' NA ' ; } echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function wfs() { global $cnt; global $sec; global $ary_start; global $goal_flag; $queue[0] = $ary_start; $queue_size = count($queue[0]); $queue[0][ ' sec ' ] = 0 ; while ( ! empty ( $ queue ) ) { $ cur = array_shift ( $ queue ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ queue_size ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ 0 ] ) { break ; } $ cnt ++ ; } if ( $ cnt === $ queue_size ) { $ goal_flag = 1 ; $ sec = $ cur [ ' sec ' ] ; break ; } for ( $ i = 0 ; $ i < $ queue_size - 1 ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ $ i + 1 ] ) { $ new = $ cur ; $ new [ ' sec ' ] = $ cur [ ' sec ' ] + 1 ; if ( $ cur [ $ i ] !== ' r ' && $ cur [ $ i + 1 ] !== ' r ' ) { $ new [ $ i ] = ' r ' ; $ new [ $ i + 1 ] = ' r ' ; } else if ( $ cur [ $ i ] !== ' g ' && $ cur [ $ i + 1 ] !== ' g ' ) { $ new [ $ i ] = ' g ' ; $ new [ $ i + 1 ] = ' g ' ; } else { $ new [ $ i ] = ' b ' ; $ new [ $ i + 1 ] = ' b ' ; } $ str = toString ( $ new ) ; if ( empty ( $ visited [ $ str ] ) ) { array_push ( $ queue , $ new ) ; $ visited [ $ str ] = 1 ; } } } } } function toString ( $ ary ) { $ str = ' ' ; foreach ( $ ary as $ key => $ val ) { if ( is_numeric ( $ key ) ) { $ str = $ str . $ val ; } } return $ str ; } while ( 1 ) { $ sec = 0 ; $ goal_flag = 0 ; $ stdin = trim ( fgets ( $ file_handle ) ) ; if ( $ stdin == ' 0 ' ) { break ; } $ ary_start = str_split ( $ stdin ) ; wfs ( ) ; if ( $ goal_flag === 1 ) { echo $ sec ; } else { echo ' NA ' ; } echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function wfs() { global $sec; global $ary_start; global $goal_flag; $queue[0] = $ary_start; $queue_size = count($queue[0]); $queue[0][ ' sec ' ] = 0 ; while ( ! empty ( $ queue ) ) { $ cur = array_shift ( $ queue ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ queue_size ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ 0 ] ) { break ; } $ cnt ++ ; } if ( $ cnt === $ queue_size ) { $ goal_flag = 1 ; $ sec = $ cur [ ' sec ' ] ; break ; } for ( $ i = 0 ; $ i < $ queue_size - 1 ; $ i ++ ) { if ( $ cur [ $ i ] !== $ cur [ $ i + 1 ] ) { $ new = $ cur ; $ new [ ' sec ' ] = $ cur [ ' sec ' ] + 1 ; if ( $ cur [ $ i ] !== ' r ' && $ cur [ $ i + 1 ] !== ' r ' ) { $ new [ $ i ] = ' r ' ; $ new [ $ i + 1 ] = ' r ' ; } else if ( $ cur [ $ i ] !== ' g ' && $ cur [ $ i + 1 ] !== ' g ' ) { $ new [ $ i ] = ' g ' ; $ new [ $ i + 1 ] = ' g ' ; } else { $ new [ $ i ] = ' b ' ; $ new [ $ i + 1 ] = ' b ' ; } $ str = toString ( $ new ) ; if ( empty ( $ visited [ $ str ] ) ) { array_push ( $ queue , $ new ) ; $ visited [ $ str ] = 1 ; } } } } } function toString ( $ ary ) { $ str = ' ' ; foreach ( $ ary as $ key => $ val ) { if ( is_numeric ( $ key ) ) { $ str = $ str . $ val ; } } return $ str ; } while ( 1 ) { $ sec = 0 ; $ goal_flag = 0 ; $ stdin = trim ( fgets ( $ file_handle ) ) ; if ( $ stdin == ' 0 ' ) { break ; } $ ary_start = str_split ( $ stdin ) ; wfs ( ) ; if ( $ goal_flag === 1 ) { echo $ sec ; } else { echo ' NA ' ; } echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php class Queue { private $ arr = [ ] ; private $ size = 0 ; public function push ( $ item ) { $ this -> size ++ ; array_push ( $ this -> arr , $ item ) ; } public function pop ( ) { $ this -> size -- ; return array_shift ( $ this -> arr ) ; } public function isEmpty ( ) { return $ this -> size === 0 ; } } while ( true ) { $ s = trim ( fgets ( STDIN ) ) ; if ( $ s === \" 0 \" ) { break ; } search ( $ s ) ; } function search ( $ s ) { $ length = strlen ( $ s ) ; $ que = new Queue ( ) ; $ que -> push ( [ 0 , $ s ] ) ; $ dic = [ ] ; $ r = \" \" ; $ g = \" \" ; $ b = \" \" ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ r .= \" r \" ; $ g .= \" g \" ; $ b .= \" b \" ; } $ singles = [ $ r , $ g , $ b ] ; $ ok = false ; while ( ! $ que -> isEmpty ( ) ) { list ( $ score , $ state ) = $ que -> pop ( ) ; if ( isSingleColor ( $ state , $ singles ) ) { echo $ score . \" \\n \" ; $ ok = true ; break ; } for ( $ i = 0 ; $ i < $ length - 1 ; $ i ++ ) { $ c1 = $ state [ $ i ] ; $ c2 = $ state [ $ i + 1 ] ; if ( $ c1 != $ c2 ) { $ c3 = other ( $ c1 , $ c2 ) ; $ newState = substr_replace ( $ state , $ c3 , $ i , 2 ) ; if ( ! array_key_exists ( $ newState , $ dic ) ) { $ dic [ $ newState ] = $ score + 1 ; $ que -> push ( [ $ score + 1 , $ newState ] ) ; } } } } if ( ! $ ok ) { echo \" NA \\n \" ; } } function isSingleColor ( $ s , $ singles ) { foreach ( $ singles as $ single ) { if ( $ s === $ single ) { return true ; } } return false ; } function other ( $ c1 , $ c2 ) { if ( $ c1 === \" r \" ) { if ( $ c2 === \" g \" ) { return \" bb \" ; } elseif ( $ c2 === \" b \" ) { return \" gg \" ; } } elseif ( $ c1 === \" g \" ) { if ( $ c2 === \" r \" ) { return \" bb \" ; } elseif ( $ c2 === \" b \" ) { return \" rr \" ; } } elseif ( $ c1 === \" b \" ) { if ( $ c2 === \" r \" ) { return \" gg \" ; } elseif ( $ c2 === \" g \" ) { return \" rr \" ; } } }",
    "label": 3
  },
  {
    "code": "<?php class Item { public $ name ; public $ price ; public $ minimumPrice ; public $ material_items = [ ] ; public function __construct ( $ name , $ price ) { $ this -> name = $ name ; $ this -> price = intval ( $ price ) ; $ this -> minimumPrice = intval ( $ price ) ; } public function materialItems ( $ material_items ) { $ this -> material_items = $ material_items ; } public function getMaterials ( ) { return $ this -> material_items ; } public function setMinimumPrice ( $ minimumPrice ) { $ this -> minimumPrice = intval ( $ minimumPrice ) ; } public function getMinimumPrice ( ) { return $ this -> minimumPrice ; } } while ( true ) { $ items = [ ] ; $ n = fgets ( STDIN ) ; if ( $ n == 0 ) { exit ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; list ( $ name , $ price ) = explode ( ' ' , $ line ) ; $ items [ $ name ] = new Item ( $ name , $ price ) ; } $ n = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; $ recipe_arr = explode ( ' ' , $ line ) ; $ generate_item = ' ' ; $ material_items = [ ] ; for ( $ j = 0 ; $ j < count ( $ recipe_arr ) ; $ j ++ ) { if ( $ j == 0 ) { $ generate_item = $ recipe_arr [ $ j ] ; } if ( $ j >= 2 ) { $ material_items [ ] = $ recipe_arr [ $ j ] ; } } $ items [ $ generate_item ] -> materialItems ( $ material_items ) ; } $ emulateItem = trim ( fgets ( STDIN ) ) ; $ loop = true ; while ( $ loop ) { $ loop = false ; foreach ( $ items as $ item_key => $ item_value ) { $ materials = $ item_value -> getMaterials ( ) ; if ( count ( $ item_value -> getMaterials ( ) ) > 0 ) { $ create_value = 0 ; foreach ( $ materials as $ material_value ) { $ create_value += $ items [ $ material_value ] -> getMinimumPrice ( ) ; } if ( $ item_value -> getMinimumPrice ( ) > $ create_value ) { $ item_value -> setMinimumPrice ( $ create_value ) ; $ loop = true ; } } } } echo $ items [ $ emulateItem ] -> getMinimumPrice ( ) . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { list ( $ itemValue ) = stdInput ( ) ; if ( $ itemValue == 0 ) { exit ; } $ itemList = [ ] ; for ( $ i = 0 ; $ i < $ itemValue ; $ i ++ ) { list ( $ itemName , $ itemCost ) = stdInput ( ) ; $ itemList = array_merge ( $ itemList , array ( $ itemName => $ itemCost ) ) ; } list ( $ recipeValue ) = stdInput ( ) ; for ( $ i = 0 ; $ i < $ recipeValue ; $ i ++ ) { $ recipe = stdInput ( ) ; $ recipeCost = 0 ; for ( $ j = 2 ; $ j < $ recipe [ 1 ] + 2 ; $ j ++ ) { $ recipeCost += $ itemList [ $ recipe [ $ j ] ] ; } if ( $ itemList [ $ recipe [ 0 ] ] > $ recipeCost ) { $ itemList [ $ recipe [ 0 ] ] = $ recipeCost ; } } list ( $ itemWanted ) = stdInput ( ) ; echo $ itemList [ $ itemWanted ] , PHP_EOL ; } function stdInput ( ) { return explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { $ f = trim ( fgets ( STDIN ) ) ; if ( $ f == 0 ) { break ; } $ c = 1 ; $ vc = 0 ; $ v = 0 ; $ flag = false ; while ( $ c <= 12 ) { list ( $ a , $ b ) = explode ( \" \" , fgets ( STDIN ) ) ; $ vc = intval ( $ a ) - intval ( $ b ) ; $ v += $ vc ; if ( $ v >= $ f && $ flag == false ) { print $ c . PHP_EOL ; $ flag = true ; } $ c ++ ; if ( $ c == 13 && $ flag == false ) { print ' NA ' . PHP_EOL ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ move = array ( array ( 1 , 0 ) , array ( 0 , 1 ) , array ( - 1 , 0 ) , array ( 0 , - 1 ) ) ; function dfs ( $ c , $ y , $ x ) { global $ move ; global $ map ; global $ goal_flag ; global $ yg ; global $ xg ; if ( $ y === $ yg && $ x === $ xg ) { $ goal_flag = 1 ; return ; } $ map [ $ c ] [ $ y ] [ $ x ] = 0 ; for ( $ i = 0 ; $ i <= 3 ; $ i ++ ) { $ y2 = $ y + $ move [ $ i ] [ 1 ] ; $ x2 = $ x + $ move [ $ i ] [ 0 ] ; if ( ! empty ( $ map [ $ c ] [ $ y2 ] [ $ x2 ] ) && $ map [ $ c ] [ $ y2 ] [ $ x2 ] === 1 ) { dfs ( $ c , $ y2 , $ x2 ) ; } } return ; } while ( 1 ) { $ goal_flag = 0 ; $ map = array ( ) ; $ usecolor = 0 ; fscanf ( STDIN , ' %d %d ' , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) { break ; } fscanf ( STDIN , ' %d %d ' , $ xs , $ ys ) ; fscanf ( STDIN , ' %d %d ' , $ xg , $ yg ) ; fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %d %d %d %d ' , $ c , $ d , $ xblock , $ yblock ) ; if ( $ d === 0 ) { for ( $ p = 0 ; $ p <= 3 ; $ p ++ ) { for ( $ q = 0 ; $ q <= 1 ; $ q ++ ) { $ map [ $ c ] [ $ yblock + $ q ] [ $ xblock + $ p ] = 1 ; } } } else { for ( $ p = 0 ; $ p <= 1 ; $ p ++ ) { for ( $ q = 0 ; $ q <= 3 ; $ q ++ ) { $ map [ $ c ] [ $ yblock + $ q ] [ $ xblock + $ p ] = 1 ; } } } } for ( $ c = 1 ; $ c <= 5 ; $ c ++ ) { if ( ! empty ( $ map [ $ c ] [ $ ys ] [ $ xs ] ) && $ map [ $ c ] [ $ ys ] [ $ xs ] === 1 ) { $ usecolor = $ c ; break ; } } if ( $ usecolor !== 0 ) { dfs ( $ usecolor , $ ys , $ xs ) ; } if ( $ goal_flag === 1 ) { echo ' OK ' ; } else { echo ' NG ' ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ move = array ( array ( 1 , 0 ) , array ( 0 , 1 ) , array ( - 1 , 0 ) , array ( 0 , - 1 ) ) ; function dfs ( $ c , $ y , $ x ) { global $ move ; global $ map ; global $ goal_flag ; global $ yg ; global $ xg ; if ( $ y === $ yg && $ x === $ xg ) { $ goal_flag = 1 ; return ; } $ map [ $ c ] [ $ y ] [ $ x ] = 0 ; for ( $ i = 0 ; $ i <= 3 ; $ i ++ ) { $ y2 = $ y + $ move [ $ i ] [ 1 ] ; $ x2 = $ x + $ move [ $ i ] [ 0 ] ; if ( ! empty ( $ map [ $ c ] [ $ y2 ] [ $ x2 ] ) && $ map [ $ c ] [ $ y2 ] [ $ x2 ] === 1 ) { dfs ( $ c , $ y2 , $ x2 ) ; } } return ; } while ( 1 ) { $ goal_flag = 0 ; $ map = array ( ) ; $ usecolor = 0 ; fscanf ( STDIN , ' %d %d ' , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) { break ; } fscanf ( STDIN , ' %d %d ' , $ xs , $ ys ) ; fscanf ( STDIN , ' %d %d ' , $ xg , $ yg ) ; fscanf ( STDIN , ' %d ' , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %d %d %d %d ' , $ c , $ d , $ xblock , $ yblock ) ; if ( $ d === 0 ) { for ( $ p = 0 ; $ p <= 3 ; $ p ++ ) { for ( $ q = 0 ; $ q <= 1 ; $ q ++ ) { $ map [ $ c ] [ $ yblock + $ q ] [ $ xblock + $ p ] = 1 ; } } } else { for ( $ p = 0 ; $ p <= 1 ; $ p ++ ) { for ( $ q = 0 ; $ q <= 3 ; $ q ++ ) { $ map [ $ c ] [ $ yblock + $ q ] [ $ xblock + $ p ] = 1 ; } } } } for ( $ c = 1 ; $ c <= 5 ; $ c ++ ) { if ( ! empty ( $ map [ $ c ] [ $ ys ] [ $ xs ] ) && $ map [ $ c ] [ $ ys ] [ $ xs ] === 1 ) { $ usecolor = $ c ; break ; } } if ( $ usecolor !== 0 ) { dfs ( $ usecolor , $ ys , $ xs ) ; } if ( $ goal_flag === 1 ) { echo ' OK ' ; } else { echo ' NG ' ; } echo PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ inputArr = ReadStd ( ) ; $ octalArr = ChangeOctalToDecimal ( $ inputArr ) ; $ answerArr = CreateAnswer ( $ octalArr ) ; Display ( $ answerArr ) ; function ReadStd ( ) { $ inputArr = array ( ) ; while ( intval ( $ line_num = trim ( fgets ( STDIN ) ) ) != 0 ) { $ inputArr [ ] = intval ( $ line_num ) ; } return $ inputArr ; } function ChangeOctalToDecimal ( $ inputArr ) { $ octalArr = array ( ) ; foreach ( $ inputArr as $ num ) { $ octalArr [ ] = decoct ( $ num ) ; } return $ octalArr ; } function CreateAnswer ( $ octalArr ) { $ answerArr = array ( ) ; foreach ( $ octalArr as $ num ) { $ num = str_replace ( \" 7 \" , \" 9 \" , $ num ) ; $ num = str_replace ( \" 6 \" , \" 8 \" , $ num ) ; $ num = str_replace ( \" 5 \" , \" 7 \" , $ num ) ; $ num = str_replace ( \" 4 \" , \" 5 \" , $ num ) ; $ answerArr [ ] = $ num ; } return $ answerArr ; } function Display ( $ answerArr ) { echo implode ( \" \\n \" , $ answerArr ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ inputArr = ReadStd ( ) ; $ octalArr = ChangeOctalToDecimal ( $ inputArr ) ; $ answerArr = CreateAnswer ( $ octalArr ) ; Display ( $ answerArr ) ; function ReadStd ( ) { $ inputArr = array ( ) ; while ( intval ( $ line_num = trim ( fgets ( STDIN ) ) ) != 0 ) { $ inputArr [ ] = intval ( $ line_num ) ; } return $ inputArr ; } function ChangeOctalToDecimal ( $ inputArr ) { $ octalArr = array ( ) ; foreach ( $ inputArr as $ num ) { $ octalArr [ ] = decoct ( $ num ) ; } return $ octalArr ; } function CreateAnswer ( $ octalArr ) { $ answerArr = array ( ) ; foreach ( $ octalArr as $ num ) { $ targets = array ( \" 7 \" , \" 6 \" , \" 5 \" , \" 4 \" ) ; $ modifieds = array ( \" 9 \" , \" 8 \" , \" 7 \" , \" 5 \" ) ; $ num = str_replace ( $ targets , $ modifieds , $ num ) ; $ answerArr [ ] = $ num ; } return $ answerArr ; } function Display ( $ answerArr ) { echo implode ( \" \\n \" , $ answerArr ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ nums = array ( ) ; while ( intval ( $ line = trim ( fgets ( STDIN ) ) ) != 0 ) { $ nums [ ] = intval ( $ line ) ; } $ octalNums = array ( ) ; foreach ( $ nums as $ num ) { $ octalNums [ ] = decoct ( $ num ) ; } $ answerArr = CreateAnswer ( $ octalNums ) ; echo implode ( \" \\n \" , $ answerArr ) ; function CreateAnswer ( $ octalNums ) { $ answerArr = array ( ) ; $ targets = array ( \" 7 \" , \" 6 \" , \" 5 \" , \" 4 \" ) ; $ alters = array ( \" 9 \" , \" 8 \" , \" 7 \" , \" 5 \" ) ; foreach ( $ octalNums as $ num ) { $ answerArr [ ] = str_replace ( $ targets , $ alters , $ num ) ; } return $ answerArr ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ getNum = trim ( fgets ( STDIN ) ) ; if ( $ getNum === ' 0 ' ) { break ; } $ list [ ] = $ getNum ; } foreach ( $ list as $ num ) { $ search = array ( ' 7 ' , ' 6 ' , ' 5 ' , ' 4 ' ) ; $ replace = array ( ' 9 ' , ' 8 ' , ' 7 ' , ' 5 ' ) ; $ ans [ ] = str_replace ( $ search , $ replace , decoct ( $ num ) ) ; } $ ans = implode ( \" \\n \" , $ ans ) ; echo $ ans ; ?>",
    "label": 3
  },
  {
    "code": "<?php while ( ! feof ( STDIN ) ) { $ v = trim ( fgets ( STDIN ) ) ; if ( $ v !== \" \" ) { $ lines [ ] = $ v ; } } array_pop ( $ lines ) ; while ( count ( $ lines ) > 0 ) { $ lines = array_values ( $ lines ) ; $ loopCount = $ lines [ 0 ] ; unset ( $ lines [ 0 ] ) ; $ dataSet = array_slice ( $ lines , 0 , $ loopCount ) ; $ dataCount = array_count_values ( $ dataSet ) ; array_splice ( $ lines , 0 , $ loopCount ) ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { if ( ! empty ( $ dataCount [ $ i ] ) ) { echo str_repeat ( \" * \" , $ dataCount [ $ i ] ) . \" \\n \" ; } else { echo \" - \\n \" ; } } }",
    "label": 3
  },
  {
    "code": "<?php function solve ( $ a , $ b ) { $ hit = 0 ; $ blow = 0 ; $ aa = str_split ( $ a ) ; $ ab = str_split ( $ b ) ; foreach ( $ aa as $ ka => $ va ) { foreach ( $ ab as $ kb => $ vb ) { if ( $ va != $ vb ) continue ; if ( $ ka == $ kb ) $ hit ++ ; if ( $ ka != $ kb ) $ blow ++ ; } } echo $ hit . ' ' . $ blow . PHP_EOL ; } while ( true ) { $ in = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ a = $ in [ 0 ] ; $ b = $ in [ 1 ] ; if ( $ a == 0 && $ b == 0 ) break ; solve ( $ a , $ b ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { list ( $ r , $ a ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( 0 == $ r && 0 == $ a ) break ; $ r_dash = str_split ( $ r ) ; $ a_dash = str_split ( $ a ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ cnt += $ r_dash [ $ i ] == $ a_dash [ $ i ] ? 1 : 0 ; } $ answer = [ ] ; $ answer [ ] = $ cnt ; $ answer [ ] = 4 - count ( array_diff ( $ r_dash , $ a_dash ) ) - $ cnt ; echo implode ( ' ' , $ answer ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ inLine = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ inLine [ 0 ] == 0 && $ inLine [ 1 ] == 0 ) { break ; } $ hit = 0 ; $ blow = 0 ; $ trueWords = str_split ( $ inLine [ 0 ] ) ; $ ansWords = str_split ( $ inLine [ 1 ] ) ; foreach ( $ trueWords as $ trueKey => $ trueDigit ) { foreach ( $ ansWords as $ ansKey => $ ansDigit ) { if ( $ trueDigit == $ ansDigit ) { if ( $ trueKey == $ ansKey ) { $ hit ++ ; } else { $ blow ++ ; } } } } echo $ hit . \" \" . $ blow . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ blow = function ( $ a , $ b ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { yield $ a [ $ i ] == $ b [ $ i ] ? 1 : 0 ; } } ; while ( true ) { list ( $ r , $ a ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( 0 == $ r && 0 == $ a ) break ; $ cnt = 0 ; $ r_dash = str_split ( $ r ) ; $ a_dash = str_split ( $ a ) ; foreach ( $ blow ( $ r_dash , $ a_dash ) as $ num ) { $ cnt += $ num ; } $ answer = [ ] ; $ answer [ ] = $ cnt ; $ answer [ ] = 4 - count ( array_diff ( $ r_dash , $ a_dash ) ) - $ cnt ; echo implode ( ' ' , $ answer ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ isBlow = function ( $ a , $ b ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { yield $ a [ $ i ] == $ b [ $ i ] ? 1 : 0 ; } } ; while ( true ) { list ( $ r , $ a ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( 0 == $ r && 0 == $ a ) break ; $ cnt = 0 ; $ r_dash = str_split ( $ r ) ; $ a_dash = str_split ( $ a ) ; foreach ( $ isBlow ( $ r_dash , $ a_dash ) as $ num ) { $ cnt += $ num ; } $ non_blow = count ( array_diff ( $ r_dash , $ a_dash ) ) ; list ( $ hit , $ blow ) = array ( $ cnt , 4 - $ non_blow - $ cnt ) ; echo $ hit . ' ' . $ blow . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ loop_cnt = 0 ; 12000 > $ loop_cnt ; $ loop_cnt ++ ) { $ input = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( 0 == $ input [ 0 ] && 0 == $ input [ 1 ] ) { break ; } $ r = str_split ( $ input [ 0 ] ) ; $ a = str_split ( $ input [ 1 ] ) ; $ hit = 0 ; $ brow = 0 ; $ loop_r = 0 ; foreach ( $ r as $ r_char ) { $ loop_a = 0 ; foreach ( $ a as $ a_char ) { if ( $ r_char == $ a_char ) { if ( $ loop_r == $ loop_a ) { $ hit ++ ; } else { $ brow ++ ; } break ; } $ loop_a ++ ; } $ loop_r ++ ; } echo $ hit . \" \" . $ brow . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ num = trim ( fgets ( STDIN ) ) ; if ( strlen ( $ num <= 3 ) ) { break ; } $ hit = 0 ; $ brow = 0 ; $ brow2 = 0 ; $ num = str_split ( $ num ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ num [ $ i ] == $ num [ 5 ] ) { $ brow ++ ; } if ( $ num [ $ i ] == $ num [ 6 ] ) { $ brow ++ ; } if ( $ num [ $ i ] == $ num [ 7 ] ) { $ brow ++ ; } if ( $ num [ $ i ] == $ num [ 8 ] ) { $ brow ++ ; } } if ( $ num [ 0 ] == $ num [ 5 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 1 ] == $ num [ 6 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 2 ] == $ num [ 7 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 3 ] == $ num [ 8 ] ) { $ hit ++ ; $ brow -- ; } echo $ hit . \" \" . $ brow . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ num = trim ( fgets ( STDIN ) ) ; if ( strlen ( $ num <= 3 ) ) { break ; } $ hit = 0 ; $ brow = 0 ; $ num = str_split ( $ num ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ num [ $ i ] == $ num [ 5 ] ) { $ brow ++ ; } if ( $ num [ $ i ] == $ num [ 6 ] ) { $ brow ++ ; } if ( $ num [ $ i ] == $ num [ 7 ] ) { $ brow ++ ; } if ( $ num [ $ i ] == $ num [ 8 ] ) { $ brow ++ ; } } if ( $ num [ 0 ] == $ num [ 5 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 1 ] == $ num [ 6 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 2 ] == $ num [ 7 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 3 ] == $ num [ 8 ] ) { $ hit ++ ; $ brow -- ; } echo $ hit . \" \" . $ brow . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ num = trim ( fgets ( STDIN ) ) ; if ( strlen ( $ num <= 3 ) ) { break ; } $ hit = 0 ; $ brow = 0 ; $ num = str_split ( $ num ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ num [ $ i ] == $ num [ 5 ] ) { $ brow ++ ; } elseif ( $ num [ $ i ] == $ num [ 6 ] ) { $ brow ++ ; } elseif ( $ num [ $ i ] == $ num [ 7 ] ) { $ brow ++ ; } elseif ( $ num [ $ i ] == $ num [ 8 ] ) { $ brow ++ ; } } if ( $ num [ 0 ] == $ num [ 5 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 1 ] == $ num [ 6 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 2 ] == $ num [ 7 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 3 ] == $ num [ 8 ] ) { $ hit ++ ; $ brow -- ; } echo $ hit . \" \" . $ brow . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ num = trim ( fgets ( STDIN ) ) ; if ( strlen ( $ num <= 3 ) ) { break ; } $ hit = 0 ; $ brow = 0 ; $ num = str_split ( $ num ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( $ num [ $ i ] == $ num [ 5 ] ) { $ brow ++ ; } elseif ( $ num [ $ i ] == $ num [ 6 ] ) { $ brow ++ ; } elseif ( $ num [ $ i ] == $ num [ 7 ] ) { $ brow ++ ; } elseif ( $ num [ $ i ] == $ num [ 8 ] ) { $ brow ++ ; } } if ( $ num [ 0 ] == $ num [ 5 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 1 ] == $ num [ 6 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 2 ] == $ num [ 7 ] ) { $ hit ++ ; $ brow -- ; } if ( $ num [ 3 ] == $ num [ 8 ] ) { $ hit ++ ; $ brow -- ; } echo $ hit . \" \" . $ brow . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ hit = 0 ; $ blow = 0 ; $ que_card = array ( ) ; $ ans_card = array ( ) ; $ hoge = fgets ( STDIN ) ; $ hoge = explode ( ' ' , $ hoge ) ; $ hoge [ 1 ] = str_replace ( array ( \" \\r \\n \" , \" \\r \" , \" \\n \" ) , ' ' , $ hoge [ 1 ] ) ; if ( $ hoge [ 0 ] == 0 && $ hoge [ 1 ] == 0 ) { break ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ que_card [ ] = substr ( $ hoge [ 0 ] , $ i , 1 ) ; $ ans_card [ ] = substr ( $ hoge [ 1 ] , $ i , 1 ) ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( in_array ( $ ans_card [ $ i ] , $ que_card ) ) { $ blow += 1 ; } if ( $ que_card [ $ i ] == $ ans_card [ $ i ] ) { $ blow -= 1 ; $ hit += 1 ; } } echo $ hit . ' ' . $ blow . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ input_lines = trim ( fgets ( STDIN ) ) ; $ input_data = trim ( fgets ( STDIN ) ) ; $ array = explode ( \" \" , $ input_data ) ; sort ( $ array ) ; $ min_diff_all = 100000000 ; $ min_diff_ab = 100000000 ; $ min_diff_key = null ; foreach ( $ array as $ key => $ value ) { if ( $ key > 0 ) { $ diff = $ array [ $ key ] - $ array [ $ key - 1 ] ; if ( $ diff < $ min_diff_all ) { $ min_diff_all = $ diff ; $ min_diff_key = $ key ; } if ( $ key < $ input_lines - 1 ) { if ( $ diff < $ min_diff_ab ) { $ min_diff_ab = $ diff ; } } } } $ sum_ab = $ array [ $ input_lines - 1 ] + $ array [ $ input_lines - 2 ] ; array_splice ( $ array , $ min_diff_key , 1 ) ; array_splice ( $ array , $ min_diff_key - 1 , 1 ) ; $ sum_ab_2 = $ array [ count ( $ array ) - 1 ] + $ array [ count ( $ array ) - 2 ] ; $ result_1 = $ sum_ab / $ min_diff_ab ; $ result_2 = $ sum_ab_2 / $ min_diff_all ; if ( $ result_1 > $ result_2 ) { echo $ result_1 ; } else { echo $ result_2 ; } ?>",
    "label": 3
  },
  {
    "code": "<?php # $ans = ($a+$b)/($c-$d) $n = intval(trim(fgets(STDIN))); $a = explode(' ',trim(fgets(STDIN))); sort($a); $ans = 0.0; $array = range(1, $n); foreach ($array as $i) { $cd = @$a[$i] - @$a[$i-1]; if ($i == $n-1) { $ab = intval($a[$n-3])+intval($a[$n-4]); } elseif ($i == $n-2) { $ab = intval($a[$n-1])+intval($a[$n-4]); } else { $ab = intval($a[$n-1])+intval($a[$n-2]); } $ans=max($ans, $ab/$cd); } echo $ans . \"\\n\"; exit(0);",
    "label": 3
  },
  {
    "code": "<?php # $ans = ($a+$b)/($c-$d) $n = intval(trim(fgets(STDIN))); $a = explode(' ',trim(fgets(STDIN))); sort($a); $ans = 0.0; $array = range(1, $n); foreach ($array as $i) { $cd = @$a[$i] - $a[$i-1]; if ($i == $n-1) { $ab = $a[$n-3] + $a[$n-4]; } elseif ($i == $n-2) { $ab = $a[$n-1] + $a[$n-4]; } else { $ab = $a[$n-1] + $a[$n-2]; } $ans=max($ans, $ab/$cd); } echo $ans . \"\\n\"; exit(0);",
    "label": 3
  },
  {
    "code": "<?php # $ans = ($a+$b)/($c-$d) $n = intval(trim(fgets(STDIN))); $a = explode(' ',trim(fgets(STDIN))); sort($a); $ans = 0.0; $array = range(1, $n); foreach ($array as $i) { $cd = @$a[$i] - $a[$i-1]; if ($i == $n-1) { $ab = $a[$n-3] + $a[$n-4]; } elseif ($i == $n-2) { $ab = $a[$n-1] + $a[$n-4]; } else { $ab = $a[$n-1] + $a[$n-2]; } $ans = max($ans, $ab/$cd); } echo $ans . \"\\n\";",
    "label": 3
  },
  {
    "code": "<?php $ num = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; sort ( $ arr ) ; $ ret = 0.0 ; for ( $ i = 0 ; $ i < $ num - 1 ; $ i ++ ) { for ( $ j = $ i + 2 ; $ j < $ num - 1 ; $ j ++ ) { $ m1 = 1.0 * ( $ arr [ $ j + 1 ] + $ arr [ $ j ] ) / ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ; $ m2 = 1.0 * ( $ arr [ $ i + 1 ] + $ arr [ $ i ] ) / ( $ arr [ $ j + 1 ] - $ arr [ $ j ] ) ; $ ret = max ( $ ret , $ m1 ) ; $ ret = max ( $ ret , $ m2 ) ; } } print $ ret ;",
    "label": 3
  },
  {
    "code": "<?php $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ a = intval ( $ input [ 0 ] ) ; $ b = intval ( $ input [ 1 ] ) ; $ money = ( $ a + $ b ) / 2 ; echo $ money ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input_line = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ N = $ input_line [ 0 ] ; $ K = $ input_line [ 1 ] ; $ s = 0 ; $ t = 1 ; $ res = 0 ; while ( 1 ) { if ( $ t + $ s > $ N ) { break ; } else if ( $ t * $ K >= $ s ) { $ res ++ ; $ s += $ t ; } else { $ t ++ ; } } echo $ res ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ rightCard = 0 ; $ leftCard = 0 ; $ rightAns = 0 ; $ leftAns = 0 ; while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin == 0 ) { break ; } if ( $ stdin <= 10000 ) { for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ cardin = trim ( fgets ( STDIN ) ) ; $ cards = explode ( \" \" , $ cardin ) ; $ leftCard = $ cards [ 0 ] ; $ rightCard = $ cards [ 1 ] ; if ( $ leftCard > $ rightCard ) { $ leftAns += $ leftCard + $ rightCard ; } else if ( $ leftCard < $ rightCard ) { $ rightAns += $ leftCard + $ rightCard ; } else if ( $ leftCard == $ rightCard ) { $ leftAns += $ leftCard ; $ rightAns += $ rightCard ; } } echo $ leftAns . \" \" . $ rightAns . \" \\n \" ; $ rightAns = 0 ; $ leftAns = 0 ; } }",
    "label": 3
  },
  {
    "code": "<?php function calc ( $ n ) { $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ na = $ num [ 0 ] ; $ nb = $ num [ 1 ] ; if ( $ na > $ nb ) $ a += ( $ na + $ nb ) ; if ( $ na < $ nb ) $ b += ( $ na + $ nb ) ; if ( $ na == $ nb ) { $ a += $ na ; $ b += $ nb ; } } echo $ a . ' ' . $ b . PHP_EOL ; } while ( true ) { $ n = trim ( fgets ( STDIN ) ) ; if ( $ n == 0 ) break ; calc ( $ n ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ score = array ( ' a ' => 0 , ' b ' => 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a_cards [ ] , $ b_cards [ ] ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a_card = array_shift ( $ a_cards ) ; $ b_card = array_shift ( $ b_cards ) ; if ( $ a_card == $ b_card ) { $ score [ ' a ' ] += $ a_card ; $ score [ ' b ' ] += $ b_card ; } elseif ( $ a_card > $ b_card ) { $ score [ ' a ' ] += $ a_card + $ b_card ; } else { $ score [ ' b ' ] += $ a_card + $ b_card ; } } echo implode ( ' ' , $ score ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ score = array ( ' a ' => 0 , ' b ' => 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a_card , $ b_card ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ a_card == $ b_card ) { $ score [ ' a ' ] += $ a_card ; $ score [ ' b ' ] += $ b_card ; } elseif ( $ a_card > $ b_card ) { $ score [ ' a ' ] += $ a_card + $ b_card ; } else { $ score [ ' b ' ] += $ a_card + $ b_card ; } } echo implode ( ' ' , $ score ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ score = array ( ' a ' => 0 , ' b ' => 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ a_card , $ b_card ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ a_card == $ b_card ) { $ score [ ' a ' ] += $ a_card ; $ score [ ' b ' ] += $ b_card ; } elseif ( $ a_card > $ b_card ) { $ score [ ' a ' ] += $ a_card + $ b_card ; } else { $ score [ ' b ' ] += $ a_card + $ b_card ; } } echo $ score [ ' a ' ] . ' ' . $ score [ ' b ' ] . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ dataset_cnt = 0 ; 5 > $ dataset_cnt ; $ dataset_cnt ++ ) { $ input_cnt = trim ( fgets ( STDIN ) ) ; if ( 0 == $ input_cnt ) { break ; } $ pointa = 0 ; $ pointb = 0 ; for ( $ loop_cnt = 0 ; $ input_cnt > $ loop_cnt ; $ loop_cnt ++ ) { $ input_data = split ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ input_data [ 0 ] > $ input_data [ 1 ] ) { $ pointa += $ input_data [ 0 ] + $ input_data [ 1 ] ; } else if ( $ input_data [ 0 ] < $ input_data [ 1 ] ) { $ pointb += $ input_data [ 0 ] + $ input_data [ 1 ] ; } else { $ pointa += $ input_data [ 0 ] ; $ pointb += $ input_data [ 1 ] ; } } echo $ pointa . \" \" . $ pointb . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php for ( $ dataset_cnt = 0 ; 5 >= $ dataset_cnt ; $ dataset_cnt ++ ) { $ input_cnt = trim ( fgets ( STDIN ) ) ; if ( 0 == $ input_cnt ) { break ; } $ pointa = 0 ; $ pointb = 0 ; for ( $ loop_cnt = 0 ; $ input_cnt > $ loop_cnt ; $ loop_cnt ++ ) { $ input_data = split ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ input_data [ 0 ] > $ input_data [ 1 ] ) { $ pointa += $ input_data [ 0 ] + $ input_data [ 1 ] ; } else if ( $ input_data [ 0 ] < $ input_data [ 1 ] ) { $ pointb += $ input_data [ 0 ] + $ input_data [ 1 ] ; } else { $ pointa += $ input_data [ 0 ] ; $ pointb += $ input_data [ 1 ] ; } } echo $ pointa . \" \" . $ pointb . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ score = [ ] ; while ( true ) { $ cnt = trim ( fgets ( STDIN ) ) ; if ( $ cnt == 0 ) { break ; } $ sumA = 0 ; $ sumB = 0 ; for ( $ i = 0 ; $ i < $ cnt ; $ i ++ ) { $ score = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ scoreA = $ score [ 0 ] ; $ scoreB = $ score [ 1 ] ; if ( $ scoreA > $ scoreB ) { $ sumA += $ scoreA + $ scoreB ; } elseif ( $ scoreA < $ scoreB ) { $ sumB += $ scoreA + $ scoreB ; } elseif ( $ scoreA == $ scoreB ) { $ sumA += $ scoreA ; $ sumB += $ scoreB ; } } echo $ sumA . \" \" . $ sumB . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ line = fgets ( STDIN ) ; if ( $ line == 0 ) { break ; } $ score1 = 0 ; $ score2 = 0 ; for ( $ i = 0 ; $ i < $ line ; $ i ++ ) { $ hoge = fgets ( STDIN ) ; $ hoge = explode ( ' ' , $ hoge ) ; $ hoge [ 1 ] = str_replace ( array ( \" \\r \\n \" , \" \\r \" , \" \\n \" ) , ' ' , $ hoge [ 1 ] ) ; if ( $ hoge [ 0 ] > $ hoge [ 1 ] ) { $ score1 += $ hoge [ 0 ] + $ hoge [ 1 ] ; } elseif ( $ hoge [ 0 ] < $ hoge [ 1 ] ) { $ score2 += $ hoge [ 0 ] + $ hoge [ 1 ] ; } elseif ( $ hoge [ 0 ] == $ hoge [ 1 ] ) { $ score1 += $ hoge [ 0 ] ; $ score2 += $ hoge [ 0 ] ; } } echo $ score1 . ' ' . $ score2 . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ cnt = trim ( fgets ( STDIN ) ) ; if ( $ cnt == 0 ) { break ; } $ sumA = 0 ; $ sumB = 0 ; for ( $ i = 0 ; $ i < $ cnt ; $ i ++ ) { $ score = trim ( fgets ( STDIN ) ) ; $ scoreA = substr ( $ score , 0 , 1 ) ; $ scoreB = substr ( $ score , - 1 ) ; if ( $ scoreA > $ scoreB ) { $ sumA += $ scoreA + $ scoreB ; } elseif ( $ scoreA < $ scoreB ) { $ sumB += $ scoreA + $ scoreB ; } elseif ( $ scoreA == $ scoreB ) { $ sumA += $ scoreA ; $ sumB += $ scoreB ; } } echo $ sumA . \" \" . $ sumB . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ input_line = intval ( fgets ( STDIN ) ) ; $ n = $ input_line ; while ( $ n != 0 ) { $ player1 = 0 ; $ player2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ m1 = intval ( $ numbers [ 0 ] ) ; $ m2 = intval ( $ numbers [ 1 ] ) ; if ( $ m1 > $ m2 ) { $ player1 += $ m1 + $ m2 ; } else if ( $ m1 == $ m2 ) { $ player1 += $ m1 ; $ player2 += $ m2 ; } else { $ player2 += $ m1 + $ m2 ; } } print $ player1 . \" \" . $ player2 . \" \\n \" ; $ input_line = intval ( fgets ( STDIN ) ) ; $ n = $ input_line ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin == 0 ) { break ; } $ a_pnt = 0 ; $ b_pnt = 0 ; for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ cards = trim ( fgets ( STDIN ) ) ; list ( $ a , $ b ) = explode ( \" \" , $ cards ) ; if ( $ a > $ b ) { $ a_pnt += $ a + $ b ; } elseif ( $ a < $ b ) { $ b_pnt += $ a + $ b ; } else { $ a_pnt += $ a ; $ b_pnt += $ b ; } } echo $ a_pnt . \" \" . $ b_pnt . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ changeList ; $ ans = \" \" ; while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin == 0 ) { break ; } for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ changeIn = trim ( fgets ( STDIN ) ) ; $ changes = explode ( \" \" , $ changeIn ) ; $ changeList [ $ i ] [ 0 ] = $ changes [ 0 ] ; $ changeList [ $ i ] [ 1 ] = $ changes [ 1 ] ; } $ m = trim ( fgets ( STDIN ) ) ; if ( $ m <= 10 ** 5 ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ in = trim ( fgets ( STDIN ) ) ; for ( $ j = 0 ; $ j < $ stdin ; $ j ++ ) { if ( $ in == $ changeList [ $ j ] [ 0 ] ) { $ in = $ changeList [ $ j ] [ 1 ] ; break ; } } $ ans .= $ in ; } } echo $ ans . \" \\n \" ; $ ans = \" \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ rep_words = [ ] ; $ string = [ ] ; $ rep_count = trim ( fgets ( STDIN ) ) ; if ( 0 == $ rep_count ) break ; for ( $ i = 0 ; $ i < $ rep_count ; $ i ++ ) { list ( $ before , $ after ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ rep_words [ ] = array ( ' before ' => $ before , ' after ' => $ after ) ; } $ string_count = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ string_count ; $ i ++ ) { $ string [ ] = trim ( fgets ( STDIN ) ) ; } $ done = array_fill ( 0 , count ( $ string ) , false ) ; foreach ( $ rep_words as $ rep ) { for ( $ i = 0 ; $ i < count ( $ done ) ; $ i ++ ) { if ( $ done [ $ i ] == true ) continue ; if ( $ string [ $ i ] == $ rep [ ' before ' ] ) { $ string [ $ i ] = $ rep [ ' after ' ] ; $ done [ $ i ] = true ; } } } echo implode ( $ string ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ rep_words = [ ] ; $ string = [ ] ; $ rep_count = trim ( fgets ( STDIN ) ) ; if ( 0 == $ rep_count ) break ; for ( $ i = 0 ; $ i < $ rep_count ; $ i ++ ) { list ( $ before , $ after ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ rep_words [ ] = array ( ' before ' => $ before , ' after ' => $ after ) ; } $ string_count = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ string_count ; $ i ++ ) { $ string [ ] = trim ( fgets ( STDIN ) ) ; } $ done = array_fill ( 0 , count ( $ string ) , false ) ; foreach ( $ rep_words as $ rep ) { for ( $ i = 0 ; $ i < count ( $ done ) ; $ i ++ ) { if ( $ done [ $ i ] == true ) continue ; if ( $ string [ $ i ] == $ rep [ ' before ' ] ) { $ string [ $ i ] = $ rep [ ' after ' ] ; $ done [ $ i ] = true ; } } } echo implode ( $ string ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ rep_words = [ ] ; $ string = [ ] ; $ rep_count = trim ( fgets ( STDIN ) ) ; if ( 0 == $ rep_count ) break ; for ( $ i = 0 ; $ i < $ rep_count ; $ i ++ ) { list ( $ before , $ after ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ rep_words [ ] = array ( ' before ' => $ before , ' after ' => $ after ) ; } $ string_count = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ string_count ; $ i ++ ) { $ string [ ] = trim ( fgets ( STDIN ) ) ; } $ done = array_fill ( 0 , count ( $ string ) , false ) ; foreach ( $ rep_words as $ rep ) { for ( $ i = 0 ; $ i < count ( $ done ) ; $ i ++ ) { if ( $ done [ $ i ] == true ) continue ; if ( $ string [ $ i ] == $ rep [ ' before ' ] ) { $ string [ $ i ] = $ rep [ ' after ' ] ; $ done [ $ i ] = true ; } } } echo implode ( $ string ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ loop_cnt = 0 ; $ loop_cnt < 5 ; $ loop_cnt ++ ) { $ data_set = array ( ) ; $ data = array ( ) ; $ input_n = trim ( fgets ( STDIN ) ) ; if ( 0 == $ input_n ) { break ; } for ( $ loop_n = 0 ; $ loop_n < $ input_n ; $ loop_n ++ ) { $ input_conv = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ data_set [ $ input_conv [ 0 ] ] = $ input_conv [ 1 ] ; } $ input_m = trim ( fgets ( STDIN ) ) ; for ( $ loop_m = 0 ; $ loop_m < $ input_m ; $ loop_m ++ ) { $ input_data = trim ( fgets ( STDIN ) ) ; $ data [ $ loop_m ] = $ input_data ; } $ work = [ ] ; for ( $ loop_m = 0 ; $ loop_m < $ input_m ; $ loop_m ++ ) { if ( isset ( $ data_set [ $ data [ $ loop_m ] ] ) ) { $ work [ ] = $ data_set [ $ data [ $ loop_m ] ] ; } else { $ work [ ] = $ data [ $ loop_m ] ; } } echo implode ( ' ' , $ work ) ; echo \" \\n \" ; } ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ loop_cnt = 0 ; $ loop_cnt < 5 ; $ loop_cnt ++ ) { $ data_set = array ( ) ; $ data = array ( ) ; $ input_n = trim ( fgets ( STDIN ) ) ; if ( 0 == $ input_n ) { break ; } for ( $ loop_n = 0 ; $ loop_n < $ input_n ; $ loop_n ++ ) { $ input_conv = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ data_set = $ data_set + array ( $ input_conv [ 0 ] => $ input_conv [ 1 ] ) ; } $ input_m = trim ( fgets ( STDIN ) ) ; for ( $ loop_m = 0 ; $ loop_m < $ input_m ; $ loop_m ++ ) { $ input_data = trim ( fgets ( STDIN ) ) ; $ data [ $ loop_m ] = $ input_data ; } $ work = [ ] ; for ( $ loop_m = 0 ; $ loop_m < $ input_m ; $ loop_m ++ ) { if ( isset ( $ data_set [ $ data [ $ loop_m ] ] ) ) { $ work [ ] = $ data_set [ $ data [ $ loop_m ] ] ; } else { $ work [ ] = $ data [ $ loop_m ] ; } } echo implode ( ' ' , $ work ) ; echo \" \\n \" ; } ; ?>",
    "label": 3
  },
  {
    "code": "<?php for ( $ loop_cnt = 0 ; $ loop_cnt < 5 ; $ loop_cnt ++ ) { $ data_set = array ( ) ; $ data = array ( ) ; $ input_n = trim ( fgets ( STDIN ) ) ; if ( 0 == $ input_n ) { break ; } for ( $ loop_n = 0 ; $ loop_n < $ input_n ; $ loop_n ++ ) { $ input_conv = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ data_set = $ data_set + array ( $ input_conv [ 0 ] => $ input_conv [ 1 ] ) ; } $ input_m = trim ( fgets ( STDIN ) ) ; for ( $ loop_m = 0 ; $ loop_m < $ input_m ; $ loop_m ++ ) { $ input_data = trim ( fgets ( STDIN ) ) ; $ data [ $ loop_m ] = $ input_data ; } $ work = [ ] ; for ( $ loop_m = 0 ; $ loop_m < $ input_m ; $ loop_m ++ ) { if ( isset ( $ data_set [ $ data [ $ loop_m ] ] ) ) { $ work [ ] = $ data_set [ $ data [ $ loop_m ] ] ; } else { $ work [ ] = $ data [ $ loop_m ] ; } } echo implode ( ' ' , $ work ) ; echo \" \\n \" ; } ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input_line = intval ( fgets ( STDIN ) ) ; $ n = $ input_line ; while ( $ n != 0 ) { $ m1 = [ ] ; $ m2 = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ m1 [ ] = $ numbers [ 0 ] ; $ m2 [ ] = $ numbers [ 1 ] ; } $ input_line = intval ( fgets ( STDIN ) ) ; $ nn = $ input_line ; $ answer = ' ' ; for ( $ i = 0 ; $ i < $ nn ; $ i ++ ) { $ numbers = rtrim ( fgets ( STDIN ) ) ; $ l = $ numbers ; $ index = array_search ( $ l , $ m1 ) ; if ( $ index !== false ) { $ answer .= $ m2 [ $ index ] ; } else { $ answer .= $ l ; } } echo $ answer ; echo \" \\n \" ; $ input_line = intval ( fgets ( STDIN ) ) ; $ n = $ input_line ; }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin == 0 ) { break ; } $ words_list = array ( ) ; for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ words = trim ( fgets ( STDIN ) ) ; list ( $ a , $ b ) = explode ( \" \" , $ words ) ; $ words_list [ $ a ] = $ b ; } $ stdin = trim ( fgets ( STDIN ) ) ; $ result = \" \" ; for ( $ i = 0 ; $ i < $ stdin ; $ i ++ ) { $ str = trim ( fgets ( STDIN ) ) ; if ( array_key_exists ( $ str , $ words_list ) ) { $ str = $ words_list [ $ str ] ; } $ result .= $ str ; } echo $ result . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ S = array_sum ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ T = array_sum ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; echo max ( $ S , $ T ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php echo max ( array_sum ( explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) , array_sum ( explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ fp = fopen ( \" php: $ str = explode( \" \" , rtrim ( fgets ( $ fp ) ) ) ; $ sum_a = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ sum_a += ( int ) ( $ str [ $ i ] ) ; } $ str = explode ( \" \" , rtrim ( fgets ( $ fp ) ) ) ; $ sum_b = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ sum_b += ( int ) ( $ str [ $ i ] ) ; } echo $ sum_a > $ sum_b ? $ sum_a : $ sum_b ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d %d %d \" , $ a_info , $ a_math , $ a_sci , $ a_eng ) ; fscanf ( STDIN , \" %d %d %d %d \" , $ b_info , $ b_math , $ b_sci , $ b_eng ) ; $ a = [ $ a_info , $ a_math , $ a_sci , $ a_eng ] ; $ b = [ $ b_info , $ b_math , $ b_sci , $ b_eng ] ; echo max ( array_sum ( $ a ) , array_sum ( $ b ) ) , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ student_number = [ ] ; for ( $ i = 0 ; $ i < 28 ; $ i ++ ) { $ student_number [ ] = trim ( fgets ( STDIN ) ) ; } for ( $ i = 1 ; $ i < 31 ; $ i ++ ) { if ( ! in_array ( $ i , $ student_number ) ) echo $ i . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ student_number = [ ] ; for ( $ i = 0 ; $ i < 28 ; $ i ++ ) { $ student_number [ ] = intval ( trim ( fgets ( STDIN ) ) ) ; } for ( $ i = 1 ; $ i < 31 ; $ i ++ ) { if ( ! in_array ( $ i , $ student_number ) ) echo $ i . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ ary = [ ] ; for ( $ i = 0 ; $ i < 28 ; $ i ++ ) $ ary [ ] = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < 30 ; $ i ++ ) { if ( ! in_array ( $ i + 1 , $ ary ) ) echo ( $ i + 1 ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ attend = [ ] ; for ( $ cnt1 = 0 ; $ cnt1 < 28 ; $ cnt1 ++ ) { $ attend [ ] = trim ( fgets ( STDIN ) ) ; } for ( $ cnt2 = 1 ; $ cnt2 <= 30 ; $ cnt2 ++ ) { if ( ! in_array ( $ cnt2 , $ attend ) ) { echo $ cnt2 . PHP_EOL ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = array ( ) ; for ( $ loop_cnt = 0 ; 28 > $ loop_cnt ; $ loop_cnt ++ ) { $ input [ ] = ( int ) trim ( fgets ( STDIN ) ) ; } for ( $ loop_cnt = 1 ; 30 >= $ loop_cnt ; $ loop_cnt ++ ) { if ( ! ( in_array ( $ loop_cnt , $ input ) ) ) { echo $ loop_cnt . \" \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ t = \" \" ; $ array = array ( ) ; while ( $ line = fgets ( STDIN ) ) { $ t .= strtolower ( trim ( $ line ) . ' ' ) ; } $ array = explode ( ' ' , $ t ) ; for ( $ i = 1 ; $ i <= 30 ; $ i ++ ) { if ( in_array ( $ i , $ array ) ) { continue ; } echo $ i . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( $ list [ ] = rtrim ( fgets ( STDIN ) ) ) ; for ( $ i = 1 , $ count = 0 ; $ count < 2 ; $ i ++ ) in_array ( $ i , $ list ) ? : printf ( \" %d \\n \" , $ i , $ count ++ ) ;",
    "label": 3
  },
  {
    "code": "<?php $ student = array ( ) ; for ( $ i = 0 ; $ i < 28 ; $ i ++ ) { $ students [ ] = trim ( fgets ( STDIN ) ) ; } $ all_students = range ( 1 , 30 ) ; $ not_submitter = array_diff ( $ all_students , $ students ) ; sort ( $ not_submitter ) ; echo implode ( \" \\n \" , $ not_submitter ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ num = [ ] ; for ( $ i = 1 ; $ i <= 28 ; $ i ++ ) { $ num [ ] = trim ( fgets ( STDIN ) ) ; } for ( $ i = 1 ; $ i <= 30 ; $ i ++ ) { if ( ! in_array ( $ i , ( array ) $ num ) ) { echo $ i . PHP_EOL ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ studens = range ( 1 , 30 ) ; for ( $ i = 0 ; $ i < 30 ; ++ $ i ) { fscanf ( STDIN , \" %d \" , $ n ) ; unset ( $ studens [ $ n - 1 ] ) ; } foreach ( $ studens as $ index => $ studens ) { echo $ studens , \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ inputs = array ( ) ; while ( ! feof ( STDIN ) ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line !== ' ' ) { $ inputs [ ] = $ line ; } } $ cards = range ( 1 , $ inputs [ 0 ] * 2 ) ; $ cut_count = $ inputs [ 1 ] ; for ( $ i = 0 ; $ i < $ cut_count ; $ i ++ ) { $ k = $ inputs [ 2 + $ i ] ; if ( $ k == 0 ) { $ l = count ( $ cards ) / 2 ; $ temp1 = array_slice ( $ cards , 0 , $ l ) ; $ temp2 = array_slice ( $ cards , $ l ) ; $ temp3 = array ( ) ; for ( $ j = 0 ; $ j < $ l ; $ j ++ ) { $ temp3 [ ] = $ temp1 [ $ j ] ; $ temp3 [ ] = $ temp2 [ $ j ] ; } $ cards = $ temp3 ; } else { $ temp1 = array_slice ( $ cards , 0 , $ k ) ; $ temp2 = array_slice ( $ cards , $ k ) ; $ cards = array_merge ( $ temp2 , $ temp1 ) ; } } foreach ( $ cards as $ no ) { echo $ no . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 20 ; $ i ++ ) { $ inArray [ ] = trim ( fgets ( STDIN ) ) ; } $ wCollege = array ( ) ; $ kCollege = array ( ) ; foreach ( $ inArray as $ key => $ inVal ) { if ( $ key < 10 ) { $ wCollege [ ] = $ inVal ; } else { $ kCollege [ ] = $ inVal ; } } rsort ( $ wCollege ) ; rsort ( $ kCollege ) ; echo ( $ wCollege [ 0 ] + $ wCollege [ 1 ] + $ wCollege [ 2 ] ) . \" \" . ( $ kCollege [ 0 ] + $ kCollege [ 1 ] + $ kCollege [ 2 ] ) . PHP_EOL ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ data = array ( ) ; while ( ! feof ( STDIN ) ) { $ data [ ] = rtrim ( fgets ( STDIN ) ) ; } $ w_scores = array_slice ( $ data , 0 , 10 ) ; $ k_scores = array_slice ( $ data , 10 , 10 ) ; rsort ( $ w_scores ) ; rsort ( $ k_scores ) ; $ w_scores_top3 = array_splice ( $ w_scores , 0 , 3 ) ; $ k_scores_top3 = array_splice ( $ k_scores , 0 , 3 ) ; $ w_sum = array_sum ( $ w_scores_top3 ) ; $ k_sum = array_sum ( $ k_scores_top3 ) ; printf ( \" %d %d \\n \" , $ w_sum , $ k_sum ) ;",
    "label": 3
  },
  {
    "code": "<?php $ W = [ ] ; $ K = [ ] ; for ( $ i = 1 ; $ i <= 20 ; $ i ++ ) { if ( $ i <= 10 ) { $ W [ ] = trim ( fgets ( STDIN ) ) ; } else { $ K [ ] = trim ( fgets ( STDIN ) ) ; } } rsort ( $ W ) ; rsort ( $ K ) ; echo ( $ W [ 0 ] + $ W [ 1 ] + $ W [ 2 ] ) . \" \" . ( $ K [ 0 ] + $ K [ 1 ] + $ K [ 2 ] ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ w [ ] = trim ( fgets ( STDIN ) ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ k [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ w ) ; rsort ( $ k ) ; echo array_sum ( array_slice ( $ w , 0 , 3 ) ) . \" \" . array_sum ( array_slice ( $ k , 0 , 3 ) ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ w [ ] = trim ( fgets ( STDIN ) ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ k [ ] = trim ( fgets ( STDIN ) ) ; } rsort ( $ w ) ; rsort ( $ k ) ; $ sum_top_3_of = function ( $ array ) { return array_sum ( array_slice ( $ array , 0 , 3 ) ) ; } ; echo $ sum_top_3_of ( $ w ) . \" \" . $ sum_top_3_of ( $ k ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php for ( $ i = 0 ; $ i < 20 ; $ i ++ ) { $ score [ ] = trim ( fgets ( STDIN ) ) ; } $ w_scores = array_slice ( $ score , 0 , 10 ) ; $ k_scores = array_slice ( $ score , 10 ) ; rsort ( $ w_scores ) ; rsort ( $ k_scores ) ; $ w_sum_top3 = $ w_scores [ 0 ] + $ w_scores [ 1 ] + $ w_scores [ 2 ] ; $ k_sum_top3 = $ k_scores [ 0 ] + $ k_scores [ 1 ] + $ k_scores [ 2 ] ; echo $ w_sum_top3 . ' ' . $ k_sum_top3 . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ k = array ( ) ; $ w = array ( ) ; $ sumk = 0 ; $ sumw = 0 ; for ( $ i = 0 ; $ i < 20 ; $ i ++ ) { if ( $ i < 10 ) { $ w [ ] = str_replace ( array ( \" \\r \" , \" \\n \" ) , ' ' , fgets ( STDIN ) ) ; } else { $ k [ ] = str_replace ( array ( \" \\r \" , \" \\n \" ) , ' ' , fgets ( STDIN ) ) ; } } sort ( $ w ) ; sort ( $ k ) ; for ( $ i = 0 , $ j = 9 ; $ i < 3 ; $ i ++ , $ j -- ) { $ sumk += $ k [ $ j ] ; $ sumw += $ w [ $ j ] ; } echo $ sumw . ' ' . $ sumk . PHP_EOL ; ?>",
    "label": 3
  },
  {
    "code": "<?php class AOJ0534 { var $ T ; var $ TC ; var $ L ; var $ LC ; public function init ( ) { $ L = & $ this -> L ; $ LC = & $ this -> LC ; $ T = & $ this -> T ; $ TC = & $ this -> TC ; $ in = file_get_contents ( ' /dev/stdin ' ) ; $ L = explode ( \" \\n \" , trim ( $ in ) ) ; $ LC = count ( $ L ) ; $ T = array ( ) ; $ TC = 0 ; } public function input ( ) { $ L = & $ this -> L ; $ LC = & $ this -> LC ; $ T = & $ this -> T ; $ TC = & $ this -> TC ; for ( $ i = 0 ; $ i < $ LC ; ++ $ i ) { if ( $ L [ $ i ] == \" 0 \" ) break ; $ n = $ L [ $ i ++ ] ; $ T [ $ TC ] = array ( ) ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { $ T [ $ TC ] [ ] = intval ( $ L [ $ i ++ ] ) ; } $ TC ++ ; $ i -- ; } } public function check ( $ s ) { for ( $ i = 1 ; $ i <= 3 ; ++ $ i ) { $ key = str_repeat ( $ i , 4 ) ; if ( strstr ( $ s , $ key ) ) return true ; } return false ; } public function calc ( $ s ) { while ( $ this -> check ( $ s ) ) { for ( $ i = 1 ; $ i <= 3 ; ++ $ i ) { $ regexp = \" / \" . $ i . \" {4,}/ \" ; $ s = preg_replace ( $ regexp , ' ' , $ s ) ; } } return $ res = strlen ( $ s ) ; } public function check_around ( $ s , $ k ) { $ res = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < 4 ; ++ $ i ) { $ id = $ k - $ i - 1 ; if ( $ id < 0 ) break ; if ( $ s [ $ k ] != $ s [ $ id ] ) break ; $ res ++ ; } for ( $ i = 0 ; $ i < 4 ; ++ $ i ) { $ id = $ k + $ i + 1 ; if ( $ id >= $ n ) break ; if ( $ s [ $ k ] != $ s [ $ id ] ) break ; $ res ++ ; } return $ res + 1 ; } public function solve ( $ s_ ) { $ res = PHP_INT_MAX ; $ s = implode ( ' ' , $ s_ ) ; for ( $ i = 1 ; $ i <= 3 ; ++ $ i ) { $ regexp = \" / \" . $ i . \" {4,}/ \" ; $ s = preg_replace ( $ regexp , str_repeat ( $ i , 4 ) , $ s ) ; } $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ t = $ s ; for ( $ j = 1 ; $ j <= 3 ; ++ $ j ) { if ( $ t [ $ i ] == $ j ) continue ; $ t [ $ i ] = $ j ; if ( $ this -> check_around ( $ t , $ i ) < 4 ) continue ; if ( ( $ i - 1 >= 0 && $ t [ $ i - 1 ] == $ j ) || ( $ i + 1 < $ n && $ t [ $ i + 1 ] == $ j ) ) { $ res = min ( $ res , $ this -> calc ( $ t ) ) ; } } } return $ res ; } public function run ( ) { $ this -> init ( ) ; $ this -> input ( ) ; foreach ( $ this -> T as $ test ) { echo $ this -> solve ( $ test ) . \" \\n \" ; } } } $ instance = new AOJ0534 ; $ instance -> run ( ) ;",
    "label": 3
  },
  {
    "code": "<?php function calc_color ( $ n , $ a , $ b ) { if ( $ a > $ n / 2 ) $ a = ( $ n + 1 ) - $ a ; if ( $ b > $ n / 2 ) $ b = ( $ n + 1 ) - $ b ; if ( $ a < $ b ) $ ret = $ a ; else $ ret = $ b ; $ ret = $ ret % 3 ; if ( $ ret == 0 ) $ ret = 3 ; return ( $ ret ) ; } fscanf ( STDIN , \" %d \" , $ n ) ; fscanf ( STDIN , \" %d \" , $ k ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ; fprintf ( STDOUT , \" %d \\n \" , calc_color ( $ n , $ a , $ b ) ) ; } return ( 0 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ tri_status = [ 0 , 0 , 0 , 0 ] ; while ( true ) { fscanf ( STDIN , \" %d %d %d \" , $ a , $ b , $ c ) ; if ( $ a + $ b <= $ c || $ b + $ c <= $ a || $ c + $ a <= $ b ) { break ; } $ num_arr = [ $ a , $ b , $ c ] ; sort ( $ num_arr ) ; $ result = is_triangle ( $ num_arr [ 0 ] ** 2 , $ num_arr [ 1 ] ** 2 , $ num_arr [ 2 ] ** 2 ) ; $ tri_status [ 0 ] ++ ; $ tri_status [ $ result ] ++ ; } echo implode ( ' ' , $ tri_status ) . \" \\n \" ; function is_triangle ( $ a , $ b , $ c ) { if ( $ a + $ b == $ c ) { return 1 ; } elseif ( $ a + $ b < $ c ) { return 3 ; } else { return 2 ; } return 4 ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ answer = [ 0 , 0 , 0 , 0 ] ; while ( $ array = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) { sort ( $ array ) ; $ min = $ array [ 0 ] ; $ midi = $ array [ 1 ] ; $ max = $ array [ 2 ] ; if ( $ max >= $ midi + $ min ) { break ; } if ( $ max ** 2 === $ min ** 2 + $ midi ** 2 ) { $ answer [ 1 ] += 1 ; } elseif ( $ max ** 2 < $ min ** 2 + $ midi ** 2 ) { $ answer [ 2 ] += 1 ; } else { $ answer [ 3 ] += 1 ; } $ answer [ 0 ] += 1 ; } ; echo implode ( \" \" , $ answer ) ; echo \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ num = 0 ; $ acute = 0 ; $ right = 0 ; $ obtuse = 0 ; while ( $ side = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) { sort ( $ side ) ; if ( $ side [ 0 ] + $ side [ 1 ] <= $ side [ 2 ] ) { break ; } $ num ++ ; if ( pow ( $ side [ 0 ] , 2 ) + pow ( $ side [ 1 ] , 2 ) === pow ( $ side [ 2 ] , 2 ) ) { $ right ++ ; continue ; } if ( pow ( $ side [ 0 ] , 2 ) + pow ( $ side [ 1 ] , 2 ) > pow ( $ side [ 2 ] , 2 ) ) { $ acute ++ ; continue ; } $ obtuse ++ ; } echo ( \" $ num \" . ' ' . \" $ right \" . ' ' . \" $ acute \" . ' ' . \" $ obtuse \" . \" \\n \" ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ f = fopen ( ' php: function whatTriangle($three_seg) { sort($three_seg); if ($three_seg[0]+$three_seg[1] <= $three_seg[2]) { return false; } elseif (pow($three_seg[0], 2)+pow($three_seg[1], 2) === pow($three_seg[2], 2)) { return ' RT ' ; } elseif ( pow ( $ three_seg [ 0 ] , 2 ) + pow ( $ three_seg [ 1 ] , 2 ) > pow ( $ three_seg [ 2 ] , 2 ) ) { return ' AT ' ; } elseif ( pow ( $ three_seg [ 0 ] , 2 ) + pow ( $ three_seg [ 1 ] , 2 ) < pow ( $ three_seg [ 2 ] , 2 ) ) { return ' OT ' ; } } $ result_array = [ 0 , 0 , 0 , 0 ] ; while ( $ line = fgets ( $ f ) ) { $ three_seg = array_map ( ' intval ' , explode ( ' ' , $ line ) ) ; $ test = whatTriangle ( $ three_seg ) ; switch ( $ test ) { case ' RT ' : $ result_array [ 0 ] ++ ; $ result_array [ 1 ] ++ ; break ; case ' AT ' : $ result_array [ 0 ] ++ ; $ result_array [ 2 ] ++ ; break ; case ' OT ' : $ result_array [ 0 ] ++ ; $ result_array [ 3 ] ++ ; break ; case false : break 2 ; } } $ result = implode ( ' ' , $ result_array ) ; echo $ result ; fclose ( $ f ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ ave = 0 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ n ) ; if ( $ n < 40 ) $ n = 40 ; $ ave += $ n / 5 ; } echo $ ave . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ result = array ( ) ; $ hata = array ( ) ; $ template = array ( ) ; fscanf ( STDIN , \" %d %d \" , $ m , $ n ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) fscanf ( STDIN , \" %s \" , $ hata [ $ i ] ) ; for ( $ i = 0 ; $ i < 2 ; $ i ++ ) fscanf ( STDIN , \" %s \" , $ template [ $ i ] ) ; $ cnt4 = 0 ; for ( $ i = 0 ; $ i < $ m - 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) { $ cnt = 0 ; for ( $ k = 0 ; $ k < 2 ; $ k ++ ) for ( $ l = 0 ; $ l < 2 ; $ l ++ ) $ cnt += ( substr ( $ hata [ $ i + $ k ] , $ j + $ l , 1 ) == substr ( $ template [ $ k ] , $ l , 1 ) ) ? 1 : 0 ; if ( $ cnt == 4 ) $ cnt4 ++ ; if ( $ cnt == 3 ) { for ( $ k = 0 ; $ k < 2 ; $ k ++ ) for ( $ l = 0 ; $ l < 2 ; $ l ++ ) if ( substr ( $ hata [ $ i + $ k ] , $ j + $ l , 1 ) != substr ( $ template [ $ k ] , $ l , 1 ) ) { if ( isset ( $ result [ $ i + $ k ] [ $ j + $ l ] [ substr ( $ template [ $ k ] , $ l , 1 ) ] ) ) $ result [ $ i + $ k ] [ $ j + $ l ] [ substr ( $ template [ $ k ] , $ l , 1 ) ] ++ ; else $ result [ $ i + $ k ] [ $ j + $ l ] [ substr ( $ template [ $ k ] , $ l , 1 ) ] = 1 ; } } } $ max = 0 ; foreach ( $ result as $ key1 => $ val1 ) { foreach ( $ val1 as $ key2 => $ val2 ) { foreach ( $ val2 as $ key3 => $ val3 ) { $ max = max ( $ max , $ val3 ) ; } } } printf ( \" %d \\n \" , $ cnt4 + $ max ) ; return ( 0 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ stdins = array ( ) ; $ stdin = \" nope \" ; while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ stdin == \" \" ) { break ; } else { $ stdins [ ] = $ stdin ; } } $ args = $ stdins ; $ x_month = $ args [ 0 ] ; $ y_base = $ args [ 1 ] ; $ y_max = $ args [ 2 ] ; $ y_l = $ args [ 3 ] ; $ joy = $ args [ 4 ] ; $ x_result = floor ( $ joy ) * $ x_month ; if ( $ joy >= $ y_max ) { $ y_over = ( $ joy - $ y_max ) * $ y_l ; } else { $ y_over = 0 ; } $ y_result = $ y_base + $ y_over ; if ( $ x_result >= $ y_result ) { $ result = $ y_result ; } else { $ result = $ x_result ; } print ( $ result ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ a = trim ( fgets ( STDIN ) ) ; $ b = trim ( fgets ( STDIN ) ) ; $ c = trim ( fgets ( STDIN ) ) ; $ d = trim ( fgets ( STDIN ) ) ; $ e = trim ( fgets ( STDIN ) ) ; if ( $ a < 0 ) { $ heat = abs ( $ a ) * $ c ; $ heat_time = $ e * $ b ; $ time = $ heat + $ heat_time + $ d ; echo $ time . PHP_EOL ; } else { $ heat = $ b - $ a ; $ time = $ heat * $ e ; echo $ time . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d %d %d %d \" , $ N , $ x_num , $ x_money , $ y_num , $ y_money ) ; $ x_total = 0 ; $ y_total = 0 ; if ( $ N % $ x_num != 0 ) { $ x_total = ceil ( $ N / $ x_num ) * $ x_money ; } else { $ x_total = $ N / $ x_num * $ x_money ; } if ( $ N % $ x_num != 0 ) { $ y_total = ceil ( $ N / $ y_num ) * $ y_money ; } else { $ y_total = $ N / $ y_num * $ y_money ; } echo min ( $ x_total , $ y_total ) , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ N ) ; $ board_values = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ max = 0 ; $ tmp = 0 ; $ prev = $ board_values [ 0 ] ; if ( $ prev == 1 ) { $ tmp ++ ; } for ( $ i = 1 ; $ i < count ( $ board_values ) ; ++ $ i ) { if ( $ prev != 1 ) { $ tmp = 0 ; } if ( $ board_values [ $ i ] == 1 ) { ++ $ tmp ; } if ( $ max < $ tmp ) $ max = $ tmp ; $ prev = $ board_values [ $ i ] ; } echo $ max + 1 , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ H , $ W ) ; $ loadmap = [ ] ; for ( $ i = 0 ; $ i < $ H ; ++ $ i ) { $ loadmap [ ] = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; } $ answer = 2000000000000000 ; for ( $ i = 0 ; $ i < $ H ; ++ $ i ) { for ( $ j = 0 ; $ j < $ W ; ++ $ j ) { $ tmp_sum = 0 ; for ( $ row = 0 ; $ row < $ H ; ++ $ row ) { for ( $ col = 0 ; $ col < $ W ; ++ $ col ) { $ tmp_sum += $ loadmap [ $ row ] [ $ col ] * min ( abs ( $ row - $ i ) , abs ( $ col - $ j ) ) ; } } $ answer = min ( $ answer , $ tmp_sum ) ; } } echo $ answer , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ input_line = trim ( fgets ( STDIN ) ) ; list ( $ bns_day , $ bns_week , $ target ) = explode ( \" \" , $ input_line ) ; $ cnt = 0 ; $ day = 0 ; while ( $ target > $ cnt ) { $ cnt += $ bns_day ; $ day ++ ; if ( $ day % 7 == 0 ) { $ cnt += $ bns_week ; } } echo $ day ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d %d \" , $ a , $ b , $ c ) ; $ daily = 0 ; $ min_login = 0 ; while ( $ c > 0 ) { $ daily ++ ; if ( $ daily == 7 ) { $ c -= $ b ; $ daily = 0 ; } $ c -= $ a ; $ min_login ++ ; } echo $ min_login . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ target_count = intval ( trim ( fgets ( STDIN ) ) ) ; $ target_posi = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ command_count = intval ( trim ( fgets ( STDIN ) ) ) ; $ commands = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ limit = 2019 ; foreach ( $ commands as $ command ) { if ( $ target_posi [ $ command - 1 ] == 2019 ) { continue ; } if ( $ command == $ target_count ) { $ target_posi [ $ command - 1 ] ++ ; continue ; } if ( $ target_posi [ $ command - 1 ] + 1 == $ target_posi [ $ command ] ) { continue ; } $ target_posi [ $ command - 1 ] ++ ; } echo implode ( \" \\n \" , $ target_posi ) ; echo \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ target_count ) ; $ heights = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ target_tmp = [ 0 ] ; $ prev = 0 ; for ( $ i = 0 ; $ i < count ( $ heights ) ; ++ $ i ) { if ( $ heights [ $ i ] != $ prev ) $ target_tmp [ ] = $ heights [ $ i ] ; $ prev = $ heights [ $ i ] ; } array_push ( $ target_tmp , 0 ) ; $ heights = [ ] ; $ target = [ 0 ] ; $ prev = 0 ; for ( $ i = 1 ; $ i < count ( $ target_tmp ) - 1 ; ++ $ i ) { if ( ( $ prev < $ target_tmp [ $ i ] && $ target_tmp [ $ i ] > $ target_tmp [ $ i + 1 ] ) || ( $ prev > $ target_tmp [ $ i ] && $ target_tmp [ $ i ] < $ target_tmp [ $ i + 1 ] ) ) $ target [ ] = $ target_tmp [ $ i ] ; $ prev = $ target_tmp [ $ i ] ; } $ target_tmp = [ ] ; $ mountain = [ ] ; $ valley = [ ] ; for ( $ i = 0 ; $ i < count ( $ target ) ; ++ $ i ) { if ( $ i % 2 == 1 ) { $ mountain [ ] = $ target [ $ i ] ; } else { $ valley [ ] = $ target [ $ i ] ; } } sort ( $ target ) ; sort ( $ mountain ) ; sort ( $ valley ) ; array_push ( $ target , 0 ) ; array_push ( $ mountain , 0 ) ; array_push ( $ valley , 0 ) ; $ ans = 0 ; $ max = 0 ; if ( count ( $ target ) == 1 ) { echo $ max , \" \\n \" ; return ; } $ m = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < count ( $ target ) - 1 ; ++ $ i ) { if ( $ mountain [ $ m ] == $ target [ $ i ] ) { ++ $ m ; -- $ ans ; } if ( $ valley [ $ b ] == $ target [ $ i ] ) { ++ $ b ; ++ $ ans ; } if ( $ target [ $ i ] < $ target [ $ i + 1 ] ) { if ( $ ans > $ max ) $ max = $ ans ; } } echo $ max , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) > 0 ) { print ( $ a + $ b . \" \\n \" ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) > 0 ) { print ( $ a + $ b ) . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ b ) > 0 ) { echo $ a + $ b . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function zigzag ( $ y , $ x , $ n ) { if ( $ y == 0 ) { if ( ( $ x % 2 ) == 0 ) return ( ( $ x + 2 ) * ( $ x + 1 ) / 2 ) ; else return ( 1 + $ x * ( $ x + 1 ) / 2 ) ; } if ( $ x + $ y < $ n ) { if ( ( $ x + $ y ) % 2 == 0 ) return ( - $ y + zigzag ( 0 , $ x + $ y , $ n ) ) ; else return ( $ y + zigzag ( 0 , $ x + $ y , $ n ) ) ; } return ( $ n * $ n + 1 - zigzag ( $ n - 1 - $ y , $ n - 1 - $ x , $ n ) ) ; } $ no = 1 ; while ( fscanf ( STDIN , \" %d \" , $ siz ) && $ siz ) { fprintf ( STDOUT , \" Case %d: \\n \" , $ no ) ; for ( $ i = 0 ; $ i < $ siz ; $ i ++ ) { for ( $ j = 0 ; $ j < $ siz ; $ j ++ ) fprintf ( STDOUT , \" %3d \" , zigzag ( $ i , $ j , $ siz ) ) ; fprintf ( STDOUT , \" \\n \" ) ; } $ no ++ ; } return ( 0 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { list ( $ N , $ K ) = explode ( ' ' , $ line ) ; if ( $ N == 0 && $ K == 0 ) { break ; } $ S = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ yes = true ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { $ B = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ j = 0 ; $ j < $ K ; ++ $ j ) { $ S [ $ j ] -= $ B [ $ j ] ; if ( $ S [ $ j ] < 0 ) { $ yes = false ; } } } if ( $ yes ) echo \" Yes \\n \" ; else echo \" No \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ cnt = 0 ; while ( true ) { $ stdin = trim ( fgets ( STDIN ) ) ; if ( $ cnt === 0 ) { list ( $ ninzu , $ shurui ) = explode ( ' ' , $ stdin ) ; if ( $ ninzu == 0 && $ shurui == 0 ) { break ; } $ cnt ++ ; continue ; } $ val = explode ( ' ' , $ stdin ) ; if ( $ cnt == 1 ) { $ ryo = $ val ; $ kei = array ( ) ; for ( $ i = 0 ; $ i < $ shurui ; $ i ++ ) { $ kei [ $ i ] = 0 ; } $ cnt ++ ; continue ; } for ( $ i = 0 ; $ i < $ shurui ; $ i ++ ) { $ kei [ $ i ] += $ val [ $ i ] ; } $ flg = true ; if ( $ cnt == $ ninzu + 1 ) { for ( $ i = 0 ; $ i < $ shurui ; $ i ++ ) { if ( $ kei [ $ i ] > $ ryo [ $ i ] ) { $ flg = false ; break ; } } if ( $ flg ) { print ( \" Yes \\n \" ) ; } else { print ( \" No \\n \" ) ; } $ cnt = 0 ; continue ; } $ cnt ++ ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' DEBUG ' , 0 ) ; $ dx = [ 0 , 1 , 0 , - 1 ] ; $ dy = [ 1 , 0 , - 1 , 0 ] ; $ cells = array ( ' A ' => [ 0 , 0 ] , ' B ' => [ 1 , 0 ] , ' C ' => [ 2 , 0 ] , ' D ' => [ 0 , 1 ] , ' E ' => [ 1 , 1 ] , ' F ' => [ 2 , 1 ] , ' G ' => [ 0 , 2 ] , ' H ' => [ 1 , 2 ] , ' I ' => [ 2 , 2 ] ) ; $ memo = array ( ) ; function f ( $ cx , $ cy , $ n , $ t , $ b ) { if ( DEBUG ) echo \" $ cx , $ cy , $ n , $ t , $ b : \" ; global $ cells , $ dx , $ dy , $ memo ; if ( array_key_exists ( \" $ cx : $ cy : $ n \" , $ memo ) ) { if ( DEBUG ) echo $ memo [ \" $ cx : $ cy : $ n \" ] . \" \\n \" ; return $ memo [ \" $ cx : $ cy : $ n \" ] ; } if ( $ n == 0 ) { if ( $ cx == $ cells [ $ t ] [ 0 ] && $ cy == $ cells [ $ t ] [ 1 ] ) { if ( DEBUG ) echo \" 1 \\n \" ; return 1 ; } else { if ( DEBUG ) echo \" 0_1 \\n \" ; return 0 ; } } $ ret = 0 ; for ( $ i = 0 ; $ i < 4 ; ++ $ i ) { $ x = $ cx + $ dx [ $ i ] ; $ y = $ cy + $ dy [ $ i ] ; if ( $ x < 0 || 2 < $ x || $ y < 0 || 2 < $ y || ( $ x == $ cells [ $ b ] [ 0 ] && $ y == $ cells [ $ b ] [ 1 ] ) ) { $ x = $ cx ; $ y = $ cy ; } if ( DEBUG ) echo \" f \\n \" ; $ ret += f ( $ x , $ y , $ n - 1 , $ t , $ b ) ; } $ memo [ \" $ cx : $ cy : $ n \" ] = $ ret ; if ( DEBUG ) echo \" $ ret \\n \" ; return $ ret ; } while ( $ n = chop ( fgets ( STDIN ) ) ) { list ( $ s , $ t , $ b ) = explode ( ' ' , chop ( fgets ( STDIN ) ) ) ; $ memo = array ( ) ; $ num = f ( $ cells [ $ s ] [ 0 ] , $ cells [ $ s ] [ 1 ] , $ n , $ t , $ b ) ; echo sprintf ( ' %.8f ' , $ num / pow ( 4 , $ n ) ) . \" \\n \" ; unset ( $ memo ) ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' NONE ' , - 1 ) ; class AOJ1031 { var $ L ; var $ LC ; var $ n ; var $ X ; var $ Y ; public function init ( ) { $ L = & $ this -> L ; $ LC = & $ this -> LC ; $ L = file ( ' /dev/stdin ' ) ; $ LC = count ( $ L ) ; } public function input ( & $ offset ) { $ L = & $ this -> L ; $ LC = & $ this -> LC ; $ n = & $ this -> n ; $ markup = & $ this -> markup ; $ X = & $ this -> X ; $ Y = & $ this -> Y ; $ n = $ L [ $ offset ] ; if ( $ n == 0 ) return false ; $ markup = $ L [ $ offset + 1 ] ; $ offset += 2 ; $ X = array ( ) ; $ Y = array ( ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i , ++ $ offset ) { $ line = $ L [ $ offset ] ; $ terms = split ( ' ' , $ line ) ; $ X [ $ i ] = intval ( $ terms [ 0 ] ) ; $ Y [ $ i ] = intval ( $ terms [ 1 ] ) ; } return true ; } public function hit_test ( $ x , $ y , $ x1 , $ y1 , $ x2 , $ y2 ) { return $ x1 <= $ x && $ x <= $ x2 && $ y1 <= $ y && $ y <= $ y2 ; } public function get_positions ( $ line , & $ x1 , & $ y1 , & $ x2 , & $ y2 ) { $ terms = split ( ' , ' , $ line ) ; $ x1 = $ terms [ 0 ] ; $ y1 = $ terms [ 1 ] ; $ x2 = $ terms [ 2 ] ; $ y2 = $ terms [ 3 ] ; } public function check_clicked ( $ root , $ x , $ y , & $ name , & $ childs ) { $ this -> get_positions ( $ root , $ x1 , $ y1 , $ x2 , $ y2 ) ; if ( $ this -> hit_test ( $ x , $ y , $ x1 , $ y1 , $ x2 , $ y2 ) ) { foreach ( $ root as $ child ) { $ this -> get_positions ( $ child , $ x1 , $ y1 , $ x2 , $ y2 ) ; if ( $ this -> check_clicked ( $ child , $ x , $ y , $ name , $ childs ) ) { return true ; } } $ name = $ root -> getName ( ) ; $ childs = $ root -> count ( ) ; return true ; } $ name = ' OUT OF MAIN PANEL ' ; $ childs = 1 ; return false ; } public function solve ( ) { $ n = & $ this -> n ; $ markup = & $ this -> markup ; $ X = & $ this -> X ; $ Y = & $ this -> Y ; $ object = new SimpleXMLElement ( $ markup ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ name = \" \" ; $ childs = - 1 ; $ this -> check_clicked ( $ object , $ X [ $ i ] , $ Y [ $ i ] , $ name , $ childs ) ; echo \" $ name $ childs \\n \" ; } } public function run ( ) { $ L = & $ this -> L ; $ LC = & $ this -> LC ; $ this -> init ( ) ; for ( $ i = 0 ; $ i < $ LC ; ++ $ i ) { while ( $ this -> input ( $ i ) ) { $ this -> solve ( ) ; } } } } $ instance = new AOJ1031 ; $ instance -> run ( ) ;",
    "label": 3
  },
  {
    "code": "<?php $ str ; while ( 1 ) { $ a = trim ( fgets ( STDIN ) ) ; if ( $ a == \" END OF INPUT \" ) break ; $ b = explode ( \" \" , $ a ) ; foreach ( $ b as $ i ) { echo strlen ( $ i ) ; } echo PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?= \" 1 1.5 2.12 2.76 3.37 4 4.62 5.24 5.86 6.48 7.1 7.72 8.35 8.97 9.6 10.21 10.83 11.45 12.07 12.7 13.32 13.94 14.56 15.18 15.8 16.42 17.05 17.67 18.3 18.91 19.53 20.15 20.77 21.4 22.02 22.64 23.26 23.88 24.5 25.12 25.75 26.37 27 27.61 28.23 28.85 29.47 30.1 30.72 31.34 31.96 61.8 62.41 63.03 63.65 483.13 620.47 621.09 621.71 622.33 622.96 932.44 6212.86 6213.5 6214.11 6214.73 62143.02 62143.65 62144.27 62144.9 \" ?>",
    "label": 3
  },
  {
    "code": "<?php $ output = array ( ) ; while ( true ) { $ words = array ( ) ; $ times = array ( ) ; $ score = array ( ) ; $ minMember = array ( ) ; $ member = 0 ; $ member = trim ( fgets ( STDIN ) ) ; if ( $ member == \" 0 \" ) { break ; } for ( $ j = 0 ; $ j < $ member ; $ j ++ ) { $ words = preg_split ( \" /[\\s]/ \" , trim ( fgets ( STDIN ) ) ) ; $ name = $ words [ 0 ] ; $ score [ $ name ] = 0 ; $ kind = $ words [ 1 ] ; for ( $ k = 2 ; $ k < count ( $ words ) ; $ k ++ ) { $ times [ $ words [ $ k ] ] [ ] = $ name ; } } foreach ( $ times as $ key => $ value ) { $ number = count ( $ value ) ; foreach ( $ value as $ character ) { $ score [ $ character ] += $ member - $ number + 1 ; } } $ min = min ( $ score ) ; foreach ( $ score as $ key => $ value ) { if ( $ min == $ value ) { $ minMember [ ] = $ key ; } } sort ( $ minMember ) ; $ output [ ] = $ min . ' ' . $ minMember [ 0 ] ; } foreach ( $ output as $ key => $ value ) { print $ output [ $ key ] . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ n , $ q ) && ( $ n | $ q ) ) { $ day = array ( ) ; for ( $ i = 0 ; $ i < 100 ; $ i ++ ) { $ day [ ] = 0 ; } while ( $ n -- ) { $ tmp = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 1 ; $ i < count ( $ tmp ) ; $ i ++ ) { $ day [ $ tmp [ $ i ] ] ++ ; } } $ ans = 0 ; $ maxm = $ q - 1 ; for ( $ i = 0 ; $ i < 100 ; $ i ++ ) { if ( $ day [ $ i ] > $ maxm ) { $ ans = $ i ; $ maxm = $ day [ $ i ] ; } } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) && $ n ) { fscanf ( STDIN , \" %d %d \" , $ w , $ h ) ; $ map = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ map [ $ i ] [ $ j ] = 0 ; } } while ( $ n -- ) { fscanf ( STDIN , \" %d %d \" , $ x , $ y ) ; $ map [ $ y - 1 ] [ $ x - 1 ] = 1 ; } fscanf ( STDIN , \" %d %d \" , $ s , $ t ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { if ( $ i + $ t > $ h ) continue ; if ( $ j + $ s > $ w ) continue ; $ count = 0 ; for ( $ k = 0 ; $ k < $ t ; $ k ++ ) { for ( $ l = 0 ; $ l < $ s ; $ l ++ ) { if ( $ map [ $ i + $ k ] [ $ j + $ l ] ) $ count ++ ; } } $ ans = max ( $ ans , $ count ) ; } } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ n_tree = fgets ( STDIN ) ; while ( $ n_tree != 0 ) { $ input_line = fgets ( STDIN ) ; $ number = preg_split ( \" /[\\s,]+/ \" , $ input_line ) ; $ area_w = intval ( $ number [ 0 ] ) ; $ area_h = intval ( $ number [ 1 ] ) ; $ area = [ ] ; for ( $ i = 0 ; $ i < $ area_h ; $ i ++ ) { $ area_row = [ ] ; for ( $ j = 0 ; $ j < $ area_w ; $ j ++ ) { $ area_row [ ] = false ; } $ area [ ] = $ area_row ; } for ( $ i = 0 ; $ i < intval ( $ n_tree ) ; $ i ++ ) { $ input_line = fgets ( STDIN ) ; $ number = preg_split ( \" /[\\s,]+/ \" , $ input_line ) ; $ tree_w = intval ( $ number [ 0 ] ) ; $ tree_h = intval ( $ number [ 1 ] ) ; $ area [ $ tree_h - 1 ] [ $ tree_w - 1 ] = true ; } $ input_line2 = fgets ( STDIN ) ; $ number = preg_split ( \" /[\\s,]+/ \" , $ input_line2 ) ; $ own_w = intval ( $ number [ 0 ] ) ; $ own_h = intval ( $ number [ 1 ] ) ; $ count = 0 ; for ( $ i = 0 ; $ i <= $ area_w - $ own_w ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ area_h - $ own_h ; $ j ++ ) { $ c = 0 ; for ( $ k = $ i ; $ k < $ own_w + $ i ; $ k ++ ) { for ( $ l = $ j ; $ l < $ own_h + $ j ; $ l ++ ) { if ( $ area [ $ l ] [ $ k ] == true ) { $ c += 1 ; } } } if ( $ count < $ c ) { $ count = $ c ; } } } echo $ count ; echo \" \\n \" ; $ n_tree = fgets ( STDIN ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ n , $ r ) ) { if ( ( $ n | $ r ) == 0 ) break ; $ card = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ card [ ] = $ n - $ i ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { fscanf ( STDIN , \" %d %d \" , $ p , $ c ) ; $ p -- ; $ tmp = $ card ; $ card = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j < $ p ) $ card [ $ j + $ c ] = $ tmp [ $ j ] ; else if ( $ p <= $ j && $ j < $ p + $ c ) $ card [ $ j - $ p ] = $ tmp [ $ j ] ; else $ card [ $ j ] = $ tmp [ $ j ] ; } } print $ card [ 0 ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function myshuffle ( $ array , $ p , $ c ) { $ n = sizeof ( $ array ) ; $ ret_1 = array ( ) ; $ ret_2 = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i >= $ p - 1 && $ i < $ p + $ c - 1 ) { array_push ( $ ret_1 , $ array [ $ i ] ) ; } else { array_push ( $ ret_2 , $ array [ $ i ] ) ; } } return array_merge ( $ ret_1 , $ ret_2 ) ; } while ( 1 ) { fscanf ( STDIN , \" %d %d \\n \" , $ n , $ r ) ; if ( $ n == 0 && $ r == 0 ) break ; $ a = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ n - $ i ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { fscanf ( STDIN , \" %d %d \\n \" , $ p , $ c ) ; $ a = myshuffle ( $ a , $ p , $ c ) ; } echo $ a [ 0 ] , \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { list ( $ n , $ r ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ n == 0 && $ r == 0 ) break ; $ arr = [ ] ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { $ arr [ ] = $ i ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { list ( $ p , $ c ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ arr = array_merge ( array_splice ( $ arr , $ p - 1 , $ c ) , $ arr ) ; } echo $ arr [ 0 ] . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function get_two_int ( ) { $ two_data = trim ( fgets ( STDIN ) ) ; $ two_int = explode ( \" \" , $ two_data ) ; for ( $ i = 0 ; $ i < count ( $ two_int ) ; $ i ++ ) { $ two_int [ $ i ] = ( int ) $ two_int [ $ i ] ; } return $ two_int ; } function make_deck ( $ deck_num ) { $ deck = array_fill ( 0 , $ deck_num , 0 ) ; $ order = 0 ; for ( $ i = $ deck_num ; $ i >= 1 ; $ i -- ) { $ deck [ $ order ] = $ i ; $ order += 1 ; } return $ deck ; } function make_change_set ( $ start_num , $ set_num , $ deck ) { $ change_set = array_slice ( $ deck , $ start_num , $ set_num ) ; return $ change_set ; } function shuffle_deck ( $ first_set , $ second_set , $ deck ) { $ change_set = array_merge ( $ second_set , $ first_set ) ; for ( $ i = 0 ; $ i < count ( $ change_set ) ; $ i ++ ) { $ deck [ $ i ] = $ change_set [ $ i ] ; } return $ deck ; } while ( True ) { list ( $ deck_num , $ shuffle_num ) = get_two_int ( ) ; if ( $ deck_num === 0 ) { break ; } $ deck = make_deck ( $ deck_num ) ; for ( $ i = 0 ; $ i < $ shuffle_num ; $ i ++ ) { list ( $ p , $ c ) = get_two_int ( ) ; $ first_set_num = $ p - 1 ; $ second_set_num = $ c ; $ first_set = make_change_set ( 0 , $ first_set_num , $ deck ) ; $ second_set = make_change_set ( $ first_set_num , $ second_set_num , $ deck ) ; $ deck = shuffle_deck ( $ first_set , $ second_set , $ deck ) ; } echo $ deck [ 0 ] . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ dy = array ( 1 , - 1 , 0 , 0 ) ; $ dx = array ( 0 , 0 , 1 , - 1 ) ; function dfs ( $ y , $ x ) { global $ ans , $ h , $ w , $ dx , $ dy , $ visited , $ map ; $ ans ++ ; $ visited [ $ y ] [ $ x ] = 1 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ ny = $ y + $ dy [ $ i ] ; $ nx = $ x + $ dx [ $ i ] ; if ( 0 > $ ny || $ ny >= $ h ) continue ; if ( 0 > $ nx || $ nx >= $ w ) continue ; if ( $ map [ $ ny ] [ $ nx ] == ' # ' ) continue ; if ( $ visited [ $ ny ] [ $ nx ] ) continue ; dfs ( $ ny , $ nx ) ; } } while ( fscanf ( STDIN , \" %d %d \" , $ w , $ h ) && ( $ w | $ h ) ) { for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { fscanf ( STDIN , \" %s \" , $ str ) ; for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ map [ $ i ] [ $ j ] = $ str [ $ j ] ; if ( $ str [ $ j ] == ' @ ' ) { $ sy = $ i ; $ sx = $ j ; } } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ visited [ $ i ] [ $ j ] = 0 ; } } dfs ( $ sy , $ sx ) ; print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function search ( $ m , $ n ) { global $ sum , $ b ; if ( $ b [ $ m ] [ $ n + 1 ] == \" . \" ) { $ b [ $ m ] [ $ n + 1 ] = \" - \" ; $ sum ++ ; search ( $ m , $ n + 1 ) ; } if ( $ b [ $ m ] [ $ n - 1 ] == \" . \" ) { $ b [ $ m ] [ $ n - 1 ] = \" - \" ; $ sum ++ ; search ( $ m , $ n - 1 ) ; } if ( $ b [ $ m + 1 ] [ $ n ] == \" . \" ) { $ b [ $ m + 1 ] [ $ n ] = \" - \" ; $ sum ++ ; search ( $ m + 1 , $ n ) ; } if ( $ b [ $ m - 1 ] [ $ n ] == \" . \" ) { $ b [ $ m - 1 ] [ $ n ] = \" - \" ; $ sum ++ ; search ( $ m - 1 , $ n ) ; } } while ( 1 ) { fscanf ( STDIN , \" %d %d \\n \" , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) break ; $ b [ 0 ] = str_repeat ( \" - \" , $ w + 2 ) ; for ( $ i = 1 ; $ i <= $ h ; $ i ++ ) { fscanf ( STDIN , \" %s \" , $ b [ $ i ] ) ; $ b [ $ i ] = \" - \" . $ b [ $ i ] . \" - \" ; } $ b [ $ h + 1 ] = str_repeat ( \" - \" , $ w + 2 ) ; $ sum = 1 ; for ( $ i = 0 ; $ i < $ h + 2 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w + 2 ; $ j ++ ) { if ( $ b [ $ i ] [ $ j ] == \" @ \" ) { search ( $ i , $ j ) ; break 2 ; } } } echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function c_p ( $ i , $ j ) { global $ sum , $ a ; $ sum += 1 ; $ a [ $ i ] [ $ j ] = \" # \" ; } function search ( $ i , $ j ) { global $ a ; if ( isset ( $ a [ $ i + 1 ] [ $ j ] ) and $ a [ $ i + 1 ] [ $ j ] == \" . \" ) { c_p ( $ i + 1 , $ j ) ; search ( $ i + 1 , $ j ) ; } if ( isset ( $ a [ $ i - 1 ] [ $ j ] ) and $ a [ $ i - 1 ] [ $ j ] == \" . \" ) { c_p ( $ i - 1 , $ j ) ; search ( $ i - 1 , $ j ) ; } if ( isset ( $ a [ $ i ] [ $ j + 1 ] ) and $ a [ $ i ] [ $ j + 1 ] == \" . \" ) { c_p ( $ i , $ j + 1 ) ; search ( $ i , $ j + 1 ) ; } if ( isset ( $ a [ $ i ] [ $ j - 1 ] ) and $ a [ $ i ] [ $ j - 1 ] == \" . \" ) { c_p ( $ i , $ j - 1 ) ; search ( $ i , $ j - 1 ) ; } } while ( 1 ) { $ a = array ( ) ; $ sum = 1 ; fscanf ( STDIN , \" %d %d \\n \" , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) exit ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { fscanf ( STDIN , \" %s \\n \" , $ a [ $ i ] ) ; $ a [ $ i ] = str_split ( $ a [ $ i ] ) ; } for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] == \" @ \" ) { $ row = $ i ; $ col = $ j ; } } } $ sum = 1 ; search ( $ row , $ col ) ; echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function c_p ( $ i , $ j ) { global $ sum , $ a ; $ sum += 1 ; $ a [ $ i ] [ $ j ] = \" # \" ; } function search ( $ i , $ j ) { global $ a ; if ( isset ( $ a [ $ i + 1 ] [ $ j ] ) and $ a [ $ i + 1 ] [ $ j ] == \" . \" ) { c_p ( $ i + 1 , $ j ) ; search ( $ i + 1 , $ j ) ; } if ( isset ( $ a [ $ i - 1 ] [ $ j ] ) and $ a [ $ i - 1 ] [ $ j ] == \" . \" ) { c_p ( $ i - 1 , $ j ) ; search ( $ i - 1 , $ j ) ; } if ( isset ( $ a [ $ i ] [ $ j + 1 ] ) and $ a [ $ i ] [ $ j + 1 ] == \" . \" ) { c_p ( $ i , $ j + 1 ) ; search ( $ i , $ j + 1 ) ; } if ( isset ( $ a [ $ i ] [ $ j - 1 ] ) and $ a [ $ i ] [ $ j - 1 ] == \" . \" ) { c_p ( $ i , $ j - 1 ) ; search ( $ i , $ j - 1 ) ; } } while ( 1 ) { $ a = array ( ) ; $ sum = 1 ; fscanf ( STDIN , \" %d %d \\n \" , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) exit ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { fscanf ( STDIN , \" %s \\n \" , $ a [ $ i ] ) ; $ a [ $ i ] = str_split ( $ a [ $ i ] ) ; } for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] == \" @ \" ) { $ row = $ i ; $ col = $ j ; } } } $ sum = 1 ; search ( $ row , $ col ) ; echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function c_p ( $ i , $ j ) { global $ sum , $ a ; $ sum += 1 ; $ a [ $ i ] [ $ j ] = \" # \" ; } function search ( $ i , $ j ) { global $ a ; if ( isset ( $ a [ $ i + 1 ] [ $ j ] ) and $ a [ $ i + 1 ] [ $ j ] == \" . \" ) { c_p ( $ i + 1 , $ j ) ; search ( $ i + 1 , $ j ) ; } if ( isset ( $ a [ $ i - 1 ] [ $ j ] ) and $ a [ $ i - 1 ] [ $ j ] == \" . \" ) { c_p ( $ i - 1 , $ j ) ; search ( $ i - 1 , $ j ) ; } if ( isset ( $ a [ $ i ] [ $ j + 1 ] ) and $ a [ $ i ] [ $ j + 1 ] == \" . \" ) { c_p ( $ i , $ j + 1 ) ; search ( $ i , $ j + 1 ) ; } if ( isset ( $ a [ $ i ] [ $ j - 1 ] ) and $ a [ $ i ] [ $ j - 1 ] == \" . \" ) { c_p ( $ i , $ j - 1 ) ; search ( $ i , $ j - 1 ) ; } } while ( 1 ) { $ a = array ( ) ; $ sum = 1 ; fscanf ( STDIN , \" %d %d \\n \" , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) exit ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { fscanf ( STDIN , \" %s \\n \" , $ a [ $ i ] ) ; $ a [ $ i ] = str_split ( $ a [ $ i ] ) ; } for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] == \" @ \" ) { $ row = $ i ; $ col = $ j ; } } } $ sum = 1 ; search ( $ row , $ col ) ; echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ dy = array ( - 1 , 0 , 1 , 0 ) ; $ dx = array ( 0 , 1 , 0 , - 1 ) ; $ fp = fopen ( \" php: while(true){ fscanf( $ fp , \" % d % d \" , $ w , $ h ) ; if ( $ w == 0 && $ h == 0 ) break ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { fscanf ( $ fp , \" %s \" , $ mas [ $ i ] ) ; for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { if ( $ mas [ $ i ] [ $ j ] == ' @ ' ) { $ sy = $ i ; $ sx = $ j ; } $ used [ $ i ] [ $ j ] = false ; } } $ que = new SplQueue ( ) ; $ que -> push ( array ( $ sy , $ sx ) ) ; $ cnt = 0 ; while ( ! $ que -> isEmpty ( ) ) { $ p = $ que -> dequeue ( ) ; if ( $ used [ $ p [ 0 ] ] [ $ p [ 1 ] ] ) continue ; $ used [ $ p [ 0 ] ] [ $ p [ 1 ] ] = true ; $ cnt ++ ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ ny = $ p [ 0 ] + $ dy [ $ i ] ; $ nx = $ p [ 1 ] + $ dx [ $ i ] ; if ( $ ny >= 0 && $ ny < $ h && $ nx >= 0 && $ nx < $ w && $ mas [ $ ny ] [ $ nx ] == ' . ' ) { $ que -> push ( array ( $ ny , $ nx ) ) ; } } } print ( $ cnt . \" \\n \" ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function move ( $ x , $ y , $ map , & $ visit ) { $ dx = [ 1 , - 1 , 0 , 0 ] ; $ dy = [ 0 , 0 , 1 , - 1 ] ; if ( ( $ map [ $ y ] [ $ x ] == ' . ' || $ map [ $ y ] [ $ x ] == ' @ ' ) && $ visit [ $ y ] [ $ x ] == false ) { $ visit [ $ y ] [ $ x ] = true ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { if ( ( $ x + $ dx [ $ i ] < count ( $ map [ $ y ] ) && $ x + $ dx [ $ i ] >= 0 ) && ( $ y + $ dy [ $ i ] < count ( $ map ) && $ y + $ dy [ $ i ] >= 0 ) ) { move ( $ x + $ dx [ $ i ] , $ y + $ dy [ $ i ] , $ map , $ visit ) ; } } } } function printmap ( $ map ) { foreach ( $ map as $ ma ) { foreach ( $ ma as $ m ) { if ( $ m ) { echo ' X ' ; } else { echo ' . ' ; } } echo \" \\n \" ; } } $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ w = intval ( $ numbers [ 0 ] ) ; $ h = intval ( $ numbers [ 1 ] ) ; while ( $ w != 0 ) { $ map = [ ] ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { $ ar = [ ] ; for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ ar [ ] = ' ' ; } $ map [ ] = $ ar ; } $ visit = [ ] ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { $ ar = [ ] ; for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ ar [ ] = false ; } $ visit [ ] = $ ar ; } $ visit1 = & $ visit ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { $ c = rtrim ( fgets ( STDIN ) ) ; for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ map [ $ i ] [ $ j ] = substr ( $ c , $ j , 1 ) ; if ( $ map [ $ i ] [ $ j ] == ' @ ' ) { $ x = $ j ; $ y = $ i ; } } } $ count = 0 ; move ( $ x , $ y , $ map , $ visit1 ) ; foreach ( $ visit1 as $ vi ) { foreach ( $ vi as $ v ) { if ( $ v ) { $ count += 1 ; } } } echo $ count ; echo \" \\n \" ; $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ w = intval ( $ numbers [ 0 ] ) ; $ h = intval ( $ numbers [ 1 ] ) ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ m ) ; while ( $ m -- ) { fscanf ( STDIN , \" %d \" , $ fund ) ; fscanf ( STDIN , \" %d \" , $ t ) ; fscanf ( STDIN , \" %d \" , $ n ) ; $ ans = 0 ; while ( $ n -- ) { fscanf ( STDIN , \" %d %f %d \" , $ op , $ p , $ q ) ; $ total = $ fund ; if ( $ op == 0 ) { $ tmp = 0 ; for ( $ i = 0 ; $ i < $ t ; $ i ++ ) { $ tmp += floor ( $ total * $ p ) ; $ total -= $ q ; } $ total += $ tmp ; } else { for ( $ i = 0 ; $ i < $ t ; $ i ++ ) { $ total += floor ( $ total * $ p ) - $ q ; } } $ ans = max ( $ ans , $ total ) ; } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php define ( \" MAX \" , 1e6 ) ; for ( $ i = 0 ; $ i < MAX ; $ i ++ ) { $ isPrime [ ] = 1 ; } $ isPrime [ 0 ] = $ isPrime [ 1 ] = 0 ; for ( $ i = 2 ; $ i < MAX ; $ i ++ ) { if ( ! $ isPrime [ $ i ] ) continue ; for ( $ j = 2 * $ i ; $ j < MAX ; $ j += $ i ) { $ isPrime [ $ j ] = 0 ; } } while ( fscanf ( STDIN , \" %d %d %d \" , $ a , $ d , $ n ) && ( $ a | $ d | $ n ) ) { $ count = 0 ; while ( 1 ) { if ( $ isPrime [ $ a ] ) { $ count ++ ; } if ( $ count == $ n ) { break ; } $ a += $ d ; } print $ a . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ array = array_fill ( 0 , pow ( 10 , 6 ) , 1 ) ; $ array [ 0 ] = $ array [ 1 ] = 0 ; for ( $ i = 2 ; $ i <= pow ( 10 , 6 ) / 2 ; $ i ++ ) { if ( ! $ array [ $ i ] ) continue ; for ( $ j = $ i * 2 ; $ j <= pow ( 10 , 6 ) ; $ j += $ i ) { $ array [ $ j ] = 0 ; } } while ( 1 ) { fscanf ( STDIN , \" %d %d %d \\n \" , $ a , $ d , $ n ) ; if ( $ a == 0 && $ d == 0 && $ n == 0 ) break ; $ sum = 0 ; for ( $ i = $ a ; $ i <= pow ( 10 , 6 ) ; $ i += $ d ) { $ sum += $ array [ $ i ] ; if ( $ sum == $ n ) { echo $ i . \" \\n \" ; break ; } } } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ m ) ; while ( $ m -- ) { $ str = rtrim ( fgets ( STDIN ) ) ; $ ans = array ( ) ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ a = substr ( $ str , 0 , $ i ) ; $ b = substr ( $ str , $ i ) ; $ ans [ $ a . $ b ] = 1 ; $ ans [ strrev ( $ a ) . $ b ] = 1 ; $ ans [ $ a . strrev ( $ b ) ] = 1 ; $ ans [ strrev ( $ a ) . strrev ( $ b ) ] = 1 ; $ ans [ $ b . $ a ] = 1 ; $ ans [ strrev ( $ b ) . $ a ] = 1 ; $ ans [ $ b . strrev ( $ a ) ] = 1 ; $ ans [ strrev ( $ b ) . strrev ( $ a ) ] = 1 ; } print count ( $ ans ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) ) { if ( $ n == 0 ) break ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ s [ $ i ] ) ; } sort ( $ s ) ; $ sum = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ sum += $ s [ $ i ] ; } $ ans = ( int ) ( $ sum / ( $ n - 2 ) ) ; print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { fscanf ( STDIN , \" %d \\n \" , $ n ) ; if ( $ n == 0 ) break ; else { $ a = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d \\n \" , $ a [ $ i ] ) ; } sort ( $ a ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ sum += $ a [ $ i ] ; } echo floor ( $ sum / ( $ n - 2 ) ) . \" \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ s = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s [ ] = trim ( fgets ( STDIN ) ) ; } sort ( $ s ) ; $ res = floor ( ( array_sum ( $ s ) - ( $ s [ 0 ] + $ s [ $ n - 1 ] ) ) / ( $ n - 2 ) ) ; echo $ res . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( $ n = trim ( fgets ( STDIN ) ) ) { $ s = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s [ ] = trim ( fgets ( STDIN ) ) ; } $ ans = floor ( ( array_sum ( $ s ) - ( max ( $ s ) + min ( $ s ) ) ) / ( $ n - 2 ) ) ; echo $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php function judge($n){ $ma=0; $mi=1000; $s=0; for($i=0;$i<$n;$i++){ $x=fgets(STDIN)+0; if($x<$mi){$mi=$x;} if($x>$ma){$ma=$x;} $s+=$x; } print floor(($s-$ma-$mi)/($n-2)); print \"\\n\"; } while(1){ $n=fgets(STDIN); if($n==0){break;} judge($n); } ?>",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php function judge($n){ $ma=0; $mi=1000; $s=0; for($i=0;$i<$n;$i++){ $x=fgets(STDIN)+0; if($x<$mi){$mi=$x;} if($x>$ma){$ma=$x;} $s+=$x; } print floor(($s-$ma-$mi)/($n-2)); print \"\\n\"; } while(1){ $n=fgets(STDIN); if($n==0){break;} judge($n); } ?>",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php function judge($n){ $ma=0; $mi=1000; $s=0; for($i=0;$i<$n;$i++){ $x=fgets(STDIN)+0; if($x<$mi){$mi=$x;} if($x>$ma){$ma=$x;} $s+=$x; } echo floor(($s-$ma-$mi)/($n-2)),\"\\n\"; } while(1){ $n=fgets(STDIN); if($n==0){break;} judge($n); } ?>",
    "label": 3
  },
  {
    "code": "<?php function get_input_num ( ) { $ input_num = ( int ) fgets ( STDIN ) ; return $ input_num ; } function make_score_list ( $ judge_num ) { $ score_list = [ ] ; for ( $ i = 0 ; $ i < $ judge_num ; $ i ++ ) { $ score_list [ ] = get_input_num ( ) ; } return $ score_list ; } function calculate_adjusted_ave_score ( $ judge_num , $ score_list ) { $ max_num = max ( $ score_list ) ; $ min_num = min ( $ score_list ) ; $ score_sum = array_sum ( $ score_list ) - $ max_num - $ min_num ; $ adjusted_ave_score = $ score_sum / ( $ judge_num - 2 ) ; return $ adjusted_ave_score ; } while ( True ) { $ judge_num = get_input_num ( ) ; if ( $ judge_num === 0 ) { break ; } $ score_list = make_score_list ( $ judge_num ) ; $ adjusted_ave_score = calculate_adjusted_ave_score ( $ judge_num , $ score_list ) ; $ adjusted_ave_score = floor ( $ adjusted_ave_score ) ; echo $ adjusted_ave_score . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ n , $ m ) && ( $ n | $ m ) ) { $ s_arr = $ t_arr = array ( ) ; $ s_sum = $ t_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ s_arr [ $ i ] ) ; $ s_sum += $ s_arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { fscanf ( STDIN , \" %d \" , $ t_arr [ $ i ] ) ; $ t_sum += $ t_arr [ $ i ] ; } $ s_ans = $ t_ans = 1000 ; foreach ( $ s_arr as $ s ) { foreach ( $ t_arr as $ t ) { if ( $ s_sum - $ s + $ t == $ t_sum - $ t + $ s && $ s_ans + $ t_ans > $ s + $ t ) { $ s_ans = $ s ; $ t_ans = $ t ; } } } if ( $ s_ans == 1000 && $ t_ans == 1000 ) { print \" -1 \\n \" ; } else { print $ s_ans . \" \" . $ t_ans . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php function trade ( $ dif , $ a , $ b ) { $ na = sizeof ( $ a ) ; $ nb = sizeof ( $ b ) ; $ flag = - 1 ; $ val_a = INF ; $ val_b = INF ; for ( $ i = 0 ; $ i < $ na ; $ i ++ ) { for ( $ j = 0 ; $ j < $ nb ; $ j ++ ) { if ( ( $ a [ $ i ] - $ b [ $ j ] ) * 2 == $ dif ) { $ flag = 1 ; if ( $ val_a + $ val_b > $ a [ $ i ] + $ b [ $ j ] ) { $ val_a = $ a [ $ i ] ; $ val_b = $ b [ $ j ] ; } } } } if ( $ flag == 1 ) echo $ val_a . \" \" . $ val_b . \" \\n \" ; else echo \" -1 \" . \" \\n \" ; } while ( 1 ) { $ n = 0 ; $ m = 0 ; fscanf ( STDIN , \" %d %d \\n \" , $ n , $ m ) ; if ( $ n == 0 && $ m == 0 ) { break ; } $ sum_a = 0 ; $ sum_b = 0 ; $ a = array ( ) ; $ b = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d \\n \" , $ a [ $ i ] ) ; $ sum_a += $ a [ $ i ] ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { fscanf ( STDIN , \" %d \\n \" , $ b [ $ i ] ) ; $ sum_b += $ b [ $ i ] ; } trade ( $ sum_a - $ sum_b , $ a , $ b ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php function check ( $ T ) { $ memo = $ T ; $ T = str_replace ( \" -0 \" , \" 2 \" , $ T ) ; $ T = str_replace ( \" -1 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" -2 \" , \" 0 \" , $ T ) ; if ( $ memo !== $ T ) { return check ( $ T ) ; } $ T = str_replace ( \" 0*0 \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" 0*1 \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" 0*2 \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" 1*0 \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" 1*1 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" 1*2 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" 2*0 \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" 2*1 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" 2*2 \" , \" 2 \" , $ T ) ; if ( $ memo !== $ T ) { return check ( $ T ) ; } $ T = str_replace ( \" 0+0 \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" 0+1 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" 0+2 \" , \" 2 \" , $ T ) ; $ T = str_replace ( \" 1+0 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" 1+1 \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" 1+2 \" , \" 2 \" , $ T ) ; $ T = str_replace ( \" 2+0 \" , \" 2 \" , $ T ) ; $ T = str_replace ( \" 2+1 \" , \" 2 \" , $ T ) ; $ T = str_replace ( \" 2+2 \" , \" 2 \" , $ T ) ; if ( $ memo !== $ T ) { return check ( $ T ) ; } $ T = str_replace ( \" (0) \" , \" 0 \" , $ T ) ; $ T = str_replace ( \" (1) \" , \" 1 \" , $ T ) ; $ T = str_replace ( \" (2) \" , \" 2 \" , $ T ) ; if ( $ memo !== $ T ) { return check ( $ T ) ; } return $ T ; } while ( true ) { $ S = trim ( fgets ( STDIN ) ) ; if ( $ S === \" . \" ) break ; $ ans = 0 ; for ( $ P = 0 ; $ P < 3 ; $ P ++ ) { for ( $ Q = 0 ; $ Q < 3 ; $ Q ++ ) { for ( $ R = 0 ; $ R < 3 ; $ R ++ ) { $ T = $ S ; $ T = str_replace ( \" P \" , $ P , $ T ) ; $ T = str_replace ( \" Q \" , $ Q , $ T ) ; $ T = str_replace ( \" R \" , $ R , $ T ) ; if ( check ( $ T ) === \" 2 \" ) $ ans ++ ; } } } echo $ ans . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ n , $ p ) ) { if ( ( $ n | $ p ) == 0 ) break ; $ stone = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ stone [ ] = 0 ; } $ total = $ p ; $ i = 0 ; while ( 1 ) { if ( $ p ) { $ stone [ $ i ] ++ ; $ p -- ; } else { $ p = $ stone [ $ i ] ; $ stone [ $ i ] = 0 ; } if ( $ stone [ $ i ] == $ total ) { $ ans = $ i ; break ; } $ i = ( $ i + 1 ) % $ n ; } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ ppl = array ( ) ; while ( fscanf ( STDIN , \" %d %d \\n \" , $ n , $ p ) ) { if ( $ n == 0 && $ p == 0 ) break ; $ ppl = array_fill ( 0 , $ n , 0 ) ; $ bowl = $ p ; while ( 1 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ bowl > 0 ) { $ ppl [ $ i ] ++ ; $ bowl -- ; } else { $ bowl = $ ppl [ $ i ] ; $ ppl [ $ i ] = 0 ; } if ( $ ppl [ $ i ] == $ p ) { echo $ i . \" \\n \" ; break 2 ; } } } } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { list ( $ n , $ p ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ n == 0 && $ p == 0 ) break ; $ person = array_fill ( 0 , $ n , 0 ) ; $ s = $ p ; $ t = 0 ; while ( true ) { if ( $ s > 0 ) { $ person [ $ t ] ++ ; $ s -- ; } elseif ( $ s == 0 ) { $ s = $ person [ $ t ] ; $ person [ $ t ] = 0 ; } if ( $ person [ $ t ] == $ p ) { $ ans = $ t ; break ; } $ t = ( $ t + 1 ) % $ n ; } echo $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { list ( $ n , $ p ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ n == 0 && $ p == 0 ) break ; $ person = array_fill ( 0 , $ n , 0 ) ; $ s = $ p ; $ t = 0 ; while ( 1 ) { if ( $ s > 0 ) { $ person [ $ t ] ++ ; $ s -- ; } elseif ( $ s == 0 ) { $ s = $ person [ $ t ] ; $ person [ $ t ] = 0 ; } if ( $ person [ $ t ] == $ p ) { echo $ t . \" \\n \" ; break ; } $ t = ( $ t + 1 ) % $ n ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { list ( $ n , $ m ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ n == 0 && $ m == 0 ) break ; $ p = array_fill ( 0 , $ n , 0 ) ; $ s = $ m ; $ t = 0 ; while ( true ) { if ( $ s > 0 ) { $ p [ $ t ] ++ ; $ s -- ; } elseif ( $ s == 0 ) { $ s = $ p [ $ t ] ; $ p [ $ t ] = 0 ; } if ( $ p [ $ t ] == $ m ) { echo $ t . \" \\n \" ; break ; } $ t = ( $ t + 1 ) % $ n ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ w , $ h ) && ( $ w | $ h ) ) { unset ( $ c ) ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { $ c [ ] = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; } for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { $ visited [ $ i ] [ $ j ] = 0 ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) { if ( $ c [ $ i ] [ $ j ] && ! $ visited [ $ i ] [ $ j ] ) { $ ans ++ ; dfs ( $ i , $ j ) ; } } } print $ ans . \" \\n \" ; } function dfs ( $ y , $ x ) { global $ visited , $ c , $ w , $ h ; $ visited [ $ y ] [ $ x ] = 1 ; for ( $ i = - 1 ; $ i <= 1 ; $ i ++ ) { for ( $ j = - 1 ; $ j <= 1 ; $ j ++ ) { $ ny = $ y + $ i ; $ nx = $ x + $ j ; if ( 0 > $ ny || $ ny >= $ h ) continue ; if ( 0 > $ nx || $ nx >= $ w ) continue ; if ( $ visited [ $ ny ] [ $ nx ] ) continue ; if ( ! $ c [ $ ny ] [ $ nx ] ) continue ; dfs ( $ ny , $ nx ) ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ dx = array ( - 1 , 0 , 1 , 0 ) ; $ dy = array ( 0 , 1 , 0 , - 1 ) ; while ( fscanf ( STDIN , \" %d \" , $ N ) && $ N ) { unset ( $ pos ) ; for ( $ i = 0 ; $ i < 401 ; $ i ++ ) { for ( $ j = 0 ; $ j < 401 ; $ j ++ ) { $ table [ $ i ] [ $ j ] = 0 ; } } $ table [ 200 ] [ 200 ] = 1 ; $ pos [ 0 ] = array ( 200 , 200 ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , \" %d %d \" , $ n , $ d ) ; $ x = $ pos [ $ n ] [ 0 ] + $ dx [ $ d ] ; $ y = $ pos [ $ n ] [ 1 ] + $ dy [ $ d ] ; $ table [ $ y ] [ $ x ] = 1 ; $ pos [ $ i ] = array ( $ x , $ y ) ; } $ minX = 401 ; $ minY = 401 ; $ maxX = 0 ; $ maxY = 0 ; for ( $ i = 0 ; $ i < 401 ; $ i ++ ) { for ( $ j = 0 ; $ j < 401 ; $ j ++ ) { if ( $ table [ $ i ] [ $ j ] ) { $ minX = min ( $ minX , $ j ) ; $ minY = min ( $ minY , $ i ) ; $ maxX = max ( $ maxX , $ j ) ; $ maxY = max ( $ maxY , $ i ) ; } } } printf ( \" %d %d \\n \" , $ maxX - $ minX + 1 , $ maxY - $ minY + 1 ) ; }",
    "label": 3
  },
  {
    "code": "<?php define ( \" MAX \" , 123456 * 2 + 1 ) ; for ( $ i = 0 ; $ i < MAX ; $ i ++ ) { $ isPrime [ ] = 1 ; } $ isPrime [ 0 ] = $ isPrime [ 1 ] = 0 ; for ( $ i = 2 ; $ i < MAX ; $ i ++ ) { if ( ! $ isPrime [ $ i ] ) continue ; $ prime [ ] = $ i ; for ( $ j = 2 * $ i ; $ j < MAX ; $ j += $ i ) { $ isPrime [ $ j ] = 0 ; } } while ( fscanf ( STDIN , \" %d \" , $ n ) && $ n ) { $ ans = 0 ; foreach ( $ prime as $ p ) { if ( $ n < $ p && $ p <= 2 * $ n ) $ ans ++ ; } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ a = array_fill ( 0 , 123456 * 2 , 1 ) ; for ( $ i = 2 ; $ i <= 123456 ; $ i ++ ) { for ( $ j = $ i * 2 ; $ j <= 123456 * 2 ; $ j += $ i ) { $ a [ $ j ] = 0 ; } } while ( 1 ) { fscanf ( STDIN , \" %d \\n \" , $ n ) ; if ( $ n == 0 ) break ; $ sum = 0 ; for ( $ i = $ n + 1 ; $ i <= 2 * $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; } echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { $ str = rtrim ( fgets ( STDIN ) ) ; if ( $ str == ' . ' ) { break ; } $ flg = true ; $ stack = array ( ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' || $ str [ $ i ] == ' [ ' ) { array_push ( $ stack , $ str [ $ i ] ) ; } else if ( $ str [ $ i ] == ' ) ' || $ str [ $ i ] == ' ] ' ) { if ( empty ( $ stack ) ) { $ flg = false ; } else { $ c = array_pop ( $ stack ) . $ str [ $ i ] ; if ( $ c != \" () \" && $ c != \" [] \" ) { $ flg = false ; } } } if ( ! $ flg ) { break ; } } if ( ! empty ( $ stack ) ) { $ flg = false ; } print $ flg ? \" yes \\n \" : \" no \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function paint ( $ h , $ w , $ y , $ x , & $ p , $ org , $ c ) { if ( $ org == $ c ) return ; if ( $ p [ $ y ] [ $ x ] != $ org ) return ; $ p [ $ y ] [ $ x ] = $ c ; if ( $ x > 0 ) paint ( $ h , $ w , $ y , $ x - 1 , $ p , $ org , $ c ) ; if ( $ x < $ w - 1 ) paint ( $ h , $ w , $ y , $ x + 1 , $ p , $ org , $ c ) ; if ( $ y > 0 ) paint ( $ h , $ w , $ y - 1 , $ x , $ p , $ org , $ c ) ; if ( $ y < $ h - 1 ) paint ( $ h , $ w , $ y + 1 , $ x , $ p , $ org , $ c ) ; } function count_ ( $ h , $ w , $ p , $ c ) { $ r = array ( ) ; $ r = $ p ; $ newcolor = $ c + 10 ; paint ( $ h , $ w , 0 , 0 , $ r , $ c , $ newcolor ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) for ( $ j = 0 ; $ j < $ w ; $ j ++ ) $ cnt += ( $ r [ $ i ] [ $ j ] == $ newcolor ) ? 1 : 0 ; return ( $ cnt ) ; } function dump ( $ h , $ w , $ q ) { for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { for ( $ j = 0 ; $ j < $ w ; $ j ++ ) fprintf ( STDOUT , \" %d \" , $ q [ $ i ] [ $ j ] ) ; fprintf ( STDOUT , \" \\n \" ) ; } fprintf ( STDOUT , \" --------- \\n \" ) ; } function solve ( $ h , $ w , $ p , $ c , $ turn ) { $ q = array ( ) ; if ( $ turn == 1 ) { $ q = $ p ; $ org = $ q [ 0 ] [ 0 ] ; paint ( $ h , $ w , 0 , 0 , $ q , $ org , $ c ) ; $ ret = count_ ( $ h , $ w , $ q , $ c ) ; return ( $ ret ) ; } $ max = 0 ; for ( $ color = 1 ; $ color <= 6 ; $ color ++ ) { if ( $ color == $ p [ 0 ] [ 0 ] ) continue ; $ q = $ p ; $ org = $ q [ 0 ] [ 0 ] ; paint ( $ h , $ w , 0 , 0 , $ q , $ org , $ color ) ; $ ret = solve ( $ h , $ w , $ q , $ c , $ turn - 1 ) ; $ max = max ( $ max , $ ret ) ; } return ( $ max ) ; } $ p = array ( ) ; while ( fscanf ( STDIN , \" %d %d %d \" , $ h , $ w , $ c ) && ( $ h || $ w || $ c ) ) { for ( $ i = 0 ; $ i < $ h ; $ i ++ ) { $ buf = fgets ( STDIN ) ; $ p [ $ i ] [ 0 ] = strtok ( $ buf , \" \\n \\t \" ) ; for ( $ j = 1 ; $ j < $ w ; $ j ++ ) $ p [ $ i ] [ $ j ] = strtok ( \" \\n \\t \" ) ; } $ ret = solve ( $ h , $ w , $ p , $ c , 5 ) ; fprintf ( STDOUT , \" %d \\n \" , $ ret ) ; } return ( 0 ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; while ( $ n -- ) { fscanf ( STDIN , \" %d %d %d \" , $ y , $ m , $ d ) ; $ cnt = 0 ; while ( $ y != 1000 || $ m != 1 || $ d != 1 ) { $ cnt ++ ; $ d ++ ; if ( $ y % 3 ) { if ( ( $ m % 2 && $ d > 20 ) || ( $ m % 2 == 0 && $ d > 19 ) ) { $ m ++ ; $ d = 1 ; } } else { if ( $ d > 20 ) { $ m ++ ; $ d = 1 ; } } if ( $ m > 10 ) { $ y ++ ; $ m = 1 ; } } print $ cnt . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function mygetDate ( $ y , $ m , $ d ) { if ( $ y % 3 == 0 ) { $ d_sum = 20 * ( $ m - 1 ) + $ d ; } else { $ d_sum = 0 ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ d_sum += 19 ; } else { $ d_sum += 20 ; } } $ d_sum += $ d ; } return ( $ d_sum ) ; } $ piled_days = array_fill ( 0 , 1001 , 0 ) ; $ a = mygetDate ( 1 , 10 , 19 ) ; $ b = mygetDate ( 3 , 10 , 20 ) ; for ( $ i = 1 ; $ i < 1000 ; $ i ++ ) { if ( $ i % 3 == 0 ) { $ piled_days [ $ i ] += ( $ piled_days [ $ i - 1 ] + $ b ) ; } else { $ piled_days [ $ i ] += ( $ piled_days [ $ i - 1 ] + $ a ) ; } } $ millennium = $ piled_days [ 999 ] + 1 ; fscanf ( STDIN , \" %d \\n \" , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \\n \" , $ y , $ m , $ d ) ; $ sum = $ piled_days [ $ y - 1 ] + mygetDate ( $ y , $ m , $ d ) ; echo $ millennium - $ sum , \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php $n=fgets(STDIN)+0; for($i=0;$i<$n;$i++){ list($y,$m,$d)=split(\" \",fgets(STDIN)); $y-=1;$m-=1; echo 196471-$y*195-floor($y/3)*5-$m*20+($y%3!=2?floor($m/2):0)-$d,\"\\n\"; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d \" , $ a , $ L ) && ( $ a || $ L ) ) { $ table = array ( ) ; for ( $ i = 0 ; ; $ i ++ ) { if ( isset ( $ table [ $ a ] ) ) { print $ table [ $ a ] . \" \" . $ a . \" \" . ( $ i - $ table [ $ a ] ) . \" \\n \" ; break ; } else { $ table [ $ a ] = $ i ; } $ a = strval ( $ a ) ; while ( strlen ( $ a ) != $ L ) $ a .= \" 0 \" ; $ a = str_split ( $ a ) ; rsort ( $ a ) ; $ b = implode ( $ a ) ; sort ( $ a ) ; $ c = implode ( $ a ) ; $ a = intval ( $ b ) - intval ( $ c ) ; } }",
    "label": 3
  },
  {
    "code": "<?php $ N = trim ( fgets ( STDIN ) ) ; function saiki ( $ str ) { if ( is_numeric ( $ str ) ) { return ( $ str + 1 ) / 2 ; } $ array = array ( ) ; $ d = 0 ; $ memo ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == ' [ ' ) { if ( $ d == 0 ) { $ memo = $ i ; } $ d ++ ; } else if ( $ str [ $ i ] == ' ] ' ) { $ d -- ; if ( $ d == 0 ) { array_push ( $ array , saiki ( substr ( $ str , $ memo + 1 , $ i - $ memo - 1 ) ) ) ; } } } sort ( $ array ) ; $ size = ( sizeof ( $ array ) + 1 ) / 2 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ sum += $ array [ $ i ] ; } return $ sum ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ str = trim ( fgets ( STDIN ) ) ; echo saiki ( $ str ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ N = trim ( fgets ( STDIN ) ) ; function saiki ( $ str ) { if ( is_numeric ( $ str ) ) { return ( $ str + 1 ) / 2 ; } $ array = array ( ) ; $ d = 0 ; $ memo ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == ' [ ' ) { if ( $ d == 0 ) { $ memo = $ i ; } $ d ++ ; } else if ( $ str [ $ i ] == ' ] ' ) { $ d -- ; if ( $ d == 0 ) { array_push ( $ array , saiki ( substr ( $ str , $ memo + 1 , $ i - $ memo - 1 ) ) ) ; } } } sort ( $ array ) ; $ size = ( sizeof ( $ array ) + 1 ) / 2 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ sum += $ array [ $ i ] ; } return $ sum ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { echo saiki ( trim ( fgets ( STDIN ) ) ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; while ( $ n -- ) { fscanf ( STDIN , \" %s \" , $ o ) ; fscanf ( STDIN , \" %s \" , $ m ) ; $ o = strrev ( $ o ) ; for ( $ i = 0 ; $ i < strlen ( $ o ) ; $ i ++ ) { $ ch = $ o [ $ i ] ; if ( $ ch == ' J ' ) { $ m = substr ( $ m , strlen ( $ m ) - 1 ) . substr ( $ m , 0 , strlen ( $ m ) - 1 ) ; } else if ( $ ch == ' C ' ) { $ m = substr ( $ m , 1 ) . substr ( $ m , 0 , 1 ) ; } else if ( $ ch == ' E ' ) { if ( strlen ( $ m ) % 2 ) { $ m = substr ( $ m , ( int ) ( strlen ( $ m ) / 2 ) + 1 ) . $ m [ ( int ) ( strlen ( $ m ) / 2 ) ] . substr ( $ m , 0 , ( int ) ( strlen ( $ m ) / 2 ) ) ; } else { $ m = substr ( $ m , strlen ( $ m ) / 2 ) . substr ( $ m , 0 , strlen ( $ m ) / 2 ) ; } } else if ( $ ch == ' A ' ) { $ m = strrev ( $ m ) ; } else if ( $ ch == ' P ' ) { for ( $ j = 0 ; $ j < strlen ( $ m ) ; $ j ++ ) { if ( is_numeric ( $ m [ $ j ] ) ) { $ m [ $ j ] = ( string ) ( ( ( int ) $ m [ $ j ] - 1 + 10 ) % 10 ) ; } } } else if ( $ ch == ' M ' ) { for ( $ j = 0 ; $ j < strlen ( $ m ) ; $ j ++ ) { if ( is_numeric ( $ m [ $ j ] ) ) { $ m [ $ j ] = ( string ) ( ( ( int ) $ m [ $ j ] + 1 ) % 10 ) ; } } } } print $ m . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ isPrime = array_fill ( 0 , 10001 , true ) ; $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i <= 5000 ; $ i ++ ) { for ( $ j = 2 ; $ i * $ j <= 10000 ; $ j ++ ) { $ isPrime [ $ i * $ j ] = false ; } } $ primeNumber = array ( ) ; foreach ( $ isPrime as $ key => $ value ) { if ( $ value ) { $ primeNumber [ ] = $ key ; } } while ( true ) { fscanf ( STDIN , \" %d \" , $ input ) ; if ( $ input == 0 ) break ; $ result = 0 ; for ( $ l = 0 ; $ l < count ( $ primeNumber ) ; $ l ++ ) { $ sum = 0 ; for ( $ m = $ l ; $ m < count ( $ primeNumber ) ; $ m ++ ) { $ sum += $ primeNumber [ $ m ] ; if ( $ sum == $ input ) { $ result ++ ; } } unset ( $ sum ) ; } echo $ result . \" \\n \" ; unset ( $ result ) ; }",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php for(;;){ list($n,$k,$m)=split(\" \",fgets(STDIN)); if(!$n)break; for($r=$i=0;++$i<$n;$r%=$i)$r+=$k; echo (($r+$m)%$n+1).PHP_EOL; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( true ) { $ n = trim ( fgets ( STDIN ) ) ; if ( $ n == 0 ) break ; unset ( $ v ) ; $ grp = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; $ line = substr ( $ line , 0 , - 1 ) ; $ arr = explode ( ' : ' , $ line ) ; if ( $ i == 0 ) { $ grp = $ arr [ 0 ] ; } $ v [ $ arr [ 0 ] ] = explode ( ' , ' , $ arr [ 1 ] ) ; } $ changed = true ; while ( $ changed ) { $ changed = false ; foreach ( $ v [ $ grp ] as $ k => $ g ) { if ( isset ( $ v [ $ g ] ) ) { unset ( $ v [ $ grp ] [ $ k ] ) ; $ v [ $ grp ] = array_merge ( $ v [ $ grp ] , $ v [ $ g ] ) ; $ v [ $ grp ] = array_unique ( $ v [ $ grp ] ) ; $ changed = true ; break ; ; } } } $ v [ $ grp ] = array_unique ( $ v [ $ grp ] ) ; echo count ( $ v [ $ grp ] ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ keys = array ( \" A \" => array ( \" B \" => true , \" D \" => true , ) , \" B \" => array ( \" A \" => true , \" C \" => true , \" E \" => true , ) , \" C \" => array ( \" B \" => true , \" F \" => true , ) , \" D \" => array ( \" A \" => true , \" E \" => true , \" G \" => true , ) , \" E \" => array ( \" B \" => true , \" D \" => true , \" F \" => true , \" H \" => true , ) , \" F \" => array ( \" C \" => true , \" E \" => true , \" I \" => true , ) , \" G \" => array ( \" D \" => true , \" H \" => true , ) , \" H \" => array ( \" E \" => true , \" G \" => true , \" I \" => true , ) , \" I \" => array ( \" F \" => true , \" H \" => true , ) , ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ flg = true ; $ prev = null ; foreach ( str_split ( $ line ) as $ char ) { if ( isset ( $ prev ) && ! isset ( $ keys [ $ prev ] [ $ char ] ) ) { $ flg = false ; break ; } $ prev = $ char ; } if ( $ flg ) { echo $ line , PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( $ line = trim ( fgets ( STDIN ) ) ) { $ a = $ line ; $ zitem = ' ' ; $ flg = true ; for ( $ i = 0 ; $ i < strlen ( $ a ) ; $ i ++ ) { if ( $ i == 0 ) { $ zitem = $ a [ $ i ] ; continue ; } switch ( $ zitem ) { case ' A ' : if ( ! in_array ( $ a [ $ i ] , array ( ' B ' , ' D ' ) ) ) { $ flg = false ; break ; } break ; case ' B ' : if ( ! in_array ( $ a [ $ i ] , array ( ' A ' , ' E ' , ' C ' ) ) ) { $ flg = false ; break ; } break ; case ' C ' : if ( ! in_array ( $ a [ $ i ] , array ( ' B ' , ' F ' ) ) ) { $ flg = false ; break ; } break ; case ' D ' : if ( ! in_array ( $ a [ $ i ] , array ( ' A ' , ' E ' , ' G ' ) ) ) { $ flg = false ; break ; } break ; case ' E ' : if ( ! in_array ( $ a [ $ i ] , array ( ' B ' , ' D ' , ' F ' , ' H ' ) ) ) { $ flg = false ; break ; } break ; case ' F ' : if ( ! in_array ( $ a [ $ i ] , array ( ' C ' , ' E ' , ' I ' ) ) ) { $ flg = false ; break ; } break ; case ' G ' : if ( ! in_array ( $ a [ $ i ] , array ( ' D ' , ' H ' ) ) ) { $ flg = false ; break ; } break ; case ' H ' : if ( ! in_array ( $ a [ $ i ] , array ( ' G ' , ' E ' , ' I ' ) ) ) { $ flg = false ; break ; } break ; case ' I ' : if ( ! in_array ( $ a [ $ i ] , array ( ' H ' , ' F ' ) ) ) { $ flg = false ; break ; } break ; } $ zitem = $ a [ $ i ] ; } if ( $ flg ) { echo $ a . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ p = array ( ' A ' => array ( ' B ' , ' D ' ) , ' B ' => array ( ' A ' , ' C ' , ' E ' ) , ' C ' => array ( ' B ' , ' F ' ) , ' D ' => array ( ' A ' , ' E ' , ' G ' ) , ' E ' => array ( ' B ' , ' D ' , ' F ' , ' H ' ) , ' F ' => array ( ' C ' , ' E ' , ' I ' ) , ' G ' => array ( ' D ' , ' H ' ) , ' H ' => array ( ' G ' , ' E ' , ' I ' ) , ' I ' => array ( ' F ' , ' H ' ) , ) ; while ( $ line = trim ( fgets ( STDIN ) ) ) { $ str = str_split ( $ line ) ; $ len = count ( $ str ) ; $ ok = true ; for ( $ i = 0 ; $ i < $ len - 1 ; ++ $ i ) { if ( in_array ( $ str [ $ i + 1 ] , $ p [ $ str [ $ i ] ] ) ) { } else { $ ok = false ; break ; } } if ( $ ok ) echo \" $ line \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php class Scanner { private $ arr = [ ] ; private $ count = 0 ; private $ pointer = 0 ; public function next ( ) { if ( $ this -> pointer >= $ this -> count ) { $ str = trim ( fgets ( STDIN ) ) ; $ this -> arr = explode ( ' ' , $ str ) ; $ this -> count = count ( $ this -> arr ) ; $ this -> pointer = 0 ; } $ result = $ this -> arr [ $ this -> pointer ] ; $ this -> pointer ++ ; return $ result ; } public function hasNext ( ) { return $ this -> pointer < $ this -> count ; } public function nextInt ( ) { return ( int ) $ this -> next ( ) ; } public function nextDouble ( ) { return ( double ) $ this -> next ( ) ; } } class DijkstraPriorityQueue extends SplPriorityQueue { public function compare ( $ priority1 , $ priority2 ) { if ( $ priority1 === $ priority2 ) { return 0 ; } return $ priority1 < $ priority2 ? 1 : - 1 ; } } $ sc = new Scanner ( ) ; while ( true ) { $ n = $ sc -> nextInt ( ) ; $ m = $ sc -> nextInt ( ) ; if ( $ n == 0 && $ m == 0 ) { break ; } $ costArray = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ costArray [ $ i ] = $ sc -> nextInt ( ) ; } $ result = - 1 ; foreach ( $ costArray as $ i => $ cost ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ sum = $ cost + $ costArray [ $ j ] ; if ( $ result < $ sum && $ sum <= $ m ) { $ result = $ sum ; } } } if ( $ result != - 1 ) { echo $ result . \" \\n \" ; } else { echo ' NONE ' . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( $ str = trim ( fgets ( STDIN ) ) ) { $ line1 = explode ( \" \" , $ str ) ; $ n = $ line1 [ 0 ] ; $ m = $ line1 [ 1 ] ; if ( $ n == 0 && $ m == 0 ) { break ; } $ str = trim ( fgets ( STDIN ) ) ; $ line2 = explode ( \" \" , $ str ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ t = ( int ) $ line2 [ $ i ] + ( int ) $ line2 [ $ j ] ; if ( $ t >= $ ans && $ t <= $ m ) { $ ans = $ t ; } } } if ( $ ans == 0 ) { echo \" NONE \" . \" \\n \" ; continue ; } echo $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ input_line = fgets ( STDIN ) ; $ number = preg_split ( \" /[\\s,]+/ \" , $ input_line ) ; $ n = intval ( $ number [ 0 ] ) ; $ m = intval ( $ number [ 1 ] ) ; while ( $ n != 0 ) { $ input_line = fgets ( STDIN ) ; $ amounts = preg_split ( \" /[\\s,]+/ \" , $ input_line ) ; $ maxX = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 1 + $ i ; $ j < $ n ; $ j ++ ) { $ sum = intval ( $ amounts [ $ i ] ) + intval ( $ amounts [ $ j ] ) ; if ( $ sum <= $ m ) { if ( $ maxX < $ sum ) { $ maxX = $ sum ; } } } } if ( $ maxX == 0 ) { echo ' NONE ' . \" \\n \" ; } else { echo $ maxX . \" \\n \" ; } $ input_line = fgets ( STDIN ) ; $ number = preg_split ( \" /[\\s,]+/ \" , $ input_line ) ; $ n = intval ( $ number [ 0 ] ) ; $ m = intval ( $ number [ 1 ] ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ n_people = intval ( fgets ( STDIN ) ) ; while ( $ n_people != 0 ) { $ input_line = rtrim ( fgets ( STDIN ) ) ; $ number = preg_split ( \" /[\\s,]+/ \" , $ input_line ) ; $ income = [ ] ; for ( $ i = 0 ; $ i < $ n_people ; $ i ++ ) { $ income [ ] = intval ( $ number [ $ i ] ) ; } $ avg = array_sum ( $ income ) / $ n_people ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n_people ; $ i ++ ) { if ( $ income [ $ i ] <= $ avg ) { $ count += 1 ; } } print $ count ; print \" \\n \" ; $ n_people = intval ( fgets ( STDIN ) ) ; }",
    "label": 3
  },
  {
    "code": "<?php class Scanner { private $ arr = [ ] ; private $ count = 0 ; private $ pointer = 0 ; public function next ( ) { if ( $ this -> pointer >= $ this -> count ) { $ str = trim ( fgets ( STDIN ) ) ; $ this -> arr = explode ( ' ' , $ str ) ; $ this -> count = count ( $ this -> arr ) ; $ this -> pointer = 0 ; } $ result = $ this -> arr [ $ this -> pointer ] ; $ this -> pointer ++ ; return $ result ; } public function hasNext ( ) { return $ this -> pointer < $ this -> count ; } public function nextInt ( ) { return ( int ) $ this -> next ( ) ; } public function nextDouble ( ) { return ( double ) $ this -> next ( ) ; } } class out { public static function println ( $ str = \" \" ) { echo $ str . PHP_EOL ; } } $ sc = new Scanner ( ) ; while ( true ) { $ n = $ sc -> nextInt ( ) ; if ( $ n === 0 ) { break ; } $ sum = 0 ; $ array = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ array [ $ i ] = $ sc -> nextInt ( ) ; $ sum += $ array [ $ i ] ; } $ avg = $ sum / $ n ; $ count = 0 ; foreach ( $ array as $ a ) { if ( ( int ) $ avg >= $ a ) { ++ $ count ; } } out :: println ( $ count ) ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) && $ n ) { $ map = array ( array ( ) ) ; for ( $ i = 0 ; $ i < 21 ; $ i ++ ) { for ( $ j = 0 ; $ j < 21 ; $ j ++ ) { $ map [ $ i ] [ $ j ] = 0 ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d %d \" , $ x , $ y ) ; $ map [ $ y ] [ $ x ] = 1 ; } fscanf ( STDIN , \" %d \" , $ m ) ; $ cnt = 0 ; $ x = 10 ; $ y = 10 ; $ dx = array ( 1 , 0 , - 1 , 0 ) ; $ dy = array ( 0 , 1 , 0 , - 1 ) ; $ dir = array ( ' E ' => 0 , ' N ' => 1 , ' W ' => 2 , ' S ' => 3 ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { fscanf ( STDIN , \" %c %d \" , $ d , $ l ) ; for ( $ j = 0 ; $ j < $ l ; $ j ++ ) { $ x += $ dx [ $ dir [ $ d ] ] ; $ y += $ dy [ $ dir [ $ d ] ] ; if ( $ map [ $ y ] [ $ x ] ) { $ map [ $ y ] [ $ x ] = 0 ; $ cnt ++ ; } } } print ( $ cnt == $ n ? \" Yes \" : \" No \" ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ dir = [ \" N \" => 0 , \" E \" => 1 , \" S \" => 2 , \" W \" => 3 ] ; $ dx = [ 0 , 1 , 0 , - 1 ] ; $ dy = [ 1 , 0 , - 1 , 0 ] ; while ( $ N = trim ( fgets ( STDIN ) ) ) { $ land = [ ] ; for ( $ i = 0 ; $ i <= 20 ; $ i ++ ) { for ( $ j = 0 ; $ j <= 20 ; $ j ++ ) { $ land [ $ i ] [ $ j ] = 0 ; } } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { list ( $ x , $ y ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ land [ $ y ] [ $ x ] = 1 ; } $ o = trim ( fgets ( STDIN ) ) ; $ cnt = 0 ; $ x = 10 ; $ y = 10 ; for ( $ i = 0 ; $ i < $ o ; $ i ++ ) { list ( $ d , $ l ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; for ( $ j = 0 ; $ j < $ l ; $ j ++ ) { $ x += $ dx [ $ dir [ $ d ] ] ; $ y += $ dy [ $ dir [ $ d ] ] ; if ( $ land [ $ y ] [ $ x ] == 1 ) { $ land [ $ y ] [ $ x ] = 0 ; $ cnt ++ ; } } } echo ( $ cnt == $ N ? \" Yes \" : \" No \" ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php function first_check ( $ sorted , $ pre , $ post ) { $ keys = [ ] ; for ( $ cur = $ pre ; $ cur <= $ post ; $ cur ++ ) { if ( empty ( $ sorted ) ) { return $ keys ; } do { $ value = reset ( $ sorted ) ; if ( $ cur < $ value ) { continue 2 ; } $ key = key ( $ sorted ) ; unset ( $ sorted [ $ key ] ) ; if ( $ cur == $ value ) { $ keys [ ] = $ key ; } } while ( $ sorted ) ; } return $ keys ; } function second_check ( $ sorted , $ keys , $ cur ) { foreach ( $ keys as $ k => $ key ) { if ( $ sorted [ $ key ] != $ cur ) { unset ( $ keys [ $ k ] ) ; } } return $ keys ; } function found ( & $ gems , & $ state , $ d , $ l ) { $ keys = [ ] ; switch ( $ d ) { case ' N ' : $ keys = first_check ( $ gems [ ' y ' ] , $ state [ 1 ] , $ state [ 1 ] + $ l ) ; $ keys = second_check ( $ gems [ ' x ' ] , $ keys , $ state [ 0 ] ) ; $ state [ 1 ] += $ l ; break ; case ' E ' : $ keys = first_check ( $ gems [ ' x ' ] , $ state [ 0 ] , $ state [ 0 ] + $ l ) ; $ keys = second_check ( $ gems [ ' y ' ] , $ keys , $ state [ 1 ] ) ; $ state [ 0 ] += $ l ; break ; case ' S ' : $ keys = first_check ( $ gems [ ' y ' ] , $ state [ 1 ] - $ l , $ state [ 1 ] ) ; $ keys = second_check ( $ gems [ ' x ' ] , $ keys , $ state [ 0 ] ) ; $ state [ 1 ] -= $ l ; break ; case ' W ' : $ keys = first_check ( $ gems [ ' x ' ] , $ state [ 0 ] - $ l , $ state [ 0 ] ) ; $ keys = second_check ( $ gems [ ' y ' ] , $ keys , $ state [ 1 ] ) ; $ state [ 0 ] -= $ l ; break ; } foreach ( $ keys as $ key ) { unset ( $ gems [ ' x ' ] [ $ key ] ) ; unset ( $ gems [ ' y ' ] [ $ key ] ) ; } } function process ( ) { $ n = fgets ( STDIN ) ; if ( $ n == 0 ) { return ; } $ gems = [ ' x ' => [ ] , ' y ' => [ ] ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %d %d \" , $ x , $ y ) ; $ gems [ ' x ' ] [ $ i ] = ( int ) $ x ; $ gems [ ' y ' ] [ $ i ] = ( int ) $ y ; } asort ( $ gems [ ' x ' ] ) ; asort ( $ gems [ ' y ' ] ) ; $ state = [ 10 , 10 ] ; $ m = fgets ( STDIN ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { fscanf ( STDIN , \" %c %d \" , $ d , $ l ) ; found ( $ gems , $ state , $ d , $ l ) ; } if ( $ gems [ ' x ' ] ) { echo ' No ' . PHP_EOL ; } else { echo ' Yes ' . PHP_EOL ; } process ( ) ; } process ( ) ;",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d \" , $ n , $ m , $ a ) && ( $ n | $ m | $ a ) ) { $ w = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ h , $ p , $ q ) ; $ w [ $ i ] = array ( $ h , $ p - 1 , $ q - 1 ) ; } rsort ( $ w ) ; $ amida = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ amida [ $ i ] = $ i + 1 ; } foreach ( $ w as $ w ) { list ( $ amida [ $ w [ 2 ] ] , $ amida [ $ w [ 1 ] ] ) = array ( $ amida [ $ w [ 1 ] ] , $ amida [ $ w [ 2 ] ] ) ; } $ ans = - 1 ; foreach ( $ amida as $ key => $ value ) { if ( $ value == $ a ) { $ ans = $ key + 1 ; } } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d %d \" , $ n , $ m , $ a ) ; while ( $ n != 0 || $ m != 0 || $ a != 0 ) { $ array = [ ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { fscanf ( STDIN , \" %d %d %d \" , $ key , $ x , $ y ) ; $ array [ $ key ] [ $ x ] = $ y ; $ array [ $ key ] [ $ y ] = $ x ; } $ now = $ a ; for ( $ i = 1000 ; $ i > 0 ; $ i -- ) { if ( isset ( $ array [ $ i ] [ $ now ] ) ) { $ now = $ array [ $ i ] [ $ now ] ; } } printf ( \" %d \\n \" , $ now ) ; fscanf ( STDIN , \" %d %d %d \" , $ n , $ m , $ a ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 && $ m == 0 && $ s == 0 && $ g1 == 0 && $ g2 == 0 ) break ; $ cost = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ min = min ( $ min , $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ) ; } echo $ min ; echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 && $ m == 0 && $ s == 0 && $ g1 == 0 && $ g2 == 0 ) break ; $ cost = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min ; echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { if ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue; $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 && $ m == 0 && $ s == 0 && $ g1 == 0 && $ g2 == 0 ) break ; $ cost = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min ; echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { if ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue; $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 && $ m == 0 && $ s == 0 && $ g1 == 0 && $ g2 == 0 ) break ; $ cost = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ cost [ $ s ] [ $ i ] === INF || $ cost [ $ i ] [ $ g1 ] === INF || $ cost [ $ i ] [ $ g2 ] === INF ) continue ; $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min ; echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { if ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue; $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 ) break ; $ cost = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min ; echo PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { if ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue; $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 ) break ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min . PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { if ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue; $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 ) break ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ e = explode ( ' ' , $ info2 ) ; $ cost [ $ e [ 0 ] ] [ $ e [ 1 ] ] = $ e [ 2 ] ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min . PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ file_handle = fopen ( ' php: function warshall_floyd($cost) { global $n; for ($i = 1; $i <= $n; ++$i) { for ($j = 1; $j <= $n; ++$j) { for ($k = 1; $k <= $n; ++$k) { if ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue; $via = $cost[$j][$i] + $cost[$i][$k]; if ($via < $cost[$j][$k]) { $cost[$j][$k] = $via; } } } } return $cost; } while(1){ $info = trim(fgets($file_handle)); $explode = explode( ' ' , $ info ) ; $ n = $ explode [ 0 ] ; $ m = $ explode [ 1 ] ; $ s = $ explode [ 2 ] ; $ g1 = $ explode [ 3 ] ; $ g2 = $ explode [ 4 ] ; if ( $ n == 0 ) break ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= $ n ; ++ $ j ) { if ( $ i === $ j ) { $ cost [ $ i ] [ $ i ] = 0 ; } else { $ cost [ $ i ] [ $ j ] = INF ; } } } for ( $ i = 1 ; $ i <= $ m ; ++ $ i ) { $ info2 = trim ( fgets ( $ file_handle ) ) ; $ explode = explode ( ' ' , $ info2 ) ; $ a = $ explode [ 0 ] ; $ b = $ explode [ 1 ] ; $ c = $ explode [ 2 ] ; $ cost [ $ a ] [ $ b ] = $ c ; } $ cost = warshall_floyd ( $ cost ) ; $ min = INF ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ via = $ cost [ $ s ] [ $ i ] + $ cost [ $ i ] [ $ g1 ] + $ cost [ $ i ] [ $ g2 ] ; $ min = min ( $ min , $ via ) ; } echo $ min . PHP_EOL ; } fclose ( $ file_handle ) ;",
    "label": 3
  },
  {
    "code": "<?php $ button [ 1 ] = array ( ' . ' , ' , ' , ' ! ' , ' ? ' , ' ' ) ; $ button [ 2 ] = array ( ' a ' , ' b ' , ' c ' ) ; $ button [ 3 ] = array ( ' d ' , ' e ' , ' f ' ) ; $ button [ 4 ] = array ( ' g ' , ' h ' , ' i ' ) ; $ button [ 5 ] = array ( ' j ' , ' k ' , ' l ' ) ; $ button [ 6 ] = array ( ' m ' , ' n ' , ' o ' ) ; $ button [ 7 ] = array ( ' p ' , ' q ' , ' r ' , ' s ' ) ; $ button [ 8 ] = array ( ' t ' , ' u ' , ' v ' ) ; $ button [ 9 ] = array ( ' w ' , ' x ' , ' y ' , ' z ' ) ; fscanf ( STDIN , \" %d \" , $ n ) ; while ( $ n -- ) { fscanf ( STDIN , \" %s \" , $ str ) ; $ ans = \" \" ; $ push = \" \" ; $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ ch == 0 ) { if ( $ cnt ) { $ ans .= $ button [ $ push ] [ ( $ cnt - 1 ) % count ( $ button [ $ push ] ) ] ; $ cnt = 0 ; } } else { $ push = $ ch ; $ cnt ++ ; } } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ coins = array ( 500 , 100 , 50 , 10 ) ; $ flg = false ; while ( fscanf ( STDIN , \" %d \" , $ cost ) && $ cost ) { $ mycoins = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ flg ) print \" \\n \" ; $ flg = true ; $ a = $ b = $ c = $ d = $ min = 10000 ; $ cnt = 0 ; foreach ( $ mycoins as $ value ) { $ cnt += $ value ; } for ( $ i = 0 ; $ i <= $ mycoins [ 0 ] ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ mycoins [ 1 ] ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ mycoins [ 2 ] ; $ k ++ ) { for ( $ l = 0 ; $ l <= $ mycoins [ 3 ] ; $ l ++ ) { $ sum = $ i * 10 + $ j * 50 + $ k * 100 + $ l * 500 ; if ( $ sum < $ cost ) continue ; $ sum -= $ cost ; $ count = $ cnt - $ i - $ j - $ k - $ l ; foreach ( $ coins as $ value ) { $ count += ( int ) ( $ sum / $ value ) ; $ sum %= $ value ; } if ( $ count < $ min ) { $ min = $ count ; $ a = $ i ; $ b = $ j ; $ c = $ k ; $ d = $ l ; } } } } } if ( $ a ) print \" 10 \" . $ a . \" \\n \" ; if ( $ b ) print \" 50 \" . $ b . \" \\n \" ; if ( $ c ) print \" 100 \" . $ c . \" \\n \" ; if ( $ d ) print \" 500 \" . $ d . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ e ) && $ e ) { $ m = 1000000000 ; for ( $ z = 0 ; $ z * $ z * $ z <= $ e ; $ z ++ ) { $ tmp = $ e - $ z * $ z * $ z ; $ y = ( int ) ( sqrt ( $ tmp ) ) ; $ x = $ tmp - $ y * $ y ; $ m = min ( $ m , $ x + $ y + $ z ) ; } print $ m . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d%d \" , $ N , $ M ) && ( $ N | $ M ) ) { $ D = $ P = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , \" %d%d \" , $ d , $ p ) ; $ D [ ] = $ d ; $ P [ ] = $ p ; } $ arr = array ( $ D , $ P ) ; array_multisort ( $ arr [ 1 ] , SORT_DESC , $ arr [ 0 ] ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ v = max ( 0 , $ arr [ 0 ] [ $ i ] - $ M ) ; $ M = max ( 0 , $ M - $ arr [ 0 ] [ $ i ] ) ; $ ans += $ v * $ arr [ 1 ] [ $ i ] ; } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ stdin = fopen ( ' php: while(true) { fscanf($stdin, \"%d\", $num); if($num === 0) { break; } echo isPerfectNumber($num) . PHP_EOL; } function isPerfectNumber($num) { $mean = floor(sqrt($num)); $divPlus = 1; if($num === 1) { return \"deficient number\"; } for($i = 2; $i <= $mean; $i++) { $tmp = $num/$i; if(is_int($tmp)) { if($tmp === $i){ $divPlus = $divPlus + $tmp; } else { $divPlus = $divPlus + $tmp + $i; } if($divPlus > $num) { return \"abundant number\"; } } } if($divPlus === $num) { return \"perfect number\"; } else { return \"deficient number\"; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ stdin = fopen ( ' php: while(true) { fscanf($stdin, \"%d\", $num); if($num === 0) { break; } echo isPerfectNumber($num) . PHP_EOL; } function isPerfectNumber($num) { $mean = floor(sqrt($num)); $divPlus = 1; if($num === 1) { return \"deficient number\"; } for($i = 2; $i <= $mean; $i++) { $tmp = $num/$i; if(is_int($tmp)) { if($tmp === $i){ $divPlus = $divPlus + $tmp; } else { $divPlus = $divPlus + $tmp + $i; } } } if($divPlus === $num) { return \"perfect number\"; } else if($divPlus > $num) { return \"abundant number\"; } else { return \"deficient number\"; } } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d %d %d \" , $ n , $ a , $ b , $ c , $ x ) ) { if ( ( $ n | $ a | $ b | $ c | $ x ) == 0 ) break ; $ y = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ ans = - 1 ; $ idx = 0 ; for ( $ i = 0 ; $ i < 10001 ; $ i ++ ) { if ( $ x == $ y [ $ idx ] && ++ $ idx == $ n ) { $ ans = $ i ; break ; } $ x = ( $ a * $ x + $ b ) % $ c ; } print $ ans . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) && $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum = $ i ; for ( $ j = $ i + 1 ; $ j <= $ n ; $ j ++ ) { $ sum += $ j ; if ( $ sum == $ n ) { $ cnt ++ ; } } } print $ cnt . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ n ) && $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum = $ i ; for ( $ j = $ i + 1 ; $ j <= $ n ; $ j ++ ) { $ sum += $ j ; if ( $ sum == $ n ) { $ cnt ++ ; } else if ( $ sum > $ n ) { break ; } } } print $ cnt . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ list = array_fill ( 0 , 1001 , 0 ) ; for ( $ i = 1 ; $ i <= 1000 ; $ i ++ ) { $ list [ $ i ] = $ list [ $ i - 1 ] + $ i ; } while ( 1 ) { fscanf ( STDIN , \" %d \" , $ l ) ; if ( $ l == 0 ) break ; $ sum = 0 ; for ( $ i = ceil ( $ l / 2 ) ; $ i >= 1 ; $ i -- ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ list [ $ i ] - $ list [ $ j ] == $ l ) { $ sum ++ ; } } } if ( $ l == 1 ) echo \" 0 \\n \" ; else echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "#!/usr/bin/php <?php while($s=fgets(STDIN)){ $n=$s; if($n==0)break; $r=0; for($i=2;;$i++){ $x=$n-$i*($i-1)/2; if($x<$i)break; if(fmod($x,$i)==0)$r++; } echo $r.PHP_EOL; }",
    "label": 3
  },
  {
    "code": "<?php $ left = \" qwertasdfgzxcvb \" ; while ( fscanf ( STDIN , \" %s \" , $ str ) && $ str != ' # ' ) { $ bef = 0 ; $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( strstr ( $ left , $ str [ $ i ] ) ) { if ( $ bef == 2 ) $ cnt ++ ; $ bef = 1 ; } else { if ( $ bef == 1 ) $ cnt ++ ; $ bef = 2 ; } } print $ cnt . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ hash = array ( ) ; $ hash [ \" q \" ] = 0 ; $ hash [ \" w \" ] = 0 ; $ hash [ \" e \" ] = 0 ; $ hash [ \" r \" ] = 0 ; $ hash [ \" t \" ] = 0 ; $ hash [ \" a \" ] = 0 ; $ hash [ \" s \" ] = 0 ; $ hash [ \" d \" ] = 0 ; $ hash [ \" f \" ] = 0 ; $ hash [ \" g \" ] = 0 ; $ hash [ \" z \" ] = 0 ; $ hash [ \" x \" ] = 0 ; $ hash [ \" c \" ] = 0 ; $ hash [ \" v \" ] = 0 ; $ hash [ \" b \" ] = 0 ; $ hash [ \" y \" ] = 1 ; $ hash [ \" u \" ] = 1 ; $ hash [ \" i \" ] = 1 ; $ hash [ \" o \" ] = 1 ; $ hash [ \" p \" ] = 1 ; $ hash [ \" h \" ] = 1 ; $ hash [ \" j \" ] = 1 ; $ hash [ \" k \" ] = 1 ; $ hash [ \" l \" ] = 1 ; $ hash [ \" n \" ] = 1 ; $ hash [ \" m \" ] = 1 ; while ( fscanf ( STDIN , \" %s \\n \" , $ l ) ) { if ( $ l == \" # \" ) break ; $ flag = $ hash [ $ l [ 0 ] ] ; $ sum = 0 ; for ( $ i = 1 ; $ i < strlen ( $ l ) ; $ i ++ ) { if ( $ flag != $ hash [ $ l [ $ i ] ] ) { $ flag = $ hash [ $ l [ $ i ] ] ; $ sum ++ ; } } echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ arr = [ ] ; function solve ( $ S ) { global $ arr ; if ( is_numeric ( $ S ) ) return [ $ S => true ] ; if ( $ S [ 0 ] === ' $ ' && is_numeric ( substr ( $ S , 1 ) ) ) return $ arr [ substr ( $ S , 1 ) ] ; for ( $ i = 0 ; $ i < strlen ( $ S ) ; $ i ++ ) { if ( $ S [ $ i ] === ' ( ' ) { $ count = 1 ; for ( $ j = $ i + 1 ; $ j < strlen ( $ S ) ; $ j ++ ) { if ( $ S [ $ j ] === ' ( ' ) $ count ++ ; if ( $ S [ $ j ] === ' ) ' ) $ count -- ; if ( $ count === 0 ) { $ arr [ ] = solve ( substr ( $ S , $ i + 1 , $ j - $ i - 1 ) ) ; $ S = substr_replace ( $ S , ' $ ' . ( sizeof ( $ arr ) - 1 ) , $ i , $ j - $ i + 1 ) ; break ; } } } } $ f = false ; $ ans = [ ] ; for ( $ i = 0 ; $ i < strlen ( $ S ) ; $ i ++ ) { if ( $ S [ $ i ] === ' + ' || $ S [ $ i ] === ' - ' || $ S [ $ i ] === ' * ' || $ S [ $ i ] === ' / ' ) { $ f = true ; $ right = solve ( substr ( $ S , $ i + 1 , strlen ( $ S ) - $ i ) ) ; $ left = solve ( substr ( $ S , 0 , $ i ) ) ; foreach ( $ left as $ lk => $ lv ) { foreach ( $ right as $ rk => $ rv ) { if ( $ S [ $ i ] === ' + ' ) { $ ans [ $ lk + $ rk ] = true ; } if ( $ S [ $ i ] === ' - ' ) { $ ans [ $ lk - $ rk ] = true ; } if ( $ S [ $ i ] === ' * ' ) { $ ans [ $ lk * $ rk ] = true ; } if ( $ S [ $ i ] === ' / ' && $ rk != 0 ) { $ ans [ ( int ) ( $ lk * 1.0 / $ rk ) ] = true ; } } } } } if ( ! $ f ) return solve ( $ S ) ; return $ ans ; } while ( true ) { $ S = trim ( fgets ( STDIN ) ) ; if ( $ S === \" # \" ) break ; echo count ( solve ( $ S ) ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \\n \" , $ n ) ; echo ceil ( log ( $ n , 3 ) ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d \" , $ N ) && $ N ) { $ P = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ tmp = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; array_shift ( $ tmp ) ; $ P [ ] = $ tmp ; } $ tmp = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; array_shift ( $ tmp ) ; $ L = $ tmp ; $ id = - 1 ; for ( $ i = 0 ; $ i < count ( $ P ) ; $ i ++ ) { $ flg = true ; foreach ( $ L as $ v1 ) { $ found = false ; foreach ( $ P [ $ i ] as $ v2 ) { if ( $ v1 == $ v2 ) { $ found = true ; break ; } } if ( ! $ found ) { $ flg = false ; break ; } } if ( $ flg ) { if ( $ id != - 1 ) { $ id = - 1 ; break ; } $ id = $ i + 1 ; } } print $ id . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d \" , $ T , $ P , $ R ) && ( $ T | $ P | $ R ) ) { $ correct = array ( array ( ) ) ; $ wrong = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ T ; $ i ++ ) { for ( $ j = 0 ; $ j < $ P ; $ j ++ ) { $ correct [ $ i + 1 ] [ $ j + 1 ] = 0 ; $ wrong [ $ i + 1 ] [ $ j + 1 ] = 0 ; } } for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { $ in = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ in [ 3 ] == ' WRONG ' ) { $ wrong [ $ in [ 0 ] ] [ $ in [ 1 ] ] ++ ; } else { if ( $ correct [ $ in [ 0 ] ] [ $ in [ 1 ] ] ) continue ; $ correct [ $ in [ 0 ] ] [ $ in [ 1 ] ] = 1200 * $ wrong [ $ in [ 0 ] ] [ $ in [ 1 ] ] + $ in [ 2 ] ; } } $ id = array ( ) ; $ solved = array ( ) ; $ total = array ( ) ; for ( $ i = 0 ; $ i < $ T ; $ i ++ ) { $ s = $ t = 0 ; for ( $ j = 0 ; $ j < $ P ; $ j ++ ) { $ s += ( $ correct [ $ i + 1 ] [ $ j + 1 ] > 0 ) ? 1 : 0 ; $ t += $ correct [ $ i + 1 ] [ $ j + 1 ] ; } $ id [ ] = $ i + 1 ; $ solved [ ] = $ s ; $ total [ ] = $ t ; } $ state = array ( $ solved , $ total , $ id ) ; array_multisort ( $ state [ 0 ] , SORT_DESC , $ state [ 1 ] , SORT_ASC , $ state [ 2 ] , SORT_ASC ) ; for ( $ i = 0 ; $ i < $ T ; $ i ++ ) { print $ state [ 2 ] [ $ i ] . \" \" . $ state [ 0 ] [ $ i ] . \" \" . $ state [ 1 ] [ $ i ] . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( fscanf ( STDIN , \" %d %d %d \" , $ T , $ P , $ R ) && ( $ T | $ P | $ R ) ) { $ correct = array ( array ( ) ) ; $ wrong = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ T ; $ i ++ ) { for ( $ j = 0 ; $ j < $ P ; $ j ++ ) { $ correct [ $ i + 1 ] [ $ j + 1 ] = 0 ; $ wrong [ $ i + 1 ] [ $ j + 1 ] = 0 ; } } for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { $ in = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ in [ 3 ] == ' WRONG ' ) { $ wrong [ $ in [ 0 ] ] [ $ in [ 1 ] ] ++ ; } else { if ( $ correct [ $ in [ 0 ] ] [ $ in [ 1 ] ] ) continue ; $ correct [ $ in [ 0 ] ] [ $ in [ 1 ] ] = 1200 * $ wrong [ $ in [ 0 ] ] [ $ in [ 1 ] ] + $ in [ 2 ] ; } } $ id = array ( ) ; $ solved = array ( ) ; $ total = array ( ) ; for ( $ i = 0 ; $ i < $ T ; $ i ++ ) { $ s = $ t = 0 ; for ( $ j = 0 ; $ j < $ P ; $ j ++ ) { $ s += ( $ correct [ $ i + 1 ] [ $ j + 1 ] > 0 ) ? 1 : 0 ; $ t += $ correct [ $ i + 1 ] [ $ j + 1 ] ; } $ id [ ] = $ i + 1 ; $ solved [ ] = $ s ; $ total [ ] = $ t ; } $ state = array ( $ solved , $ total , $ id ) ; array_multisort ( $ state [ 0 ] , SORT_DESC , $ state [ 1 ] , SORT_ASC , $ state [ 2 ] , SORT_ASC ) ; for ( $ i = 0 ; $ i < $ T ; $ i ++ ) { print $ state [ 2 ] [ $ i ] . \" \" . $ state [ 0 ] [ $ i ] . \" \" . $ state [ 1 ] [ $ i ] . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php function check ( $ S ) { if ( $ S == ' T ' ) { return ' T ' ; } else if ( $ S == ' F ' ) { return ' F ' ; } for ( $ i = 0 ; $ i < strlen ( $ S ) ; $ i ++ ) { if ( $ S [ $ i ] === ' ( ' ) { $ count = 1 ; for ( $ j = $ i + 1 ; $ j < strlen ( $ S ) ; $ j ++ ) { if ( $ S [ $ j ] === ' ) ' ) { $ count -- ; if ( $ count == 0 ) { $ S = substr ( $ S , 0 , $ i ) . check ( substr ( $ S , $ i + 1 , $ j - $ i - 1 ) ) . substr ( $ S , $ j + 1 ) ; $ i = 0 ; break ; } } else if ( $ S [ $ j ] === ' ( ' ) { $ count ++ ; } } } } $ Sprev = ' 0 ' ; while ( $ Sprev !== $ S ) { $ Sprev = $ S ; $ S = str_replace ( [ ' -T ' , ' -F ' ] , [ ' F ' , ' T ' ] , $ S ) ; } $ Sprev = ' 0 ' ; while ( $ Sprev !== $ S ) { $ Sprev = $ S ; $ S = str_replace ( [ ' T*T ' , ' T*F ' , ' F*T ' , ' F*F ' ] , [ ' T ' , ' F ' , ' F ' , ' F ' ] , $ S ) ; } $ Sprev = ' 0 ' ; while ( $ Sprev !== $ S ) { $ Sprev = $ S ; $ S = str_replace ( [ ' T+T ' , ' T+F ' , ' F+T ' , ' F+F ' ] , [ ' T ' , ' T ' , ' T ' , ' F ' ] , $ S ) ; } $ S = str_replace ( [ ' T->T ' , ' T->F ' , ' F->T ' , ' F->F ' ] , [ ' T ' , ' F ' , ' T ' , ' T ' ] , $ S ) ; $ Sprev = ' 0 ' ; while ( $ Sprev !== $ S ) { $ Sprev = $ S ; } return $ S ; } while ( 1 ) { $ S = trim ( fgets ( STDIN ) ) ; if ( $ S === ' # ' ) { break ; } $ C = [ ] ; for ( $ i = 0 ; $ i < strlen ( $ S ) ; $ i ++ ) { @ $ C [ $ S [ $ i ] ] ++ ; } $ d = [ ] ; foreach ( $ C as $ x => $ y ) { if ( ' a ' <= $ x && $ x <= ' k ' ) { @ $ d [ $ x ] ++ ; } } $ e = [ ] ; $ index = 0 ; foreach ( $ d as $ k => $ v ) { $ e [ $ index ++ ] = $ k ; } $ memo = sizeof ( $ e ) ; $ flag = true ; for ( $ i = 0 ; $ i < ( 1 << $ memo ) ; $ i ++ ) { $ j = $ i ; $ index = 0 ; $ replace = [ ] ; for ( $ k = 0 ; $ k < $ memo ; $ k ++ ) { $ replace [ $ index ++ ] = ( ( $ j % 2 == 1 ) ? ' T ' : ' F ' ) ; $ j >>= 1 ; } $ Scopy = $ S ; $ Sreplace = str_replace ( $ e , $ replace , $ Scopy ) ; list ( $ left , $ right ) = explode ( ' = ' , $ Sreplace ) ; if ( check ( $ left ) !== check ( $ right ) ) { $ flag = false ; break ; } } if ( $ flag ) { echo ' YES ' . PHP_EOL ; } else { echo ' NO ' . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; while ( $ n -- ) { $ data [ trim ( fgets ( STDIN ) ) ] = 1 ; } fscanf ( STDIN , \" %d \" , $ m ) ; $ isOpen = 0 ; while ( $ m -- ) { $ id = trim ( fgets ( STDIN ) ) ; if ( isset ( $ data [ $ id ] ) ) { $ isOpen ^= 1 ; if ( $ isOpen ) { printf ( \" Opened by %s \\n \" , $ id ) ; } else { printf ( \" Closed by %s \\n \" , $ id ) ; } } else { printf ( \" Unknown %s \\n \" , $ id ) ; } }",
    "label": 3
  },
  {
    "code": "<?php while ( ! feof ( STDIN ) ) { $ id [ ] = trim ( fgets ( STDIN ) ) ; } $ input_num = $ id [ 0 ] ; $ search_num = $ input_num + 1 ; $ input_max = $ search_num + $ id [ $ search_num ] ; $ input_id = [ ] ; $ i = 0 ; $ lock = 0 ; while ( $ i <= $ input_num ) { $ input_id [ ] = $ id [ $ i ] ; $ i ++ ; } $ c = $ search_num + 1 ; while ( $ c <= $ input_max ) { if ( in_array ( $ id [ $ c ] , ( array ) $ input_id ) ) { if ( $ lock == 0 ) { $ lock = 1 ; echo \" Opened by \" . $ id [ $ c ] . \" \\n \" ; } else { $ lock = 0 ; echo \" Closed by \" . $ id [ $ c ] . \" \\n \" ; } } else { echo \" Unknown \" . $ id [ $ c ] . \" \\n \" ; } $ c ++ ; }",
    "label": 3
  },
  {
    "code": "40 NYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY YNYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY YYNYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY YYYNYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY YYYYNYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN YYYYYNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN",
    "label": 3
  },
  {
    "code": "<?php while ( 1 ) { fscanf ( STDIN , \" %d \\n \" , $ n ) ; if ( $ n == 0 ) break ; $ line = trim ( fgets ( STDIN ) ) ; $ a = explode ( \" \" , $ line ) ; $ flag = 0 ; $ s = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { if ( $ flag == 0 ) { $ flag = 1 ; } else if ( $ flag == 1 ) { if ( $ a [ $ i ] == \" lu \" || $ a [ $ i ] == \" ru \" ) { $ flag = 2 ; if ( $ s == 0 ) { $ s = 1 ; $ sum ++ ; } } else { $ flag = 0 ; if ( $ s == 1 ) { $ s = 0 ; $ sum ++ ; } } } else if ( $ flag == 2 ) { $ flag = 1 ; } } echo $ sum . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ d = intval ( $ numbers [ 0 ] ) ; $ e = intval ( $ numbers [ 1 ] ) ; while ( $ d != 0 ) { $ min = 9999 ; for ( $ x = 0 ; $ x < $ d ; $ x ++ ) { $ y = $ d - $ x ; $ s = abs ( sqrt ( $ x ** 2 + $ y ** 2 ) - $ e ) ; if ( $ min > $ s ) { $ min = $ s ; } } print $ min ; print \" \\n \" ; $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ d = intval ( $ numbers [ 0 ] ) ; $ e = intval ( $ numbers [ 1 ] ) ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ D , $ E ) ; while ( $ D != 0 || $ E != 0 ) { if ( $ D <= $ E ) { printf ( \" %d \\n \" , $ E - $ D ) ; } else { $ obj = $ E ; $ min = 100000 ; for ( $ i = 0 ; $ i <= $ D / 2 ; $ i ++ ) { $ cal = abs ( $ obj - sqrt ( $ i * $ i + ( $ D - $ i ) * ( $ D - $ i ) ) ) ; if ( $ min > $ cal ) { $ min = $ cal ; } } printf ( \" %f \\n \" , $ min ) ; } fscanf ( STDIN , \" %d %d \" , $ D , $ E ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ number = trim ( fgets ( STDIN ) ) ; $ pos = strpos ( $ number , \" ? \" ) ; $ ans = - 1 ; for ( $ n = 0 ; $ n < 10 ; $ n ++ ) { $ number [ $ pos ] = $ n ; if ( check_mynumber ( $ number ) ) { if ( $ ans > - 1 ) { echo \" MULTIPLE \\n \" ; exit ( 0 ) ; } else { $ ans = $ n ; } } } echo \" $ { ans } \\n \" ; function check_mynumber ( $ number ) { $ sum = 0 ; for ( $ n = 1 ; $ n <= 11 ; $ n ++ ) { $ Q = ( $ n < 7 ) ? $ n + 1 : $ n - 5 ; $ P = $ number [ 11 - $ n ] ; $ sum += ( $ P * $ Q ) ; } $ a = $ sum % 11 ; $ check_sum = ( $ a <= 1 ) ? 0 : 11 - $ a ; return ( $ check_sum == $ number [ 11 ] ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ wareki = $ numbers [ 0 ] ; $ y = intval ( $ numbers [ 1 ] ) ; $ m = intval ( $ numbers [ 2 ] ) ; $ d = intval ( $ numbers [ 3 ] ) ; while ( $ wareki != ' # ' ) { if ( $ y < 31 ) { print ' HEISEI ' . ' ' . $ y . ' ' . $ m . ' ' . $ d . \" \\n \" ; } else if ( $ y == 31 ) { if ( $ m <= 4 ) { print ' HEISEI ' . ' ' . $ y . ' ' . $ m . ' ' . $ d . \" \\n \" ; } else { print ' ? ' . ' ' . ( $ y - 30 ) . ' ' . $ m . ' ' . $ d . \" \\n \" ; } } else { print ' ? ' . ' ' . ( $ y - 30 ) . ' ' . $ m . ' ' . $ d . \" \\n \" ; } $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ wareki = $ numbers [ 0 ] ; if ( $ wareki != ' # ' ) { $ y = intval ( $ numbers [ 1 ] ) ; $ m = intval ( $ numbers [ 2 ] ) ; $ d = intval ( $ numbers [ 3 ] ) ; } }",
    "label": 3
  },
  {
    "code": "<?php list ( $ n , $ m ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ aList = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ length = count ( $ aList ) ; $ ans = 0 ; foreach ( $ aList as $ a ) { if ( $ a > $ length ) { $ ans ++ ; } } echo $ ans . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ n = intval ( $ numbers [ 0 ] ) ; while ( $ n != 0 ) { $ m = intval ( $ numbers [ 1 ] ) ; $ money = [ ] ; $ total = 0 ; $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ money [ ] = intval ( $ numbers [ $ i ] ) ; if ( ( $ m / $ n ) <= $ numbers [ $ i ] ) { $ total += ( $ m / $ n ) ; } else { $ total += $ numbers [ $ i ] ; } } print $ total ; print \" \\n \" ; $ numbers = preg_split ( \" /[\\s,]+/ \" , rtrim ( fgets ( STDIN ) ) ) ; $ n = intval ( $ numbers [ 0 ] ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) * 2 ; $ h = floor ( $ n / 60 ) ; $ m = $ n % 60 ; echo $ h . \" \" . $ m . PHP_EOL ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d %d \" , $ n , $ m , $ c ) ; $ clrs = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { fscanf ( STDIN , \" %d %d \" , $ cn , $ wn ) ; $ balls [ $ wn ] [ ] = $ cn - 1 ; } krsort ( $ balls ) ; $ result = 0 ; $ j = 0 ; foreach ( $ balls AS $ price => $ array ) { foreach ( $ array AS $ color ) { if ( $ clrs [ $ color ] > 0 ) { $ result += ( int ) $ price ; -- $ clrs [ $ color ] ; if ( ++ $ j >= $ m ) { break 2 ; } } } } echo $ result . PHP_EOL ; ?>",
    "label": 3
  },
  {
    "code": "<?php list ( $ a , $ b , $ c ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ count = trim ( fgets ( STDIN ) ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ ha = trim ( fgets ( STDIN ) ) ; switch ( $ ha ) { case $ ha == \" nobiro \" : $ a += $ b ; break ; case $ ha == \" tidime \" : $ a += $ c ; break ; case $ ha == \" karero \" : $ a = 0 ; break ; } if ( $ a < 0 ) { $ a = 0 ; } } if ( $ a >= 0 ) { echo intval ( $ a ) . PHP_EOL ; } else { echo 0 . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "square1001",
    "label": 3
  },
  {
    "code": "square1001",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; if ( $ n < 2 ) { echo \" 1 \\n \" ; die ; } $ prev1 = 1 ; $ prev2 = 1 ; $ result = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ result = $ prev1 + $ prev2 ; $ prev2 = $ prev1 ; $ prev1 = $ result ; } echo $ result , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ stdin = trim ( fgets ( STDIN ) ) ; $ array = array ( 0 => 1 , 1 => 1 , ) ; for ( $ i = 1 ; $ i < 44 ; $ i ++ ) { $ array [ $ i + 1 ] = $ array [ $ i - 1 ] + $ array [ $ i ] ; } print ( \" { $ array [ $ stdin ] } \\n \" ) ;",
    "label": 3
  },
  {
    "code": "<?php $ num = intval ( trim ( fgets ( STDIN ) ) ) ; $ a = 1 ; $ b = 1 ; for ( $ j = 2 ; $ j <= $ num ; $ j += 2 ) { $ a += $ b ; $ b += $ a ; } if ( $ num % 2 == 0 ) { echo $ a ; } else { echo $ b ; } echo \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ fibo = [ ] ; $ fibo [ 0 ] = 1 ; $ fibo [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 50 ; ++ $ i ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; } echo $ fibo [ $ n ] , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php if ( ! empty ( $ argv [ 1 ] ) ) { Util :: enablingDebug ( ) ; } myMain ( ) ; Util :: printBench ( ) ; class Util { private static $ isDebug = false ; private static $ startTime ; public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" , \" , $ arr ) ; } public static function enablingDebug ( ) { self :: $ isDebug = true ; self :: $ startTime = time ( ) ; } public static function isDebug ( ) { return self :: $ isDebug ; } public static function debugLog ( $ text , $ isReturn = true ) { if ( self :: $ isDebug ) { echo $ text ; if ( $ isReturn ) { echo PHP_EOL ; } } } public static function varDump ( $ obj ) { if ( self :: $ isDebug ) { var_dump ( $ obj ) ; } } public static function arrFirst ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return current ( $ arr ) ; } public static function arrLast ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return end ( $ arr ) ; } public static function printBench ( ) { if ( ! self :: $ isDebug ) { return ; } echo sprintf ( \" Fin. Time: %.3f s MemoryPeakUsage: %.3f KB \" . PHP_EOL , time ( ) - self :: $ startTime , memory_get_peak_usage ( ) / 1024 ) ; } } function myMain ( ) { $ n = Util :: input ( ) ; $ fibonacci = new Fibonacci ( ) ; echo $ fibonacci -> getN ( $ n ) . PHP_EOL ; } class Fibonacci { private $ _memo = [ ] ; public function getN ( $ n ) { if ( isset ( $ this -> _memo [ $ n ] ) ) { return $ this -> _memo [ $ n ] ; } if ( $ n <= 1 ) { return 1 ; } $ this -> _memo [ $ n ] = self :: getN ( $ n - 2 ) + self :: getN ( $ n - 1 ) ; return $ this -> _memo [ $ n ] ; } }",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } $ n = ( int ) input ( ) ; $ f [ 0 ] = $ f [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f [ $ i ] = $ f [ $ i - 1 ] + $ f [ $ i - 2 ] ; } echo $ f [ $ n ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ v_arr = [ ] ; $ u_arr = [ ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ u_arr [ $ i ] = array_fill ( 0 , $ n , 0 ) ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ inputs = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ v_arr [ ] = $ inputs [ 0 ] ; for ( $ j = 0 ; $ j < $ inputs [ 1 ] ; ++ $ j ) { $ u_arr [ $ i ] [ $ inputs [ $ j + 2 ] - 1 ] = 1 ; } } foreach ( $ u_arr as $ u ) { echo implode ( ' ' , $ u ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php function input_and_explode ( ) { $ input_line = trim ( fgets ( STDIN ) ) ; return explode ( ' ' , $ input_line ) ; } function array_head ( $ array ) { return isset ( $ array [ 0 ] ) ? $ array [ 0 ] : null ; } function array_tail ( $ array ) { return array_slice ( $ array , 1 ) ; } function make_multi_dim_array ( $ sizes , $ initial_value ) { $ result = [ ] ; $ size = array_head ( $ sizes ) ; $ tail = array_tail ( $ sizes ) ; $ M = count ( $ tail ) === 0 ? $ initial_value : make_multi_dim_array ( $ tail , $ initial_value ) ; foreach ( range ( 1 , $ size ) as $ i ) { $ result [ ] = $ M ; } return $ result ; } function index_to_ordinal ( $ index ) { return $ index + 1 ; } function ordinal_to_index ( $ ordinal ) { return $ ordinal - 1 ; } $ n = input_and_explode ( ) [ 0 ] ; $ M = make_multi_dim_array ( [ $ n , $ n ] , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ targets = array_slice ( input_and_explode ( ) , 2 ) ; foreach ( $ targets as $ target ) { $ M [ $ i ] [ ordinal_to_index ( $ target ) ] = 1 ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ output = implode ( ' ' , $ M [ $ i ] ) ; echo \" $ output \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ vertex_num = intval ( trim ( fgets ( STDIN ) ) ) ; for ( $ i = 1 ; $ i <= $ vertex_num ; $ i ++ ) { $ graph [ $ i ] = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; array_shift ( $ graph [ $ i ] ) ; array_shift ( $ graph [ $ i ] ) ; } global $ seen ; $ seen = array_fill ( 1 , $ vertex_num , 0 ) ; global $ todo ; $ todo = array_fill ( 1 , $ vertex_num , 0 ) ; global $ time_first ; global $ time_last ; global $ count ; $ time_first = array_fill ( 1 , $ vertex_num , 0 ) ; $ time_last = array_fill ( 1 , $ vertex_num , 0 ) ; $ count = 1 ; for ( $ j = 1 ; $ j <= $ vertex_num ; $ j ++ ) { if ( $ seen [ $ j ] == 0 ) { dfs ( $ graph , $ j ) ; } } for ( $ k = 1 ; $ k <= $ vertex_num ; $ k ++ ) { echo $ k ; echo \" \" ; echo $ time_first [ $ k ] ; echo \" \" ; echo $ time_last [ $ k ] ; echo \" \\n \" ; } function dfs ( $ graph , $ vertex ) { global $ seen ; global $ todo ; global $ time_first ; global $ time_last ; global $ count ; $ seen [ $ vertex ] = 1 ; $ time_first [ $ vertex ] = $ count ++ ; foreach ( $ graph [ $ vertex ] as $ vertex_a ) { if ( $ seen [ $ vertex_a ] == 1 ) continue ; $ info = dfs ( $ graph , $ vertex_a ) ; } $ time_last [ $ vertex ] = $ count ++ ; } ?>",
    "label": 3
  },
  {
    "code": "<?php if ( ! empty ( $ argv [ 1 ] ) ) { Util :: enablingDebug ( ) ; } myMain ( ) ; Util :: printBench ( ) ; class Util { private static $ isDebug = false ; private static $ startTime ; public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" , \" , $ arr ) ; } public static function enablingDebug ( ) { self :: $ isDebug = true ; self :: $ startTime = time ( ) ; } public static function isDebug ( ) { return self :: $ isDebug ; } public static function debugLog ( $ text , $ isReturn = true ) { if ( self :: $ isDebug ) { echo $ text ; if ( $ isReturn ) { echo PHP_EOL ; } } } public static function varDump ( $ obj ) { if ( self :: $ isDebug ) { var_dump ( $ obj ) ; } } public static function arrFirst ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return current ( $ arr ) ; } public static function arrLast ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return end ( $ arr ) ; } public static function printBench ( ) { if ( ! self :: $ isDebug ) { return ; } echo sprintf ( \" Fin. Time: %.3f s MemoryPeakUsage: %.3f KB \" . PHP_EOL , time ( ) - self :: $ startTime , memory_get_peak_usage ( ) / 1024 ) ; } public static function getDigit ( $ num ) { return ( int ) ceil ( log10 ( $ num ) ) ; } } function myMain ( ) { $ n = Util :: input ( ) ; $ graph = new Graph ( ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ input = Util :: input ( true ) ; $ graph -> add ( $ input [ 0 ] , $ input [ 1 ] , array_slice ( $ input , 2 ) ) ; } for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ graph -> dfs ( $ i ) ; } $ graph -> printResult ( ) ; } class Graph { private $ _list = [ ] ; private $ _time = 0 ; private $ _visitTimeList = [ ] ; private $ _completeTimeList = [ ] ; public function add ( $ u , $ k , $ vList ) { if ( empty ( $ vList ) ) { $ vList = [ ] ; } $ this -> _list [ $ u ] = $ vList ; } public function dfs ( $ vIndex ) { if ( ! empty ( $ this -> _visitTimeList [ $ vIndex ] ) ) { return ; } $ this -> _time += 1 ; $ this -> _visitTimeList [ $ vIndex ] = $ this -> _time ; foreach ( $ this -> _list [ $ vIndex ] as $ v ) { $ this -> dfs ( $ v ) ; } $ this -> _time += 1 ; $ this -> _completeTimeList [ $ vIndex ] = $ this -> _time ; } public function printResult ( ) { foreach ( $ this -> _list as $ vIndex => $ v ) { echo sprintf ( \" %s %s %s \" . PHP_EOL , $ vIndex , $ this -> _visitTimeList [ $ vIndex ] , $ this -> _completeTimeList [ $ vIndex ] ) ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ num = intval ( trim ( fgets ( STDIN ) ) ) ; $ i = 1 ; while ( $ array = trim ( fgets ( STDIN ) ) ) { $ Graph [ $ i ] = array_map ( ' intval ' , explode ( \" \" , $ array ) ) ; array_shift ( $ Graph [ $ i ] ) ; array_shift ( $ Graph [ $ i ] ) ; $ i ++ ; } $ dist = array_fill ( 1 , $ num , - 1 ) ; $ queue = new SplQueue ( ) ; $ dist [ 1 ] = 0 ; $ queue -> enqueue ( 1 ) ; while ( ! $ queue -> isEmpty ( ) ) { $ v = $ queue -> dequeue ( ) ; foreach ( $ Graph [ $ v ] as $ value ) { if ( $ dist [ $ value ] != - 1 ) continue ; $ dist [ $ value ] = $ dist [ $ v ] + 1 ; $ queue -> push ( $ value ) ; } } for ( $ j = 1 ; $ j <= $ num ; $ j ++ ) { if ( $ dist [ $ j ] == 0 && $ j != 1 ) { echo $ j . \" \" . \" -1 \" . \" \\n \" ; } else { echo $ j . \" \" . $ dist [ $ j ] . \" \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ to = array_fill ( 0 , $ n , [ ] ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ input = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ u = $ input [ 0 ] ; -- $ u ; for ( $ j = 0 ; $ j < $ input [ 1 ] ; ++ $ j ) { $ to [ $ u ] [ ] = $ input [ $ j + 2 ] - 1 ; } } $ ans = array_fill ( 0 , $ n , - 1 ) ; $ q = new SplQueue ( ) ; $ q -> enqueue ( 0 ) ; $ ans [ 0 ] = 0 ; while ( ! $ q -> isEmpty ( ) ) { $ u = $ q -> dequeue ( ) ; for ( $ i = 0 ; $ i < count ( $ to [ $ u ] ) ; ++ $ i ) { $ v = $ to [ $ u ] [ $ i ] ; if ( $ ans [ $ v ] !== - 1 ) continue ; $ ans [ $ v ] = $ ans [ $ u ] + 1 ; $ q -> enqueue ( $ v ) ; } } foreach ( $ ans as $ key => $ val ) { echo ( $ key + 1 ) . ' ' . $ val , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php class Scanner { private $ arr = [ ] ; private $ count = 0 ; private $ pointer = 0 ; public function next ( ) { if ( $ this -> pointer >= $ this -> count ) { $ str = trim ( fgets ( STDIN ) ) ; $ this -> arr = explode ( ' ' , $ str ) ; $ this -> count = count ( $ this -> arr ) ; $ this -> pointer = 0 ; } $ result = $ this -> arr [ $ this -> pointer ] ; $ this -> pointer ++ ; return $ result ; } public function hasNext ( ) { return $ this -> pointer < $ this -> count ; } public function nextInt ( ) { return ( int ) $ this -> next ( ) ; } public function nextDouble ( ) { return ( double ) $ this -> next ( ) ; } } class DijkstraPriorityQueue extends SplPriorityQueue { public function compare ( $ priority1 , $ priority2 ) { if ( $ priority1 === $ priority2 ) { return 0 ; } return $ priority1 < $ priority2 ? 1 : - 1 ; } } $ sc = new Scanner ( ) ; $ n = $ sc -> nextInt ( ) ; $ nodeCostList = array ( ) ; $ edgeList = array ( ) ; $ fixedList = array ( ) ; foreach ( range ( 0 , $ n - 1 ) as $ lineNum ) { $ u = $ sc -> nextInt ( ) ; $ nodeCostList [ $ u ] = INF ; $ k = $ sc -> nextInt ( ) ; foreach ( range ( 0 , $ k - 1 ) as $ setNum ) { $ v = $ sc -> nextInt ( ) ; $ c = $ sc -> nextInt ( ) ; $ edgeList [ $ u ] [ $ v ] = $ c ; } } $ nodeCostList [ 0 ] = 0 ; $ result = array ( ) ; $ result [ 0 ] = 0 ; $ pQueue = new DijkstraPriorityQueue ( ) ; $ pQueue -> insert ( 0 , 0 ) ; while ( ! $ pQueue -> isEmpty ( ) ) { if ( count ( $ result ) >= $ n ) { break ; } $ targetNode = $ pQueue -> extract ( ) ; $ result [ $ targetNode ] = $ nodeCostList [ $ targetNode ] ; foreach ( $ edgeList [ $ targetNode ] as $ adjNode => $ cost ) { if ( isset ( $ result [ $ adjNode ] ) ) { continue ; } if ( $ nodeCostList [ $ targetNode ] + $ cost < $ nodeCostList [ $ adjNode ] ) { $ nodeCostList [ $ adjNode ] = $ nodeCostList [ $ targetNode ] + $ cost ; $ pQueue -> insert ( $ adjNode , $ nodeCostList [ $ adjNode ] ) ; } } } ksort ( $ result ) ; foreach ( $ result as $ node => $ resultCost ) { echo $ node . ' ' . $ resultCost . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ money = ( int ) trim ( fgets ( STDIN ) ) ; $ coin = [ 25 , 10 , 5 , 1 ] ; echo GetRequiredNumber ( $ money , $ coin ) . PHP_EOL ; function GetRequiredNumber ( $ money , $ coin ) { $ count = 0 ; for ( $ i = 0 ; $ i < 4 ; ++ $ i ) { $ quotient = floor ( $ money / $ coin [ $ i ] ) ; $ count += $ quotient ; if ( $ money % $ coin [ $ i ] == 0 ) { return $ count ; } $ money -= $ quotient * $ coin [ $ i ] ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php define ( ' N ' , 1000 ) ; function trace ( array $ A , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) printf ( \" \" ) ; printf ( \" %d \" , $ A [ $ i ] ) ; } printf ( \" \\n \" ) ; } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ key = $ A [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ A [ $ j ] > $ key ) { $ A [ $ j + 1 ] = $ A [ $ j ] ; $ j -- ; } $ A [ $ j + 1 ] = $ key ; trace ( $ A , $ n ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php define ( ' N ' , 1000 ) ; function trace ( array $ A , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) printf ( \" \" ) ; printf ( \" %d \" , $ A [ $ i ] ) ; } printf ( \" \\n \" ) ; } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ key = $ A [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ A [ $ j ] > $ key ) { $ A [ $ j + 1 ] = $ A [ $ j ] ; $ j -- ; } $ A [ $ j + 1 ] = $ key ; trace ( $ A , $ n ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php define ( ' N ' , 1000 ) ; function trace ( array $ A , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) printf ( \" \" ) ; printf ( \" %d \" , $ A [ $ i ] ) ; } printf ( \" \\n \" ) ; } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ key = $ A [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ A [ $ j ] > $ key ) { $ A [ $ j + 1 ] = $ A [ $ j ] ; $ j -- ; } $ A [ $ j + 1 ] = $ key ; trace ( $ A , $ n ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; echo implode ( ' ' , $ arr ) , PHP_EOL ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ v = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > $ v ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j -- ; $ arr [ $ j + 1 ] = $ v ; } echo implode ( ' ' , $ arr ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ length ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; echo implode ( ' ' , $ arr ) , PHP_EOL ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ compared = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ compared < $ arr [ $ j ] ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ compared ; $ j -- ; } echo implode ( ' ' , $ arr ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; echo implode ( ' ' , $ arr ) , PHP_EOL ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ tmp = $ arr [ $ i ] ; if ( $ arr [ $ i - 1 ] > $ tmp ) { $ j = $ i ; do { $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ j -- ; } while ( $ j > 0 && $ arr [ $ j - 1 ] > $ tmp ) ; $ arr [ $ j ] = $ tmp ; } echo implode ( ' ' , $ arr ) , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; insertionSort ( $ a , $ n ) ; function insertionSort ( $ a , $ n ) { echo implode ( \" \" , $ a ) . \" \\n \" ; for ( $ i = 1 ; $ i <= $ n - 1 ; $ i ++ ) { $ v = $ a [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ a [ $ j ] > $ v ) { $ a [ $ j + 1 ] = $ a [ $ j ] ; $ j -- ; $ a [ $ j + 1 ] = $ v ; } echo implode ( \" \" , $ a ) . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ format = ' ' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) { $ format .= ' ' ; } $ format .= ' %d ' ; } $ nums = fscanf ( STDIN , $ format ) ; insertionSort ( $ nums , $ n ) ; function insertionSort ( $ A , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ val = $ A [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ A [ $ j ] > $ val ) { $ A [ $ j + 1 ] = $ A [ $ j ] ; $ j -- ; } $ A [ $ j + 1 ] = $ val ; echo join ( ' ' , $ A ) . \" \\n \" ; } return $ A ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ nums = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ output = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ key = $ nums [ $ i ] ; $ j = $ i - 1 ; while ( 0 <= $ j && $ key < $ nums [ $ j ] ) { $ nums [ $ j + 1 ] = $ nums [ $ j ] ; $ j -- ; } $ nums [ $ j + 1 ] = $ key ; array_push ( $ output , implode ( ' ' , $ nums ) ) ; } print implode ( PHP_EOL , $ output ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ data = trim ( fgets ( STDIN ) ) ; echo \" $ { data } \" . PHP_EOL ; $ a = explode ( \" \" , $ data ) ; for ( $ i = 1 ; $ i <= $ n - 1 ; $ i ++ ) { $ v = $ a [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 and $ a [ $ j ] > $ v ) { $ a [ $ j + 1 ] = $ a [ $ j ] ; $ j -- ; } $ a [ $ j + 1 ] = $ v ; echo implode ( \" \" , $ a ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ fnum = trim ( fgets ( STDIN ) ) ; $ sline = trim ( fgets ( STDIN ) ) ; $ sarray = explode ( ' ' , $ sline ) ; insertion_sort ( $ sarray , $ fnum ) ; function insertion_sort ( $ array , $ num ) { for ( $ i = 0 ; $ i <= $ num - 1 ; $ i ++ ) { $ v = $ array [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ array [ $ j ] > $ v ) { $ array [ $ j + 1 ] = $ array [ $ j ] ; $ j -- ; $ array [ $ j + 1 ] = $ v ; } foreach ( $ array as $ key => $ value ) { echo $ value ; if ( $ key != $ num - 1 ) { echo \" \" ; } else { echo \" \\n \" ; } } } }",
    "label": 3
  },
  {
    "code": "<?php $ fnum = trim ( fgets ( STDIN ) ) ; $ sline = trim ( fgets ( STDIN ) ) ; $ sarray = explode ( ' ' , $ sline ) ; echo implode ( ' ' , $ sarray ) , PHP_EOL ; insertion_sort ( $ sarray , $ fnum ) ; function insertion_sort ( $ array , $ num ) { for ( $ i = 1 ; $ i <= $ num - 1 ; $ i ++ ) { $ v = $ array [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ array [ $ j ] > $ v ) { $ array [ $ j + 1 ] = $ array [ $ j ] ; $ j -- ; $ array [ $ j + 1 ] = $ v ; } echo implode ( ' ' , $ array ) , PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ A = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; echo implode ( \" \" , $ A ) . \" \\n \" ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { $ v = $ A [ $ i ] ; $ j = $ i - 1 ; while ( $ j > - 1 && $ A [ $ j ] > $ v ) { $ A [ $ j + 1 ] = $ A [ $ j ] ; $ j -- ; } $ A [ $ j + 1 ] = $ v ; echo implode ( \" \" , $ A ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ N = trim ( fgets ( STDIN ) ) ; $ A = trim ( fgets ( STDIN ) ) ; $ A = explode ( ' ' , $ A , $ N ) ; $ out = implode ( ' ' , $ A ) . PHP_EOL ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ v = $ A [ $ i ] ; $ j = $ i - 1 ; #A[i]???????????????????????????????????????????????? while($j>=0 && $A[$j]>$v){ $A[$j+1]=$A[$j]; $j--; } $A[$j+1]=$v; $out.=implode(' ',$A).PHP_EOL; } print $out;",
    "label": 3
  },
  {
    "code": "<?php $ N = trim ( fgets ( STDIN ) ) ; $ A = explode ( ' ' , trim ( fgets ( STDIN ) ) , $ N ) ; $ out = implode ( ' ' , $ A ) . PHP_EOL ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ v = $ A [ $ i ] ; $ j = $ i - 1 ; #A[i]???????????????????????????????????????????????? while($j>=0 && $A[$j]>$v){ $A[$j+1]=$A[$j]; $j--; } $A[$j+1]=$v; $out.=implode(' ',$A).PHP_EOL; } print $out;",
    "label": 3
  },
  {
    "code": "<?php $ num = ( int ) trim ( fgets ( STDIN ) ) ; $ arr = array_map ( function ( $ val ) { return ( int ) $ val ; } , explode ( \" \" , fgets ( STDIN ) ) ) ; for ( $ i = 1 ; $ i < $ num ; $ i ++ ) { echo implode ( \" \" , $ arr ) , PHP_EOL ; $ v = $ arr [ $ i ] ; for ( $ j = $ i - 1 ; 0 <= $ j and $ arr [ $ j ] > $ v ; $ j -- ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ v ; } } echo implode ( \" \" , $ arr ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ numberCount = fgets ( STDIN ) ; $ numbers = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; echo implode ( \" \" , $ numbers ) . PHP_EOL ; for ( $ i = 1 ; $ i < $ numberCount ; $ i ++ ) { $ currentNumber = $ numbers [ $ i ] ; $ insertIndex = $ i ; for ( $ y = $ i - 1 ; $ y >= 0 ; $ y -- ) { if ( $ currentNumber < $ numbers [ $ y ] ) { $ numbers [ $ y + 1 ] = $ numbers [ $ y ] ; $ insertIndex = $ y ; } else { break ; } } $ numbers [ $ insertIndex ] = $ currentNumber ; echo implode ( \" \" , $ numbers ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; echo implode ( ' ' , $ a ) . PHP_EOL ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ v = $ a [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ a [ $ j ] > $ v ) { $ a [ $ j + 1 ] = $ a [ $ j ] ; $ j -- ; } $ a [ $ j + 1 ] = $ v ; echo implode ( ' ' , $ a ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php class Util { public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" \" , $ arr ) ; } } class Bench { private $ _startTime ; public function __construct ( ) { $ this -> _startTime = microtime ( true ) ; } public function getTime ( ) { return microtime ( true ) - $ this -> _startTime ; } public function printBench ( ) { echo sprintf ( \" Time[s]: %f MemoryUsage: %s \" . PHP_EOL , $ this -> getTime ( ) , memory_get_peak_usage ( ) ) ; } } $ n = Util :: input ( ) ; $ arr = Util :: input ( true ) ; insertionSort ( $ arr , $ n ) ; function insertionSort ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ v = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > $ v ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j -= 1 ; } $ arr [ $ j + 1 ] = $ v ; echo Util :: arrToStr ( $ arr ) . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php class Util { public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" \" , $ arr ) ; } } class Bench { private $ _startTime ; public function __construct ( ) { $ this -> _startTime = microtime ( true ) ; } public function getTime ( ) { return microtime ( true ) - $ this -> _startTime ; } public function printBench ( ) { echo sprintf ( \" Time[s]: %f MemoryUsage: %s \" . PHP_EOL , $ this -> getTime ( ) , memory_get_peak_usage ( ) ) ; } } $ n = Util :: input ( ) ; $ arr = Util :: input ( true ) ; insertionSort ( $ arr , $ n ) ; function insertionSort ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ v = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > $ v ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j -= 1 ; } $ arr [ $ j + 1 ] = $ v ; echo Util :: arrToStr ( $ arr ) . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php $ num = fgets ( STDIN ) ; $ array = explode ( \" \" , fgets ( STDIN ) ) ; $ a = [ ] ; foreach ( $ array as $ v ) { $ a [ ] = intval ( $ v ) ; } $ n = count ( $ a ) ; print implode ( ' ' , $ a ) . \" \\n \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ tmp = $ a [ $ i ] ; for ( $ j = $ i - 1 ; $ j >= 0 && $ a [ $ j ] > $ tmp ; $ j -- ) { $ a [ $ j + 1 ] = $ a [ $ j ] ; } $ a [ $ j + 1 ] = $ tmp ; print implode ( ' ' , $ a ) . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; $ N = trim ( fgets ( $ input ) ) ; $ line = fgets ( $ input ) ; print $ line ; $ seq = explode ( ' ' , trim ( $ line ) ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ key = $ seq [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ seq [ $ j ] > $ key ) { $ seq [ $ j + 1 ] = $ seq [ $ j ] ; $ j -- ; } $ seq [ $ j + 1 ] = $ key ; print implode ( ' ' , $ seq ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ num ) ; while ( $ tmp = trim ( fgets ( STDIN ) ) ) { $ input = explode ( ' ' , $ tmp ) ; } for ( $ n = 0 ; $ n < $ num ; $ n ++ ) { if ( $ n === $ num - 1 ) { echo $ input [ $ n ] . \" \\n \" ; } else { echo $ input [ $ n ] . ' ' ; } } for ( $ i = 1 ; $ i < $ num ; $ i ++ ) { $ h = $ i - 1 ; $ target = $ input [ $ i ] ; while ( $ h >= 0 && ( int ) $ input [ $ h ] >= ( int ) $ target ) { $ input [ $ h + 1 ] = $ input [ $ h ] ; $ input [ $ h ] = $ target ; $ h -- ; } for ( $ n = 0 ; $ n < $ num ; $ n ++ ) { if ( $ n === $ num - 1 ) { echo $ input [ $ n ] . \" \\n \" ; } else { echo $ input [ $ n ] . ' ' ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ count = intval ( trim ( fgets ( STDIN ) ) ) ; $ target = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ tmp = 0 ; echo implode ( \" \" , $ target ) . \" \\n \" ; for ( $ i = 1 ; $ i < count ( $ target ) ; $ i ++ ) { $ j = $ i - 1 ; $ tmp = $ target [ $ i ] ; while ( $ j >= 0 && $ target [ $ j ] > $ tmp ) { $ target [ $ j + 1 ] = $ target [ $ j ] ; $ j -- ; } $ target [ $ j + 1 ] = $ tmp ; echo implode ( \" \" , $ target ) . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ s = implode ( \" \" , $ a ) ; echo $ s . \" \\n \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ j = $ i - 1 ; $ v = $ a [ $ i ] ; while ( $ j >= 0 && $ v < $ a [ $ j ] ) { $ a [ $ j + 1 ] = $ a [ $ j ] ; $ j -- ; } $ a [ $ j + 1 ] = $ v ; $ s = implode ( \" \" , $ a ) ; echo $ s . \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php while ( ! feof ( STDIN ) ) { $ line [ ] = trim ( fgets ( STDIN ) ) ; } $ lengthSequence = $ line [ 0 ] ; $ numbers = explode ( \" \" , $ line [ 1 ] ) ; print ( $ line [ 1 ] . \" \\n \" ) ; for ( $ i = 1 ; $ i < $ lengthSequence ; $ i ++ ) { $ v = $ numbers [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ numbers [ $ j ] > $ v ) { $ numbers [ $ j + 1 ] = $ numbers [ $ j ] ; $ j -- ; } $ numbers [ $ j + 1 ] = $ v ; print ( trim ( implode ( \" \" , $ numbers ) ) . \" \\n \" ) ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; echo implode ( ' ' , $ a ) . PHP_EOL ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ v = $ a [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ a [ $ j ] > $ v ) { $ a [ $ j + 1 ] = $ a [ $ j ] ; $ j -- ; } $ a [ $ j + 1 ] = $ v ; echo implode ( ' ' , $ a ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ length = fgets ( STDIN ) ; $ numbers = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; echo implode ( \" \" , $ numbers ) . PHP_EOL ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ key = $ numbers [ $ i ] ; for ( $ y = $ i - 1 ; $ y >= 0 and $ numbers [ $ y ] > $ key ; $ y -- ) { $ numbers [ $ y + 1 ] = $ numbers [ $ y ] ; } $ numbers [ $ y + 1 ] = $ key ; echo implode ( \" \" , $ numbers ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } $ N = input ( ) ; $ array = input_array ( ) ; $ array = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , $ array ) ; echo implode ( ' ' , $ array ) . \" \\n \" ; for ( $ i = 1 , $ count = count ( $ array ) ; $ i < $ count ; $ i ++ ) { $ key = $ array [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ array [ $ j ] > $ key ) { $ array [ $ j + 1 ] = $ array [ $ j ] ; $ j -- ; } $ array [ $ j + 1 ] = $ key ; echo implode ( ' ' , $ array ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ sequence ; private $ sequence_len ; public function __construct ( ) { while ( 1 ) { $ line = FGETS ( STDIN ) ; if ( $ line == false ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> sequence_len = $ lines [ 0 ] ; $ this -> sequence = $ lines [ 1 ] ; } public function insertSort ( ) { echo $ this -> sequence . \" \\n \" ; $ seq = explode ( ' ' , $ this -> sequence ) ; for ( $ i = 1 ; $ i < $ this -> sequence_len ; $ i ++ ) { $ v = $ seq [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ seq [ $ j ] > $ v ) { $ seq [ $ j + 1 ] = $ seq [ $ j ] ; $ j -- ; $ seq [ $ j + 1 ] = $ v ; } echo implode ( \" \" , $ seq ) . \" \\n \" ; } } } $ answer = new Answer ; $ answer -> insertSort ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Solver { private $ num_x ; private $ num_y ; public function __construct ( ) { while ( 1 ) { $ line = fgets ( STDIN ) ; if ( $ line == false ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ num_xy = explode ( ' ' , $ lines [ 0 ] ) ; $ this -> num_x = $ num_xy [ 0 ] ; $ this -> num_y = $ num_xy [ 1 ] ; } public function getAnswer ( ) { echo $ this -> calculateGCD ( $ this -> num_x , $ this -> num_y ) , PHP_EOL ; } public function calculateGCD ( $ x , $ y ) { list ( $ x , $ y ) = $ x > $ y ? [ $ x , $ y ] : [ $ y , $ x ] ; if ( $ x == $ y ) { return $ x ; } $ candidate = $ x % $ y ; if ( ( $ this -> num_x % $ candidate ) + ( $ this -> num_y % $ candidate ) > 0 ) { return $ this -> calculateGCD ( $ y , $ candidate ) ; } else { return $ candidate ; } } } $ answer = new Solver ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d %d ' , $ a , $ b ) ; if ( $ a < $ b ) { list ( $ a , $ b ) = array ( $ b , $ a ) ; } while ( $ b > 0 ) { list ( $ a , $ b ) = array ( $ b , $ a % $ b ) ; } echo $ a , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x , $ y ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ g = gcd ( $ x , $ y ) ; echo $ g . \" \\n \" ; function gcd ( $ x , $ y ) { if ( $ x < $ y ) { $ t = $ y ; $ y = $ x ; $ x = $ t ; } while ( $ y ) { $ r = $ x % $ y ; $ x = $ y ; $ y = $ r ; } return $ x ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ x , $ y ) ; $ d = ( $ x >= $ y ) ? gcd ( $ x , $ y ) : gcd ( $ y , $ x ) ; echo \" $ d \\n \" ; function gcd ( $ x , $ y ) { if ( 0 == $ y || 0 == $ x % $ y ) { return $ y ; } return gcd ( $ y , $ x % $ y ) ; }",
    "label": 3
  },
  {
    "code": "<?php function gcb ( $ x , $ y ) { while ( 0 != $ y ) { $ t = $ y ; $ y = $ x % $ y ; $ x = $ t ; } return $ x ; } $ nums = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ x = max ( $ nums ) ; $ y = min ( $ nums ) ; print gcb ( $ x , $ y ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ nums = trim ( fgets ( STDIN ) ) ; $ array = explode ( ' ' , $ nums ) ; if ( $ array [ 0 ] != $ array [ 1 ] ) { $ small_num = $ array [ 0 ] > $ array [ 1 ] ? $ array [ 1 ] : $ array [ 0 ] ; $ big_per_small = ( $ array [ 0 ] > $ array [ 1 ] ? $ array [ 0 ] : $ array [ 1 ] ) % $ small_num ; $ small_num_cp = $ big_per_small ; while ( true ) { if ( ( ( $ big_per_small % $ small_num_cp ) == 0 ) && ( ( $ small_num % $ small_num_cp ) == 0 ) ) { echo $ small_num_cp , PHP_EOL ; break ; } else $ small_num_cp -- ; } } else echo $ array [ 0 ] , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ natural = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; sort ( $ natural , SORT_NUMERIC ) ; $ x = $ natural [ 1 ] ; $ y = $ natural [ 0 ] ; $ r = 1 ; while ( $ y > 0 ) { list ( $ x , $ y ) = array ( $ y , $ x % $ y ) ; } echo $ x ; ?>",
    "label": 3
  },
  {
    "code": "<?php list ( $ A , $ B ) = explode ( ' ' , trim ( fgets ( STDIN ) ) , 2 ) ; if ( $ A < $ B ) list ( $ A , $ B ) = [ $ B , $ A ] ; while ( $ B ) list ( $ A , $ B ) = [ $ B , $ A % $ B ] ; print $ A ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ x , $ y ) ; if ( $ x < $ y ) { list ( $ x , $ y ) = array ( $ y , $ x ) ; } while ( $ y > 0 ) { $ r = $ x % $ y ; $ x = $ y ; $ y = $ r ; } echo $ x . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ line = fgets ( STDIN ) ; $ lines = explode ( \" \" , $ line ) ; $ lines [ 0 ] = trim ( $ lines [ 0 ] ) ; $ lines [ 1 ] = trim ( $ lines [ 1 ] ) ; while ( True ) { if ( $ lines [ 0 ] < $ lines [ 1 ] ) { $ tmp = $ lines [ 0 ] ; $ lines [ 0 ] = $ lines [ 1 ] ; $ lines [ 1 ] = $ tmp ; } if ( $ lines [ 0 ] % $ lines [ 1 ] == 0 ) { echo $ lines [ 1 ] ; break ; } else { $ lines [ 0 ] = $ lines [ 0 ] % $ lines [ 1 ] ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d %d ' , $ x , $ y ) ; if ( $ x < $ y ) { $ z = $ x ; $ x = $ y ; $ y = $ z ; } while ( $ y > 0 ) { $ r = $ x % $ y ; $ x = $ y ; $ y = $ r ; } echo $ x . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php function gcb ( $ max , $ min ) { while ( 0 != $ min ) { $ n = $ min ; $ min = $ max % $ min ; $ max = $ n ; } return $ max ; } $ nums = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ max = intval ( max ( $ nums ) ) ; $ min = intval ( min ( $ nums ) ) ; echo gcb ( $ max , $ min ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ x , $ y ) { $ r = $ x % $ y ; if ( $ r == 0 ) { return $ y ; } else { return gcd ( $ y , $ r ) ; } } $ input = STDIN ; list ( $ a , $ b ) = explode ( ' ' , trim ( fgets ( $ input ) ) ) ; print gcd ( $ a , $ b ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php function gcd ( $ a , $ b ) { if ( $ b == 0 ) { return $ a ; } return gcd ( $ b , $ a % $ b ) ; } fscanf ( STDIN , \" %d %d \" , $ a , $ b ) ; if ( $ a < $ b ) { list ( $ a , $ b ) = array ( $ b , $ a ) ; } echo gcd ( $ a , $ b ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ num1 , $ num2 ) ; $ div = 0 ; $ max_num = max ( $ num1 , $ num2 ) ; $ min_num = min ( $ num1 , $ num2 ) ; while ( $ min_num != 0 ) { $ tmp = $ min_num ; $ min_num = $ max_num % $ min_num ; $ max_num = $ tmp ; } echo $ max_num . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ stdin = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( $ stdin [ 0 ] > $ stdin [ 1 ] ) { $ x = $ stdin [ 0 ] ; $ y = $ stdin [ 1 ] ; } else { $ x = $ stdin [ 1 ] ; $ y = $ stdin [ 0 ] ; } $ result = 0 ; while ( $ x % $ y != 0 ) { $ rest = $ x % $ y ; $ x = $ y ; $ y = $ rest ; } $ result = $ y ; print ( $ result . \" \\n \" ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ number = fgets ( STDIN ) ; $ numbers = explode ( \" \" , $ number ) ; $ num1 = trim ( $ numbers [ 0 ] ) ; $ num2 = trim ( $ numbers [ 1 ] ) ; $ min_num = min ( $ num1 , $ num2 ) ; if ( $ num1 < $ num2 ) { $ hoge = $ num1 ; $ num1 = $ num2 ; $ num2 = $ hoge ; } while ( $ num2 > 0 ) : $ r = $ num1 % $ num2 ; $ num1 = $ num2 ; $ num2 = $ r ; endwhile ; echo $ num1 . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ input_number ; public function __construct ( ) { while ( 1 ) { $ line = FGETS ( STDIN ) ; if ( $ line == false ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> input_number = explode ( ' ' , $ lines [ 0 ] ) ; } public function getGreatestCommonDivisor ( ) { $ x = $ this -> input_number [ 0 ] ; $ y = $ this -> input_number [ 1 ] ; if ( $ x < $ y ) { $ tmp = $ y ; $ y = $ x ; $ x = $ tmp ; } while ( $ x % $ y != 0 ) { $ tmp = $ y ; $ y = $ x % $ y ; $ x = $ tmp ; } echo $ y , PHP_EOL ; } } $ answer = new Answer ; $ answer -> getGreatestCommonDivisor ( ) ;",
    "label": 3
  },
  {
    "code": "<?php function input_array ( ) { return explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; } function gcd ( $ x , $ y ) { if ( $ x < $ y ) { list ( $ x , $ y ) = [ $ y , $ x ] ; } while ( $ y !== 0 ) { list ( $ x , $ y ) = [ $ y , $ x % $ y ] ; } return $ x ; } list ( $ x , $ y ) = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; echo gcd ( $ x , $ y ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ times = 0 ; $ flag = 1 ; while ( $ flag ) { $ flag = 0 ; for ( $ j = $ n - 1 ; $ j >= 1 ; $ j -- ) { if ( $ arr [ $ j ] < $ arr [ $ j - 1 ] ) { $ tmp = $ arr [ $ j ] ; $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; $ times ++ ; $ flag = 1 ; } } } echo implode ( ' ' , $ arr ) , PHP_EOL , $ times ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; for ( $ i = 0 , $ len = count ( $ arr ) , $ cnt = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ len - 1 ; $ j > $ i ; $ j -- ) { $ tmp = $ arr [ $ j ] ; if ( $ arr [ $ j - 1 ] > $ tmp ) { $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; $ cnt ++ ; } } } echo implode ( ' ' , $ arr ) , PHP_EOL , $ cnt , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ format = join ( ' ' , array_fill ( 0 , $ n , ' %d ' ) ) ; $ nums = array_map ( ' intval ' , fscanf ( STDIN , $ format ) ) ; $ count = bubble_sort ( $ nums ) ; echo join ( ' ' , $ nums ) . \" \\n \" ; echo \" $ count \\n \" ; function bubble_sort ( & $ nums ) { $ count = 0 ; $ need_to_sort = true ; while ( $ need_to_sort ) { $ need_to_sort = false ; for ( $ i = count ( $ nums ) - 1 ; $ i > 0 ; $ i -- ) { if ( $ nums [ $ i - 1 ] <= $ nums [ $ i ] ) { continue ; } $ tmp = $ nums [ $ i ] ; $ nums [ $ i ] = $ nums [ $ i - 1 ] ; $ nums [ $ i - 1 ] = $ tmp ; $ need_to_sort = true ; $ count ++ ; } } return $ count ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ format = join ( ' ' , array_fill ( 0 , $ n , ' %d ' ) ) ; $ nums = array_map ( ' intval ' , fscanf ( STDIN , $ format ) ) ; $ count = bubble_sort ( $ nums ) ; echo join ( ' ' , $ nums ) . \" \\n \" ; echo \" $ count \\n \" ; function bubble_sort ( & $ nums ) { $ count = 0 ; $ n = true ; while ( $ n ) { $ n = false ; for ( $ i = count ( $ nums ) - 1 ; $ i > 0 ; $ i -- ) { if ( $ nums [ $ i - 1 ] <= $ nums [ $ i ] ) { continue ; } $ temp = $ nums [ $ i ] ; $ nums [ $ i ] = $ nums [ $ i - 1 ] ; $ nums [ $ i - 1 ] = $ temp ; $ n = true ; $ count ++ ; } } return $ count ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ A = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ cnt = 0 ; $ f = $ n - 1 ; for ( $ i = 0 ; $ i < $ f ; ++ $ i ) { for ( $ j = $ f ; $ j > $ i ; -- $ j ) { if ( $ A [ $ j - 1 ] > $ A [ $ j ] ) { $ v = $ A [ $ j - 1 ] ; $ A [ $ j - 1 ] = $ A [ $ j ] ; $ A [ $ j ] = $ v ; $ cnt ++ ; } } } echo implode ( \" \" , $ A ) . \" \\n \" ; echo $ cnt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) trim ( fgets ( STDIN ) ) ; $ A = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ trade = 0 ; $ flag = 1 ; while ( $ flag ) { $ flag = 0 ; for ( $ j = $ N - 1 ; 0 < $ j ; $ j -- ) { if ( $ A [ $ j ] < $ A [ $ j - 1 ] ) { list ( $ A [ $ j ] , $ A [ $ j - 1 ] ) = [ $ A [ $ j - 1 ] , $ A [ $ j ] ] ; $ flag = 1 ; ++ $ trade ; } } } echo implode ( ' ' , $ A ) , PHP_EOL , $ trade ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ flag = 1 ; $ count = 0 ; while ( $ flag ) { $ flag = 0 ; for ( $ i = count ( $ a ) - 1 ; $ i > 0 ; $ i -- ) { if ( $ a [ $ i ] < $ a [ $ i - 1 ] ) { $ t = $ a [ $ i ] ; $ a [ $ i ] = $ a [ $ i - 1 ] ; $ a [ $ i - 1 ] = $ t ; $ flag = 1 ; $ count ++ ; } } } echo implode ( ' ' , $ a ) . PHP_EOL ; echo $ count . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ num = intval ( fgets ( STDIN ) ) ; $ array = explode ( \" \" , fgets ( STDIN ) ) ; $ num_array = [ ] ; foreach ( $ array as $ v ) { $ num_array [ ] = intval ( $ v ) ; } $ count = 0 ; for ( $ i = 0 ; $ i < $ num ; $ i ++ ) { for ( $ n = 1 ; $ n < $ num ; $ n ++ ) { if ( $ num_array [ $ n - 1 ] > $ num_array [ $ n ] ) { $ t = $ num_array [ $ n ] ; $ num_array [ $ n ] = $ num_array [ $ n - 1 ] ; $ num_array [ $ n - 1 ] = $ t ; $ count ++ ; } } } print implode ( ' ' , $ num_array ) . \" \\n \" ; print $ count . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; $ n = trim ( fgets ( $ input ) ) ; $ seq = explode ( ' ' , trim ( fgets ( $ input ) ) ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) { if ( $ seq [ $ j ] < $ seq [ $ j - 1 ] ) { list ( $ seq [ $ j - 1 ] , $ seq [ $ j ] ) = array ( $ seq [ $ j ] , $ seq [ $ j - 1 ] ) ; $ cnt ++ ; } } } print implode ( ' ' , $ seq ) . \" \\n \" ; print $ cnt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php class BubbleSort { public function rearrangeNumbers ( ) { $ numbers = $ this -> getInput ( ) ; $ count = 0 ; for ( $ i = 0 ; $ i < count ( $ numbers ) - 1 ; $ i ++ ) { for ( $ j = count ( $ numbers ) - 1 ; $ j > $ i ; $ j -- ) { if ( $ numbers [ $ j ] < $ numbers [ $ j - 1 ] ) { list ( $ numbers [ $ j ] , $ numbers [ $ j - 1 ] ) = [ $ numbers [ $ j - 1 ] , $ numbers [ $ j ] ] ; $ count ++ ; } } } echo implode ( \" \" , $ numbers ) . PHP_EOL ; echo $ count . PHP_EOL ; } public function getInput ( ) { $ input_number = trim ( fgets ( STDIN ) ) ; while ( True ) { $ input_numbers = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; if ( count ( $ input_numbers ) == $ input_number ) { break ; } } return $ input_numbers ; } } $ bubble_sort = new BubbleSort ( ) ; $ bubble_sort -> rearrangeNumbers ( ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ num ) ; $ tmp = trim ( fgets ( STDIN ) ) ; $ input = explode ( ' ' , $ tmp ) ; $ sum = 0 ; $ flag = true ; $ h = 0 ; while ( $ flag ) { $ flag = false ; for ( $ i = $ num - 1 ; $ i > $ h ; $ i -- ) { $ target = $ input [ $ i ] ; if ( $ input [ $ i - 1 ] > $ target ) { $ input [ $ i ] = $ input [ $ i - 1 ] ; $ input [ $ i - 1 ] = $ target ; $ flag = true ; $ sum ++ ; } } $ h ++ ; } for ( $ i = 0 ; $ i < $ num ; $ i ++ ) { if ( $ i === $ num - 1 ) { echo \" $ input [ $ i ] \\n \" ; } else { echo $ input [ $ i ] . ' ' ; } } echo \" $ sum \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ cnt = 0 ; for ( $ i = 0 , $ len = count ( $ arr ) ; $ i < $ len ; $ i ++ ) { for ( $ j = $ len - 1 ; $ j > $ i ; $ j -- ) { $ tmp = $ arr [ $ j ] ; if ( $ arr [ $ j - 1 ] > $ tmp ) { $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; $ cnt ++ ; } } } echo implode ( \" \" , $ arr ) . \" \\n \" ; echo $ cnt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) { if ( $ a [ $ j ] < $ a [ $ j - 1 ] ) { $ w = $ a [ $ j - 1 ] ; $ a [ $ j - 1 ] = $ a [ $ j ] ; $ a [ $ j ] = $ w ; $ c ++ ; } } } $ s = implode ( \" \" , $ a ) ; echo $ s . \" \\n \" ; echo $ c . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ Arraylength = trim ( fgets ( STDIN ) ) ; $ stdins = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; bubbleSort ( $ stdins , $ Arraylength ) ; function bubbleSort ( $ Array , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { for ( $ j = $ N - 1 ; $ j > $ i ; -- $ j ) { if ( $ Array [ $ j ] < $ Array [ $ j - 1 ] ) { $ tmp = $ Array [ $ j ] ; $ Array [ $ j ] = $ Array [ $ j - 1 ] ; $ Array [ $ j - 1 ] = $ tmp ; $ count ++ ; } } } echo implode ( \" \" , $ Array ) . PHP_EOL ; echo $ count . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = trim ( fgets ( STDIN ) ) ; $ a = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ swapped = 0 ; $ flag = true ; for ( $ i = 0 ; $ flag ; $ i ++ ) { $ flag = false ; for ( $ j = $ n - 1 ; $ j >= $ i + 1 ; $ j -- ) { if ( $ a [ $ j ] < $ a [ $ j - 1 ] ) { $ tmp = $ a [ $ j ] ; $ a [ $ j ] = $ a [ $ j - 1 ] ; $ a [ $ j - 1 ] = $ tmp ; $ flag = true ; $ swapped ++ ; } } } echo implode ( ' ' , $ a ) . PHP_EOL ; echo $ swapped . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ sequence_len ; private $ sequence ; public function __construct ( ) { while ( 1 ) { $ line = FGETS ( STDIN ) ; if ( $ line == false ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> sequence_len = $ lines [ 0 ] ; $ this -> sequence = explode ( ' ' , $ lines [ 1 ] ) ; } public function bubbleSort ( ) { $ seq_len = $ this -> sequence_len ; $ seq = $ this -> sequence ; $ count = 0 ; for ( $ i = 0 ; $ i < $ seq_len ; $ i ++ ) { for ( $ j = 1 ; $ j < $ seq_len ; $ j ++ ) { if ( $ seq [ $ j - 1 ] > $ seq [ $ j ] ) { list ( $ seq [ $ j ] , $ seq [ $ j - 1 ] ) = array ( $ seq [ $ j - 1 ] , $ seq [ $ j ] ) ; $ count ++ ; } } } echo implode ( \" \" , $ seq ) , PHP_EOL ; echo $ count , PHP_EOL ; } } $ answer = new Answer ; $ answer -> bubbleSort ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ N ; private $ numbers ; private $ flag ; public function __construct ( ) { $ this -> N = trim ( fgets ( STDIN ) ) ; $ number = trim ( fgets ( STDIN ) ) ; $ this -> numbers = explode ( \" \" , $ number ) ; $ this -> flag = 1 ; } public function doBubbleSort ( ) { $ N = $ this -> N ; $ numbers = $ this -> numbers ; $ flag = $ this -> flag ; $ i = 0 ; $ count = 0 ; while ( $ flag ) { $ flag = 0 ; for ( $ j = $ N - 1 ; $ j > $ i ; $ j -- ) { if ( $ numbers [ $ j - 1 ] > $ numbers [ $ j ] ) { list ( $ numbers [ $ j - 1 ] , $ numbers [ $ j ] ) = [ $ numbers [ $ j ] , $ numbers [ $ j - 1 ] ] ; $ flag = 1 ; $ count ++ ; } } $ i ++ ; } echo implode ( ' ' , $ numbers ) . PHP_EOL ; echo $ count . PHP_EOL ; } } $ answer = new Answer ( ) ; $ answer -> doBubbleSort ( ) ;",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } input ( ) ; $ A = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; list ( $ A , $ swap_count ) = bubble_sort ( $ A ) ; echo implode ( ' ' , $ A ) . \" \\n \" ; echo $ swap_count . \" \\n \" ; function bubble_sort ( $ A ) { $ swap_count = 0 ; for ( $ i = 0 , $ count = count ( $ A ) ; $ i <= $ count - 1 ; $ i ++ ) { for ( $ j = $ count - 1 ; $ j >= $ i + 1 ; $ j -- ) { if ( $ A [ $ j ] < $ A [ $ j - 1 ] ) { swap ( $ A [ $ j ] , $ A [ $ j - 1 ] ) ; $ swap_count ++ ; } } } return [ $ A , $ swap_count ] ; } function swap ( & $ a , & $ b ) { $ tmp = $ a ; $ a = $ b ; $ b = $ tmp ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ count ) ; $ numbers = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ isContinue = true ; $ changeCount = 0 ; $ y = 0 ; while ( $ isContinue ) { $ isContinue = false ; for ( $ i = $ count - 1 ; $ i > $ y ; $ i -- ) { if ( $ numbers [ $ i ] < $ numbers [ $ i - 1 ] ) { $ tmp = $ numbers [ $ i ] ; $ numbers [ $ i ] = $ numbers [ $ i - 1 ] ; $ numbers [ $ i - 1 ] = $ tmp ; $ isContinue = true ; $ changeCount ++ ; } } $ y ++ ; } echo implode ( \" \" , $ numbers ) . PHP_EOL ; echo $ changeCount . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php define ( ' N ' , 1000 ) ; function trace ( array $ A , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) printf ( \" \" ) ; printf ( \" %d \" , $ A [ $ i ] ) ; } printf ( \" \\n \" ) ; } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ count = 0 ; $ flag = 1 ; while ( $ flag ) { $ flag = 0 ; for ( $ j = $ n - 1 ; $ j > 0 ; $ j -- ) { if ( $ A [ $ j ] < $ A [ $ j - 1 ] ) { $ tmp = $ A [ $ j ] ; $ A [ $ j ] = $ A [ $ j - 1 ] ; $ A [ $ j - 1 ] = $ tmp ; $ flag = 1 ; $ count ++ ; } } } trace ( $ A , $ n ) ; printf ( \" %d \" , $ count ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ length ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ times = 0 ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ min = $ i ; for ( $ j = $ i ; $ j < $ length ; $ j ++ ) { if ( $ arr [ $ j ] < $ arr [ $ min ] ) { $ min = $ j ; } } if ( $ min == $ i ) { continue ; } $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ min ] ; $ arr [ $ min ] = $ temp ; $ times ++ ; } echo implode ( ' ' , $ arr ) , PHP_EOL , $ times , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; for ( $ i = 0 , $ len = count ( $ arr ) , $ cnt = 0 ; $ i < $ len ; $ i ++ ) { $ key = $ i ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { if ( $ arr [ $ j ] < $ arr [ $ key ] ) { $ key = $ j ; } } if ( $ key !== $ i ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ key ] ; $ arr [ $ key ] = $ tmp ; $ cnt ++ ; } } echo implode ( ' ' , $ arr ) , PHP_EOL , $ cnt , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ format = join ( ' ' , array_fill ( 0 , $ n , ' %d ' ) ) ; $ nums = array_map ( ' intval ' , fscanf ( STDIN , $ format ) ) ; $ count = selectionSort ( $ nums ) ; vprintf ( $ format . \" \\n \" , $ nums ) ; echo \" $ count \\n \" ; function selectionSort ( & $ nums ) { $ count = 0 ; $ N = count ( $ nums ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) { if ( $ nums [ $ j ] < $ nums [ $ minj ] ) { $ minj = $ j ; } } if ( $ i != $ minj ) { $ tmp = $ nums [ $ i ] ; $ nums [ $ i ] = $ nums [ $ minj ] ; $ nums [ $ minj ] = $ tmp ; $ count += 1 ; } } return $ count ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ A = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ minj = $ i ; for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { if ( $ A [ $ j ] < $ A [ $ minj ] ) { $ minj = $ j ; } } if ( $ i == $ minj ) continue ; $ v = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ minj ] ; $ A [ $ minj ] = $ v ; $ cnt ++ ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ i ) echo \" \" ; echo $ A [ $ i ] ; } echo \" \\n \" ; echo $ cnt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) trim ( fgets ( STDIN ) ) ; $ A = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ trade = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) if ( $ A [ $ j ] < $ A [ $ mini ] ) $ mini = $ j ; if ( $ mini == $ i ) continue ; list ( $ A [ $ i ] , $ A [ $ mini ] ) = [ $ A [ $ mini ] , $ A [ $ i ] ] ; ++ $ trade ; } echo implode ( ' ' , $ A ) , PHP_EOL , $ trade ; ?>",
    "label": 3
  },
  {
    "code": "<?php function swap ( & $ array , $ i , $ j ) { $ tmp = $ array [ $ i ] ; $ array [ $ i ] = $ array [ $ j ] ; $ array [ $ j ] = $ tmp ; } function selectionSort ( & $ array ) { $ count = 0 ; for ( $ i = 0 ; $ i < count ( $ array ) - 1 ; ++ $ i ) { $ min = $ array [ $ i ] ; $ index = $ i ; for ( $ j = $ i + 1 ; $ j < count ( $ array ) ; ++ $ j ) { if ( $ min > $ array [ $ j ] ) { $ min = $ array [ $ j ] ; $ index = $ j ; } } if ( $ i != $ index ) { swap ( $ array , $ i , $ index ) ; ++ $ count ; } } return $ count ; } function insertionSort ( & $ array ) { for ( $ i = 1 ; $ i < count ( $ array ) ; ++ $ i ) { $ x = $ array [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ array [ $ j ] > $ x ) { $ array [ $ j + 1 ] = $ array [ $ j ] ; -- $ j ; } $ array [ $ j + 1 ] = $ x ; } } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ line = trim ( fgets ( STDIN ) ) ; $ numbers = explode ( \" \" , $ line ) ; $ count = selectionSort ( $ numbers ) ; for ( $ i = 0 ; $ i < count ( $ numbers ) ; ++ $ i ) { echo $ numbers [ $ i ] ; if ( $ i != ( count ( $ numbers ) - 1 ) ) echo \" \" ; } echo PHP_EOL ; echo $ count . PHP_EOL ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ num = intval ( fgets ( STDIN ) ) ; $ array = [ ] ; $ int = explode ( ' ' , fgets ( STDIN ) ) ; foreach ( $ int as $ v ) { $ array [ ] = intval ( $ v ) ; } $ count = count ( $ array ) ; $ change_count = 0 ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ min = $ i ; for ( $ j = $ i + 1 ; $ j < $ count ; $ j ++ ) { if ( $ array [ $ j ] < $ array [ $ min ] ) { $ min = $ j ; } } $ tmp = $ array [ $ i ] ; $ array [ $ i ] = $ array [ $ min ] ; $ array [ $ min ] = $ tmp ; if ( $ i != $ min ) { $ change_count ++ ; } } echo implode ( \" \" , $ array ) . \" \\n \" ; echo $ change_count . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; $ N = trim ( fgets ( $ input ) ) ; $ seq = explode ( ' ' , trim ( fgets ( $ input ) ) ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) { if ( $ seq [ $ j ] < $ seq [ $ mini ] ) { $ mini = $ j ; } } list ( $ seq [ $ i ] , $ seq [ $ mini ] ) = array ( $ seq [ $ mini ] , $ seq [ $ i ] ) ; if ( $ i != $ mini ) { $ cnt ++ ; } } print implode ( ' ' , $ seq ) . \" \\n \" ; print $ cnt . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ tmp = trim ( fgets ( STDIN ) ) ; $ input = explode ( ' ' , $ tmp ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ tmp_i = $ i ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( ( int ) $ input [ $ j ] < ( int ) $ input [ $ tmp_i ] ) { $ tmp_i = $ j ; } } if ( $ tmp_i !== $ i ) { $ tmp_num = $ input [ $ tmp_i ] ; $ input [ $ tmp_i ] = $ input [ $ i ] ; $ input [ $ i ] = $ tmp_num ; $ sum ++ ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i === $ n - 1 ) { echo \" $ input [ $ i ] \\n \" ; } else { echo $ input [ $ i ] . ' ' ; } } echo \" $ sum \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ count ) ; $ num_arr = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ min = 0 ; $ countup = 0 ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ count - 1 ; $ i ++ ) { $ min = $ i ; for ( $ j = $ i + 1 ; $ j < $ count ; $ j ++ ) { if ( $ num_arr [ $ j ] < $ num_arr [ $ min ] ) { $ min = $ j ; $ flag = 1 ; } } if ( $ flag ) { $ tmp = $ num_arr [ $ i ] ; $ num_arr [ $ i ] = $ num_arr [ $ min ] ; $ num_arr [ $ min ] = $ tmp ; $ countup ++ ; $ flag = 0 ; } } echo implode ( \" \" , $ num_arr ) . \" \\n \" ; echo $ countup . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ a = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ minj = $ i ; $ j = $ i + 1 ; while ( $ j < $ n ) { if ( $ a [ $ minj ] > $ a [ $ j ] ) { $ minj = $ j ; } $ j ++ ; } if ( $ minj != $ i ) { $ t = $ a [ $ i ] ; $ a [ $ i ] = $ a [ $ minj ] ; $ a [ $ minj ] = $ t ; $ c ++ ; } } $ s = implode ( \" \" , $ a ) ; echo $ s . \" \\n \" ; echo $ c . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ Arraylength = trim ( fgets ( STDIN ) ) ; $ stdins = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; selectionSort ( $ stdins , $ Arraylength ) ; function selectionSort ( $ Array , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; ++ $ j ) { if ( $ Array [ $ j ] < $ Array [ $ mini ] ) { $ mini = $ j ; } } if ( $ mini != $ i ) { $ tmp = $ Array [ $ i ] ; $ Array [ $ i ] = $ Array [ $ mini ] ; $ Array [ $ mini ] = $ tmp ; $ count ++ ; } } echo implode ( \" \" , $ Array ) . PHP_EOL ; echo $ count . PHP_EOL ; } ?>",
    "label": 3
  },
  {
    "code": "<?php class Solver { private $ number_of_elements ; private $ values = array ( ) ; public function __construct ( ) { $ lines = array ( ) ; while ( 1 ) { if ( ! $ line = fgets ( STDIN ) ) break ; $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> number_of_elements = $ lines [ 0 ] ; $ this -> values = explode ( ' ' , $ lines [ 1 ] ) ; } public function getAnswer ( ) { $ change_frec = 0 ; for ( $ i = 0 ; $ i < $ this -> number_of_elements ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ this -> number_of_elements ; $ j ++ ) { if ( $ this -> values [ $ j ] < $ this -> values [ $ minj ] ) { $ minj = $ j ; } } if ( $ minj != $ i ) { list ( $ this -> values [ $ i ] , $ this -> values [ $ minj ] ) = [ $ this -> values [ $ minj ] , $ this -> values [ $ i ] ] ; $ change_frec ++ ; } } echo implode ( ' ' , $ this -> values ) . PHP_EOL ; echo $ change_frec . PHP_EOL ; } } $ answer = new Solver ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ N ; private $ numbers ; public function __construct ( ) { $ this -> N = trim ( fgets ( STDIN ) ) ; $ number = trim ( fgets ( STDIN ) ) ; $ this -> numbers = explode ( ' ' , $ number ) ; } public function selectionSort ( ) { $ numbers = $ this -> numbers ; $ count = 0 ; for ( $ i = 0 ; $ i < $ this -> N ; ++ $ i ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ this -> N ; ++ $ j ) { if ( $ numbers [ $ j ] < $ numbers [ $ minj ] ) { $ minj = $ j ; } } if ( $ minj === $ i ) { continue ; } list ( $ numbers [ $ i ] , $ numbers [ $ minj ] ) = [ $ numbers [ $ minj ] , $ numbers [ $ i ] ] ; ++ $ count ; } echo implode ( ' ' , $ numbers ) . PHP_EOL ; echo $ count . PHP_EOL ; } } $ answer = new Answer ( ) ; $ answer -> selectionSort ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ sequence_len ; private $ sequence ; public function __construct ( ) { while ( 1 ) { $ line = FGETS ( STDIN ) ; if ( $ line == false ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> sequence_len = $ lines [ 0 ] ; $ this -> sequence = explode ( ' ' , $ lines [ 1 ] ) ; } public function selectionSort ( ) { $ seq = $ this -> sequence ; $ count = 0 ; for ( $ i = 0 ; $ i < $ this -> sequence_len ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ this -> sequence_len ; $ j ++ ) { if ( $ seq [ $ j ] < $ seq [ $ minj ] ) { $ minj = $ j ; } } if ( $ i != $ minj ) { list ( $ seq [ $ i ] , $ seq [ $ minj ] ) = array ( $ seq [ $ minj ] , $ seq [ $ i ] ) ; $ count ++ ; } } echo implode ( ' ' , $ seq ) , PHP_EOL ; echo $ count , PHP_EOL ; } } $ answer = new Answer ; $ answer -> selectionSort ( ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ arr = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 , $ len = count ( $ arr ) , $ swapCnt = 0 ; $ i < $ len ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { if ( $ arr [ $ j ] < $ arr [ $ minj ] ) { $ minj = $ j ; } } if ( $ minj !== $ i ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ minj ] ; $ arr [ $ minj ] = $ tmp ; $ swapCnt ++ ; } } echo implode ( ' ' , $ arr ) , PHP_EOL , $ swapCnt , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ count ) ; $ numbers = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ exchangeCount = 0 ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ min = $ i ; for ( $ j = $ i + 1 ; $ j < $ count ; $ j ++ ) { if ( $ numbers [ $ min ] > $ numbers [ $ j ] ) { $ min = $ j ; } } if ( $ i != $ min ) { $ tmp = $ numbers [ $ min ] ; $ numbers [ $ min ] = $ numbers [ $ i ] ; $ numbers [ $ i ] = $ tmp ; $ exchangeCount ++ ; } } echo implode ( \" \" , $ numbers ) . PHP_EOL ; echo $ exchangeCount . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } function swap ( & $ a , & $ b ) { $ tmp = $ a ; $ a = $ b ; $ b = $ tmp ; } function selection_sort ( $ A ) { $ swap_count = 0 ; for ( $ i = 0 , $ count = count ( $ A ) ; $ i < $ count ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ count ; $ j ++ ) { if ( $ A [ $ j ] < $ A [ $ minj ] ) { $ minj = $ j ; } } if ( $ i !== $ minj ) { swap ( $ A [ $ i ] , $ A [ $ minj ] ) ; $ swap_count ++ ; } } return [ $ A , $ swap_count ] ; } input ( ) ; $ A = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; list ( $ A , $ swap_count ) = selection_sort ( $ A ) ; echo implode ( ' ' , $ A ) . \" \\n \" ; echo \" { $ swap_count } \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php define ( ' N ' , 1000 ) ; function trace ( array $ A , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) printf ( \" \" ) ; printf ( \" %d \" , $ A [ $ i ] ) ; } printf ( \" \\n \" ) ; } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ A [ $ j ] < $ A [ $ minj ] ) { $ minj = $ j ; } } if ( $ i != $ minj ) { $ tmp = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ minj ] ; $ A [ $ minj ] = $ tmp ; $ count ++ ; } } trace ( $ A , $ n ) ; printf ( \" %d \" , $ count ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ bubbleArr = BubbleSort ( $ arr , $ N ) ; echo ( implode ( ' ' , $ bubbleArr ) . PHP_EOL . \" Stable \" . PHP_EOL ) ; $ selectionArr = SelectionSort ( $ arr , $ N ) ; echo implode ( \" \" , $ selectionArr ) . PHP_EOL ; if ( isStable ( $ bubbleArr , $ selectionArr ) == true ) { echo ( \" Stable \" . PHP_EOL ) ; } else { echo ( \" Not stable \" . PHP_EOL ) ; } function BubbleSort ( $ arr , $ N ) { for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { for ( $ j = $ N - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ j - 1 ] [ 1 ] ) { $ tmp = $ arr [ $ j ] ; $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; } } } return $ arr ; } function SelectionSort ( $ arr , $ N ) { for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; ++ $ j ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ mini ] [ 1 ] ) { $ mini = $ j ; } } if ( $ mini != $ i ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ mini ] ; $ arr [ $ mini ] = $ tmp ; } } return $ arr ; } function isStable ( $ bubbleArr , $ selectionArr ) { $ result = array_diff_assoc ( $ bubbleArr , $ selectionArr ) ; if ( count ( $ result ) == 0 ) { return true ; } else { return false ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ bubbleArr = BubbleSort ( $ arr , $ N ) ; echo ( implode ( ' ' , $ bubbleArr ) . PHP_EOL . \" Stable \" . PHP_EOL ) ; $ selectionArr = SelectionSort ( $ arr , $ N ) ; echo implode ( \" \" , $ selectionArr ) . PHP_EOL ; if ( isStable ( $ bubbleArr , $ selectionArr ) == true ) { echo ( \" Stable \" . PHP_EOL ) ; } else { echo ( \" Not stable \" . PHP_EOL ) ; } function BubbleSort ( $ arr , $ N ) { for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { for ( $ j = $ N - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ j - 1 ] [ 1 ] ) { $ tmp = $ arr [ $ j ] ; $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; } } } return $ arr ; } function SelectionSort ( $ arr , $ N ) { for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; ++ $ j ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ mini ] [ 1 ] ) { $ mini = $ j ; } } if ( $ mini != $ i ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ mini ] ; $ arr [ $ mini ] = $ tmp ; } } return $ arr ; } function isStable ( $ bubbleArr , $ selectionArr ) { $ result = array_diff_assoc ( $ bubbleArr , $ selectionArr ) ; if ( count ( $ result ) == 0 ) { return true ; } else { return false ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ bubbleArr = BubbleSort ( $ arr , $ N ) ; echo ( implode ( ' ' , $ bubbleArr ) . PHP_EOL . \" Stable \" . PHP_EOL ) ; $ selectionArr = SelectionSort ( $ arr , $ N ) ; echo implode ( \" \" , $ selectionArr ) . PHP_EOL ; isStable ( $ bubbleArr , $ selectionArr ) ; function BubbleSort ( $ arr , $ N ) { for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { for ( $ j = $ N - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ j - 1 ] [ 1 ] ) { $ tmp = $ arr [ $ j ] ; $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; } } } return $ arr ; } function SelectionSort ( $ arr , $ N ) { for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; ++ $ j ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ mini ] [ 1 ] ) { $ mini = $ j ; } } if ( $ mini != $ i ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ mini ] ; $ arr [ $ mini ] = $ tmp ; } } return $ arr ; } function isStable ( $ bubbleArr , $ selectionArr ) { $ result = array_diff_assoc ( $ bubbleArr , $ selectionArr ) ; if ( count ( $ result ) == 0 ) { echo ( \" Stable \" . PHP_EOL ) ; } else { echo ( \" Not stable \" . PHP_EOL ) ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ length ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ arr1 = bubble_sort ( $ arr , $ length ) ; $ arr2 = selection_sort ( $ arr , $ length ) ; $ bool = count ( array_diff_assoc ( $ arr1 , $ arr2 ) ) === 0 ; echo implode ( ' ' , $ arr1 ) , PHP_EOL , ' Stable ' , PHP_EOL ; echo implode ( ' ' , $ arr2 ) , PHP_EOL , $ bool ? ' Stable ' : ' Not stable ' , PHP_EOL ; function bubble_sort ( $ a , $ length ) { $ flag = 1 ; while ( $ flag ) { $ flag = 0 ; for ( $ i = $ length - 1 ; $ i > 0 ; $ i -- ) { if ( $ a [ $ i - 1 ] [ 1 ] > $ a [ $ i ] [ 1 ] ) { $ temp = $ a [ $ i - 1 ] ; $ a [ $ i - 1 ] = $ a [ $ i ] ; $ a [ $ i ] = $ temp ; $ flag = 1 ; } } } return $ a ; } function selection_sort ( $ a , $ length ) { for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ min = $ i ; for ( $ j = $ i ; $ j < $ length ; $ j ++ ) { if ( $ a [ $ j ] [ 1 ] < $ a [ $ min ] [ 1 ] ) { $ min = $ j ; } } if ( $ min !== $ i ) { $ temp = $ a [ $ i ] ; $ a [ $ i ] = $ a [ $ min ] ; $ a [ $ min ] = $ temp ; } } return ( $ a ) ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = explode ( ' ' , $ line ) ; $ bubble = bubbleSort ( $ arr ) ; $ select = selectionSort ( $ arr ) ; echo implode ( ' ' , $ bubble ) , PHP_EOL , ' Stable ' , PHP_EOL ; $ bool = count ( array_diff_assoc ( $ bubble , $ select ) ) === 0 ; echo implode ( ' ' , $ select ) , PHP_EOL , $ bool ? ' Stable ' : ' Not stable ' , PHP_EOL ; function bubbleSort ( $ arr ) { for ( $ i = 0 , $ len = count ( $ arr ) ; $ i < $ len ; $ i ++ ) { for ( $ j = $ len - 1 ; $ j > $ i ; $ j -- ) { $ tmp = $ arr [ $ j ] ; if ( $ arr [ $ j - 1 ] [ 1 ] > $ tmp [ 1 ] ) { $ arr [ $ j ] = $ arr [ $ j - 1 ] ; $ arr [ $ j - 1 ] = $ tmp ; } } } return $ arr ; } function selectionSort ( $ arr ) { for ( $ i = 0 , $ len = count ( $ arr ) , $ cnt = 0 ; $ i < $ len ; $ i ++ ) { $ key = $ i ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { if ( $ arr [ $ j ] [ 1 ] < $ arr [ $ key ] [ 1 ] ) { $ key = $ j ; } } if ( $ key !== $ i ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ key ] ; $ arr [ $ key ] = $ tmp ; $ cnt ++ ; } } return $ arr ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ format = join ( ' ' , array_fill ( 0 , $ n , ' %s ' ) ) ; $ cards = fscanf ( STDIN , $ format ) ; $ cards1 = $ cards ; bubbleSort ( $ cards1 ) ; $ cards2 = $ cards ; selectionSort ( $ cards2 ) ; printResult ( $ cards , $ cards1 ) ; printResult ( $ cards , $ cards2 ) ; function printResult ( $ cards , $ sorted_cards ) { $ result = join ( ' ' , $ sorted_cards ) ; echo \" $ result \\n \" ; echo checkStable ( $ cards , $ sorted_cards ) . \" \\n \" ; } function checkStable ( $ cards , $ sorted_cards ) { $ prev_card = \" S0 \" ; $ prev_card_index = - 1 ; foreach ( $ sorted_cards as $ card ) { $ card_index = array_search ( $ card , $ cards ) ; if ( cardNum ( $ prev_card ) == cardNum ( $ card ) ) { if ( $ prev_card_index >= $ card_index ) { return ' Not stable ' ; } } $ prev_card = $ card ; $ prev_card_index = $ card_index ; } return ' Stable ' ; } function cardNum ( $ card ) { return intval ( substr ( $ card , 1 ) ) ; } function swap ( & $ cards , $ i , $ j ) { $ tmp = $ cards [ $ i ] ; $ cards [ $ i ] = $ cards [ $ j ] ; $ cards [ $ j ] = $ tmp ; } function bubbleSort ( & $ cards ) { $ need_to_sort = true ; while ( $ need_to_sort ) { $ need_to_sort = false ; for ( $ i = count ( $ cards ) - 1 ; $ i > 0 ; $ i -- ) { if ( cardNum ( $ cards [ $ i - 1 ] ) <= cardNum ( $ cards [ $ i ] ) ) { continue ; } swap ( $ cards , $ i , $ i - 1 ) ; $ need_to_sort = true ; } } } function selectionSort ( & $ cards ) { $ N = count ( $ cards ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) { if ( cardNum ( $ cards [ $ j ] ) < cardNum ( $ cards [ $ minj ] ) ) { $ minj = $ j ; } } if ( $ i != $ minj ) { swap ( $ cards , $ i , $ minj ) ; } } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ C = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ C1 = BubbleSort ( $ C , $ n ) ; $ C2 = SelectionSort ( $ C , $ n ) ; echo implode ( \" \" , $ C1 ) . \" \\n \" ; echo \" Stable \" . \" \\n \" ; echo implode ( \" \" , $ C2 ) . \" \\n \" ; echo ( isStable ( $ C1 , $ C2 , $ n ) ? \" Stable \\n \" : \" Not stable \\n \" ) ; function BubbleSort ( $ C , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { for ( $ j = $ n - 1 ; $ j > $ i ; -- $ j ) { if ( $ C [ $ j - 1 ] [ 1 ] > $ C [ $ j ] [ 1 ] ) { $ tmp = $ C [ $ j - 1 ] ; $ C [ $ j - 1 ] = $ C [ $ j ] ; $ C [ $ j ] = $ tmp ; } } } return $ C ; } function SelectionSort ( $ C , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ minj = $ i ; for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { if ( $ C [ $ minj ] [ 1 ] > $ C [ $ j ] [ 1 ] ) { $ minj = $ j ; } } if ( $ i == $ minj ) continue ; $ tmp = $ C [ $ i ] ; $ C [ $ i ] = $ C [ $ minj ] ; $ C [ $ minj ] = $ tmp ; } return $ C ; } function isStable ( $ C1 , $ C2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ C1 [ $ i ] != $ C2 [ $ i ] ) { return false ; } } return true ; }",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) trim ( fgets ( STDIN ) ) ; $ Ab = $ As = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ N - 1 ; $ i < $ j ; $ j -- ) if ( $ Ab [ $ j ] [ 1 ] < $ Ab [ $ j - 1 ] [ 1 ] ) list ( $ Ab [ $ j ] , $ Ab [ $ j - 1 ] ) = [ $ Ab [ $ j - 1 ] , $ Ab [ $ j ] ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) if ( $ As [ $ j ] [ 1 ] < $ As [ $ mini ] [ 1 ] ) $ mini = $ j ; if ( $ i == $ mini ) continue ; list ( $ As [ $ i ] , $ As [ $ mini ] ) = [ $ As [ $ mini ] , $ As [ $ i ] ] ; } $ diff = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ Ab [ $ i ] != $ As [ $ i ] ) { $ diff = 1 ; break ; } } $ sAb = implode ( ' ' , $ Ab ) ; echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ; if ( $ diff ) echo implode ( ' ' , $ As ) , PHP_EOL , ' Not stable ' , PHP_EOL ; else echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) fgets ( STDIN ) ; $ Ab = $ As = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ N - 1 ; $ i < $ j ; $ j -- ) if ( $ Ab [ $ j ] [ 1 ] < $ Ab [ $ j - 1 ] [ 1 ] ) list ( $ Ab [ $ j ] , $ Ab [ $ j - 1 ] ) = [ $ Ab [ $ j - 1 ] , $ Ab [ $ j ] ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) if ( $ As [ $ j ] [ 1 ] < $ As [ $ mini ] [ 1 ] ) $ mini = $ j ; if ( $ i == $ mini ) continue ; list ( $ As [ $ i ] , $ As [ $ mini ] ) = [ $ As [ $ mini ] , $ As [ $ i ] ] ; } $ diff = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ Ab [ $ i ] != $ As [ $ i ] ) { $ diff = 1 ; break ; } } $ sAb = implode ( ' ' , $ Ab ) ; echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ; if ( $ diff ) echo implode ( ' ' , $ As ) , PHP_EOL , ' Not stable ' , PHP_EOL ; else echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) fgets ( STDIN ) ; $ Ab = $ As = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ N - 1 ; $ i < $ j ; $ j -- ) if ( $ Ab [ $ j ] [ 1 ] < $ Ab [ $ j - 1 ] [ 1 ] ) list ( $ Ab [ $ j ] , $ Ab [ $ j - 1 ] ) = [ $ Ab [ $ j - 1 ] , $ Ab [ $ j ] ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ mini = $ j = $ i ; $ j < $ N ; $ j ++ ) if ( $ As [ $ j ] [ 1 ] < $ As [ $ mini ] [ 1 ] ) $ mini = $ j ; if ( $ i != $ mini ) list ( $ As [ $ i ] , $ As [ $ mini ] ) = [ $ As [ $ mini ] , $ As [ $ i ] ] ; } $ diff = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ Ab [ $ i ] != $ As [ $ i ] ) { $ diff = 1 ; break ; } } $ sAb = implode ( ' ' , $ Ab ) ; echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ; if ( $ diff ) echo implode ( ' ' , $ As ) , PHP_EOL , ' Not stable ' , PHP_EOL ; else echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) fgets ( STDIN ) ; $ Ab = $ As = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ N - 1 ; $ i < $ j ; $ j -- ) if ( $ Ab [ $ j ] [ 1 ] < $ Ab [ $ j - 1 ] [ 1 ] ) list ( $ Ab [ $ j ] , $ Ab [ $ j - 1 ] ) = [ $ Ab [ $ j - 1 ] , $ Ab [ $ j ] ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ mini = $ j = $ i ; $ j < $ N ; $ j ++ ) if ( $ As [ $ j ] [ 1 ] < $ As [ $ mini ] [ 1 ] ) $ mini = $ j ; if ( $ i != $ mini ) list ( $ As [ $ i ] , $ As [ $ mini ] ) = [ $ As [ $ mini ] , $ As [ $ i ] ] ; } $ diff = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ Ab [ $ i ] != $ As [ $ i ] ) { $ diff = 1 ; break ; } $ sAb = implode ( ' ' , $ Ab ) ; echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ; if ( $ diff ) echo implode ( ' ' , $ As ) , PHP_EOL , ' Not stable ' , PHP_EOL ; else echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ N = ( int ) fgets ( STDIN ) ; $ Ab = $ As = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ N - 1 ; $ i < $ j ; $ j -- ) if ( $ Ab [ $ j ] [ 1 ] < $ Ab [ $ j - 1 ] [ 1 ] ) list ( $ Ab [ $ j ] , $ Ab [ $ j - 1 ] ) = [ $ Ab [ $ j - 1 ] , $ Ab [ $ j ] ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ mini = $ j = $ i ; $ j < $ N ; $ j ++ ) if ( $ As [ $ j ] [ 1 ] < $ As [ $ mini ] [ 1 ] ) $ mini = $ j ; if ( $ i != $ mini ) list ( $ As [ $ i ] , $ As [ $ mini ] ) = [ $ As [ $ mini ] , $ As [ $ i ] ] ; } $ diff = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ Ab [ $ i ] != $ As [ $ i ] ) { $ diff = 1 ; break ; } $ sAb = implode ( ' ' , $ Ab ) ; echo $ sAb , PHP_EOL , ' Stable ' , PHP_EOL ; if ( $ diff ) echo implode ( ' ' , $ As ) , PHP_EOL , ' Not stable ' ; else echo $ sAb , PHP_EOL , ' Stable ' ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; $ N = trim ( fgets ( $ input ) ) ; $ seq = explode ( ' ' , trim ( fgets ( $ input ) ) ) ; $ cards_b = $ seq ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ N - 1 ; $ j > $ i ; $ j -- ) { if ( $ cards_b [ $ j ] [ 1 ] < $ cards_b [ $ j - 1 ] [ 1 ] ) { list ( $ cards_b [ $ j - 1 ] , $ cards_b [ $ j ] ) = array ( $ cards_b [ $ j ] , $ cards_b [ $ j - 1 ] ) ; } } } $ cards_s = $ seq ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ mini = $ i ; for ( $ j = $ i ; $ j < $ N ; $ j ++ ) { if ( $ cards_s [ $ j ] [ 1 ] < $ cards_s [ $ mini ] [ 1 ] ) { $ mini = $ j ; } } list ( $ cards_s [ $ i ] , $ cards_s [ $ mini ] ) = array ( $ cards_s [ $ mini ] , $ cards_s [ $ i ] ) ; } print implode ( ' ' , $ cards_b ) . \" \\n \" ; print \" Stable \\n \" ; print implode ( ' ' , $ cards_s ) . \" \\n \" ; if ( $ cards_s != $ cards_b ) { print \" Not stable \\n \" ; } else { print \" Stable \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ tmp = trim ( fgets ( STDIN ) ) ; $ input = explode ( ' ' , $ tmp ) ; $ buble = $ input ; $ select = $ input ; $ flag = false ; $ select_flag = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ h = $ n - 1 ; $ h >= $ i + 1 ; $ h -- ) { if ( ( int ) $ buble [ $ h - 1 ] [ 1 ] > ( int ) $ buble [ $ h ] [ 1 ] ) { $ tmp_buble = $ buble [ $ h ] ; $ buble [ $ h ] = $ buble [ $ h - 1 ] ; $ buble [ $ h - 1 ] = $ tmp_buble ; } } $ min = $ i ; for ( $ h = $ i ; $ h < $ n ; $ h ++ ) { if ( ( int ) $ select [ $ min ] [ 1 ] === ( int ) $ select [ $ h ] [ 1 ] && $ h !== $ i ) { $ flag = true ; } if ( ( int ) $ select [ $ min ] [ 1 ] > ( int ) $ select [ $ h ] [ 1 ] ) { $ min = $ h ; } } if ( $ min !== $ i ) { $ tmp_select = $ select [ $ i ] ; $ select [ $ i ] = $ select [ $ min ] ; $ select [ $ min ] = $ tmp_select ; if ( $ flag ) { $ select_flag = true ; } } $ flag = false ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i === $ n - 1 ) { echo \" $ buble [ $ i ] \\n \" ; } else { echo $ buble [ $ i ] . ' ' ; } } echo \" Stable \\n \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i === $ n - 1 ) { echo \" $ select [ $ i ] \\n \" ; } else { echo $ select [ $ i ] . ' ' ; } } if ( $ select_flag ) { echo \" Not stable \\n \" ; } else { echo \" Stable \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ num_arr = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ bubble_arr = bubble_sort ( $ num_arr ) ; echo implode ( \" \" , $ bubble_arr ) . \" \\n \" ; is_stable ( $ bubble_arr , $ bubble_arr ) ; $ selection_arr = selection_sort ( $ num_arr ) ; echo implode ( \" \" , $ selection_arr ) . \" \\n \" ; is_stable ( $ bubble_arr , $ selection_arr ) ; function bubble_sort ( $ num_arr ) { for ( $ i = 0 , $ len = count ( $ num_arr ) ; $ i < $ len ; $ i ++ ) { for ( $ j = $ len - 1 ; $ j > $ i ; $ j -- ) { $ tmp = $ j ; if ( $ num_arr [ $ j - 1 ] [ 1 ] > $ num_arr [ $ tmp ] [ 1 ] ) { $ card = $ num_arr [ $ tmp ] ; $ num_arr [ $ j ] = $ num_arr [ $ j - 1 ] ; $ num_arr [ $ j - 1 ] = $ card ; } } } return $ num_arr ; } function selection_sort ( $ num_arr ) { $ min = 0 ; $ flag = 0 ; for ( $ i = 0 ; $ i < count ( $ num_arr ) - 1 ; $ i ++ ) { $ min = $ i ; for ( $ j = $ i + 1 ; $ j < count ( $ num_arr ) ; $ j ++ ) { if ( $ num_arr [ $ j ] [ 1 ] < $ num_arr [ $ min ] [ 1 ] ) { $ min = $ j ; $ flag = 1 ; } } if ( $ flag ) { $ tmp = $ num_arr [ $ i ] ; $ num_arr [ $ i ] = $ num_arr [ $ min ] ; $ num_arr [ $ min ] = $ tmp ; $ flag = 0 ; } } return $ num_arr ; } function is_stable ( $ origin , $ sort_arr ) { for ( $ i = 0 ; $ i < count ( $ origin ) ; $ i ++ ) { if ( $ origin [ $ i ] [ 0 ] != $ sort_arr [ $ i ] [ 0 ] ) { echo \" Not stable \\n \" ; return ; } } echo \" Stable \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php class Solver { private $ number_of_elements ; private $ values = array ( ) ; public function __construct ( ) { $ lines = array ( ) ; while ( 1 ) { if ( ! $ line = fgets ( STDIN ) ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> number_of_elements = $ lines [ 0 ] ; $ this -> values = explode ( ' ' , $ lines [ 1 ] ) ; } public function solveAnswer ( ) { $ BubbleSortedArray = $ this -> BubbleSort ( ) ; echo implode ( ' ' , $ BubbleSortedArray ) . PHP_EOL ; echo $ this -> isStable ( $ this -> values , $ BubbleSortedArray ) ? \" Stable \" . PHP_EOL : \" Not stable \" . PHP_EOL ; $ SelectionSortedArray = $ this -> SelectionSort ( ) ; echo implode ( ' ' , $ SelectionSortedArray ) . PHP_EOL ; echo $ this -> isStable ( $ this -> values , $ SelectionSortedArray ) ? \" Stable \" . PHP_EOL : \" Not stable \" . PHP_EOL ; } public function BubbleSort ( ) { $ tmp_array = $ this -> values ; $ flag = 1 ; while ( $ flag ) { $ flag = 0 ; for ( $ i = $ this -> number_of_elements - 1 ; $ i > 0 ; $ i -- ) { if ( substr ( $ tmp_array [ $ i ] , - 1 ) < substr ( $ tmp_array [ $ i - 1 ] , - 1 ) ) { list ( $ tmp_array [ $ i ] , $ tmp_array [ $ i - 1 ] ) = [ $ tmp_array [ $ i - 1 ] , $ tmp_array [ $ i ] ] ; $ flag = 1 ; } } } return $ tmp_array ; } public function SelectionSort ( ) { $ tmp_array = $ this -> values ; for ( $ i = 0 ; $ i < $ this -> number_of_elements ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ this -> number_of_elements ; $ j ++ ) { if ( substr ( $ tmp_array [ $ j ] , - 1 ) < substr ( $ tmp_array [ $ minj ] , - 1 ) ) { $ minj = $ j ; } } if ( $ minj != $ i ) { list ( $ tmp_array [ $ i ] , $ tmp_array [ $ minj ] ) = [ $ tmp_array [ $ minj ] , $ tmp_array [ $ i ] ] ; } } return $ tmp_array ; } public function isStable ( $ in , $ out ) { for ( $ i = 0 ; $ i < $ this -> number_of_elements ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ this -> number_of_elements ; $ j ++ ) { for ( $ a = 0 ; $ a < $ this -> number_of_elements ; $ a ++ ) { for ( $ b = $ a + 1 ; $ b < $ this -> number_of_elements ; $ b ++ ) { if ( substr ( $ in [ $ i ] , - 1 ) == substr ( $ in [ $ j ] , - 1 ) && $ in [ $ i ] == $ out [ $ b ] && $ in [ $ j ] == $ out [ $ a ] ) { return false ; } } } } } return true ; } } $ solver = new Solver ; $ solver -> solveAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ N ; private $ numbers ; public function __construct ( ) { $ this -> N = trim ( fgets ( STDIN ) ) ; $ number = trim ( fgets ( STDIN ) ) ; $ this -> numbers = explode ( ' ' , $ number ) ; } public function bubbleSort ( ) { $ numbers2 = $ this -> numbers ; for ( $ i = 0 ; $ i < $ this -> N ; ++ $ i ) { for ( $ j = $ this -> N - 1 ; $ j > $ i ; -- $ j ) { $ value_j = $ numbers2 [ $ j ] ; $ value_j_1 = $ numbers2 [ $ j - 1 ] ; if ( $ value_j [ 1 ] < $ value_j_1 [ 1 ] ) { list ( $ numbers2 [ $ j ] , $ numbers2 [ $ j - 1 ] ) = [ $ numbers2 [ $ j - 1 ] , $ numbers2 [ $ j ] ] ; } } } echo implode ( ' ' , $ numbers2 ) . \" \\n \" ; if ( true === $ this -> isStable ( $ this -> numbers , $ numbers2 ) ) { echo ' Stable ' . \" \\n \" ; } else { echo ' Not stable ' . \" \\n \" ; } } public function selectionSort ( ) { $ numbers2 = $ this -> numbers ; for ( $ i = 0 ; $ i < $ this -> N ; ++ $ i ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ this -> N ; ++ $ j ) { $ value_j = $ numbers2 [ $ j ] ; $ value_minj = $ numbers2 [ $ minj ] ; if ( $ value_j [ 1 ] < $ value_minj [ 1 ] ) { $ minj = $ j ; } } list ( $ numbers2 [ $ i ] , $ numbers2 [ $ minj ] ) = [ $ numbers2 [ $ minj ] , $ numbers2 [ $ i ] ] ; } echo implode ( ' ' , $ numbers2 ) . \" \\n \" ; if ( true === $ this -> isStable ( $ this -> numbers , $ numbers2 ) ) { echo ' Stable ' . \" \\n \" ; } else { echo ' Not stable ' . \" \\n \" ; } } public function isStable ( $ in , $ out ) { for ( $ i = 0 ; $ i < $ this -> N ; ++ $ i ) { $ value_i = $ in [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ this -> N ; ++ $ j ) { $ value_j = $ in [ $ j ] ; for ( $ a = 0 ; $ a < $ this -> N ; ++ $ a ) { for ( $ b = $ a + 1 ; $ b < $ this -> N ; ++ $ b ) { if ( $ value_i [ 1 ] === $ value_j [ 1 ] and $ in [ $ i ] === $ out [ $ b ] and $ in [ $ j ] === $ out [ $ a ] ) { return false ; } } } } } return true ; } } $ answer = new Answer ( ) ; $ answer -> bubbleSort ( ) ; $ answer -> selectionSort ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ sequence_len ; private $ sequence ; public function __construct ( ) { while ( 1 ) { $ line = FGETS ( STDIN ) ; if ( $ line == false ) { break ; } $ line = trim ( $ line ) ; $ lines [ ] = $ line ; } $ this -> sequence_len = $ lines [ 0 ] ; $ this -> sequence = explode ( ' ' , $ lines [ 1 ] ) ; } public function getAnswer ( ) { $ select = $ this -> selectionSort ( $ this -> sequence ) ; $ bubble = $ this -> bubbleSort ( $ this -> sequence ) ; echo implode ( ' ' , $ bubble ) , PHP_EOL ; echo ' Stable ' , PHP_EOL ; if ( $ select === $ bubble ) { echo implode ( ' ' , $ select ) , PHP_EOL ; echo ' Stable ' , PHP_EOL ; } else { echo implode ( ' ' , $ select ) , PHP_EOL ; echo ' Not stable ' , PHP_EOL ; } } public function selectionSort ( $ sequence ) { $ seq = $ sequence ; for ( $ i = 0 ; $ i < $ this -> sequence_len ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ this -> sequence_len ; $ j ++ ) { if ( $ seq [ $ j ] [ 1 ] < $ seq [ $ minj ] [ 1 ] ) { $ minj = $ j ; } } if ( $ i != $ minj ) { list ( $ seq [ $ i ] , $ seq [ $ minj ] ) = array ( $ seq [ $ minj ] , $ seq [ $ i ] ) ; } } return $ seq ; } public function bubbleSort ( $ sequence ) { $ seq = $ sequence ; for ( $ i = 0 ; $ i < $ this -> sequence_len ; $ i ++ ) { for ( $ j = 1 ; $ j < $ this -> sequence_len ; $ j ++ ) { if ( $ seq [ $ j - 1 ] [ 1 ] > $ seq [ $ j ] [ 1 ] ) { list ( $ seq [ $ j ] , $ seq [ $ j - 1 ] ) = array ( $ seq [ $ j - 1 ] , $ seq [ $ j ] ) ; } } } return $ seq ; } } $ answer = new Answer ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } function p ( $ card_array ) { echo implode ( ' ' , array_map ( function ( $ card ) { return ( $ card -> suit ) . ( $ card -> value ) ; } , $ card_array ) ) . \" \\n \" ; } function isStable ( $ C1 , $ C2 ) { for ( $ i = 0 , $ count = count ( $ C1 ) ; $ i < $ count ; $ i ++ ) { if ( $ C1 [ $ i ] -> suit !== $ C2 [ $ i ] -> suit ) { return false ; } } return true ; } function bubble ( & $ A ) { for ( $ i = 0 , $ count = count ( $ A ) ; $ i < $ count ; $ i ++ ) { for ( $ j = $ count - 1 ; $ j >= $ i + 1 ; $ j -- ) { if ( $ A [ $ j ] -> value < $ A [ $ j - 1 ] -> value ) { $ t = $ A [ $ j ] ; $ A [ $ j ] = $ A [ $ j - 1 ] ; $ A [ $ j - 1 ] = $ t ; } } } } function selection ( & $ A ) { for ( $ i = 0 , $ count = count ( $ A ) ; $ i < $ count ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ count ; $ j ++ ) { if ( $ A [ $ j ] -> value < $ A [ $ minj ] -> value ) { $ minj = $ j ; } } $ t = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ minj ] ; $ A [ $ minj ] = $ t ; } } class Card { public $ suit , $ value ; public function __construct ( $ suit , $ value ) { $ this -> suit = $ suit ; $ this -> value = ( int ) $ value ; } } $ N = ( int ) input ( ) ; $ C1 = array_map ( function ( $ suit_and_value ) { return new Card ( $ suit_and_value [ 0 ] , $ suit_and_value [ 1 ] ) ; } , input_array ( ) ) ; $ C2 = array_map ( function ( $ card ) { return clone $ card ; } , $ C1 ) ; bubble ( $ C1 ) ; selection ( $ C2 ) ; p ( $ C1 ) ; echo \" Stable \\n \" ; p ( $ C2 ) ; if ( isStable ( $ C1 , $ C2 ) ) { echo \" Stable \\n \" ; } else { echo \" Not stable \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php define ( ' N ' , 1000 ) ; function trace ( array $ A , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i > 0 ) printf ( \" \" ) ; printf ( \" %s \" , $ A [ $ i ] ) ; } printf ( \" \\n \" ) ; } function to_numbers ( $ str ) { $ num = preg_replace ( ' /[^0-9]/ ' , ' ' , $ str ) ; return intval ( $ num ) ; } function swap ( & $ A , $ i , $ j ) { $ tmp = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ j ] ; $ A [ $ j ] = $ tmp ; } function bubleSort ( $ A , $ n ) { $ flag = 1 ; $ B = array_map ( ' to_numbers ' , $ A ) ; while ( $ flag ) { $ flag = 0 ; for ( $ j = $ n - 1 ; $ j > 0 ; $ j -- ) { if ( $ B [ $ j ] < $ B [ $ j - 1 ] ) { swap ( $ A , $ j , $ j - 1 ) ; swap ( $ B , $ j , $ j - 1 ) ; $ flag = 1 ; } } } return $ A ; } function selectionSort ( $ A , $ n ) { $ B = array_map ( ' to_numbers ' , $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ minj = $ i ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ B [ $ j ] < $ B [ $ minj ] ) { $ minj = $ j ; } } if ( $ i != $ minj ) { swap ( $ B , $ i , $ minj ) ; swap ( $ A , $ i , $ minj ) ; } } return $ A ; } function stable ( $ A , $ B , $ n ) { $ before = to_numbers ( $ B [ 0 ] ) ; $ before_num = to_numbers ( $ B [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ B [ $ i ] ; $ now_num = to_numbers ( $ now ) ; if ( $ now_num == $ before_num ) { if ( array_search ( $ now , $ A ) < array_search ( $ before , $ A ) ) { echo \" Not stable \" ; return ; } } else { $ before = $ now ; $ before_num = $ now_num ; } } echo \" Stable \" ; } $ n = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ R = bubleSort ( $ A , $ n ) ; trace ( $ R , $ n ) ; stable ( $ A , $ R , $ n ) ; printf ( \" \\n \" ) ; $ R = selectionSort ( $ A , $ n ) ; trace ( $ R , $ n ) ; stable ( $ A , $ R , $ n ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ A = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %d ' , $ m ) ; $ A [ ] = $ m ; } shellSort ( $ A , $ n ) ; function insertionSort ( & $ A , $ n , $ g ) { global $ cnt ; for ( $ i = $ g ; $ i < $ n ; $ i ++ ) { $ v = $ A [ $ i ] ; $ j = $ i - $ g ; while ( $ j >= 0 && $ A [ $ j ] > $ v ) { $ A [ $ j + $ g ] = $ A [ $ j ] ; $ j -= $ g ; $ cnt ++ ; } $ A [ $ j + $ g ] = $ v ; } } function shellSort ( $ A , $ n ) { global $ cnt ; $ cnt = 0 ; $ G = explode ( ' , ' , ' 1,4,13,40,121,364,1093,3280,9841,29524,88573,265720,797161 ' ) ; $ m = count ( $ G ) ; while ( $ G [ $ m - 1 ] > $ n ) { $ m -- ; } echo $ m , PHP_EOL ; for ( $ i = $ m - 1 , $ arr = array ( ) ; $ i >= 0 ; $ i -- ) { $ arr [ ] = $ G [ $ i ] ; } echo implode ( ' ' , $ arr ) , PHP_EOL ; for ( $ i = $ m - 1 ; $ i >= 0 ; $ i -- ) { insertionSort ( $ A , $ n , $ G [ $ i ] ) ; } echo $ cnt , PHP_EOL , implode ( PHP_EOL , $ A ) ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ N ) ; $ nums = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { fscanf ( STDIN , ' %d ' , $ n ) ; $ nums [ ] = $ n ; } list ( $ m , $ G , $ cnt , $ nums ) = shellSort ( $ nums , $ N ) ; echo \" $ m \\n \" ; echo join ( ' ' , $ G ) . \" \\n \" ; echo \" $ cnt \\n \" ; foreach ( $ nums as $ num ) { echo \" $ num \\n \" ; } function insertionSort ( $ A , $ n , $ g , & $ cnt ) { for ( $ i = $ g ; $ i < $ n ; $ i ++ ) { $ val = $ A [ $ i ] ; $ j = $ i - $ g ; while ( $ j >= 0 && $ A [ $ j ] > $ val ) { $ A [ $ j + $ g ] = $ A [ $ j ] ; $ j -= $ g ; $ cnt ++ ; } $ A [ $ j + $ g ] = $ val ; } return $ A ; } function shellSort ( $ A , $ n ) { $ G = array ( ) ; for ( $ h = 1 ; $ h <= $ n ; $ h = 3 * $ h + 1 ) { $ G [ ] = $ h ; } $ G = array_reverse ( $ G ) ; $ cnt = 0 ; foreach ( $ G as $ g ) { $ A = insertionSort ( $ A , $ n , $ g , $ cnt ) ; } return array ( count ( $ G ) , $ G , $ cnt , $ A ) ; }",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" memory_limit \" , \" -1 \" ) ; $ input = STDIN ; $ n = ( int ) fgets ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ A [ ] = ( int ) fgets ( $ input ) ; } for ( $ i = 17 ; $ i > 0 ; $ i -- ) { $ g = ( int ) ( ( 2.25 ** $ i - 1 ) / 1.25 ) ; if ( $ g <= $ n ) { $ G [ ] = $ g ; } } $ cnt = 0 ; foreach ( $ G as $ g ) { for ( $ i = $ g ; $ i < $ n ; $ i ++ ) { $ v = $ A [ $ i ] ; $ j = $ i - $ g ; while ( $ j >= 0 && $ A [ $ j ] > $ v ) { $ A [ $ j + $ g ] = $ A [ $ j ] ; $ j -= $ g ; $ cnt ++ ; } $ A [ $ j + $ g ] = $ v ; } } print count ( $ G ) . \" \\n \" ; print implode ( \" \" , $ G ) . \" \\n \" ; print $ cnt . \" \\n \" ; print implode ( \" \\n \" , $ A ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ num ; private $ sequence ; private $ m ; private $ count = 0 ; private $ interval ; public function __construct ( ) { ini_set ( ' memory_limit ' , ' -1 ' ) ; $ this -> num = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ this -> num ; $ i ++ ) { $ this -> sequence [ ] = trim ( fgets ( STDIN ) ) ; } } public function getAnswer ( ) { $ ans = $ this -> shellSort ( $ this -> sequence , $ this -> num ) ; echo $ this -> m . PHP_EOL ; echo join ( ' ' , $ this -> interval ) . PHP_EOL ; echo $ this -> count . PHP_EOL ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) { echo $ ans [ $ i ] . PHP_EOL ; } } public function insertSort ( $ seq , $ interval , $ num ) { for ( $ i = $ interval ; $ i < $ num ; $ i ++ ) { $ tmp = $ seq [ $ i ] ; $ j = $ i - $ interval ; while ( $ j >= 0 && $ seq [ $ j ] > $ tmp ) { $ seq [ $ j + $ interval ] = $ seq [ $ j ] ; $ j = $ j - $ interval ; $ this -> count ++ ; } $ seq [ $ j + $ interval ] = $ tmp ; } return $ seq ; } public function shellSort ( $ seq , $ num ) { for ( $ i = 1 ; $ i <= $ num ; $ i = 3 * $ i + 1 ) { $ this -> interval [ ] = $ i ; } $ this -> m = count ( $ this -> interval ) ; $ this -> interval = array_reverse ( $ this -> interval ) ; for ( $ i = 0 ; $ i < $ this -> m ; $ i ++ ) { $ seq = $ this -> insertSort ( $ seq , $ this -> interval [ $ i ] , $ num ) ; } return $ seq ; } } $ answer = new Answer ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" memory_limit \" , \" -1 \" ) ; fscanf ( STDIN , \" %d \" , $ input_count ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ input_count ; ++ $ i ) $ target [ ] = intval ( trim ( fgets ( STDIN ) ) ) ; shell_sort ( $ target ) ; echo \" $ cnt \\n \" ; echo implode ( \" \\n \" , $ target ) , \" \\n \" ; function insert_sort ( & $ target , $ g ) { global $ input_count ; global $ cnt ; for ( $ i = $ g ; $ i < $ input_count ; ++ $ i ) { $ j = $ i - $ g ; $ tmp = $ target [ $ i ] ; while ( $ j >= 0 && $ target [ $ j ] > $ tmp ) { $ target [ $ j + $ g ] = $ target [ $ j ] ; $ j -= $ g ; ++ $ cnt ; } $ target [ $ j + $ g ] = $ tmp ; } } function shell_sort ( & $ target ) { global $ input_count ; $ G = [ 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 ] ; $ m = count ( $ G ) ; while ( $ G [ $ m - 1 ] > $ input_count ) -- $ m ; echo $ m , \" \\n \" ; for ( $ i = $ m - 1 , $ arr = array ( ) ; $ i >= 0 ; -- $ i ) $ arr [ ] = $ G [ $ i ] ; echo implode ( \" \" , $ arr ) , \" \\n \" ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) insert_sort ( $ target , $ arr [ $ i ] ) ; }",
    "label": 3
  },
  {
    "code": "<?php class Answer { public $ n ; public $ A = array ( ) ; public function __construct ( ) { $ this -> n = trim ( fgets ( STDIN ) ) ; ini_set ( ' memory_limit ' , ' -1 ' ) ; for ( $ i = 0 ; $ i < $ this -> n ; ++ $ i ) { fscanf ( STDIN , ' %d ' , $ d ) ; $ this -> A [ ] = $ d ; } } public function showAnswer ( ) { list ( $ m , $ gi , $ cnt , $ array ) = $ this -> shellSort ( $ this -> A , $ this -> n ) ; echo $ m . \" \\n \" ; echo join ( ' ' , $ gi ) . \" \\n \" ; echo $ cnt . \" \\n \" ; for ( $ i = 0 ; $ i < count ( $ array ) ; ++ $ i ) { echo trim ( $ array [ $ i ] ) . \" \\n \" ; } } public function insertionSort ( $ A , $ n , $ g , & $ cnt ) { for ( $ i = $ g ; $ i < $ n ; ++ $ i ) { $ v = $ A [ $ i ] ; $ j = $ i - $ g ; while ( $ j >= 0 and $ A [ $ j ] > $ v ) { $ A [ $ j + $ g ] = $ A [ $ j ] ; $ j = $ j - $ g ; ++ $ cnt ; } $ A [ $ j + $ g ] = $ v ; } return $ A ; } public function shellSort ( $ A , $ n ) { $ cnt = 0 ; $ G = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i = 3 * $ i + 1 ) { $ G [ ] = $ i ; } $ G = array_reverse ( $ G ) ; for ( $ i = 0 ; $ i < count ( $ G ) ; ++ $ i ) { $ A = $ this -> insertionSort ( $ A , $ n , $ G [ $ i ] , $ cnt ) ; } return array ( count ( $ G ) , $ G , $ cnt , $ A ) ; } } $ A = new Answer ( ) ; $ result = $ A -> showAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { private $ num ; private $ sequence ; private $ m ; private $ count = 0 ; private $ interval ; public function __construct ( ) { ini_set ( ' memory_limit ' , ' -1 ' ) ; $ this -> num = fgets ( STDIN ) ; for ( $ i = 0 ; $ i < $ this -> num ; $ i ++ ) { $ this -> sequence [ ] = trim ( fgets ( STDIN ) ) ; } } public function getAnswer ( ) { $ ans = $ this -> shellSort ( $ this -> sequence , $ this -> num ) ; echo $ this -> m . PHP_EOL ; echo join ( ' ' , $ this -> interval ) . PHP_EOL ; echo $ this -> count . PHP_EOL ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) { echo $ ans [ $ i ] . PHP_EOL ; } } public function insertSort ( $ seq , $ interval , $ num ) { for ( $ i = $ interval ; $ i < $ num ; $ i ++ ) { $ tmp = $ seq [ $ i ] ; $ j = $ i - $ interval ; while ( $ j >= 0 && $ seq [ $ j ] > $ tmp ) { $ seq [ $ j + $ interval ] = $ seq [ $ j ] ; $ j = $ j - $ interval ; $ this -> count ++ ; } $ seq [ $ j + $ interval ] = $ tmp ; } return $ seq ; } public function shellSort ( $ seq , $ num ) { for ( $ i = 1 ; $ i <= $ num ; $ i = 3 * $ i + 1 ) { $ this -> interval [ ] = $ i ; } $ this -> m = count ( $ this -> interval ) ; $ this -> interval = array_reverse ( $ this -> interval ) ; for ( $ i = 0 ; $ i < $ this -> m ; $ i ++ ) { $ seq = $ this -> insertSort ( $ seq , $ this -> interval [ $ i ] , $ num ) ; } return $ seq ; } } $ answer = new Answer ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Answer { public $ n ; public $ A = array ( ) ; public function __construct ( ) { $ this -> n = trim ( fgets ( STDIN ) ) ; ini_set ( ' memory_limit ' , ' -1 ' ) ; for ( $ i = 0 ; $ i < $ this -> n ; ++ $ i ) { fscanf ( STDIN , ' %d ' , $ d ) ; $ this -> A [ ] = $ d ; } } public function showAnswer ( ) { list ( $ m , $ gi , $ cnt , $ array ) = $ this -> shellSort ( $ this -> A , $ this -> n ) ; echo $ m . \" \\n \" ; echo join ( ' ' , $ gi ) . \" \\n \" ; echo $ cnt . \" \\n \" ; for ( $ i = 0 ; $ i < count ( $ array ) ; ++ $ i ) { echo trim ( $ array [ $ i ] ) . \" \\n \" ; } } public function insertionSort ( $ A , $ n , $ g , & $ cnt ) { for ( $ i = $ g ; $ i < $ n ; ++ $ i ) { $ v = $ A [ $ i ] ; $ j = $ i - $ g ; while ( $ j >= 0 and $ A [ $ j ] > $ v ) { $ A [ $ j + $ g ] = $ A [ $ j ] ; $ j = $ j - $ g ; ++ $ cnt ; } $ A [ $ j + $ g ] = $ v ; } return $ A ; } public function shellSort ( $ A , $ n ) { $ cnt = 0 ; $ G = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i = 3 * $ i + 1 ) { $ G [ ] = $ i ; } $ G = array_reverse ( $ G ) ; for ( $ i = 0 ; $ i < count ( $ G ) ; ++ $ i ) { $ A = $ this -> insertionSort ( $ A , $ n , $ G [ $ i ] , $ cnt ) ; } return array ( count ( $ G ) , $ G , $ cnt , $ A ) ; } } $ A = new Answer ( ) ; $ result = $ A -> showAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php function RoundRobinScheduling ( $ N , $ TMAX , $ A ) { $ arr = array ( ) ; $ total = 0 ; $ br = ' ' ; while ( $ A -> count ( ) ) { $ v = $ A -> shift ( ) ; $ t = $ v [ 1 ] ; if ( $ t <= $ TMAX ) { $ total += $ t ; echo ( $ br ) ; if ( ! $ br ) { $ br = \" \\n \" ; } echo ( $ v [ 0 ] . ' ' . $ total ) ; } else { $ total += $ TMAX ; $ v [ 1 ] = $ t - $ TMAX ; $ A -> push ( $ v ) ; } } } list ( $ N , $ T ) = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ A = new SplQueue ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ A -> push ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; } RoundRobinScheduling ( $ N , $ T , $ A ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ que = [ ] ; $ head = 0 ; $ tail = 0 ; list ( $ length , $ Q ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ que [ $ tail ++ ] = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; } $ result = ' ' ; $ TIME = 0 ; while ( $ head != $ tail ) { $ task = $ que [ $ head ++ ] ; if ( $ task [ 1 ] <= $ Q ) { $ result .= $ task [ 0 ] . ' ' . ( $ TIME + $ task [ 1 ] ) . PHP_EOL ; $ TIME += $ task [ 1 ] ; } else { $ task [ 1 ] -= $ Q ; $ que [ $ tail ++ ] = $ task ; $ TIME += $ Q ; } } echo $ result ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d %d ' , $ n , $ q ) ; $ queue = array ( ) ; $ result = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , ' %s %d ' , $ name , $ time ) ; $ queue [ ] = array ( ' name ' => $ name , ' time ' => $ time ) ; } $ total = 0 ; while ( count ( $ result ) !== $ n ) { $ queue2 = array ( ) ; foreach ( $ queue as $ i => $ arr ) { if ( $ arr [ ' time ' ] <= $ q ) { $ total += $ arr [ ' time ' ] ; $ result [ ] = sprintf ( \" %s %d \\n \" , $ arr [ ' name ' ] , $ total ) ; } else { $ arr [ ' time ' ] -= $ q ; $ total += $ q ; $ queue2 [ ] = $ arr ; } } $ queue = $ queue2 ; } echo implode ( ' ' , $ result ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ n , $ q ) ; $ queue = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %s %d \" , $ name , $ time ) ; $ queue [ ] = array ( ' name ' => $ name , ' time ' => $ time , ) ; } $ current = 0 ; $ q_current = $ q ; while ( count ( $ queue ) > 0 ) { $ queue_next = array ( ) ; $ q_next = PHP_INT_MAX ; for ( $ i = 0 ; $ i < count ( $ queue ) ; $ i ++ ) { $ process = $ queue [ $ i ] ; if ( $ process [ ' time ' ] - $ q_current <= 0 ) { $ current += $ process [ ' time ' ] ; echo $ process [ ' name ' ] . \" $ current \\n \" ; continue ; } $ current += $ q_current ; $ process [ ' time ' ] -= $ q_current ; $ queue_next [ ] = $ process ; } $ queue = $ queue_next ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ n , $ q ) ; $ queue = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %s %d \" , $ name , $ time ) ; $ queue [ ] = array ( ' name ' => $ name , ' time ' => $ time , ) ; } $ current = 0 ; while ( count ( $ queue ) > 0 ) { $ queue_next = array ( ) ; for ( $ i = 0 ; $ i < count ( $ queue ) ; $ i ++ ) { $ process = $ queue [ $ i ] ; if ( $ process [ ' time ' ] - $ q <= 0 ) { $ current += $ process [ ' time ' ] ; echo $ process [ ' name ' ] . \" $ current \\n \" ; continue ; } $ current += $ q ; $ process [ ' time ' ] -= $ q ; $ queue_next [ ] = $ process ; } $ queue = $ queue_next ; }",
    "label": 3
  },
  {
    "code": "<?php class Que { public $ data = [ ] ; public $ size = 100000 ; public $ head = 0 ; public $ tail = 0 ; function init ( ) { $ this -> head = $ this -> tail = 0 ; } function isEmpty ( ) { return $ this -> head == $ this -> tail ; } function isFull ( ) { return $ this -> head == ( $ this -> tail + 1 ) % $ this -> size ; } function push ( $ x ) { if ( $ this -> isFull ( ) ) return false ; $ t = $ this -> tail ; if ( ++ $ this -> tail == $ this -> size ) $ this -> tail = 0 ; $ this -> data [ $ t ] = $ x ; } function shift ( ) { if ( $ this -> isEmpty ( ) ) return false ; $ h = $ this -> head ; if ( ++ $ this -> head == $ this -> size ) $ this -> head = 0 ; return $ this -> data [ $ h ] ; } } $ que = new Que ( ) ; list ( $ N , $ Q ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ que -> push ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ TIME = 0 ; while ( ! $ que -> isEmpty ( ) ) { $ task = $ que -> shift ( ) ; if ( $ task [ 1 ] <= $ Q ) { echo $ task [ 0 ] , ' ' , $ TIME + $ task [ 1 ] , PHP_EOL ; $ TIME += $ task [ 1 ] ; } else { $ task [ 1 ] -= $ Q ; $ que -> push ( $ task ) ; $ TIME += $ Q ; } }",
    "label": 3
  },
  {
    "code": "<?php $ que = [ ] ; $ head = 0 ; $ tail = 0 ; $ size = 100000 ; list ( $ N , $ Q ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ que [ $ tail ++ ] = ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ TIME = 0 ; while ( $ head != $ tail ) { $ task = $ que [ $ head ++ ] ; if ( $ head == $ size ) { $ head = 0 ; } if ( $ task [ 1 ] <= $ Q ) { echo $ task [ 0 ] , ' ' , $ TIME + $ task [ 1 ] , PHP_EOL ; $ TIME += $ task [ 1 ] ; } else { $ task [ 1 ] -= $ Q ; $ que [ $ tail ++ ] = $ task ; if ( $ tail == $ size ) { $ tail = 0 ; } $ TIME += $ Q ; } }",
    "label": 3
  },
  {
    "code": "<?php $ que = [ ] ; $ head = 0 ; $ tail = 0 ; list ( $ N , $ Q ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ que [ $ tail ++ ] = ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ TIME = 0 ; while ( $ head != $ tail ) { $ task = $ que [ $ head ++ ] ; if ( $ task [ 1 ] <= $ Q ) { echo $ task [ 0 ] , ' ' , $ TIME + $ task [ 1 ] , PHP_EOL ; $ TIME += $ task [ 1 ] ; } else { $ task [ 1 ] -= $ Q ; $ que [ $ tail ++ ] = $ task ; $ TIME += $ Q ; } }",
    "label": 3
  },
  {
    "code": "<?php $ que = [ ] ; $ head = 0 ; $ tail = 0 ; list ( $ N , $ Q ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ que [ $ tail ++ ] = ( explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ o = ' ' ; $ TIME = 0 ; while ( $ head != $ tail ) { $ task = $ que [ $ head ++ ] ; if ( $ task [ 1 ] <= $ Q ) { $ o .= $ task [ 0 ] . ' ' . ( $ TIME + $ task [ 1 ] ) . PHP_EOL ; $ TIME += $ task [ 1 ] ; } else { $ task [ 1 ] -= $ Q ; $ que [ $ tail ++ ] = $ task ; $ TIME += $ Q ; } } print $ o ;",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; list ( $ n , $ q ) = explode ( \" \" , trim ( fgets ( $ input ) ) ) ; $ n = ( int ) $ n ; $ q = ( int ) $ q ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ name_i , $ time_i ) = explode ( \" \" , trim ( fgets ( $ input ) ) ) ; $ time_i = ( int ) $ time_i ; $ queue [ ] = [ $ name_i , $ time_i ] ; } $ head = 0 ; $ tail = $ n ; $ result = 0 ; $ ans = \" \" ; while ( $ head != $ tail ) { list ( $ p_name , $ remain ) = $ queue [ $ head ] ; if ( $ head == $ n ) { $ head = 0 ; } else { $ head ++ ; } if ( $ remain <= $ q ) { $ result += $ remain ; $ ans .= \" { $ p_name } { $ result } \\n \" ; } else { $ result += $ q ; $ remain -= $ q ; $ queue [ $ tail ] = [ $ p_name , $ remain ] ; if ( $ tail == $ n ) { $ tail = 0 ; } else { $ tail ++ ; } } } print $ ans ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; list ( $ n , $ q ) = explode ( \" \" , trim ( fgets ( $ input ) ) ) ; $ n = ( int ) $ n ; $ q = ( int ) $ q ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ name_i , $ time_i ) = explode ( \" \" , trim ( fgets ( $ input ) ) ) ; $ time_i = ( int ) $ time_i ; $ queue [ ] = [ $ name_i , $ time_i ] ; } $ head = 0 ; $ tail = $ n ; $ elapsed = 0 ; $ ans = \" \" ; while ( $ head != $ tail ) { list ( $ p_name , $ remaining ) = $ queue [ $ head ] ; if ( $ head == $ n ) $ head = 0 ; else $ head ++ ; if ( $ remaining <= $ q ) { $ elapsed += $ remaining ; $ ans .= \" { $ p_name } { $ elapsed } \\n \" ; } else { $ elapsed += $ q ; $ remaining -= $ q ; $ queue [ $ tail ] = [ $ p_name , $ remaining ] ; if ( $ tail == $ n ) $ tail = 0 ; else $ tail ++ ; } } print $ ans ;",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; list ( $ n , $ q ) = explode ( \" \" , trim ( fgets ( $ input ) ) ) ; $ n = ( int ) $ n ; $ q = ( int ) $ q ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { list ( $ name_i , $ time_i ) = explode ( \" \" , trim ( fgets ( $ input ) ) ) ; $ time_i = ( int ) $ time_i ; $ queue [ ] = [ $ name_i , $ time_i ] ; } $ head = 0 ; $ tail = $ n ; $ elapsed = 0 ; $ ans = \" \" ; while ( $ head != $ tail ) { list ( $ p_name , $ remaining ) = $ queue [ $ head ] ; if ( $ head == $ n ) $ head = 0 ; else $ head ++ ; if ( $ remaining <= $ q ) { $ elapsed += $ remaining ; $ ans .= \" { $ p_name } { $ elapsed } \\n \" ; } else { $ elapsed += $ q ; $ remaining -= $ q ; $ queue [ $ tail ] = [ $ p_name , $ remaining ] ; if ( $ tail == $ n ) $ tail = 0 ; else $ tail ++ ; } } print $ ans ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ process_count , $ quantum ) ; $ queue = [ ] ; $ head = 0 ; $ tail = 0 ; for ( $ i = 0 ; $ i < $ process_count ; $ i ++ ) $ queue [ $ tail ++ ] = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ total_time = 0 ; while ( $ head != $ tail ) { $ tmp = $ queue [ $ head ++ ] ; if ( $ tmp [ 1 ] <= $ quantum ) { $ total_time += $ tmp [ 1 ] ; $ tmp [ 1 ] = $ total_time ; echo ( \" $ tmp [ 0 ] $ tmp [ 1 ] \\n \" ) ; continue ; } $ tmp [ 1 ] -= $ quantum ; $ queue [ $ tail ++ ] = $ tmp ; $ total_time += $ quantum ; }",
    "label": 3
  },
  {
    "code": "<?php class Queue { private $ q ; private $ head ; private $ tail ; private $ max ; public function __construct ( $ max ) { $ this -> q = array ( ) ; $ this -> head = 0 ; $ this -> tail = 0 ; $ this -> max = $ max ; $ this -> count = 0 ; } public function isFull ( ) { return $ this -> count >= $ this -> max ; } public function isEmpty ( ) { return $ this -> count == 0 ; } public function enqueue ( $ v ) { if ( $ this -> isFull ( ) ) { echo \" The queue is full. \\n \" ; return false ; } $ this -> q [ $ this -> tail ] = $ v ; if ( $ this -> tail + 1 == $ this -> max ) { $ this -> tail = 0 ; } else { $ this -> tail ++ ; } $ this -> count ++ ; } public function dequeue ( ) { if ( $ this -> isEmpty ( ) ) { echo \" The queue is empty. \\n \" ; return false ; } $ x = $ this -> q [ $ this -> head ] ; if ( $ this -> head + 1 == $ this -> max ) { $ this -> head = 0 ; } else { $ this -> head ++ ; } $ this -> count -- ; return $ x ; } public function getQ ( ) { return $ this -> q ; } public function getHead ( ) { return $ this -> head ; } public function getTail ( ) { return $ this -> tail ; } public function getMax ( ) { return $ this -> max ; } public function getCount ( ) { return $ this -> count ; } public function setQ ( $ q ) { return $ this -> q = $ q ; } public function setHead ( $ head ) { return $ this -> head = $ head ; } public function setTail ( $ tail ) { return $ this -> tail = $ tail ; } public function setMax ( $ max ) { return $ this -> max = $ max ; } public function setCount ( $ count ) { return $ this -> count = $ count ; } public function setNewProcess ( $ sec ) { $ this -> q [ $ this -> head ] [ ' sec ' ] = $ sec ; } } fscanf ( STDIN , \" %d %d \" , $ n , $ quantum ) ; $ processes = new Queue ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %s %d \" , $ name , $ sec ) ; $ processes -> enqueue ( array ( ' name ' => $ name , ' sec ' => $ sec ) ) ; } $ requiredSec = 0 ; while ( $ processes -> getCount ( ) != 0 ) { $ sec = $ processes -> getQ ( ) [ $ processes -> getHead ( ) ] [ ' sec ' ] ; $ remainingSec = $ sec - $ quantum ; if ( $ remainingSec <= 0 ) { $ requiredSec += $ sec ; $ x = $ processes -> dequeue ( ) ; echo $ x [ ' name ' ] . \" \" . $ requiredSec ; if ( ! $ processes -> isEmpty ( ) ) { echo \" \\n \" ; } } else { $ requiredSec += $ quantum ; $ processes -> setNewProcess ( $ processes -> getQ ( ) [ $ processes -> getHead ( ) ] [ ' sec ' ] - $ quantum ) ; $ x = $ processes -> dequeue ( ) ; $ processes -> enqueue ( $ x ) ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php class Simulator { public $ queue = array ( ) ; public $ n_processes ; public $ quantum ; public function __construct ( ) { fscanf ( STDIN , \" %s %d \" , $ this -> n_processes , $ this -> quantum ) ; $ n = $ this -> n_processes ; while ( $ n > 0 ) { fscanf ( STDIN , \" %s %d \" , $ name , $ time ) ; $ this -> queue [ ] = [ ' name ' => $ name , ' time ' => $ time ] ; $ n -= 1 ; } } public function executeProcess ( ) { $ time_count = 0 ; while ( count ( $ this -> queue ) > 0 ) { $ queue_rest = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> queue ) ; $ i ++ ) { $ process = $ this -> queue [ $ i ] ; if ( $ process [ ' time ' ] - $ this -> quantum <= 0 ) { $ time_count += $ process [ ' time ' ] ; echo $ process [ ' name ' ] . ' ' . $ time_count . \" \\n \" ; continue ; } else { $ process [ ' time ' ] -= $ this -> quantum ; $ queue_rest [ ] = $ process ; $ time_count += $ this -> quantum ; } } $ this -> queue = $ queue_rest ; } } } $ answer = new Simulator ( ) ; $ answer -> executeProcess ( ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ n , $ q ) ; $ queue = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { fscanf ( STDIN , \" %s %d \" , $ name , $ time ) ; $ queue [ ] = array ( ' name ' => $ name , ' time ' => $ time , ) ; } $ current = 0 ; while ( count ( $ queue ) > 0 ) { $ queue_next = array ( ) ; for ( $ i = 0 ; $ i < count ( $ queue ) ; $ i ++ ) { $ process = $ queue [ $ i ] ; if ( $ process [ ' time ' ] - $ q <= 0 ) { $ current += $ process [ ' time ' ] ; echo $ process [ ' name ' ] . \" $ current \\n \" ; continue ; } $ current += $ q ; $ process [ ' time ' ] -= $ q ; $ queue_next [ ] = $ process ; } $ queue = $ queue_next ; }",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } class Process { public $ name ; public $ time ; public function __construct ( $ name , $ time ) { $ this -> name = $ name ; $ this -> time = $ time ; } } class Queue { private $ _size ; private $ _queue ; private $ _head ; private $ _tail ; public function __construct ( $ size ) { $ this -> _size = $ size ; $ this -> _queue = array_fill ( 0 , $ size , null ) ; $ this -> _head = 0 ; $ this -> _tail = 0 ; } public function isEmpty ( ) { return $ this -> _head === $ this -> _tail ; } public function enqueue ( $ x ) { $ this -> _queue [ $ this -> _tail ] = $ x ; $ this -> _tail = ( $ this -> _tail + 1 ) % $ this -> _size ; } public function dequeue ( ) { $ x = $ this -> _queue [ $ this -> _head ] ; $ this -> _head = ( $ this -> _head + 1 ) % $ this -> _size ; return $ x ; } } list ( $ n , $ q ) = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; $ Q = new Queue ( $ n + 5 ) ; for ( $ _ = 0 ; $ _ < $ n ; $ _ ++ ) { list ( $ name , $ time ) = input_array ( ) ; $ Q -> enqueue ( new Process ( $ name , $ time ) ) ; } $ elaps = 0 ; while ( ! $ Q -> isEmpty ( ) ) { $ u = $ Q -> dequeue ( ) ; $ c = min ( $ q , $ u -> time ) ; $ u -> time -= $ c ; $ elaps += $ c ; if ( $ u -> time > 0 ) { $ Q -> enqueue ( $ u ) ; } else { echo ( $ u -> name ) . ' ' . $ elaps . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ dll = new \\ SplDoublyLinkedList ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line [ 0 ] === ' i ' ) { $ dll -> unshift ( substr ( $ line , 7 ) ) ; } elseif ( $ line [ 6 ] === ' F ' ) { $ dll -> shift ( ) ; } elseif ( $ line [ 6 ] === ' L ' ) { $ dll -> pop ( ) ; } else { $ check = substr ( $ line , 7 ) ; foreach ( $ dll as $ key => $ val ) { if ( $ val === $ check ) { $ dll -> offsetUnset ( $ key ) ; break ; } } } } $ str = array ( ) ; while ( true ) { try { $ val = $ dll -> shift ( ) ; $ str [ ] = $ val ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } }",
    "label": 3
  },
  {
    "code": "<?php class Simulator { public $ queue = array ( ) ; public $ n_processes ; public $ quantum ; public $ dll2 ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ n ) ; $ dll = new \\ SplDoublyLinkedList ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line [ 0 ] === ' i ' ) { $ dll -> unshift ( substr ( $ line , 7 ) ) ; } elseif ( $ line [ 6 ] === ' F ' ) { $ dll -> shift ( ) ; } elseif ( $ line [ 6 ] === ' L ' ) { $ dll -> pop ( ) ; } else { $ check = substr ( $ line , 7 ) ; foreach ( $ dll as $ key => $ val ) { if ( $ val === $ check ) { $ dll -> offsetUnset ( $ key ) ; break ; } } } } $ this -> dll2 = $ dll ; } public function getAnswer ( ) { $ str = array ( ) ; $ dll = $ this -> dll2 ; while ( true ) { try { $ val = $ dll -> shift ( ) ; $ str [ ] = $ val ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } } } } $ answer = new Simulator ( ) ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { public $ line = array ( ) ; public $ n_operations ; public $ quantum ; public $ dll2 ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> n_operations ) ; $ dll = new \\ SplDoublyLinkedList ( ) ; for ( $ i = 0 ; $ i < $ this -> n_operations ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line [ 0 ] === ' i ' ) { $ dll -> unshift ( substr ( $ line , 7 ) ) ; } elseif ( $ line [ 6 ] === ' F ' ) { $ dll -> shift ( ) ; } elseif ( $ line [ 6 ] === ' L ' ) { $ dll -> pop ( ) ; } else { $ check = substr ( $ line , 7 ) ; foreach ( $ dll as $ key => $ val ) { if ( $ val === $ check ) { $ dll -> offsetUnset ( $ key ) ; break ; } } } } $ this -> dll2 = $ dll ; } public function getAnswer ( ) { $ str = array ( ) ; $ dll = $ this -> dll2 ; while ( true ) { try { $ val = $ dll -> shift ( ) ; $ str [ ] = $ val ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } } } } $ answer = new Simulator ( ) ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { public $ word = array ( ) ; public $ n_operations ; public $ operations2 ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> n_operations ) ; $ operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> n_operations > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ operations -> pop ( ) ; } else { foreach ( $ operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> n_operations -= 1 ; } $ this -> dll2 = $ operations ; } public function getAnswer ( ) { $ str = array ( ) ; $ operations = $ this -> dll2 ; while ( true ) { try { $ element = $ operations -> shift ( ) ; $ str [ ] = $ element ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } } } } $ answer = new Simulator ( ) ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { public $ word = array ( ) ; public $ n_operations ; public $ operations ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> n_operations ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> n_operations > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> n_operations -= 1 ; } $ this -> dll2 = $ this -> operations ; } public function getAnswer ( ) { $ str = array ( ) ; $ this -> operations = $ this -> dll2 ; while ( true ) { try { $ element = $ this -> operations -> shift ( ) ; $ str [ ] = $ element ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } } } } $ answer = new Simulator ( ) ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { public $ array = array ( ) ; public $ n_operations ; public $ operations ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> n_operations ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> n_operations > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> n_operations -= 1 ; } } public function getAnswer ( ) { $ str = array ( ) ; while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ array [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ array ) , PHP_EOL ; } } $ answer = new Simulator ( ) ; $ answer -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { public $ n_operations ; public $ operations ; public $ keys_operated = array ( ) ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> n_operations ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> n_operations > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> n_operations -= 1 ; } } public function getAnswer ( ) { while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { public $ operations ; public $ n_operations ; public $ keys_operated = array ( ) ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> n_operations ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> n_operations > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> n_operations -= 1 ; } } public function getAnswer ( ) { while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function __construct ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> operations_count > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> operations_count -= 1 ; } } public function getAnswer ( ) { while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; while ( $ this -> operations_count > 0 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } $ this -> operations_count -= 1 ; } } public function getAnswer ( ) { while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ word = trim ( fgets ( STDIN ) ) ; if ( $ word [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ word , 7 ) ) ; } elseif ( $ word [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ word [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ word , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = trim ( fgets ( STDIN ) ) ; if ( $ operation [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ operation , 7 ) ) ; } elseif ( $ operation [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ operation [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ operation , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = trim ( fgets ( STDIN ) ) ; if ( $ operation [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ operation , 7 ) ) ; } elseif ( $ operation [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ operation [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ operation , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = trim ( fgets ( STDIN ) ) ; if ( $ operation [ 0 ] === ' i ' ) { $ this -> operations -> unshift ( substr ( $ operation , 7 ) ) ; } elseif ( $ operation [ 6 ] === ' F ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ operation [ 6 ] === ' L ' ) { $ this -> operations -> pop ( ) ; } else { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === substr ( $ operation , 7 ) ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> operations -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> operations -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( 1 ) { if ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } else { break ; } } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operations = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> operations -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> operations -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> operations -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> operations as $ key => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> operations -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( count ( $ this -> operations ) > 0 ) { $ keys_operated [ ] = $ this -> operations -> shift ( ) ; } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operations ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> linked_list = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> linked_list -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> linked_list -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> linked_list -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> linked_list as $ key => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> linked_list -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( count ( $ this -> linked_list ) > 0 ) { $ keys_operated [ ] = $ this -> linked_list -> shift ( ) ; } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ linked_list ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> linked_list = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> linked_list -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> linked_list -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> linked_list -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> linked_list as $ key => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> linked_list -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( count ( $ this -> linked_list ) > 0 ) { $ keys_operated [ ] = $ this -> linked_list -> shift ( ) ; } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ linked_list ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> linked_list = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> linked_list -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> linked_list -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> linked_list -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> linked_list as $ key => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> linked_list -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( count ( $ this -> linked_list ) > 0 ) { $ keys_operated [ ] = $ this -> linked_list -> shift ( ) ; } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operated_keys ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operated_keys = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> operated_keys -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> operated_keys -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> operated_keys -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> operated_keys as $ key => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> operated_keys -> offsetUnset ( $ key ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( count ( $ this -> operated_keys ) > 0 ) { $ keys_operated [ ] = $ this -> operated_keys -> shift ( ) ; } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Operator { private $ operated_keys ; private $ operations_count ; public function doOperations ( ) { fscanf ( STDIN , ' %d ' , $ this -> operations_count ) ; $ this -> operated_keys = new \\ SplDoublyLinkedList ( ) ; for ( ; $ this -> operations_count > 0 ; $ this -> operations_count -= 1 ) { $ operation = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; if ( $ operation [ 0 ] === ' insert ' ) { $ this -> operated_keys -> unshift ( $ operation [ 1 ] ) ; } elseif ( $ operation [ 0 ] === ' deleteFirst ' ) { $ this -> operated_keys -> shift ( ) ; } elseif ( $ operation [ 0 ] === ' deleteLast ' ) { $ this -> operated_keys -> pop ( ) ; } elseif ( $ operation [ 0 ] === ' delete ' ) { foreach ( $ this -> operated_keys as $ index => $ element ) { if ( $ element === $ operation [ 1 ] ) { $ this -> operated_keys -> offsetUnset ( $ index ) ; break ; } } } } } public function getAnswer ( ) { $ keys_operated = array ( ) ; while ( count ( $ this -> operated_keys ) > 0 ) { $ keys_operated [ ] = $ this -> operated_keys -> shift ( ) ; } echo implode ( ' ' , $ keys_operated ) , PHP_EOL ; } } $ operator = new Operator ( ) ; $ operator -> doOperations ( ) ; $ operator -> getAnswer ( ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ dll = new \\ splDoublyLinkedList ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line [ 0 ] === ' i ' ) { $ dll -> unshift ( substr ( $ line , 7 ) ) ; } elseif ( $ line [ 6 ] === ' F ' ) { $ dll -> shift ( ) ; } elseif ( $ line [ 6 ] === ' L ' ) { $ dll -> pop ( ) ; } else { $ check = substr ( $ line , 7 ) ; foreach ( $ dll as $ key => $ val ) { if ( $ val === $ check ) { $ dll -> offsetUnset ( $ key ) ; break ; } } } } $ str = array ( ) ; while ( true ) { try { $ val = $ dll -> shift ( ) ; $ str [ ] = $ val ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ dll = new \\ SplDoublyLinkedList ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; if ( $ line [ 0 ] === ' i ' ) { $ dll -> unshift ( substr ( $ line , 7 ) ) ; } elseif ( $ line [ 6 ] === ' F ' ) { $ dll -> shift ( ) ; } elseif ( $ line [ 6 ] === ' L ' ) { $ dll -> pop ( ) ; } else { $ check = substr ( $ line , 7 ) ; foreach ( $ dll as $ key => $ val ) { if ( $ val === $ check ) { $ dll -> offsetUnset ( $ key ) ; break ; } } } } $ str = array ( ) ; while ( true ) { try { $ val = $ dll -> shift ( ) ; $ str [ ] = $ val ; } catch ( Exception $ e ) { echo implode ( ' ' , $ str ) , PHP_EOL ; break ; } }",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" memory_limit \" , \" -1 \" ) ; $ input = STDIN ; $ n = ( int ) trim ( fgets ( $ input ) ) ; $ keys = array_fill ( 0 , 2000000 , 0 ) ; $ head = 1 ; $ tail = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ command = trim ( fgets ( $ input ) ) ; if ( $ command [ 0 ] == \" i \" ) { $ keys [ $ head ++ ] = substr ( $ command , 7 ) ; } else { switch ( $ command [ 6 ] ) { case \" F \" : -- $ head ; break ; case \" L \" : ++ $ tail ; break ; default : $ x = substr ( $ command , 7 ) ; $ keys [ $ tail ] = $ x ; $ idx = $ head ; while ( $ keys [ -- $ idx ] != $ x ) { } if ( $ idx != $ tail ) { if ( $ idx - $ tail < $ head - $ idx ) { ++ $ tail ; for ( $ j = $ idx ; $ j > $ tail ; $ j -- ) { $ keys [ $ j ] = $ keys [ $ j - 1 ] ; } } else { -- $ head ; for ( $ j = $ idx ; $ j < $ head ; $ j ++ ) { $ keys [ $ j ] = $ keys [ $ j + 1 ] ; } } } } } } $ reversed_keys = array_slice ( $ keys , $ tail + 1 , $ head - $ tail - 1 ) ; print implode ( \" \" , array_reverse ( $ reversed_keys ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" memory_limit \" , \" -1 \" ) ; $ input = STDIN ; $ n = ( int ) trim ( fgets ( $ input ) ) ; $ keys = array_fill ( 0 , 2000000 , 0 ) ; $ head = 1 ; $ tail = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ command = trim ( fgets ( $ input ) ) ; if ( $ command [ 0 ] == \" i \" ) { $ keys [ $ head ++ ] = substr ( $ command , 7 ) ; } else { switch ( $ command [ 6 ] ) { case \" F \" : -- $ head ; break ; case \" L \" : ++ $ tail ; break ; default : $ x = substr ( $ command , 7 ) ; $ keys [ $ tail ] = $ x ; $ idx = $ head ; while ( $ keys [ -- $ idx ] != $ x ) { } if ( $ idx != $ tail ) { if ( $ idx - $ tail < $ head - $ idx ) { ++ $ tail ; for ( $ j = $ idx ; $ j > $ tail ; $ j -- ) { $ keys [ $ j ] = $ keys [ $ j - 1 ] ; } } else { -- $ head ; for ( $ j = $ idx ; $ j < $ head ; $ j ++ ) { $ keys [ $ j ] = $ keys [ $ j + 1 ] ; } } } } } } $ reversed_keys = array_slice ( $ keys , $ tail + 1 , $ head - $ tail - 1 ) ; print implode ( \" \" , array_reverse ( $ reversed_keys ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ N = intval ( trim ( fgets ( STDIN ) ) ) ; $ A = new SplDoublyLinkedList ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ arr = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ c = $ arr [ 0 ] ; $ v = count ( $ arr ) > 1 ? $ arr [ 1 ] : ' ' ; switch ( $ c ) { case ' insert ' : $ A -> unshift ( $ v ) ; break ; case ' delete ' : $ index = 0 ; for ( $ A -> rewind ( ) ; $ A -> valid ( ) ; $ A -> next ( ) ) { if ( $ A -> current ( ) == $ v ) { $ A -> offsetUnset ( $ index ) ; break ; } $ index ++ ; } break ; case ' deleteFirst ' : $ A -> shift ( ) ; break ; case ' deleteLast ' : $ A -> pop ( ) ; break ; default : # code... break; } } $need = false; for($A->rewind();$A->valid();$A->next()){ if ($need) { echo \" \"; } else { $need = true; } echo $A->current(); } ?>",
    "label": 3
  },
  {
    "code": "<?php class Simulator { private $ inputs ; private $ backslash = array ( ) ; private $ area_pond = array ( ) ; private $ pending_area = array ( ) ; public function __construct ( ) { $ this -> inputs = trim ( fgets ( STDIN ) ) ; } public function calculateAreas ( ) { $ count = 0 ; for ( $ index = 0 ; $ index < strlen ( $ this -> inputs ) ; $ index ++ ) { if ( $ this -> inputs [ $ index ] == \" \\\\ \" ) { $ this -> backslash [ ] = $ index ; } elseif ( $ this -> inputs [ $ index ] == \" / \" and $ this -> backslash ) { $ last_bs_index = array_pop ( $ this -> backslash ) ; $ diff = $ index - $ last_bs_index ; $ count += $ diff ; while ( $ this -> area_pond and end ( $ this -> area_pond ) > $ last_bs_index ) { $ diff += array_pop ( $ this -> pending_area ) ; array_pop ( $ this -> area_pond ) ; } $ this -> area_pond [ ] = $ last_bs_index ; $ this -> pending_area [ ] = $ diff ; } } echo $ count . PHP_EOL ; echo implode ( \" \" , array_merge ( [ count ( $ this -> area_pond ) ] , $ this -> pending_area ) ) . PHP_EOL ; } } $ simulator = new Simulator ( ) ; $ simulator -> calculateAreas ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { private $ inputs ; private $ backslash = array ( ) ; private $ area_pond = array ( ) ; private $ pending_area = array ( ) ; public function __construct ( ) { $ this -> inputs = trim ( fgets ( STDIN ) ) ; } public function calculateAreas ( ) { $ count = 0 ; for ( $ index = 0 ; $ index < strlen ( $ this -> inputs ) ; $ index ++ ) { if ( $ this -> inputs [ $ index ] == \" \\\\ \" ) { $ this -> backslash [ ] = $ index ; } elseif ( $ this -> inputs [ $ index ] == \" / \" and $ this -> backslash ) { $ last_bs_index = array_pop ( $ this -> backslash ) ; $ diff = $ index - $ last_bs_index ; $ count += $ diff ; while ( $ this -> area_pond and end ( $ this -> area_pond ) > $ last_bs_index ) { $ diff += array_pop ( $ this -> pending_area ) ; array_pop ( $ this -> area_pond ) ; } $ this -> area_pond [ ] = $ last_bs_index ; $ this -> pending_area [ ] = $ diff ; } } echo $ count . PHP_EOL ; echo implode ( \" \" , array_merge ( [ count ( $ this -> area_pond ) ] , $ this -> pending_area ) ) . PHP_EOL ; } } $ simulator = new Simulator ( ) ; $ simulator -> calculateAreas ( ) ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { private $ inputs ; private $ backslash = array ( ) ; private $ area_pond = array ( ) ; private $ pending_area = array ( ) ; public function __construct ( ) { $ this -> inputs = trim ( fgets ( STDIN ) ) ; } public function calculateAreas ( ) { $ count = 0 ; for ( $ index = 0 ; $ index < strlen ( $ this -> inputs ) ; $ index ++ ) { if ( $ this -> inputs [ $ index ] == \" \\\\ \" ) { $ this -> backslash [ ] = $ index ; } elseif ( $ this -> inputs [ $ index ] == \" / \" and $ this -> backslash ) { $ last_bs_index = array_pop ( $ this -> backslash ) ; $ diff = $ index - $ last_bs_index ; $ count += $ diff ; while ( $ this -> area_pond and end ( $ this -> area_pond ) > $ last_bs_index ) { $ diff += array_pop ( $ this -> pending_area ) ; array_pop ( $ this -> area_pond ) ; } $ this -> area_pond [ ] = $ last_bs_index ; $ this -> pending_area [ ] = $ diff ; } } echo $ count . PHP_EOL ; echo implode ( \" \" , array_merge ( [ count ( $ this -> area_pond ) ] , $ this -> pending_area ) ) . PHP_EOL ; } } $ simulator = new Simulator ( ) ; $ simulator -> calculateAreas ( ) ;",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; $ slopes = trim ( fgets ( $ input ) ) ; $ down = [ ] ; $ areas = [ ] ; $ left_edges = [ ] ; foreach ( str_split ( $ slopes ) as $ pos => $ slope ) { if ( $ slope === \" \\\\ \" ) { $ down [ ] = $ pos ; } elseif ( $ slope === \" / \" && $ down ) { $ left_edge = array_pop ( $ down ) ; $ area = $ pos - $ left_edge ; while ( $ areas && $ left_edge < end ( $ left_edges ) ) { $ pre_area = array_pop ( $ areas ) ; array_pop ( $ left_edges ) ; $ area += $ pre_area ; } array_push ( $ areas , $ area ) ; array_push ( $ left_edges , $ left_edge ) ; } } print array_sum ( $ areas ) . \" \\n \" ; array_unshift ( $ areas , count ( $ areas ) ) ; print implode ( \" \" , $ areas ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php class Simulator { private $ inputs ; private $ backslash = array ( ) ; private $ area_pond = array ( ) ; private $ pending_area = array ( ) ; public function __construct ( ) { $ this -> inputs = trim ( fgets ( STDIN ) ) ; } public function calculateAreas ( ) { $ count = 0 ; for ( $ index = 0 ; $ index < strlen ( $ this -> inputs ) ; $ index ++ ) { if ( $ this -> inputs [ $ index ] == \" \\\\ \" ) { $ this -> backslash [ ] = $ index ; } elseif ( $ this -> inputs [ $ index ] == \" / \" and $ this -> backslash ) { $ last_bs_index = array_pop ( $ this -> backslash ) ; $ diff = $ index - $ last_bs_index ; $ count += $ diff ; while ( $ this -> area_pond and end ( $ this -> area_pond ) > $ last_bs_index ) { $ diff += array_pop ( $ this -> pending_area ) ; array_pop ( $ this -> area_pond ) ; } $ this -> area_pond [ ] = $ last_bs_index ; $ this -> pending_area [ ] = $ diff ; } } echo $ count . PHP_EOL ; echo implode ( \" \" , array_merge ( [ count ( $ this -> area_pond ) ] , $ this -> pending_area ) ) . PHP_EOL ; } } $ simulator = new Simulator ( ) ; $ simulator -> calculateAreas ( ) ;",
    "label": 3
  },
  {
    "code": "<?php $ lengthA = ( int ) fgets ( STDIN ) ; $ stdinA = explode ( \" \" , fgets ( STDIN ) ) ; $ lengthKey = ( int ) fgets ( STDIN ) ; $ stdinKey = explode ( \" \" , fgets ( STDIN ) ) ; $ count = 0 ; for ( $ j = 0 ; $ j < $ lengthKey ; ++ $ j ) { $ result = linearSearch ( $ stdinA , $ stdinKey [ $ j ] , $ lengthA ) ; if ( $ result == 1 ) { $ count ++ ; } } echo $ count . PHP_EOL ; function linearSearch ( $ stdin , $ key , $ N ) { $ i = 0 ; while ( ( int ) $ stdin [ $ i ] != ( int ) $ key ) { $ i ++ ; if ( $ i === $ N ) { return 0 ; } } return 1 ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr1 = array ( ) ; $ arr2 = array ( ) ; $ count = 0 ; fscanf ( STDIN , ' %d ' , $ n1 ) ; $ temp_arr1 = fgets ( STDIN ) ; $ temp_arr1 = trim ( $ temp_arr1 ) ; $ arr1 = explode ( ' ' , $ temp_arr1 ) ; fscanf ( STDIN , ' %d ' , $ n2 ) ; $ arr2 = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; foreach ( $ arr2 as $ a ) { if ( in_array ( $ a , $ arr1 ) ) { $ count ++ ; } } echo $ count . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ S = array_unique ( explode ( ' ' , $ line ) ) ; fscanf ( STDIN , ' %d ' , $ q ) ; $ line = trim ( fgets ( STDIN ) ) ; $ T = explode ( ' ' , $ line ) ; echo count ( array_intersect ( $ S , $ T ) ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ fline = trim ( fgets ( STDIN ) ) ; $ fnum = trim ( fgets ( STDIN ) ) ; $ farray = explode ( ' ' , $ fnum ) ; $ sline = trim ( fgets ( STDIN ) ) ; $ snum = trim ( fgets ( STDIN ) ) ; $ sarray = explode ( ' ' , $ snum ) ; $ scount = 0 ; foreach ( $ sarray as $ skey => $ svalue ) { foreach ( $ farray as $ fkey => $ fvalue ) { if ( $ svalue == $ fvalue ) { $ scount ++ ; break ; } } } echo $ scount , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ S = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ q = ( int ) trim ( fgets ( STDIN ) ) ; $ T = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; print count ( array_intersect ( $ T , $ S ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ num_count ) ; $ target_num = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; fscanf ( STDIN , \" %d \" , $ search_count ) ; $ keys = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ count = 0 ; foreach ( $ keys as $ key ) { if ( in_array ( $ key , $ target_num ) ) ++ $ count ; } echo $ count , \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ sLen = intval ( trim ( fgets ( STDIN ) ) ) ; $ s = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ tLen = intval ( trim ( fgets ( STDIN ) ) ) ; $ t = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ count = 0 ; for ( $ j = 0 ; $ j < $ tLen ; $ j ++ ) { $ i = 0 ; $ s [ $ sLen ] = $ t [ $ j ] ; while ( $ s [ $ i ] !== $ t [ $ j ] ) { $ i ++ ; } if ( $ i !== $ sLen ) { $ count ++ ; } } echo $ count . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ S = array_unique ( explode ( ' ' , $ line ) ) ; fscanf ( STDIN , ' %d ' , $ q ) ; $ line = trim ( fgets ( STDIN ) ) ; $ T = explode ( ' ' , $ line ) ; echo count ( array_intersect ( $ S , $ T ) ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } function search ( $ A , $ key ) { $ i = 0 ; $ count = count ( $ A ) ; $ A [ $ count ] = $ key ; while ( $ A [ $ i ] !== $ key ) $ i ++ ; return $ i !== $ count ; } input ( ) ; $ A = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; input ( ) ; echo array_sum ( array_map ( function ( $ key ) use ( $ A ) { return ( int ) search ( $ A , ( int ) $ key ) ; } , input_array ( ) ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php $ lengthA = ( int ) fgets ( STDIN ) ; $ stdinA = explode ( \" \" , fgets ( STDIN ) ) ; $ lengthKey = ( int ) fgets ( STDIN ) ; $ stdinKey = explode ( \" \" , fgets ( STDIN ) ) ; $ count = 0 ; for ( $ j = 0 ; $ j < $ lengthKey ; ++ $ j ) { $ result = BinarySearch ( $ lengthA , $ stdinA , $ stdinKey [ $ j ] ) ; if ( $ result == 1 ) { $ count ++ ; } } echo $ count . PHP_EOL ; function BinarySearch ( $ N , $ A , $ key ) { $ left = 0 ; $ right = $ N ; while ( $ left < $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( ( int ) $ A [ $ mid ] == ( int ) $ key ) { return 1 ; } if ( ( int ) $ key < ( int ) $ A [ $ mid ] ) { $ right = $ mid ; } else { $ left = $ mid + 1 ; } } return 0 ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr1 = array ( ) ; $ arr2 = array ( ) ; $ count = 0 ; fscanf ( STDIN , ' %d ' , $ n1 ) ; $ temp_arr1 = fgets ( STDIN ) ; $ temp_arr1 = trim ( $ temp_arr1 ) ; $ arr1 = explode ( ' ' , $ temp_arr1 ) ; fscanf ( STDIN , ' %d ' , $ n2 ) ; $ arr2 = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ count = 0 ; foreach ( $ arr2 as $ a ) { $ left = 0 ; $ right = $ n1 ; $ a = ( int ) $ a ; while ( $ left < $ right ) { $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; $ b = ( int ) $ arr1 [ $ mid ] ; if ( $ b === $ a ) { $ count ++ ; break ; } else if ( $ b < $ a ) { $ left = $ mid + 1 ; } else { $ right = $ mid ; } } } echo $ count . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ S = explode ( ' ' , $ line ) ; fscanf ( STDIN , ' %d ' , $ q ) ; $ line = trim ( fgets ( STDIN ) ) ; $ T = explode ( ' ' , $ line ) ; $ result = 0 ; foreach ( $ T as $ t ) { $ left = 0 ; $ right = $ n ; $ t = ( int ) $ t ; $ test = 0 ; while ( $ left < $ right ) { $ i = ( int ) ( ( $ left + $ right ) / 2 ) ; $ s = ( int ) $ S [ $ i ] ; if ( $ s === $ t ) { $ result ++ ; break ; } elseif ( $ s < $ t ) { $ left = $ i + 1 ; } else { $ right = $ i ; } } } echo $ result , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ S = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; fscanf ( STDIN , \" %d \" , $ q ) ; $ T = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) { if ( search ( $ n , $ S , $ T [ $ i ] ) ) { $ ans ++ ; } else { } } echo $ ans . PHP_EOL ; function search ( $ n , $ S , $ a ) { $ ret = null ; $ l = 0 ; $ r = $ n - 1 ; if ( $ S [ $ l ] == $ a || $ S [ $ r ] == $ a ) { return true ; } while ( is_null ( $ ret ) ) { $ m = ceil ( ( $ l + $ r ) / 2 ) ; if ( $ l == $ m || $ r == $ m ) { return false ; } if ( $ S [ $ m ] == $ a ) { return true ; } elseif ( $ S [ $ m ] > $ a ) { $ r = $ m ; } else { $ l = $ m ; } } }",
    "label": 3
  },
  {
    "code": "<?php $ num_a = intval ( trim ( fgets ( STDIN ) ) ) ; $ array_a = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ num_b = intval ( trim ( fgets ( STDIN ) ) ) ; $ array_b = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; for ( $ i = 0 ; $ i < $ num_b ; $ i ++ ) { $ left = 0 ; $ right = count ( $ array_a ) - 1 ; while ( $ left <= $ right ) { $ mid = floor ( ( $ left + $ right ) / 2 ) ; if ( $ array_a [ $ mid ] == $ array_b [ $ i ] ) { $ flg [ $ i ] = 1 ; $ ans [ ] = $ array_b [ $ i ] ; break ; } elseif ( $ array_b [ $ i ] < $ array_a [ $ mid ] ) { $ right = $ mid - 1 ; } else { $ left = $ mid + 1 ; } } } echo array_sum ( $ flg ) . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ n ) ; $ S = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; fscanf ( STDIN , \" %d \" , $ q ) ; $ T = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ q ; ++ $ i ) { $ l = 0 ; $ r = $ n ; $ flg = false ; while ( $ r - $ l >= 1 ) { $ mid = floor ( ( $ l + $ r ) / 2 ) ; if ( $ S [ $ mid ] === $ T [ $ i ] ) { $ flg = true ; break ; } else if ( $ T [ $ i ] < $ S [ $ mid ] ) { $ r = $ mid ; } else { $ l = $ mid + 1 ; } } $ cnt += $ flg ? 1 : 0 ; } echo $ cnt , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ S = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ q = ( int ) trim ( fgets ( STDIN ) ) ; $ T = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; sort ( $ S ) ; $ cnt = 0 ; foreach ( $ T as $ t ) { $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; $ diff = $ t - $ S [ $ mid ] ; if ( $ diff == 0 ) { $ cnt ++ ; break ; } elseif ( $ diff > 0 ) { $ left = $ mid + 1 ; } else { $ right = $ mid - 1 ; } } } print \" { $ cnt } \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ num_count ) ; $ target_num = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; fscanf ( STDIN , \" %d \" , $ search_count ) ; $ keys = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ count = 0 ; foreach ( $ keys as $ key ) { if ( binary_search ( $ target_num , $ key ) ) ++ $ count ; } echo $ count , \" \\n \" ; function binary_search ( $ target_num , $ key ) { $ left = 0 ; $ right = count ( $ target_num ) ; while ( $ left < $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ target_num [ $ mid ] == $ key ) return true ; elseif ( $ target_num [ $ mid ] > $ key ) $ right = $ mid ; else $ left = $ mid + 1 ; } return false ; }",
    "label": 3
  },
  {
    "code": "<?php $ sLen = intval ( trim ( fgets ( STDIN ) ) ) ; $ s = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ tLen = intval ( trim ( fgets ( STDIN ) ) ) ; $ t = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ count = 0 ; for ( $ j = 0 ; $ j < $ tLen ; $ j ++ ) { $ left = 0 ; $ right = $ sLen ; while ( $ left < $ right ) { $ mid = floor ( ( $ left + $ right ) / 2 ) ; if ( $ s [ $ mid ] === $ t [ $ j ] ) { $ count ++ ; break ; } else if ( $ s [ $ mid ] > $ t [ $ j ] ) { $ right = $ mid ; } else { $ left = $ mid + 1 ; } } } echo $ count . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php class Searcher { private $ n_array_S ; private $ array_S ; private $ n_array_T ; private $ array_T ; public function __construct ( ) { fscanf ( STDIN , \" %d \" , $ this -> n_array_S ) ; $ this -> array_S = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; fscanf ( STDIN , \" %d \" , $ this -> n_array_T ) ; $ this -> array_T = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; } public function countSameNumbers ( ) { echo count ( array_intersect ( array_unique ( $ this -> array_S ) , $ this -> array_T ) ) . PHP_EOL ; } } $ searcher = new Searcher ( ) ; $ searcher -> countSameNumbers ( ) ;",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } function binarySearch ( $ A , $ key ) { $ left = 0 ; $ right = count ( $ A ) ; while ( $ left < $ right ) { $ mid = floor ( ( $ left + $ right ) / 2 ) ; if ( $ key === $ A [ $ mid ] ) { return true ; } else if ( $ key > $ A [ $ mid ] ) { $ left = $ mid + 1 ; } else if ( $ key < $ A [ $ mid ] ) { $ right = $ mid ; } } return false ; } input ( ) ; $ A = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; input ( ) ; echo array_sum ( array_map ( function ( $ key ) use ( $ A ) { return ( int ) binarySearch ( $ A , ( int ) $ key ) ; } , input_array ( ) ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php myMain ( $ argv ) ; class Util { private static $ isDebug = false ; private static $ startTime ; public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" , \" , $ arr ) ; } public static function enablingDebug ( ) { self :: $ isDebug = true ; self :: $ startTime = time ( ) ; } public static function DebugLog ( $ text , $ isReturn = true ) { if ( self :: $ isDebug ) { echo $ text ; if ( $ isReturn ) { echo PHP_EOL ; } } } public static function varDump ( $ obj ) { if ( self :: $ isDebug ) { var_dump ( $ obj ) ; } } public static function arrFirst ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return current ( $ arr ) ; } public static function printBench ( ) { if ( ! self :: $ isDebug ) { return ; } echo sprintf ( \" Time: %.3f s \" . PHP_EOL , time ( ) - self :: $ startTime ) ; } } function myMain ( $ argv ) { if ( ! empty ( $ argv [ 1 ] ) ) { Util :: enablingDebug ( ) ; } list ( $ n , $ leastTrack ) = Util :: input ( true ) ; $ bList = [ ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ bList [ ] = Util :: input ( ) ; } $ left = max ( $ bList ) ; $ right = array_sum ( $ bList ) ; while ( $ right - $ left > 1 ) { $ mid = floor ( ( $ left + $ right ) / 2 ) ; if ( isOkP ( $ mid , $ leastTrack , $ bList ) ) { $ right = $ mid ; } else { $ left = $ mid ; } Util :: DebugLog ( $ left . \" \" . $ right ) ; } if ( isOkP ( $ left , $ leastTrack , $ bList ) ) { echo $ left . PHP_EOL ; } else { echo $ right . PHP_EOL ; } Util :: printBench ( ) ; } function isOkP ( $ p , $ leastTrack , $ bList ) { $ leastP = $ p ; foreach ( $ bList as $ b ) { if ( $ leastP >= $ b ) { $ leastP -= $ b ; continue ; } if ( $ leastTrack > 1 ) { $ leastTrack -= 1 ; $ leastP = $ p - $ b ; continue ; } return false ; } return true ; }",
    "label": 3
  },
  {
    "code": "<?php myMain ( $ argv ) ; class Util { private static $ isDebug = false ; private static $ startTime ; public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" , \" , $ arr ) ; } public static function enablingDebug ( ) { self :: $ isDebug = true ; self :: $ startTime = time ( ) ; } public static function DebugLog ( $ text , $ isReturn = true ) { if ( self :: $ isDebug ) { echo $ text ; if ( $ isReturn ) { echo PHP_EOL ; } } } public static function varDump ( $ obj ) { if ( self :: $ isDebug ) { var_dump ( $ obj ) ; } } public static function arrFirst ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return current ( $ arr ) ; } public static function printBench ( ) { if ( ! self :: $ isDebug ) { return ; } echo sprintf ( \" Time: %.3f s \" . PHP_EOL , time ( ) - self :: $ startTime ) ; } } function myMain ( $ argv ) { if ( ! empty ( $ argv [ 1 ] ) ) { Util :: enablingDebug ( ) ; } list ( $ n , $ leastTrack ) = Util :: input ( true ) ; $ bList = [ ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ bList [ ] = Util :: input ( ) ; } $ left = max ( $ bList ) ; $ right = array_sum ( $ bList ) ; while ( $ right - $ left > 1 ) { $ mid = floor ( ( $ left + $ right ) / 2 ) ; if ( isOkP ( $ mid , $ leastTrack , $ bList ) ) { $ right = $ mid ; } else { $ left = $ mid ; } Util :: DebugLog ( $ left . \" \" . $ right ) ; } if ( isOkP ( $ left , $ leastTrack , $ bList ) ) { echo $ left . PHP_EOL ; } else { echo $ right . PHP_EOL ; } Util :: printBench ( ) ; } function isOkP ( $ p , $ leastTrack , $ bList ) { $ leastP = $ p ; foreach ( $ bList as $ b ) { if ( $ leastP >= $ b ) { $ leastP -= $ b ; continue ; } if ( $ leastTrack > 1 ) { $ leastTrack -= 1 ; $ leastP = $ p - $ b ; continue ; } return false ; } return true ; }",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; list ( $ n , $ k ) = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( $ input ) ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ w [ ] = ( int ) trim ( fgets ( $ input ) ) ; } $ upper = array_sum ( $ w ) ; if ( $ k == 1 ) { print \" { $ upper } \\n \" ; } else { $ lower = max ( $ w ) ; while ( $ lower < $ upper ) { $ mid = ( int ) ( ( $ lower + $ upper ) / 2 ) ; $ num = 1 ; $ tmp_wt = 0 ; foreach ( $ w as $ w_i ) { if ( $ tmp_wt + $ w_i <= $ mid ) { $ tmp_wt += $ w_i ; } else { $ num ++ ; $ tmp_wt = $ w_i ; } if ( $ num > $ k ) break ; } if ( $ num > $ k ) { $ lower = ++ $ mid ; } else { $ upper = $ mid ; } } $ P = $ mid ; print \" { $ P } \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ n = ( int ) $ input [ 0 ] ; $ k = ( int ) $ input [ 1 ] ; $ ws = [ ] ; $ max = 0 ; for ( $ m = 0 ; $ m < $ n ; $ m ++ ) { $ input = ( int ) trim ( fgets ( STDIN ) ) ; $ ws [ ] = $ input ; $ max = max ( $ max , $ input ) ; } $ p_min = $ max ; $ p_max = 100000 * 10000 ; $ p = solve ( $ k , $ ws , $ p_min , $ p_max ) ; echo $ p . PHP_EOL ; function can ( $ p , $ array ) { $ sum = 0 ; $ len = count ( $ array ) ; $ tmp_sum = 0 ; $ check = [ ] ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ tmp_sum + $ array [ $ i ] > $ p ) { $ check [ ] = $ tmp_sum ; $ tmp_sum = $ array [ $ i ] ; ++ $ sum ; } else { $ tmp_sum += $ array [ $ i ] ; } if ( $ i === $ len - 1 ) { $ check [ ] = $ tmp_sum ; ++ $ sum ; break ; } } return $ sum ; } function solve ( $ k , $ array , $ p_min , $ p_max ) { $ left = $ p_min ; $ right = $ p_max ; $ min = $ right ; while ( $ left < $ right ) { $ mid = ( int ) floor ( ( $ left + $ right ) / 2 ) ; $ can = can ( $ mid , $ array ) ; if ( $ can <= $ k ) { $ min = min ( $ min , $ mid ) ; $ right = $ mid ; } else { $ left = $ mid + 1 ; } } return $ min ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ line = explode ( ' ' , $ line ) ; $ A = array_map ( function ( $ val ) { return ( int ) $ val ; } , $ line ) ; sort ( $ A ) ; $ sum = array_sum ( $ A ) ; fscanf ( STDIN , ' %d ' , $ q ) ; $ line = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ arr = array ( ) ; foreach ( $ line as $ l ) { $ l = ( int ) $ l ; if ( $ l > $ sum ) { echo \" no \\n \" ; $ arr [ $ l ] = false ; } elseif ( isset ( $ arr [ $ l ] ) ) { echo $ arr [ $ l ] ? \" yes \\n \" : \" no \\n \" ; } else { $ bool = cal ( 0 , $ l ) ; $ arr [ $ l ] = $ bool ; echo $ bool ? \" yes \\n \" : \" no \\n \" ; } } function cal ( $ i , $ l ) { global $ n , $ A ; if ( $ l === 0 ) { return true ; } elseif ( $ i === $ n ) { return false ; } elseif ( cal ( $ i + 1 , $ l ) ) { return true ; } elseif ( cal ( $ i + 1 , $ l - $ A [ $ i ] ) ) { return true ; } return false ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ line = explode ( ' ' , $ line ) ; $ A = array_map ( function ( $ val ) { return ( int ) $ val ; } , $ line ) ; sort ( $ A ) ; $ sum = array_sum ( $ A ) ; fscanf ( STDIN , ' %d ' , $ q ) ; $ line = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ arr = array ( ) ; foreach ( $ line as $ l ) { $ l = ( int ) $ l ; if ( $ l > $ sum ) { echo \" no \\n \" ; $ arr [ $ l ] = false ; } else { $ bool = cal ( 0 , $ l ) ; $ arr [ $ l ] = $ bool ; echo $ bool ? \" yes \\n \" : \" no \\n \" ; } } function cal ( $ i , $ l ) { global $ n , $ A ; if ( $ l === 0 ) { return true ; } elseif ( $ i === $ n ) { return false ; } elseif ( cal ( $ i + 1 , $ l ) ) { return true ; } elseif ( cal ( $ i + 1 , $ l - $ A [ $ i ] ) ) { return true ; } return false ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ A = array_map ( function ( $ val ) { return ( int ) $ val ; } , explode ( ' ' , $ line ) ) ; sort ( $ A ) ; $ sum = array_sum ( $ A ) ; fscanf ( STDIN , ' %d ' , $ q ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = array ( ) ; foreach ( explode ( ' ' , $ line ) as $ m ) { $ m = ( int ) $ m ; if ( $ m > $ sum ) { echo \" no \\n \" ; $ arr [ $ m ] = false ; } elseif ( isset ( $ arr [ $ m ] ) ) { echo $ arr [ $ m ] ? \" yes \\n \" : \" no \\n \" ; } else { $ bool = solve ( 0 , $ m ) ; $ arr [ $ m ] = $ bool ; echo $ bool ? \" yes \\n \" : \" no \\n \" ; } } function solve ( $ i , $ m ) { global $ n , $ A ; if ( $ m === 0 ) { return true ; } elseif ( $ i === $ n ) { return false ; } elseif ( solve ( $ i + 1 , $ m ) ) { return true ; } elseif ( solve ( $ i + 1 , $ m - $ A [ $ i ] ) ) { return true ; } return false ; }",
    "label": 3
  },
  {
    "code": "<?php $ num_a = intval ( trim ( fgets ( STDIN ) ) ) ; $ array_a = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ num_b = intval ( trim ( fgets ( STDIN ) ) ) ; $ array_b = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ Ss = array_fill ( 0 , 2000 , 0 ) ; $ ans_array = array_fill ( 0 , $ num_b , 0 ) ; for ( $ bit = 0 ; $ bit < ( 1 << $ num_a ) ; $ bit ++ ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ num_a ; $ i ++ ) { if ( $ bit & ( 1 << $ i ) ) { $ sum += $ array_a [ $ i ] ; } } for ( $ i = 0 ; $ i < $ num_b ; $ i ++ ) { if ( $ array_b [ $ i ] == $ sum ) { $ ans_array [ $ i ] = 1 ; } } } for ( $ i = 0 ; $ i < $ num_b ; $ i ++ ) { if ( $ ans_array [ $ i ] == 1 ) { echo \" yes \\n \" ; } else { echo \" no \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ A = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ q = ( int ) trim ( fgets ( STDIN ) ) ; $ Ms = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ ] = array_fill ( 0 , 2001 , null ) ; } function solve ( $ p , $ t ) { if ( $ t === 0 ) { return true ; } global $ n ; if ( $ t < 0 || $ p >= $ n ) { return false ; } global $ dp ; $ memo = $ dp [ $ p ] [ $ t ] ; if ( $ memo !== null ) { return $ memo ; } global $ A ; $ ans = solve ( $ p + 1 , $ t - $ A [ $ p ] ) || solve ( $ p + 1 , $ t ) ; $ dp [ $ p ] [ $ t ] = $ ans ; return $ ans ; } $ ans = \" \" ; foreach ( $ Ms as $ M_i ) { if ( solve ( 0 , $ M_i ) ) { $ ans .= \" yes \\n \" ; } else { $ ans .= \" no \\n \" ; } } print $ ans ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ num_count ) ; $ target_num = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; sort ( $ target_num ) ; fscanf ( STDIN , \" %d \" , $ search_count ) ; $ keys = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ hash = [ ] ; $ hash [ 0 ] = true ; for ( $ i = 0 ; $ i < $ num_count ; ++ $ i ) { $ new_hash = [ ] ; foreach ( $ hash as $ k => $ v ) { $ new_hash [ $ k ] = true ; $ new_hash [ $ k + $ target_num [ $ i ] ] = true ; } $ hash = $ new_hash ; } ksort ( $ hash ) ; foreach ( $ keys as $ v ) { if ( isset ( $ hash [ $ v ] ) ) echo \" yes \\n \" ; else echo \" no \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ as = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ as [ ] = ( int ) $ input [ $ i ] ; } $ q = ( int ) trim ( fgets ( STDIN ) ) ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ qs = [ ] ; for ( $ j = 0 ; $ j < $ q ; $ j ++ ) { $ qs [ ] = ( int ) $ input [ $ j ] ; } $ hash = [ ] ; $ hash [ 0 ] = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ new_hash = [ ] ; foreach ( $ hash as $ k => $ v ) { $ new_hash [ $ k ] = true ; $ new_hash [ $ k + $ as [ $ i ] ] = true ; } $ hash = $ new_hash ; } ksort ( $ hash ) ; foreach ( $ qs as $ v ) { if ( isset ( $ hash [ $ v ] ) ) { echo ' yes ' . PHP_EOL ; } else { echo ' no ' . PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ arr = array ( ) ; foreach ( explode ( ' ' , $ line ) as $ m ) { $ arr [ ] = ( int ) $ m ; } $ cnt = 0 ; mergeSort ( 0 , $ n ) ; echo implode ( ' ' , $ arr ) , PHP_EOL , $ cnt , PHP_EOL ; function merge ( $ left , $ mid , $ right ) { global $ arr , $ cnt ; $ n1 = $ mid - $ left ; $ L = array ( ) ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { $ L [ ] = $ arr [ $ left + $ i ] ; } $ L [ $ n1 ] = PHP_INT_MAX ; $ n2 = $ right - $ mid ; $ R = array ( ) ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) { $ R [ ] = $ arr [ $ mid + $ i ] ; } $ R [ $ n2 ] = PHP_INT_MAX ; for ( $ i = 0 , $ j = 0 , $ k = $ left ; $ k < $ right ; $ k ++ ) { if ( $ L [ $ i ] <= $ R [ $ j ] ) { $ arr [ $ k ] = $ L [ $ i ] ; $ i ++ ; } else { $ arr [ $ k ] = $ R [ $ j ] ; $ j ++ ; } $ cnt ++ ; } } function mergeSort ( $ left , $ right ) { if ( $ left + 1 < $ right ) { $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; mergeSort ( $ left , $ mid ) ; mergeSort ( $ mid , $ right ) ; merge ( $ left , $ mid , $ right ) ; } }",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" memory_limit \" , \" -1 \" ) ; function Merge ( $ left , $ mid , $ right ) { global $ A , $ cnt ; $ cnt += ( $ right - $ left ) ; $ n1 = $ mid - $ left ; $ n2 = $ right - $ mid ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { $ L [ ] = $ A [ $ left + $ i ] ; $ R [ ] = $ A [ $ mid + $ i ] ; } if ( $ n2 > $ n1 ) $ R [ ] = $ A [ $ right - 1 ] ; $ L [ $ n1 ] = 1000000001 ; $ R [ $ n2 ] = 1000000001 ; $ i = 0 ; $ j = 0 ; for ( $ k = $ left ; $ k < $ right ; $ k ++ ) { if ( $ L [ $ i ] <= $ R [ $ j ] ) { $ A [ $ k ] = $ L [ $ i ++ ] ; } else { $ A [ $ k ] = $ R [ $ j ++ ] ; } } } function Merge_Sort ( $ left , $ right ) { if ( $ left + 1 < $ right ) { $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; Merge_Sort ( $ left , $ mid ) ; Merge_Sort ( $ mid , $ right ) ; Merge ( $ left , $ mid , $ right ) ; } } $ input = STDIN ; $ n = ( int ) trim ( fgets ( $ input ) ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( $ input ) ) ) ) ; $ cnt = 0 ; Merge_Sort ( 0 , $ n ) ; $ ans = implode ( \" \" , $ A ) ; print ( \" { $ ans } \\n { $ cnt } \\n \" ) ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( \" memory_limit \" , \" -1 \" ) ; fscanf ( STDIN , \" %d \" , $ num_count ) ; $ target_num = array_map ( \" intval \" , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ count = 0 ; merge_sort ( 0 , $ num_count ) ; echo implode ( \" \" , $ target_num ) , \" \\n \" ; echo $ count , \" \\n \" ; function merge ( $ left , $ mid , $ right ) { global $ target_num , $ count ; $ n1 = $ mid - $ left ; $ L = [ ] ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { $ L [ ] = $ target_num [ $ left + $ i ] ; } $ L [ $ n1 ] = PHP_INT_MAX ; $ n2 = $ right - $ mid ; $ R = [ ] ; for ( $ i = 0 ; $ i < $ n2 ; ++ $ i ) { $ R [ ] = $ target_num [ $ mid + $ i ] ; } $ R [ $ n2 ] = PHP_INT_MAX ; $ i = 0 ; $ j = 0 ; for ( $ k = $ left ; $ k < $ right ; $ k ++ ) { if ( $ L [ $ i ] <= $ R [ $ j ] ) { $ target_num [ $ k ] = $ L [ $ i ] ; $ i ++ ; } else { $ target_num [ $ k ] = $ R [ $ j ] ; $ j ++ ; } ++ $ count ; } } function merge_sort ( $ left , $ right ) { if ( $ left + 1 < $ right ) { $ mid = floor ( ( $ left + $ right ) / 2 ) ; merge_sort ( $ left , $ mid ) ; merge_sort ( $ mid , $ right ) ; merge ( $ left , $ mid , $ right ) ; } }",
    "label": 3
  },
  {
    "code": "<?php myMain ( $ argv ) ; class Util { private static $ isDebug = false ; private static $ startTime ; public static function input ( $ isSplitSpace = false ) { $ input = trim ( fgets ( STDIN ) ) ; if ( ! $ isSplitSpace ) { return $ input ; } return explode ( ' ' , $ input ) ; } public static function arrToStr ( $ arr ) { return implode ( \" , \" , $ arr ) ; } public static function enablingDebug ( ) { self :: $ isDebug = true ; self :: $ startTime = time ( ) ; } public static function DebugLog ( $ text , $ isReturn = true ) { if ( self :: $ isDebug ) { echo $ text ; if ( $ isReturn ) { echo PHP_EOL ; } } } public static function varDump ( $ obj ) { if ( self :: $ isDebug ) { var_dump ( $ obj ) ; } } public static function arrFirst ( $ arr ) { if ( empty ( $ arr ) || ! is_array ( $ arr ) ) { return null ; } return current ( $ arr ) ; } public static function printBench ( ) { if ( ! self :: $ isDebug ) { return ; } echo sprintf ( \" Time: %.3f s \" . PHP_EOL , time ( ) - self :: $ startTime ) ; } } function myMain ( $ argv ) { if ( ! empty ( $ argv [ 1 ] ) ) { Util :: enablingDebug ( ) ; } list ( $ n ) = Util :: input ( true ) ; $ a = new Point ( 0 , 0 ) ; $ b = new Point ( 100 , 0 ) ; Point :: stackPoint ( $ a ) ; koch ( $ n , $ a , $ b ) ; Point :: stackPoint ( $ b ) ; Point :: printPointList ( ) ; Util :: printBench ( ) ; } class Point { public $ x ; public $ y ; private static $ _pointList = [ ] ; public static function stackPoint ( Point $ p ) { self :: $ _pointList [ ] = $ p ; } public static function printPointList ( ) { foreach ( self :: $ _pointList as $ p ) { echo $ p -> x . \" \" . $ p -> y . PHP_EOL ; } } public function __construct ( $ x , $ y ) { $ this -> x = $ x ; $ this -> y = $ y ; } } function koch ( $ n , Point $ a , Point $ b ) { if ( $ n <= 0 ) { return ; } $ s = new Point ( ( 2.0 * $ a -> x + 1.0 * $ b -> x ) / 3 , ( 2.0 * $ a -> y + 1.0 * $ b -> y ) / 3 ) ; $ t = new Point ( ( 1.0 * $ a -> x + 2.0 * $ b -> x ) / 3 , ( 1.0 * $ a -> y + 2.0 * $ b -> y ) / 3 ) ; $ u = round60 ( $ s , $ t ) ; koch ( $ n - 1 , $ a , $ s ) ; Point :: stackPoint ( $ s ) ; koch ( $ n - 1 , $ s , $ u ) ; Point :: stackPoint ( $ u ) ; koch ( $ n - 1 , $ u , $ t ) ; Point :: stackPoint ( $ t ) ; koch ( $ n - 1 , $ t , $ b ) ; } function round60 ( Point $ a , Point $ b ) { $ rad60 = pi ( ) / 3 ; $ cx = ( $ b -> x - $ a -> x ) * cos ( $ rad60 ) - ( $ b -> y - $ a -> y ) * sin ( $ rad60 ) + $ a -> x ; $ cy = ( $ b -> x - $ a -> x ) * sin ( $ rad60 ) + ( $ b -> y - $ a -> y ) * cos ( $ rad60 ) + $ a -> y ; return new Point ( $ cx , $ cy ) ; }",
    "label": 3
  },
  {
    "code": "<?php function koch ( $ p1 , $ p2 , $ n , $ start = false ) { list ( $ p1x , $ p1y ) = $ p1 ; list ( $ p2x , $ p2y ) = $ p2 ; if ( $ start ) { return \" { $ p1x } { $ p1y } \\n \" . koch ( $ p1 , $ p2 , $ n ) . \" { $ p2x } { $ p2y } \\n \" ; } elseif ( $ n > 0 ) { $ sx = ( 2 * $ p1x + $ p2x ) / 3 ; $ sy = ( 2 * $ p1y + $ p2y ) / 3 ; $ tx = ( $ p1x + 2 * $ p2x ) / 3 ; $ ty = ( $ p1y + 2 * $ p2y ) / 3 ; $ x = $ tx - $ sx ; $ y = $ ty - $ sy ; $ cos = cos ( M_PI / 3 ) ; $ sin = sin ( M_PI / 3 ) ; $ ux = $ sx + $ x * $ cos - $ y * $ sin ; $ uy = $ sy + $ x * $ sin + $ y * $ cos ; $ s = [ $ sx , $ sy ] ; $ t = [ $ tx , $ ty ] ; $ u = [ $ ux , $ uy ] ; $ n -- ; return koch ( $ p1 , $ s , $ n ) . \" { $ sx } { $ sy } \\n \" . koch ( $ s , $ u , $ n ) . \" { $ ux } { $ uy } \\n \" . koch ( $ u , $ t , $ n ) . \" { $ tx } { $ ty } \\n \" . koch ( $ t , $ p2 , $ n ) ; } } $ n = ( int ) trim ( fgets ( STDIN ) ) ; print koch ( [ 0 , 0 ] , [ 100 , 0 ] , $ n , true ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d \" , $ count ) ; $ koch_arr = [ ] ; if ( $ count == 0 ) { $ koch_arr [ ] = [ 0 , 0 ] ; $ koch_arr [ ] = [ 100 , 0 ] ; foreach ( $ koch_arr as $ koch ) { echo implode ( \" \" , $ koch ) . \" \\n \" ; } return ; } koch ( [ 0 , 0 ] , [ 100 , 0 ] , $ count ) ; echo \" 100 0 \\n \" ; function koch ( $ p1 , $ p2 , $ count ) { global $ koch_arr ; $ s = [ $ p1 [ 0 ] + ( $ p2 [ 0 ] - $ p1 [ 0 ] ) / 3 , $ p1 [ 1 ] + ( $ p2 [ 1 ] - $ p1 [ 1 ] ) / 3 ] ; $ t = [ $ p2 [ 0 ] - ( $ p2 [ 0 ] - $ p1 [ 0 ] ) / 3 , $ p2 [ 1 ] - ( $ p2 [ 1 ] - $ p1 [ 1 ] ) / 3 ] ; $ u = [ $ s [ 0 ] + ( $ t [ 0 ] - $ s [ 0 ] ) / 2 - ( $ t [ 1 ] - $ s [ 1 ] ) * sqrt ( 3 ) / 2 , $ s [ 1 ] + ( $ t [ 0 ] - $ s [ 0 ] ) * sqrt ( 3 ) / 2 + ( $ t [ 1 ] - $ s [ 1 ] ) / 2 ] ; if ( $ count <= 1 ) { print_arr ( $ p1 ) ; print_arr ( $ s ) ; print_arr ( $ u ) ; print_arr ( $ t ) ; } else { koch ( $ p1 , $ s , $ count - 1 ) ; koch ( $ s , $ u , $ count - 1 ) ; koch ( $ u , $ t , $ count - 1 ) ; koch ( $ t , $ p2 , $ count - 1 ) ; } } function print_arr ( $ arr ) { echo $ arr [ 0 ] , \" \" , $ arr [ 1 ] , \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ max = 10000 ; $ A = new \\ SplFixedArray ( $ n + 1 ) ; $ B = new \\ SplFixedArray ( $ n + 1 ) ; $ C = new \\ SplFixedArray ( $ max + 1 ) ; foreach ( explode ( ' ' , $ line ) as $ i => $ m ) { $ m = ( int ) $ m ; $ A [ $ i + 1 ] = $ m ; $ C [ $ m ] = $ C [ $ m ] + 1 ; } for ( $ i = 1 ; $ i <= $ max ; $ i ++ ) { $ C [ $ i ] = $ C [ $ i ] + $ C [ $ i - 1 ] ; } for ( $ i = $ n ; $ i > 0 ; $ i -- ) { $ a = $ A [ $ i ] ; $ c = $ C [ $ a ] ; $ B [ $ c ] = $ a ; $ C [ $ a ] = $ C [ $ a ] - 1 ; } $ str = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ str [ ] = $ B [ $ i ] ; } echo implode ( ' ' , $ str ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php function input ( ) { return trim ( fgets ( STDIN ) ) ; } function input_array ( ) { return explode ( ' ' , input ( ) ) ; } function partition ( & $ A , $ p , $ r ) { $ x = $ A [ $ r ] ; $ i = $ p - 1 ; for ( $ j = $ p ; $ j < $ r ; $ j ++ ) { if ( $ A [ $ j ] <= $ x ) { $ i ++ ; $ t = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ j ] ; $ A [ $ j ] = $ t ; } } $ t = $ A [ $ i + 1 ] ; $ A [ $ i + 1 ] = $ A [ $ r ] ; $ A [ $ r ] = $ t ; return $ i + 1 ; } $ n = ( int ) input ( ) ; $ A = array_map ( function ( $ numeric_string ) { return ( int ) $ numeric_string ; } , input_array ( ) ) ; $ q = partition ( $ A , 0 , $ n - 1 ) ; echo implode ( ' ' , array_slice ( $ A , 0 , $ q ) ) . ' [ ' . $ A [ $ q ] . ' ] ' . implode ( ' ' , array_slice ( $ A , $ q + 1 ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ line = trim ( fgets ( STDIN ) ) ; $ A = array ( ) ; foreach ( explode ( ' ' , $ line ) as $ m ) { $ A [ ] = ( int ) $ m ; } $ A = partition ( $ A , 0 , $ n - 1 ) ; echo implode ( ' ' , $ A ) , PHP_EOL ; function partition ( $ A , $ p , $ r ) { $ x = $ A [ $ r ] ; $ i = $ p - 1 ; for ( $ j = $ p ; $ j < $ r ; $ j ++ ) { if ( $ A [ $ j ] <= $ x ) { $ i ++ ; $ tmp = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ j ] ; $ A [ $ j ] = $ tmp ; } } $ i ++ ; $ A [ $ r ] = $ A [ $ i ] ; $ A [ $ i ] = \" [ $ x ] \" ; return $ A ; }",
    "label": 3
  },
  {
    "code": "<?php $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ ary = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; foreach ( $ ary as & $ v ) { $ v = ( int ) $ v ; } partition ( $ ary , 0 , $ n - 1 ) ; function partition ( $ ary , $ p , $ r ) { $ x = $ ary [ $ r ] ; $ i = $ p - 1 ; for ( $ j = $ p ; $ j < $ r ; $ j ++ ) { if ( $ ary [ $ j ] <= $ x ) { $ i += 1 ; $ buf = $ ary [ $ j ] ; $ ary [ $ j ] = $ ary [ $ i ] ; $ ary [ $ i ] = $ buf ; } } $ buf = $ ary [ $ r ] ; $ ary [ $ r ] = $ ary [ $ i + 1 ] ; $ ary [ $ i + 1 ] = ' [ ' . $ buf . ' ] ' ; printIntArray ( $ ary ) ; return $ i + 1 ; } function printIntArray ( $ ary ) { echo implode ( ' ' , $ ary ) . PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d ' , $ n ) ; $ A = new \\ SplFixedArray ( $ n ) ; $ check = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ line = trim ( fgets ( STDIN ) ) ; $ suit = $ line [ 0 ] ; $ m = ( int ) substr ( $ line , 2 ) ; $ A [ $ i ] = array ( $ suit , $ m ) ; if ( ! isset ( $ check [ $ m ] ) ) { $ check [ $ m ] = array ( ) ; } $ check [ $ m ] [ ] = $ suit ; } quickSort ( $ A , 0 , $ n - 1 ) ; $ bool = true ; $ arr = array ( ) ; foreach ( $ A as $ a ) { $ arr [ ] = implode ( ' ' , $ a ) ; if ( $ bool ) { $ bool = $ a [ 0 ] === array_shift ( $ check [ $ a [ 1 ] ] ) ; } } echo $ bool ? ' Stable ' : ' Not stable ' , PHP_EOL , implode ( PHP_EOL , $ arr ) , PHP_EOL ; function quickSort ( $ A , $ p , $ r ) { global $ A ; if ( $ p < $ r ) { $ q = partition ( $ A , $ p , $ r ) ; quickSort ( $ A , $ p , $ q - 1 ) ; quickSort ( $ A , $ q + 1 , $ r ) ; } } function partition ( $ A , $ p , $ r ) { global $ A ; $ x = $ A [ $ r ] [ 1 ] ; $ i = $ p - 1 ; for ( $ j = $ p ; $ j < $ r ; $ j ++ ) { if ( $ A [ $ j ] [ 1 ] <= $ x ) { $ i ++ ; $ tmp = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ j ] ; $ A [ $ j ] = $ tmp ; } } $ i ++ ; $ tmp = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ r ] ; $ A [ $ r ] = $ tmp ; return $ i ; }",
    "label": 3
  },
  {
    "code": "<?php solve1 ( ) ; function solve1 ( ) { $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ list = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ node = new BTreeNode ( $ i + 1 ) ; $ list [ $ node -> getId ( ) ] = $ node ; } $ preorder = [ ] ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ preorder [ ] = ( int ) $ input [ $ i ] ; } $ inorder = [ ] ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ inorder [ ] = ( int ) $ input [ $ i ] ; } $ end = $ n ; dfs ( $ preorder , $ inorder , $ list , $ preorder [ 0 ] ) ; $ res = [ ] ; $ res = postorderWalk ( $ list , $ preorder [ 0 ] , $ res ) ; echo implode ( ' ' , $ res ) . PHP_EOL ; } function dfs ( $ preorder , $ inorder , $ list , $ p ) { $ children = getChildren ( $ inorder , $ p ) ; if ( count ( $ children [ ' left ' ] ) === 1 ) { $ list [ $ p ] -> setLeft ( $ children [ ' left ' ] [ 0 ] ) ; $ list [ $ children [ ' left ' ] [ 0 ] ] -> setParentId ( $ p ) ; } elseif ( count ( $ children [ ' left ' ] ) > 1 ) { $ p_left = null ; foreach ( $ preorder as $ pre ) { if ( in_array ( $ pre , $ children [ ' left ' ] ) ) { $ p_left = $ pre ; break ; } } $ list [ $ p ] -> setLeft ( $ p_left ) ; $ list [ $ p_left ] -> setParentId ( $ p ) ; dfs ( $ preorder , $ children [ ' left ' ] , $ list , $ p_left ) ; } if ( count ( $ children [ ' right ' ] ) === 1 ) { $ list [ $ p ] -> setRight ( $ children [ ' right ' ] [ 0 ] ) ; $ list [ $ children [ ' right ' ] [ 0 ] ] -> setParentId ( $ p ) ; } elseif ( count ( $ children [ ' right ' ] ) > 1 ) { $ p_right = null ; foreach ( $ preorder as $ pre ) { if ( in_array ( $ pre , $ children [ ' right ' ] ) ) { $ p_right = $ pre ; break ; } } $ list [ $ p ] -> setRight ( $ p_right ) ; $ list [ $ p_right ] -> setParentId ( $ p ) ; dfs ( $ preorder , $ children [ ' right ' ] , $ list , $ p_right ) ; } } function getChildren ( $ inorder , $ p ) { $ n = count ( $ inorder ) ; $ left = [ ] ; $ right = [ ] ; $ r_flg = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ inorder [ $ i ] === $ p ) { $ r_flg = true ; } else { if ( $ r_flg ) { $ right [ ] = $ inorder [ $ i ] ; } else { $ left [ ] = $ inorder [ $ i ] ; } } } return [ ' left ' => $ left , ' right ' => $ right , ] ; } function preorderWalk ( $ list , $ id ) { echo ' ' . $ id ; if ( $ list [ $ id ] -> hasLeft ( ) ) { preorderWalk ( $ list , $ list [ $ id ] -> getLeft ( ) ) ; } if ( $ list [ $ id ] -> hasRight ( ) ) { preorderWalk ( $ list , $ list [ $ id ] -> getRight ( ) ) ; } } function inorderWalk ( $ list , $ id ) { if ( $ list [ $ id ] -> hasLeft ( ) ) { inorderWalk ( $ list , $ list [ $ id ] -> getLeft ( ) ) ; } echo ' ' . $ id ; if ( $ list [ $ id ] -> hasRight ( ) ) { inorderWalk ( $ list , $ list [ $ id ] -> getRight ( ) ) ; } } function postorderWalk ( $ list , $ id , $ result ) { if ( $ list [ $ id ] -> hasLeft ( ) ) { $ result = postorderWalk ( $ list , $ list [ $ id ] -> getLeft ( ) , $ result ) ; } if ( $ list [ $ id ] -> hasRight ( ) ) { $ result = postorderWalk ( $ list , $ list [ $ id ] -> getRight ( ) , $ result ) ; } $ result [ ] = $ id ; return $ result ; } class BTreeNode { private $ id ; private $ depth = 0 ; private $ height = 0 ; private $ parent_id = - 1 ; private $ left = - 1 ; private $ right = - 1 ; function __construct ( $ id ) { $ this -> id = $ id ; } function setParentId ( $ p_id ) { $ this -> parent_id = $ p_id ; } function setLeft ( $ l_id ) { $ this -> left = $ l_id ; } function setRight ( $ r_id ) { $ this -> right = $ r_id ; } function getId ( ) { return $ this -> id ; } function getParentId ( ) { return $ this -> parent_id ; } function getLeft ( ) { return $ this -> left ; } function getRight ( ) { return $ this -> right ; } function hasChild ( ) { return ( $ this -> left !== - 1 ) || ( $ this -> right !== - 1 ) ; } function getChildren ( ) { $ children = [ ] ; if ( $ this -> hasLeft ( ) ) { $ children [ ] = $ this -> left ; } if ( $ this -> hasRight ( ) ) { $ children [ ] = $ this -> right ; } return $ children ; } function getAnotherChild ( $ c_id ) { $ c = - 1 ; if ( $ this -> getLeft ( ) === $ c_id ) { $ c = $ this -> getRight ( ) ; } elseif ( $ this -> getRight ( ) === $ c_id ) { $ c = $ this -> getLeft ( ) ; } return $ c ; } function hasLeft ( ) { return $ this -> left !== - 1 ; } function hasRight ( ) { return $ this -> right !== - 1 ; } function setDepth ( $ d ) { $ this -> depth = $ d ; } function addDepth ( ) { $ this -> depth += 1 ; } function getDepth ( ) { return $ this -> depth ; } function setHeight ( $ h ) { $ this -> height = $ h ; } function getHeight ( ) { return $ this -> height ; } }",
    "label": 3
  },
  {
    "code": "<?php solve1 ( ) ; function solve1 ( ) { $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ list = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ node = new BTreeNode ( $ i + 1 ) ; $ list [ $ node -> getId ( ) ] = $ node ; } $ preorder = [ ] ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ preorder [ ] = ( int ) $ input [ $ i ] ; } $ inorder = [ ] ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ inorder [ ] = ( int ) $ input [ $ i ] ; } $ end = $ n ; dfs ( $ preorder , $ inorder , $ list , $ preorder [ 0 ] ) ; $ res = [ ] ; $ res = postorderWalk ( $ list , $ preorder [ 0 ] , $ res ) ; echo implode ( ' ' , $ res ) . PHP_EOL ; } function dfs ( $ preorder , $ inorder , $ list , $ p ) { $ children = getChildren ( $ inorder , $ p ) ; if ( count ( $ children [ ' left ' ] ) === 1 ) { $ list [ $ p ] -> setLeft ( $ children [ ' left ' ] [ 0 ] ) ; $ list [ $ children [ ' left ' ] [ 0 ] ] -> setParentId ( $ p ) ; } elseif ( count ( $ children [ ' left ' ] ) > 1 ) { $ p_left = null ; foreach ( $ preorder as $ pre ) { if ( in_array ( $ pre , $ children [ ' left ' ] ) ) { $ p_left = $ pre ; break ; } } $ list [ $ p ] -> setLeft ( $ p_left ) ; $ list [ $ p_left ] -> setParentId ( $ p ) ; dfs ( $ preorder , $ children [ ' left ' ] , $ list , $ p_left ) ; } if ( count ( $ children [ ' right ' ] ) === 1 ) { $ list [ $ p ] -> setRight ( $ children [ ' right ' ] [ 0 ] ) ; $ list [ $ children [ ' right ' ] [ 0 ] ] -> setParentId ( $ p ) ; } elseif ( count ( $ children [ ' right ' ] ) > 1 ) { $ p_right = null ; foreach ( $ preorder as $ pre ) { if ( in_array ( $ pre , $ children [ ' right ' ] ) ) { $ p_right = $ pre ; break ; } } $ list [ $ p ] -> setRight ( $ p_right ) ; $ list [ $ p_right ] -> setParentId ( $ p ) ; dfs ( $ preorder , $ children [ ' right ' ] , $ list , $ p_right ) ; } } function getChildren ( $ inorder , $ p ) { $ n = count ( $ inorder ) ; $ left = [ ] ; $ right = [ ] ; $ r_flg = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ inorder [ $ i ] === $ p ) { $ r_flg = true ; } else { if ( $ r_flg ) { $ right [ ] = $ inorder [ $ i ] ; } else { $ left [ ] = $ inorder [ $ i ] ; } } } return [ ' left ' => $ left , ' right ' => $ right , ] ; } function preorderWalk ( $ list , $ id ) { echo ' ' . $ id ; if ( $ list [ $ id ] -> hasLeft ( ) ) { preorderWalk ( $ list , $ list [ $ id ] -> getLeft ( ) ) ; } if ( $ list [ $ id ] -> hasRight ( ) ) { preorderWalk ( $ list , $ list [ $ id ] -> getRight ( ) ) ; } } function inorderWalk ( $ list , $ id ) { if ( $ list [ $ id ] -> hasLeft ( ) ) { inorderWalk ( $ list , $ list [ $ id ] -> getLeft ( ) ) ; } echo ' ' . $ id ; if ( $ list [ $ id ] -> hasRight ( ) ) { inorderWalk ( $ list , $ list [ $ id ] -> getRight ( ) ) ; } } function postorderWalk ( $ list , $ id , $ result ) { if ( $ list [ $ id ] -> hasLeft ( ) ) { $ result = postorderWalk ( $ list , $ list [ $ id ] -> getLeft ( ) , $ result ) ; } if ( $ list [ $ id ] -> hasRight ( ) ) { $ result = postorderWalk ( $ list , $ list [ $ id ] -> getRight ( ) , $ result ) ; } $ result [ ] = $ id ; return $ result ; } class BTreeNode { private $ id ; private $ depth = 0 ; private $ height = 0 ; private $ parent_id = - 1 ; private $ left = - 1 ; private $ right = - 1 ; function __construct ( $ id ) { $ this -> id = $ id ; } function setParentId ( $ p_id ) { $ this -> parent_id = $ p_id ; } function setLeft ( $ l_id ) { $ this -> left = $ l_id ; } function setRight ( $ r_id ) { $ this -> right = $ r_id ; } function getId ( ) { return $ this -> id ; } function getParentId ( ) { return $ this -> parent_id ; } function getLeft ( ) { return $ this -> left ; } function getRight ( ) { return $ this -> right ; } function hasChild ( ) { return ( $ this -> left !== - 1 ) || ( $ this -> right !== - 1 ) ; } function getChildren ( ) { $ children = [ ] ; if ( $ this -> hasLeft ( ) ) { $ children [ ] = $ this -> left ; } if ( $ this -> hasRight ( ) ) { $ children [ ] = $ this -> right ; } return $ children ; } function getAnotherChild ( $ c_id ) { $ c = - 1 ; if ( $ this -> getLeft ( ) === $ c_id ) { $ c = $ this -> getRight ( ) ; } elseif ( $ this -> getRight ( ) === $ c_id ) { $ c = $ this -> getLeft ( ) ; } return $ c ; } function hasLeft ( ) { return $ this -> left !== - 1 ; } function hasRight ( ) { return $ this -> right !== - 1 ; } function setDepth ( $ d ) { $ this -> depth = $ d ; } function addDepth ( ) { $ this -> depth += 1 ; } function getDepth ( ) { return $ this -> depth ; } function setHeight ( $ h ) { $ this -> height = $ h ; } function getHeight ( ) { return $ this -> height ; } }",
    "label": 3
  },
  {
    "code": "<?php $ nl = ( int ) trim ( fgets ( STDIN ) ) ; $ prtw = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ intw = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ pstw = array ( $ nl ) ; for ( $ i = 0 ; $ i < $ nl ; $ i ++ ) { $ pstw [ $ i ] = 0 ; } function to_pstw ( $ pri , $ ini , $ psi , $ nl ) { global $ prtw , $ intw , $ pstw ; $ a = $ prtw [ $ pri ] ; $ pstw [ $ psi + $ nl - 1 ] = $ a ; if ( $ nl <= 1 ) { return ; } $ i = 0 ; while ( $ intw [ $ ini + $ i ] != $ a ) { ++ $ i ; } if ( $ i > 0 ) { to_pstw ( $ pri + 1 , $ ini , $ psi , $ i ) ; } if ( $ nl - $ i - 1 > 0 ) { to_pstw ( $ pri + $ i + 1 , $ ini + $ i + 1 , $ psi + $ i , $ nl - $ i - 1 ) ; } } to_pstw ( 0 , 0 , 0 , $ nl ) ; printf ( $ pstw [ 0 ] ) ; for ( $ i = 1 ; $ i < $ nl ; $ i ++ ) { printf ( \" %d \" , $ pstw [ $ i ] ) ; } printf ( \" \\n \" ) ;",
    "label": 3
  },
  {
    "code": "<?php $ nl = ( int ) trim ( fgets ( STDIN ) ) ; $ prtw = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ intw = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ pstw = array ( $ nl ) ; for ( $ i = 0 ; $ i < $ nl ; $ i ++ ) { $ pstw [ $ i ] = 0 ; } function to_pstw ( $ pri , $ ini , $ psi , $ nl ) { global $ prtw , $ intw , $ pstw ; $ a = $ prtw [ $ pri ] ; $ pstw [ $ psi + $ nl - 1 ] = $ a ; if ( $ nl <= 1 ) { return ; } $ i = 0 ; while ( $ intw [ $ ini + $ i ] != $ a ) { ++ $ i ; } if ( $ i > 0 ) { to_pstw ( $ pri + 1 , $ ini , $ psi , $ i ) ; } if ( $ nl - $ i - 1 > 0 ) { to_pstw ( $ pri + $ i + 1 , $ ini + $ i + 1 , $ psi + $ i , $ nl - $ i - 1 ) ; } } to_pstw ( 0 , 0 , 0 , $ nl ) ; printf ( $ pstw [ 0 ] ) ; for ( $ i = 1 ; $ i < $ nl ; $ i ++ ) { printf ( \" %d \" , $ pstw [ $ i ] ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php $ nl = ( int ) trim ( fgets ( STDIN ) ) ; $ prtw = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ intw = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ pstw = array ( ) ; for ( $ i = 0 ; $ i < $ nl ; $ i ++ ) { $ pstw [ ] = 0 ; } function to_pstw ( $ pri , $ ini , $ psi , $ nl ) { global $ prtw , $ intw , $ pstw ; $ a = $ prtw [ $ pri ] ; $ pstw [ $ psi + $ nl - 1 ] = $ a ; if ( $ nl <= 1 ) { return ; } $ i = 0 ; while ( $ intw [ $ ini + $ i ] != $ a ) { ++ $ i ; } if ( $ i > 0 ) { to_pstw ( $ pri + 1 , $ ini , $ psi , $ i ) ; } if ( $ nl - $ i - 1 > 0 ) { to_pstw ( $ pri + $ i + 1 , $ ini + $ i + 1 , $ psi + $ i , $ nl - $ i - 1 ) ; } } to_pstw ( 0 , 0 , 0 , $ nl ) ; printf ( $ pstw [ 0 ] ) ; for ( $ i = 1 ; $ i < $ nl ; $ i ++ ) { printf ( \" %d \" , $ pstw [ $ i ] ) ; } ?>",
    "label": 3
  },
  {
    "code": "<?php solve1 ( ) ; function solve1 ( ) { $ n = ( int ) trim ( fgets ( STDIN ) ) ; $ input = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ data = [ ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ data [ $ i + 1 ] = ( int ) $ input [ $ i ] ; } foreach ( $ data as $ k => $ v ) { echo ' node ' . $ k . ' : key = ' . $ v . ' , ' ; if ( $ k > 1 ) { echo ' parent key = ' . $ data [ ( int ) floor ( $ k / 2 ) ] . ' , ' ; } if ( isset ( $ data [ 2 * $ k ] ) ) { echo ' left key = ' . $ data [ 2 * $ k ] . ' , ' ; } if ( isset ( $ data [ ( 2 * $ k ) + 1 ] ) ) { echo ' right key = ' . $ data [ ( 2 * $ k ) + 1 ] . ' , ' ; } echo PHP_EOL ; } }",
    "label": 3
  },
  {
    "code": "<?php list ( $ target ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ target = ( int ) $ target ; $ numList = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; rsort ( $ numList ) ; array_pop ( $ numList ) ; $ min = end ( $ numList ) ; $ fail = [ ] ; function search ( $ rest , $ count ) { global $ numList , $ min , $ out , $ fail ; if ( isset ( $ fail [ $ rest ] ) ) { if ( $ fail [ $ rest ] + $ count < $ out ) { $ out = $ fail [ $ rest ] + $ count ; } return ; } if ( $ rest < $ min ) { if ( $ count + $ rest < $ out ) { $ out = $ count + $ rest ; } return ; } for ( $ i = 0 ; isset ( $ numList [ $ i ] ) ; ++ $ i ) { if ( $ rest < $ numList [ $ i ] ) { continue ; } search ( $ rest - $ numList [ $ i ] , $ count + 1 ) ; } } for ( $ i = 1 ; $ i <= $ target ; ++ $ i ) { $ out = 10000 ; search ( $ i , 0 ) ; $ fail [ $ i ] = $ out ; } echo $ fail [ $ target ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' memory_limit ' , - 1 ) ; $ num = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ item = $ num [ 0 ] ; $ WEIGHT = $ num [ 1 ] ; for ( $ i = 1 ; $ i <= $ item ; $ i ++ ) { list ( $ v , $ w ) = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ value [ $ i ] = $ v ; $ weight [ $ i ] = $ w ; } $ value [ 0 ] = 0 ; $ weight [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ item ; $ i ++ ) { for ( $ w = 0 ; $ w <= $ WEIGHT ; $ w ++ ) { $ dp [ $ i ] [ $ w ] = 0 ; } } for ( $ i = 0 ; $ i <= $ item ; $ i ++ ) { for ( $ w = 0 ; $ w <= $ WEIGHT ; $ w ++ ) { if ( $ w >= $ weight [ $ i ] ) { $ dp [ $ i + 1 ] [ $ w ] = max ( $ dp [ $ i ] [ $ w - $ weight [ $ i ] ] + $ value [ $ i ] , $ dp [ $ i ] [ $ w ] ) ; } else { $ dp [ $ i + 1 ] [ $ w ] = $ dp [ $ i ] [ $ w ] ; } } } echo max ( $ dp [ $ item + 1 ] ) . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input_line = fgets ( STDIN ) ; $ input_line = str_replace ( array ( \" \\r \\n \" , \" \\r \" , \" \\n \" ) , ' ' , $ input_line ) ; $ array = explode ( \" \" , $ input_line ) ; $ N = $ array [ 0 ] ; $ W = $ array [ 1 ] ; $ array_v = array ( - 1 ) ; $ array_w = array ( - 1 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ input_line = fgets ( STDIN ) ; $ input_line = str_replace ( array ( \" \\r \\n \" , \" \\r \" , \" \\n \" ) , ' ' , $ input_line ) ; $ array = explode ( \" \" , $ input_line ) ; array_push ( $ array_v , $ array [ 0 ] ) ; array_push ( $ array_w , $ array [ 1 ] ) ; } for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ W ; $ j ++ ) { $ x = 0 ; $ y = 0 ; if ( $ i == 0 ) { $ data [ $ i ] [ $ j ] = 0 ; } else { $ x = $ data [ $ i - 1 ] [ $ j ] ; if ( $ array_w [ $ i ] <= $ j ) $ y = $ data [ $ i - 1 ] [ $ j - $ array_w [ $ i ] ] + $ array_v [ $ i ] ; $ data [ $ i ] [ $ j ] = ( $ x > $ y ) ? $ x : $ y ; } } if ( $ i >= 2 ) { unset ( $ data [ $ i - 2 ] ) ; } } echo $ data [ $ N ] [ $ W ] ; ?>",
    "label": 3
  },
  {
    "code": "<?php class Scanner { private $ arr = [ ] ; private $ count = 0 ; private $ pointer = 0 ; public function next ( ) { if ( $ this -> pointer >= $ this -> count ) { $ str = trim ( fgets ( STDIN ) ) ; $ this -> arr = explode ( ' ' , $ str ) ; $ this -> count = count ( $ this -> arr ) ; $ this -> pointer = 0 ; } $ result = $ this -> arr [ $ this -> pointer ] ; $ this -> pointer ++ ; return $ result ; } public function hasNext ( ) { return $ this -> pointer < $ this -> count ; } public function nextInt ( ) { return ( int ) $ this -> next ( ) ; } public function nextDouble ( ) { return ( double ) $ this -> next ( ) ; } } $ sc = new Scanner ( ) ; $ N = $ sc -> nextInt ( ) ; $ W = $ sc -> nextInt ( ) ; $ v = array ( ) ; $ w = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ v [ $ i ] = $ sc -> nextInt ( ) ; $ w [ $ i ] = $ sc -> nextInt ( ) ; } unset ( $ sc ) ; $ dp = array ( ) ; $ dp [ 0 ] = array_fill ( 0 , $ W + 1 , 0 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ W ; $ j ++ ) { if ( $ j >= $ w [ $ i ] ) { $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - $ w [ $ i ] ] + $ v [ $ i ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } else { $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } } if ( $ i >= 2 ) { unset ( $ dp [ $ i - 2 ] ) ; } } echo $ dp [ $ N ] [ $ W ] . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' memory_limit ' , ' -1 ' ) ; fscanf ( STDIN , \" %d %d \" , $ N , $ W ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { fscanf ( STDIN , \" %d %d \" , $ v [ ] , $ w [ ] ) ; } $ dp = array ( ) ; for ( $ x = 0 ; $ x <= $ N ; $ x ++ ) { for ( $ y = 0 ; $ y <= $ W ; $ y ++ ) { $ dp [ $ x ] [ $ y ] = 0 ; } } for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ W ; ++ $ j ) { if ( $ j - $ w [ $ i ] >= 0 ) { $ dp [ $ i + 1 ] [ $ j ] = max ( ( $ dp [ $ i + 1 ] [ $ j - $ w [ $ i ] ] + $ v [ $ i ] ) , $ dp [ $ i ] [ $ j ] ) ; } else { $ dp [ $ i + 1 ] [ $ j ] = $ dp [ $ i ] [ $ j ] ; } } } echo $ dp [ $ N ] [ $ W ] . \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %d %d \" , $ n , $ q ) ; $ A = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; $ X = array_map ( ' intval ' , explode ( ' ' , trim ( fgets ( STDIN ) ) ) ) ; for ( $ i = 0 ; $ i < $ q ; ++ $ i ) { $ x = $ X [ $ i ] ; $ cnt = 0 ; $ sum = 0 ; $ r = 0 ; for ( $ l = 0 ; $ l < $ n ; ++ $ l ) { while ( $ r < $ n && $ sum + $ A [ $ r ] <= $ x ) { $ sum += $ A [ $ r ] ; ++ $ r ; } $ cnt += $ r - $ l ; if ( $ r === $ l ) { ++ $ r ; } else { $ sum -= $ A [ $ l ] ; } } echo $ cnt , PHP_EOL ; }",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' memory_limit ' , - 1 ) ; $ num = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ num_vertex = $ num [ 0 ] ; $ num_side = $ num [ 1 ] ; $ start = $ num [ 2 ] ; $ vertex_info = array_fill ( 0 , $ num_vertex , [ ] ) ; for ( $ i = 0 ; $ i < $ num_side ; $ i ++ ) { list ( $ s , $ t , $ d ) = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ vertex_info [ $ s ] [ ] = [ $ t , $ d ] ; } $ inf = 10 ** 10 ; $ visited = array_fill ( 0 , $ num_vertex , false ) ; $ dist = array_fill ( 0 , $ num_vertex , $ inf ) ; $ dist [ $ start ] = 0 ; $ queue = new SplPriorityQueue ( ) ; $ queue -> insert ( [ $ start , 0 ] , 0 ) ; while ( ! $ queue -> isEmpty ( ) ) { list ( $ vetex_standard , $ dist_standard ) = $ queue -> extract ( ) ; if ( $ visited [ $ vetex_standard ] == true ) { continue ; } $ visited [ $ vetex_standard ] = true ; foreach ( $ vertex_info [ $ vetex_standard ] as $ value ) { list ( $ to , $ to_dist ) = $ value ; $ total_dist = $ dist_standard + $ to_dist ; if ( $ total_dist < $ dist [ $ to ] ) { $ dist [ $ to ] = $ total_dist ; $ queue -> insert ( [ $ to , $ total_dist ] , - $ total_dist ) ; } } } foreach ( $ dist as $ result ) { if ( $ result === $ inf ) { echo \" INF \\n \" ; } else { echo $ result . \" \\n \" ; } } ?>",
    "label": 3
  },
  {
    "code": "<?php ini_set ( ' memory_limit ' , - 1 ) ; list ( $ v , $ e , $ r ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges = array_fill ( 0 , $ v , [ ] ) ; for ( $ i = 0 ; $ i < $ e ; $ i ++ ) { list ( $ s , $ t , $ d ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges [ $ s ] [ ] = [ $ t , $ d ] ; } $ INF = 10 ** 10 ; $ visited = array_fill ( 0 , $ v , false ) ; $ dist = array_fill ( 0 , $ v , $ INF ) ; $ dist [ $ r ] = 0 ; $ queue = new SplPriorityQueue ( ) ; $ queue -> insert ( [ $ r , 0 ] , 0 ) ; while ( ! $ queue -> isEmpty ( ) ) { list ( $ node , $ score ) = $ queue -> extract ( ) ; if ( $ visited [ $ node ] ) { continue ; } $ visited [ $ node ] = true ; foreach ( $ edges [ $ node ] as $ edge ) { list ( $ to , $ cost ) = $ edge ; $ newScore = $ score + $ cost ; if ( $ newScore < $ dist [ $ to ] ) { $ dist [ $ to ] = $ newScore ; $ queue -> insert ( [ $ to , $ newScore ] , - $ newScore ) ; } } } foreach ( $ dist as $ result ) { if ( $ result === $ INF ) { echo \" INF \\n \" ; } else { echo $ result . \" \\n \" ; } }",
    "label": 3
  },
  {
    "code": "<?php list ( $ V , $ E ) = array_map ( ' intval ' , explode ( \" \" , trim ( fgets ( STDIN ) ) ) ) ; $ inf = 10 ** 10 ; for ( $ i = 0 ; $ i < $ V ; $ i ++ ) { for ( $ j = 0 ; $ j < $ V ; $ j ++ ) { $ TD [ $ i ] [ $ j ] = INF ; $ DT [ $ i ] [ $ j ] = INF ; } } while ( $ array = trim ( fgets ( STDIN ) ) ) { list ( $ S , $ T , $ D ) = array_map ( ' intval ' , explode ( \" \" , $ array ) ) ; $ TD [ $ S ] [ $ T ] = $ D ; } for ( $ i = 0 ; $ i < $ V ; $ i ++ ) { $ TD [ $ i ] [ $ i ] = 0 ; } for ( $ x = 0 ; $ x < $ V ; $ x ++ ) { for ( $ y = 0 ; $ y < $ V ; $ y ++ ) { for ( $ z = 0 ; $ z < $ V ; $ z ++ ) { $ TD [ $ y ] [ $ z ] = min ( $ TD [ $ y ] [ $ z ] , $ TD [ $ y ] [ $ x ] + $ TD [ $ x ] [ $ z ] ) ; } } } for ( $ i = 0 ; $ i < $ V ; $ i ++ ) { if ( $ TD [ $ i ] [ $ i ] < 0 ) { echo \" NEGATIVE CYCLE \\n \" ; exit ; } } for ( $ i = 0 ; $ i < $ V ; $ i ++ ) { for ( $ j = 0 ; $ j < $ V ; $ j ++ ) { if ( $ TD [ $ i ] [ $ j ] == 10 ** 10 ) { echo \" INF \" ; } else { echo $ TD [ $ i ] [ $ j ] ; } if ( $ j == $ V - 1 ) { } else { echo \" \" ; } } echo \" \\n \" ; } ?>",
    "label": 3
  },
  {
    "code": "<?php list ( $ v , $ e ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges = [ ] ; for ( $ i = 0 ; $ i < $ e ; $ i ++ ) { list ( $ s , $ t , $ w ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges [ ] = [ $ w , $ s , $ t ] ; } sort ( $ edges ) ; $ parList = [ ] ; for ( $ i = 0 ; $ i < $ v ; $ i ++ ) { $ parList [ $ i ] = $ i ; } function find ( $ x ) { global $ parList ; if ( $ x === $ parList [ $ x ] ) { return $ x ; } $ parList [ $ x ] = find ( $ parList [ $ x ] ) ; return $ parList [ $ x ] ; } $ ans = 0 ; foreach ( $ edges as $ edge ) { list ( $ w , $ s , $ t ) = $ edge ; $ ps = find ( $ s ) ; $ pt = find ( $ t ) ; if ( $ ps != $ pt ) { $ ans += $ w ; $ parList [ $ ps ] = $ pt ; } } echo $ ans . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php class LowLinks { private $ edges , $ root , $ ord , $ low , $ cnt , $ bridges , $ articulations , $ par ; function __construct ( $ edges , $ v , $ root = 0 ) { $ this -> edges = $ edges ; $ this -> root = $ root ; $ this -> ord = array_fill ( 0 , $ v , null ) ; $ this -> low = array_fill ( 0 , $ v , null ) ; $ this -> cnt = 0 ; $ this -> bridges = [ ] ; $ this -> articulations = [ ] ; $ this -> par = array_fill ( 0 , $ v , null ) ; } function getArticulations ( ) { return $ this -> articulations ; } function getBridges ( ) { return $ this -> bridges ; } function build ( ) { $ this -> search ( $ this -> root ) ; } function search ( $ node ) { $ this -> ord [ $ node ] = $ this -> cnt ; $ this -> low [ $ node ] = $ this -> cnt ; $ this -> cnt ++ ; $ dim = 0 ; foreach ( $ this -> edges [ $ node ] as $ to ) { if ( $ to === $ this -> par [ $ node ] ) continue ; if ( $ this -> ord [ $ to ] === null ) { $ this -> par [ $ to ] = $ node ; $ this -> search ( $ to ) ; $ dim ++ ; $ this -> low [ $ node ] = min ( $ this -> low [ $ node ] , $ this -> low [ $ to ] ) ; if ( $ node != $ this -> root and $ this -> ord [ $ node ] <= $ this -> low [ $ to ] ) { $ this -> articulations [ ] = $ node ; } } else { $ this -> low [ $ node ] = min ( $ this -> low [ $ node ] , $ this -> ord [ $ to ] ) ; } if ( $ node == $ this -> root and $ dim > 1 ) { $ this -> articulations [ ] = $ node ; } if ( $ this -> ord [ $ node ] < $ this -> low [ $ to ] ) { $ this -> bridges [ ] = [ $ node , $ to ] ; } } } } function compBridge ( $ bridge1 , $ bridge2 ) { $ u1 = min ( $ bridge1 ) ; $ v1 = max ( $ bridge1 ) ; $ u2 = min ( $ bridge2 ) ; $ v2 = max ( $ bridge2 ) ; if ( $ u1 < $ u2 ) { return - 1 ; } elseif ( $ u1 > $ u2 ) { return 1 ; } else { if ( $ v1 < $ v2 ) { return - 1 ; } elseif ( $ v1 > $ v2 ) { return 1 ; } else { return 0 ; } } } list ( $ v , $ e ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges = array_fill ( 0 , $ v , [ ] ) ; for ( $ i = 0 ; $ i < $ e ; $ i ++ ) { list ( $ s , $ t ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges [ ( int ) $ s ] [ ] = ( int ) $ t ; $ edges [ ( int ) $ t ] [ ] = ( int ) $ s ; } $ lowlinks = new LowLinks ( $ edges , $ v , 0 ) ; $ lowlinks -> build ( ) ; $ articulations = array_unique ( $ lowlinks -> getArticulations ( ) ) ; sort ( $ articulations ) ; foreach ( $ articulations as $ art ) { echo $ art . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php class LowLinks { private $ edges , $ root , $ ord , $ low , $ cnt , $ bridges , $ articulations , $ par ; function __construct ( $ edges , $ v , $ root = 0 ) { $ this -> edges = $ edges ; $ this -> root = $ root ; $ this -> ord = array_fill ( 0 , $ v , null ) ; $ this -> low = array_fill ( 0 , $ v , null ) ; $ this -> cnt = 0 ; $ this -> bridges = [ ] ; $ this -> articulations = [ ] ; $ this -> par = array_fill ( 0 , $ v , null ) ; } function getArticulations ( ) { return $ this -> articulations ; } function getBridges ( ) { return $ this -> bridges ; } function build ( ) { $ this -> search ( $ this -> root ) ; } function search ( $ node ) { $ this -> ord [ $ node ] = $ this -> cnt ; $ this -> low [ $ node ] = $ this -> cnt ; $ this -> cnt ++ ; $ dim = 0 ; foreach ( $ this -> edges [ $ node ] as $ to ) { if ( $ to === $ this -> par [ $ node ] ) continue ; if ( $ this -> ord [ $ to ] === null ) { $ this -> par [ $ to ] = $ node ; $ this -> search ( $ to ) ; $ dim ++ ; $ this -> low [ $ node ] = min ( $ this -> low [ $ node ] , $ this -> low [ $ to ] ) ; if ( $ node != $ this -> root and $ this -> ord [ $ node ] <= $ this -> low [ $ to ] ) { $ this -> articulations [ ] = $ node ; } } else { $ this -> low [ $ node ] = min ( $ this -> low [ $ node ] , $ this -> ord [ $ to ] ) ; } if ( $ node == $ this -> root and $ dim > 1 ) { $ this -> articulations [ ] = $ node ; } if ( $ this -> ord [ $ node ] < $ this -> low [ $ to ] ) { $ this -> bridges [ ] = [ $ node , $ to ] ; } } } } function compBridge ( $ bridge1 , $ bridge2 ) { $ u1 = min ( $ bridge1 ) ; $ v1 = max ( $ bridge1 ) ; $ u2 = min ( $ bridge2 ) ; $ v2 = max ( $ bridge2 ) ; if ( $ u1 < $ u2 ) { return - 1 ; } elseif ( $ u1 > $ u2 ) { return 1 ; } else { if ( $ v1 < $ v2 ) { return - 1 ; } elseif ( $ v1 > $ v2 ) { return 1 ; } else { return 0 ; } } } list ( $ v , $ e ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges = array_fill ( 0 , $ v , [ ] ) ; for ( $ i = 0 ; $ i < $ e ; $ i ++ ) { list ( $ s , $ t ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ edges [ ( int ) $ s ] [ ] = ( int ) $ t ; $ edges [ ( int ) $ t ] [ ] = ( int ) $ s ; } $ lowlinks = new LowLinks ( $ edges , $ v , 0 ) ; $ lowlinks -> build ( ) ; $ bridges = $ lowlinks -> getBridges ( ) ; usort ( $ bridges , \" compBridge \" ) ; foreach ( $ bridges as $ bridge ) { echo min ( $ bridge ) . \" \" . max ( $ bridge ) . \" \\n \" ; }",
    "label": 3
  },
  {
    "code": "<?php $ arr = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ p = array_chunk ( $ arr , 2 ) ; $ x = abs ( $ p [ 1 ] [ 0 ] - $ p [ 0 ] [ 0 ] ) ; $ y = abs ( $ p [ 1 ] [ 1 ] - $ p [ 0 ] [ 1 ] ) ; echo sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %f %f %f %f ' , $ x1 , $ y1 , $ x2 , $ y2 ) ; $ x = abs ( $ x1 - $ x2 ) ; $ y = abs ( $ y1 - $ y2 ) ; echo sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f %f %f %f \" , $ x1 , $ y1 , $ x2 , $ y2 ) ; $ dx = $ x2 - $ x1 ; $ dy = $ y2 - $ y1 ; $ ans = sqrt ( pow ( $ dx , 2 ) + pow ( $ dy , 2 ) ) ; echo \" $ ans \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ a = pow ( ( $ x2 - $ x1 ) , 2 ) ; $ b = pow ( ( $ y2 - $ y1 ) , 2 ) ; print sqrt ( $ a + $ b ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ d = sqrt ( pow ( $ x1 - $ x2 , 2 ) + pow ( $ y1 - $ y2 , 2 ) ) ; print $ d ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = trim ( fgets ( STDIN ) ) ; $ data = explode ( \" \" , $ input ) ; $ dx = $ data [ 2 ] - $ data [ 0 ] ; $ dy = $ data [ 3 ] - $ data [ 1 ] ; $ ab = sqrt ( $ dx * $ dx + $ dy * $ dy ) ; echo $ ab . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php class Distance { public function __construct ( Point $ point1 , Point $ point2 ) { $ this -> point1 = $ point1 ; $ this -> point2 = $ point2 ; } public function compute ( ) { return sqrt ( pow ( $ this -> point2 -> x ( ) - $ this -> point1 -> x ( ) , 2 ) + pow ( $ this -> point2 -> y ( ) - $ this -> point1 -> y ( ) , 2 ) ) ; } } class Point { private $ x ; private $ y ; public function __construct ( $ x , $ y ) { $ this -> x = $ x ; $ this -> y = $ y ; } public function x ( ) { return $ this -> x ; } public function y ( ) { return $ this -> y ; } } fscanf ( STDIN , ' %f %f %f %f ' , $ x1 , $ y1 , $ x2 , $ y2 ) ; echo ( new Distance ( new Point ( $ x1 , $ y1 ) , new Point ( $ x2 , $ y2 ) ) ) -> compute ( ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php class Distance { public function __construct ( Point $ point1 , Point $ point2 ) { $ this -> point1 = $ point1 ; $ this -> point2 = $ point2 ; } public function compute ( ) { return sqrt ( pow ( $ this -> point2 -> x ( ) - $ this -> point1 -> x ( ) , 2 ) + pow ( $ this -> point2 -> y ( ) - $ this -> point1 -> y ( ) , 2 ) ) ; } } class Point { private $ x ; private $ y ; public function __construct ( $ x , $ y ) { $ this -> x = $ x ; $ this -> y = $ y ; } public function x ( ) { return $ this -> x ; } public function y ( ) { return $ this -> y ; } } fscanf ( STDIN , ' %f %f %f %f ' , $ x1 , $ y1 , $ x2 , $ y2 ) ; $ point1 = new Point ( $ x1 , $ y1 ) ; $ point2 = new Point ( $ x2 , $ y2 ) ; echo ( new Distance ( $ point1 , $ point2 ) ) -> compute ( ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ op = pow ( ( $ x2 - $ x1 ) , 2 ) + pow ( ( $ y2 - $ y1 ) , 2 ) ; echo sqrt ( $ op ) ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; echo sqrt ( pow ( $ x1 - $ x2 , 2 ) + pow ( $ y1 - $ y2 , 2 ) ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; echo sqrt ( pow ( $ x1 - $ x2 , 2 ) + pow ( $ y1 - $ y2 , 2 ) ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f %f %f %f \" , $ x1 , $ y1 , $ x2 , $ y2 ) ; $ x = abs ( $ x2 - $ x1 ) ; $ y = abs ( $ y2 - $ y1 ) ; echo sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f %f %f %f \" , $ x1 , $ y1 , $ x2 , $ y2 ) ; echo sqrt ( pow ( abs ( $ x2 - $ x1 ) , 2 ) + pow ( abs ( $ y2 - $ y1 ) , 2 ) ) . PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ a = $ x2 - $ x1 ; $ b = $ y2 - $ y1 ; echo sqrt ( $ a * $ a + $ b * $ b ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; echo sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ x1 , $ y1 , $ x2 , $ y2 ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; echo sprintf ( \" %.10f \\n \" , sqrt ( ( $ x2 - $ x1 ) * ( $ x2 - $ x1 ) + ( $ y2 - $ y1 ) * ( $ y2 - $ y1 ) ) ) ;",
    "label": 3
  },
  {
    "code": "<?php $ nums = explode ( ' ' , trim ( fgets ( STDIN ) ) ) ; $ x1 = $ nums [ 0 ] ; $ y1 = $ nums [ 1 ] ; $ x2 = $ nums [ 2 ] ; $ y2 = $ nums [ 3 ] ; $ answer = sqrt ( ( $ x2 - $ x1 ) * ( $ x2 - $ x1 ) + ( $ y2 - $ y1 ) * ( $ y2 - $ y1 ) ) ; echo $ answer . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f %f %f %f \" , $ x1 , $ y1 , $ x2 , $ y2 ) ; echo sqrt ( abs ( $ x2 - $ x1 ) ** 2 + abs ( $ y2 - $ y1 ) ** 2 ) , PHP_EOL ;",
    "label": 3
  },
  {
    "code": "<?php $ num = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; echo sqrt ( pow ( $ num [ 2 ] - $ num [ 0 ] , 2 ) + pow ( $ num [ 3 ] - $ num [ 1 ] , 2 ) ) ; echo \" \\n \" ; ?>",
    "label": 3
  },
  {
    "code": "<?php $ input = STDIN ; list ( $ x1 , $ y1 , $ x2 , $ y2 ) = array_map ( \" floatval \" , explode ( ' ' , trim ( fgets ( $ input ) ) ) ) ; $ d = ( ( $ x1 - $ x2 ) ** 2 + ( $ y1 - $ y2 ) ** 2 ) ** 0.5 ; print $ d . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f %f %f %f \" , $ x_1 , $ y_1 , $ x_2 , $ y_2 ) ; $ x_diff = abs ( $ x_2 - $ x_1 ) ; $ y_diff = abs ( $ y_2 - $ y_1 ) ; $ x_diff = $ x_diff ** 2 ; $ y_diff = $ y_diff ** 2 ; echo sqrt ( $ x_diff + $ y_diff ) . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ a , $ b , $ C ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ h = $ b * sin ( deg2rad ( $ C ) ) ; echo $ a * $ h / 2 . \" \\n \" ; echo $ a + $ b + sqrt ( $ a * $ a + $ b * $ b - 2 * $ a * $ b * cos ( deg2rad ( $ C ) ) ) . \" \\n \" ; echo $ h . \" \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , ' %d %d %d ' , $ a , $ b , $ C ) ; $ rad = deg2rad ( $ C ) ; $ S = $ a * $ b / 2 * sin ( $ rad ) ; $ c = sqrt ( pow ( $ a , 2 ) + pow ( $ b , 2 ) - 2 * $ a * $ b * cos ( $ rad ) ) ; $ L = $ a + $ b + $ c ; $ h = 2 * $ S / $ a ; printf ( \" %f \\n %f \\n %f \\n \" , $ S , $ L , $ h ) ;",
    "label": 3
  },
  {
    "code": "<?php fscanf ( STDIN , \" %f %f %f \" , $ a , $ b , $ C ) ; $ h = $ b * sin ( deg2rad ( $ C ) ) ; $ da = $ a - ( $ b * cos ( deg2rad ( $ C ) ) ) ; $ c = sqrt ( pow ( $ da , 2 ) + pow ( $ h , 2 ) ) ; $ S = $ a * $ h / 2.0 ; $ L = $ a + $ b + $ c ; echo \" $ S $ L $ h \\n \" ;",
    "label": 3
  },
  {
    "code": "<?php list ( $ a , $ b , $ r ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ s = 0.5 * ( $ a * $ b ) * ( sin ( $ r * ( M_PI / 180 ) ) ) ; $ l = $ a + $ b + sqrt ( pow ( $ a , 2 ) + pow ( $ b , 2 ) - ( 2 * $ a * $ b * cos ( $ r * ( M_PI / 180 ) ) ) ) ; $ h = $ b * sin ( $ r * ( M_PI / 180 ) ) ; print ( $ s . \" \\n \" . $ l . \" \\n \" . $ h ) ; ?>",
    "label": 3
  },
  {
    "code": "<?php list ( $ a , $ b , $ C ) = explode ( \" \" , trim ( fgets ( STDIN ) ) ) ; $ rC = deg2rad ( $ C ) ; $ h = sin ( $ rC ) * $ b ; $ ta = cos ( $ rC ) * $ b ; $ c = sqrt ( pow ( $ a - $ ta , 2 ) + pow ( $ h , 2 ) ) ; $ S = ( $ a * $ h ) / 2 ; $ L = $ a + $ b + $ c ; print $ S . PHP_EOL . $ L . PHP_EOL . $ h ; ?>",
    "label": 3
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" % d \\n \" , i ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" sort \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var height int topHeights := [ 5 ] int { } for i := 0 ; i < 10 ; i ++ { fmt . Scan ( & height ) for j := 0 ; j < 3 ; j ++ { if topHeights [ j ] < height { topHeights [ j + 2 ] = topHeights [ j + 1 ] topHeights [ j + 1 ] = topHeights [ j ] topHeights [ j ] = height break } } } for i := 0 ; i < 3 ; i ++ { fmt . Println ( topHeights [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" sort \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" % d \\n \" , mountHeightList [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" % + v \" \" \" \" \\n \" , - 1 ) fmt . Println ( arrStr ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" sort \" \" % d \\n % d \\n % d \\n \" , mt [ 9 ] , mt [ 8 ] , mt [ 7 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { mountains := make ( [ ] int , 10 , 10 ) for i := 0 ; i < 10 ; i ++ { fmt . Scan ( & mountains [ i ] ) } sort . Sort ( sort . Reverse ( sort . IntSlice ( mountains ) ) ) for i := 0 ; i < 3 ; i ++ { fmt . Println ( mountains [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var a int var i int dataint := [ 10 ] int { } i = 0 for _ , err := fmt . Scan ( & a ) ; err == nil ; _ , err = fmt . Scan ( & a ) { dataint [ i ] = a i ++ } sort . Ints ( dataint [ : ] ) for i := 9 ; i > 6 ; i -- { fmt . Println ( dataint [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var num int fmt . Scan ( & num ) for i := 0 ; i < num ; i ++ { s1 := 0 s2 := 0 s3 := 0 var chk int = 0 fmt . Scanf ( \" \" , & s1 , & s2 , & s3 ) if s1 >= s2 { if s1 > s3 { chk = 1 } else { chk = 3 } } else { if s2 >= s3 { chk = 2 } else { chk = 3 } } if ( chk == 1 && s1 * s1 == s2 * s2 + s3 * s3 ) || ( chk == 2 && s2 * s2 == s3 * s3 + s1 * s1 ) || ( chk == 3 && s3 * s3 == s1 * s1 + s2 * s2 ) { fmt . Printf ( \" \\n \" ) } else { fmt . Printf ( \" \\n \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" sort \" \" strconv \" \" strings \" \" \" \" NO \" \" YES \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" sort \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" sort \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { lines := [ 3 ] int { } var round int fmt . Scan ( & round ) for r := 0 ; r < round ; r ++ { fmt . Scan ( & lines [ 0 ] , & lines [ 1 ] , & lines [ 2 ] ) if lines [ 0 ] > lines [ 1 ] && lines [ 0 ] > lines [ 2 ] { } else if lines [ 2 ] > lines [ 1 ] { tmp := lines [ 0 ] lines [ 0 ] = lines [ 2 ] lines [ 2 ] = tmp } else { tmp := lines [ 0 ] lines [ 0 ] = lines [ 1 ] lines [ 1 ] = tmp } if lines [ 1 ] * lines [ 1 ] + lines [ 2 ] * lines [ 2 ] == lines [ 0 ] * lines [ 0 ] { fmt . Println ( \" YES \" ) } else { fmt . Println ( \" NO \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" YES \" \" NO \" \" \" \" % s \\n \" , res ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" sort \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) nQueries := nextInt ( ) for i := 0 ; i < nQueries ; i ++ { lengths := [ ] int { nextInt ( ) , nextInt ( ) , nextInt ( ) } sort . Slice ( lengths , func ( i , j int ) bool { return lengths [ i ] > lengths [ j ] } ) if math . Pow ( float64 ( lengths [ 0 ] ) , 2 ) == math . Pow ( float64 ( lengths [ 1 ] ) , 2 ) + math . Pow ( float64 ( lengths [ 2 ] ) , 2 ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scanf ( \" % d \" \" % d % d % d \" \" YES \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" sort \" \" strconv \" \" strings \" \" YES \" \" NO \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a int var b int var c int var n int fmt . Scan ( & n ) for _ , err := fmt . Scan ( & a , & b , & c ) ; err == nil ; _ , err = fmt . Scan ( & a , & b , & c ) { if a * a == b * b + c * c { fmt . Println ( \" \" ) } else if b * b == c * c + a * a { fmt . Println ( \" \" ) } else if c * c == a * a + b * b { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" math \" \" % f % f % f % f % f % f \" \" % .3 f % .3 f \\n \" , x , y ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var resultX , resultY [ 100 ] float32 var count int for { var a , b , c , d , e , f , x , y float32 fmt . Scanf ( \" % f % f % f % f % f % f \" , & a , & b , & c , & d , & e , & f ) if a == 0 { break } y = ( ( ( a * f ) - ( d * c ) ) / ( ( a * e ) - ( b * d ) ) ) x = ( ( c - ( b * y ) ) / a ) resultX [ count ] = x resultY [ count ] = y count + + } for i := 0 ; i < count ; i ++ { fmt . Printf ( \" \\n \" , resultX [ i ] , resultY [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var resultX , resultY [ 100 ] float32 var count int for { var a , b , c , d , e , f , x , y float32 fmt . Scanf ( \" % f % f % f % f % f % f \" , & a , & b , & c , & d , & e , & f ) if a == 0 { break } y = ( ( ( a * f ) - ( d * c ) ) / ( ( a * e ) - ( b * d ) ) ) x = ( ( c - ( b * y ) ) / a ) resultX [ count ] = x resultY [ count ] = y count + + } for i := 0 ; i < count ; i ++ { fmt . Printf ( \" \\n \" , resultX [ i ] , resultY [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var Xs , Ys [ ] float32 Xs = make ( [ ] float32 , 0 ) Ys = make ( [ ] float32 , 0 ) var cnt int for { var a , b , c , d , e , f , x , y float32 fmt . Scanf ( \" % f % f % f % f % f % f \" , & a , & b , & c , & d , & e , & f ) if a == 0 { break } y = ( ( ( a * f ) - ( d * c ) ) / ( ( a * e ) - ( b * d ) ) ) x = ( ( c - ( b * y ) ) / a ) Xs = append ( Xs , x ) Ys = append ( Ys , y ) cnt ++ } for i := 0 ; i < cnt ; i ++ { fmt . Printf ( \" \\n \" , Xs [ i ] , Ys [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" % .3 f % .3 f \\n \" , round ( x ) , round ( y ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % .3 f % .3 f \\n \" , x , y ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { for { var a , b , c , d , e , f float64 var x , y float64 i , _ := fmt . Scanf ( \" % f % f % f % f % f % f \" \" % .3 f % .3 f \\n \" , x , y ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" 0.000 % .3 f \\n \" , y ) } else if y == 0 { fmt . Printf ( \" % .3 f 0.000 \\n \" , x ) } else { fmt . Printf ( \" % .3 f % .3 f \\n \" , x , y ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { for { var a , b , c , d , e , f float64 i , _ := fmt . Scan ( & a , & b , & c , & d , & e , & f ) if i == 0 { break } y := ( c * d - a * f ) / ( b * d - a * e ) x := ( c - b * y ) / a fmt . Printf ( \" \\n \" , x , y ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a , b , c , d , e , f float64 var x , y float64 for _ , err := fmt . Scan ( & a , & b , & c , & d , & e , & f ) ; err == nil ; _ , err = fmt . Scan ( & a , & b , & c , & d , & e , & f ) { y = ( a * f - c * d ) / ( a * e - b * d ) x = ( c - b * y ) / a fmt . Printf ( \" \\n \" , x , y ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" % d % d \" \" % d % d \\n \" , gcd , ( a / gcd ) * b ) } } func gcd ( a int , b int ) ( gcd int ) { var i , j , k int if a > b { i = a j = b } else { i = b j = a } k = i % j for k > 0 { num := i i = j j = num % i k = i % j } return j }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" strconv \" \" bufio \" \" strings \" \" % d % d \\n \" , x , y ) } } func nextInts ( ) ( a , b int ) { s := strings . Split ( sc . Text ( ) , \" \" ) ra , _ := strconv . Atoi ( s [ 0 ] ) rb , _ := strconv . Atoi ( s [ 1 ] ) a = ra b = rb return } func gcd ( x , y int ) int { if x < y { gcd ( y , x ) } for 0 < y { r := x % y x , y = y , r } return x } func lcm ( x , y int ) int { return ( x * y ) / gcd ( x , y ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d % d \\n \" , x , y ) } } func nextInts ( ) ( a , b int ) { s := strings . Split ( sc . Text ( ) , \" \" ) ra , _ := strconv . Atoi ( s [ 0 ] ) rb , _ := strconv . Atoi ( s [ 1 ] ) a = ra b = rb return } func gcd ( x , y int ) int { if x < y { gcd ( y , x ) } for 0 < y { r := x % y x , y = y , r } return x } func lcm ( x , y int ) int { return ( x * y ) / gcd ( x , y ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func GCM ( a , b int ) int { if a < b { a , b = b , a } if b == 0 { return a } return GCM ( b , a % b ) } func LCM ( a , b int ) int { return a * b / GCM ( a , b ) } func main ( ) { for { var a , b int var G , L int fmt . Scanf ( \" % d % d \" \" % d % d \\n \" , G , L ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func gcd ( x , y int64 ) int64 { for y != 0 { r := x % y x = y y = r } return x } func lcm ( x , y int64 ) int64 { return x / gcd ( x , y ) * y } func main ( ) { for { var a , b int64 fmt . Scanf ( \" % d % d \" , & a , & b ) if a == 0 && b == 0 { break } fmt . Printf ( \" \\n \" , gcd ( a , b ) , lcm ( a , b ) ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var a , b int var gcd , lcm int for { _ , err := fmt . Scanf ( \" % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a , b int for { i , _ := fmt . Scan ( & a , & b ) if i == 0 { break } gcd := getGCD ( a , b ) fmt . Println ( gcd , getLCM ( a , b , gcd ) ) } } func getGCD ( a , b int ) int { if b == 0 { return a } return getGCD ( b , a % b ) } func getLCM ( a , b , gcd int ) int { return a * b / gcd }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func gcd ( a , b int ) int { if b == 0 { return a } return gcd ( b , a % b ) } func main ( ) { var a , b , c int for _ , err := fmt . Scan ( & a , & b ) ; err == nil ; _ , err = fmt . Scan ( & a , & b ) { c = gcd ( a , b ) fmt . Println ( c , a * b / c ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var str string fmt . Scanf ( \" % s \" , & str ) show ( len ( str ) - 1 , str ) } func show ( n int , str string ) { if n == 0 { fmt . Printf ( \" \\n \" , string ( str [ n ] ) ) } else { fmt . Printf ( \" \" , string ( str [ n ] ) ) show ( n - 1 , str ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var str string fmt . Scanf ( \" % s \" , & str ) fmt . Printf ( \" \\n \" , strReverse ( str ) ) } func strReverse ( str string ) string { data := [ ] rune ( str ) result := [ ] rune { } for i := len ( data ) - 1 ; i >= 0 ; i -- { result = append ( result , data [ i ] ) } return string ( result ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var str string rts := [ ] string { } fmt . Scan ( & str ) for _ , r := range str { rts = append ( [ ] string { string ( r ) } , rts ... ) } for _ , v := range rts { fmt . Print ( v ) } fmt . Println ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var str string var result string fmt . Scanf ( \" % s \" , & str ) for i := len ( str ) - 1 ; i >= 0 ; i -- { result += string ( str [ i ] ) } fmt . Println ( result ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a string fmt . Scan ( & a ) for i := len ( a ) - 1 ; i >= 0 ; i -- { fmt . Print ( string ( a [ i ] ) ) } fmt . Println ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d \" \" % d \\n \" , int ( debt * 1000 ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" math \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" bufio \" \" math \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d \" \" % d \\n \" , interestDebt ) } func MakeCalcInterest ( x float64 ) int { return int ( ( x * INTEREST ) ) } func RoundUp ( x float64 ) int { return int ( math . Ceil ( x * 0.001 ) * 1000 ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func roundUp1000 ( dept float64 ) float64 { iDept := int ( dept ) if iDept - ( iDept / 1000 * 1000 ) != 0 { iDept = ( ( iDept / 1000 ) + 1 ) * 1000 } return float64 ( iDept ) } func main ( ) { var week int fmt . Scan ( & week ) dept := 100000.0 for i := 0 ; i < week ; i ++ { dept *= 1.05 dept = roundUp1000 ( dept ) } fmt . Println ( int ( dept ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" math \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) n := nextInt ( ) debt := 100.0 for i := 1 ; i <= n ; i ++ { debt = math . Ceil ( 1.05 * debt ) } fmt . Println ( int ( math . Ceil ( debt ) ) * 1000 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var n int fmt . Scan ( & n ) r := 100.0 for i := 0 ; i < n ; i ++ { r = math . Ceil ( 1.05 * r ) } fmt . Println ( int ( r * 1000 ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a int var b int b = 100000 fmt . Scan ( & a ) for i := 0 ; i < a ; i ++ { b *= 105 b /= 100 if ( b % 1000 != 0 ) { b -= b % 1000 b += 1000 } } fmt . Println ( b ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" bufio \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { const MAX = 1000000 prime := make ( [ ] int , MAX , MAX ) check := make ( [ ] int , MAX , MAX ) count := make ( [ ] int , MAX , MAX ) prime [ 0 ] = 1 prime [ 1 ] = 1 for i := 2 ; i < MAX ; i ++ { if check [ i ] == 1 { continue } if prime [ i ] == 0 { for j := i * 2 ; j < MAX ; j += i { check [ j ] = 1 prime [ j ] = 1 } } } for i := 2 ; i < MAX ; i ++ { cnt := 0 if prime [ i ] == 0 { cnt = 1 } count [ i ] = count [ i - 1 ] + cnt } for { var input int inputCount , _ := fmt . Scanf ( \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) const MAX int = 1000000 var primes [ MAX ] int func main ( ) { Init ( ) var n , cnt int for { _ , err := fmt . Scanf ( \" % d \" \" % d \\n \" , cnt ) } } func Init ( ) { for i := 0 ; i < MAX ; i ++ { primes [ i ] = 1 } primes [ 0 ] = 0 primes [ 1 ] = 0 Soe ( ) } func Soe ( ) { for i := 2 ; i < MAX ; i ++ { if primes [ i ] > 0 { for j := i * 2 ; j < MAX ; j += i { primes [ j ] = 0 } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { const N = 1000000 var temp [ N + 1 ] bool for i := 0 ; i < N + 1 ; i ++ { temp [ i ] = true } temp [ 0 ] = false temp [ 1 ] = false for i := 2 ; i < int ( math . Ceil ( math . Sqrt ( float64 ( N + 1 ) ) ) ) ; i ++ { if ( temp [ i ] ) { for j := i * 2 ; j < N + 1 ; j += i { temp [ j ] = false } } } var a int var b int for _ , err := fmt . Scan ( & a ) ; err == nil ; _ , err = fmt . Scan ( & a ) { b = 0 for i := 0 ; i <= a ; i ++ { if temp [ i ] { b + + } } fmt . Println ( b ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d \" \" % f % f % f % f % f % f \" \" % .3 f % .3 f % .3 f \\n \" , px , py , r ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d \" \" % f % f % f % f % f % f \" \" % .3 f % .3 f % .3 f \\n \" , px , py , r ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" strings \" \" getInt ( % d ) \" \" % f \" \" % .3 f % .3 f % .3 f \\n \" , c . x , c . y , math . Sqrt ( v1c . x * v1c . x + v1c . y * v1c . y ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % f % f % f % f % f % f \" \" % .3 f % .3 f % .3 f \\n \" , px , py , r ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" strings \" \" , \" ) a , _ := strconv . Atoi ( infos [ 0 ] ) b , _ := strconv . Atoi ( infos [ 1 ] ) swap ( nums , a - 1 , b - 1 ) } for _ , v := range nums { fmt . Println ( v ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) w := nextInt ( ) n := nextInt ( ) numbers := make ( [ ] int , w + 1 ) for i := 1 ; i <= w ; i ++ { numbers [ i ] = i } for i := 0 ; i < n ; i ++ { line := nextString ( ) words := strings . Split ( line , \" \" ) a , _ := strconv . Atoi ( words [ 0 ] ) b , _ := strconv . Atoi ( words [ 1 ] ) numbers [ a ] , numbers [ b ] = numbers [ b ] , numbers [ a ] } for i := 1 ; i <= w ; i ++ { fmt . Println ( numbers [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var w , n int fmt . Scan ( & w ) numbers := make ( [ ] int , w ) fmt . Scan ( & n ) intersect := make ( [ ] [ 2 ] int , n ) for i := 0 ; i < n ; i ++ { var x , y int fmt . Scanf ( \" \" , & x , & y ) intersect [ i ] = [ 2 ] int { x , y } } for i := 0 ; i < w ; i ++ { numbers [ i ] = i + 1 } for _ , v := range intersect { swap ( numbers , v [ 0 ] , v [ 1 ] ) } for _ , v := range numbers { fmt . Println ( v ) } } func swap ( arr [ ] int , x , y int ) { tmp := arr [ x - 1 ] arr [ x - 1 ] = arr [ y - 1 ] arr [ y - 1 ] = tmp }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) const MAX_N = 31 var lines [ MAX_N ] int func main ( ) { var n , w int fmt . Scanf ( \" % d \" \" % d \" \" % d , % d \" \" % d \\n \" , lines [ i ] ) } } func Swp ( l int , r int ) { var s int s = lines [ l ] lines [ l ] = lines [ r ] lines [ r ] = s } func Init ( ) { for i := 0 ; i < MAX_N ; i ++ { lines [ i ] = i } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" , \" ) a , _ := strconv . Atoi ( s [ 0 ] ) b , _ := strconv . Atoi ( s [ 1 ] ) l [ a - 1 ] , l [ b - 1 ] = l [ b - 1 ] , l [ a - 1 ] } for _ , j := range l { fmt . Println ( j ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var i int stack := make ( [ ] int , 0 ) for { v , _ := fmt . Scan ( & i ) if v == 0 { break } if i == 0 { fmt . Println ( stack [ len ( stack ) - 1 ] ) stack = stack [ : len ( stack ) - 1 ] continue } stack = append ( stack , i ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var stk [ 101 ] int var c int pvt := 0 for { _ , err := fmt . Scanf ( \" \" , & c ) if err != nil { break } if c > 0 { stk [ pvt ] = c pvt + + } else { pvt -- fmt . Printf ( \" \\n \" , stk [ pvt ] ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { stack := [ ] int { } for { var a int i , _ := fmt . Scan ( & a ) if i == 0 { break } if a == 0 { fmt . Println ( stack [ len ( stack ) - 1 ] ) stack = stack [ : len ( stack ) - 1 ] continue } stack = append ( stack , a ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / big \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) const maxCapacity = 512 * 1024 buf := make ( [ ] byte , maxCapacity ) scanner . Buffer ( buf , maxCapacity ) n := nextInt ( ) maxint , _ := new ( big . Int ) . SetString ( \" \" , 10 ) for i := 0 ; i < n ; i ++ { aStr := nextString ( ) bStr := nextString ( ) a , _ := new ( big . Int ) . SetString ( aStr , 10 ) b , _ := new ( big . Int ) . SetString ( bStr , 10 ) c := big . NewInt ( 0 ) . Add ( a , b ) if c . Cmp ( maxint ) < 0 { fmt . Println ( c ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" % d \" \" overflow \" \" % d \" \" \\n \" ) } else { if len ( a ) - 1 >= 80 { fmt . Printf ( \" \" ) } else { for i := 0 ; i < len ( a ) ; i ++ { fmt . Printf ( \" \" , s [ len ( a ) - i - 1 ] ) } } fmt . Printf ( \" \\n \" ) } } else { s := add ( b , a ) if s [ len ( b ) ] > 0 { if len ( b ) >= 80 { fmt . Printf ( \" \" ) } else { for i := 0 ; i <= len ( b ) ; i ++ { fmt . Printf ( \" \" , s [ len ( b ) - i ] ) } } fmt . Printf ( \" \\n \" ) } else { if len ( b ) - 1 >= 80 { fmt . Printf ( \" \" ) } else { for i := 0 ; i < len ( b ) ; i ++ { fmt . Printf ( \" \" , s [ len ( b ) - i - 1 ] ) } } fmt . Printf ( \" \\n \" ) } } } } func add ( n string , m string ) ( s [ 100 ] int ) { ln := len ( n ) lm := len ( m ) var sum [ 100 ] int for i := 0 ; i < ln ; i ++ { var s , t int s = int ( n [ ln - 1 - i ] ) - int ( '0' ) if lm - 1 - i >= 0 { t = int ( m [ lm - 1 - i ] ) - int ( '0' ) } else { t = 0 } sum [ i + 1 ] = ( s + t + sum [ i ] ) / 10 sum [ i ] = ( s + t + sum [ i ] ) % 10 } return sum }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / big \" \" os \" \" strconv \" \" overflow \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" strings \" \" strconv \" \" , \" ) a_int , _ := strconv . Atoi ( infos [ 0 ] ) b_int , _ := strconv . Atoi ( infos [ 1 ] ) a = float64 ( a_int ) b = float64 ( b_int ) if a == 0 && b == 0 { break } x += math . Cos ( now * math . Pi / 180 ) * a y += math . Sin ( now * math . Pi / 180 ) * a now -= b } fmt . Printf ( \" \\n \\n \" , int ( x ) , int ( y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" 0 , 0 \" { break } numbers : = strings . Split ( line , \" \" ) di , _ := strconv . ParseFloat ( numbers [ 0 ] , 64 ) ai , _ := strconv . ParseFloat ( numbers [ 1 ] , 64 ) rotateRadian := math . Pi * rotate / 180.0 x += di * math . Cos ( rotateRadian ) y += di * math . Sin ( rotateRadian ) rotate -= ai } fmt . Println ( int ( x ) ) fmt . Println ( int ( y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % f , % f \" \" % d \\n \" , int ( x ) ) fmt . Printf ( \" \\n \" , int ( y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" , \" ) if data [ 0 ] == \" \" && data [ 1 ] == \" \" { break } meters , _ := strconv . Atoi ( data [ 0 ] ) m := float64 ( meters ) changedAngle , _ := strconv . Atoi ( data [ 1 ] ) a := float64 ( changedAngle ) radian := angle * math . Pi / 180 x += m * math . Cos ( radian ) y += m * math . Sin ( radian ) angle -= a } fmt . Println ( int ( x ) ) fmt . Println ( int ( y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" sort \" \" fmt \" \" % d \\n \" , v ) } else { fmt . Printf ( \" % d \" , v ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) n := 5 array := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { array [ i ] = nextInt ( ) } sort . Slice ( array , func ( i , j int ) bool { return array [ i ] > array [ j ] } ) arrayStr := fmt . Sprint ( array ) l := len ( arrayStr ) fmt . Println ( arrayStr [ 1 : ( l - 1 ) ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" sort \" \" % d \" \" % d \" \" \" \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" sort \" \" % d % d % d % d % d \\n \" , dataset [ 0 ] , dataset [ 1 ] , dataset [ 2 ] , dataset [ 3 ] , dataset [ 4 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func abs ( x float64 ) float64 { if x < 0 { return - x } return x } func main ( ) { var n int var x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 float64 fmt . Scan ( & n ) for i := 0 ; i < n ; i ++ { fmt . Scanf ( \" \" , & x1 , & y1 , & x2 , & y2 , & x3 , & y3 , & x4 , & y4 ) if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( y2 - y1 ) * ( x4 - x3 ) ) < 1e-10 { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 big . Float var n int fmt . Scanf ( \" % d \" \" % f % f % f % f % f % f % f % f \" \" YES \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var n int fmt . Scan ( & n ) for i := 0 ; i < n ; i ++ { var xa , ya , ra , xb , yb , rb float64 fmt . Scan ( & xa , & ya , & ra , & xb , & yb , & rb ) dis := math . Sqrt ( ( xa - xb ) * ( xa - xb ) + ( ya - yb ) * ( ya - yb ) ) if dis + ra < rb { fmt . Println ( - 2 ) } else if dis + rb < ra { fmt . Println ( 2 ) } else if dis > rb + ra { fmt . Println ( 0 ) } else { fmt . Println ( 1 ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d \" \" % f % f % f % f % f % f \" \" 2 \" ) } else { fmt . Println ( \" \" ) } } else { if br > ar + d { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } } else { fmt . Println ( 0 ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var n int fmt . Scan ( & n ) for i := 0 ; i < n ; i ++ { var xa , ya , ra , xb , yb , rb float64 fmt . Scan ( & xa , & ya , & ra , & xb , & yb , & rb ) distance := math . Sqrt ( ( xb - xa ) * ( xb - xa ) + ( yb - ya ) * ( yb - ya ) ) if rb + distance < ra { fmt . Println ( 2 ) } else if ra + distance < rb { fmt . Println ( - 2 ) } else if rb + ra >= distance { fmt . Println ( 1 ) } else { fmt . Println ( 0 ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" % d \\n \" , int ( ans ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % f \" \" % d \\n \" , int ( n ) ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var v float64 for { i , _ := fmt . Scan ( & v ) if i == 0 { break } t := v / 9.8 y := 4.9 * t * t N := 0 for { N ++ if height := 5 * N - 5 ; float64 ( height ) > y { fmt . Println ( N ) break } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \" \" \" \" % d % d \\n \" , hit , blow ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var a1 , a2 , a3 , a4 , b1 , b2 , b3 , b4 int for { i , _ := fmt . Scan ( & a1 , & a2 , & a3 , & a4 ) if i == 0 { break } fmt . Scan ( & b1 , & b2 , & b3 , & b4 ) a := [ 4 ] int { a1 , a2 , a3 , a4 } b := [ 4 ] int { b1 , b2 , b3 , b4 } var hit , blow int for j := 0 ; j < 4 ; j ++ { for k := 0 ; k < 4 ; k ++ { if a [ j ] == b [ k ] { if j == k { hit ++ } else { blow ++ } } } } fmt . Println ( hit , blow ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" , \" ) x , _ := strconv . Atoi ( infos [ 0 ] ) y , _ := strconv . Atoi ( infos [ 1 ] ) s , _ := strconv . Atoi ( infos [ 2 ] ) switch s { case 1 : paper [ x ] [ y ] ++ if rangeCheck ( x , y - 1 ) { paper [ x ] [ y - 1 ] ++ } if rangeCheck ( x , y + 1 ) { paper [ x ] [ y + 1 ] ++ } if rangeCheck ( x - 1 , y ) { paper [ x - 1 ] [ y ] ++ } if rangeCheck ( x + 1 , y ) { paper [ x + 1 ] [ y ] ++ } continue case 2 : paper [ x ] [ y ] ++ if rangeCheck ( x - 1 , y - 1 ) { paper [ x - 1 ] [ y - 1 ] ++ } if rangeCheck ( x , y - 1 ) { paper [ x ] [ y - 1 ] ++ } if rangeCheck ( x + 1 , y - 1 ) { paper [ x + 1 ] [ y - 1 ] ++ } if rangeCheck ( x - 1 , y ) { paper [ x - 1 ] [ y ] ++ } if rangeCheck ( x + 1 , y ) { paper [ x + 1 ] [ y ] ++ } if rangeCheck ( x - 1 , y + 1 ) { paper [ x - 1 ] [ y + 1 ] ++ } if rangeCheck ( x , y + 1 ) { paper [ x ] [ y + 1 ] ++ } if rangeCheck ( x + 1 , y + 1 ) { paper [ x + 1 ] [ y + 1 ] ++ } continue case 3 : paper [ x ] [ y ] ++ if rangeCheck ( x - 1 , y - 1 ) { paper [ x - 1 ] [ y - 1 ] ++ } if rangeCheck ( x , y - 1 ) { paper [ x ] [ y - 1 ] ++ } if rangeCheck ( x + 1 , y - 1 ) { paper [ x + 1 ] [ y - 1 ] ++ } if rangeCheck ( x - 1 , y ) { paper [ x - 1 ] [ y ] ++ } if rangeCheck ( x + 1 , y ) { paper [ x + 1 ] [ y ] ++ } if rangeCheck ( x - 1 , y + 1 ) { paper [ x - 1 ] [ y + 1 ] ++ } if rangeCheck ( x , y + 1 ) { paper [ x ] [ y + 1 ] ++ } if rangeCheck ( x + 1 , y + 1 ) { paper [ x + 1 ] [ y + 1 ] ++ } if rangeCheck ( x , y - 2 ) { paper [ x ] [ y - 2 ] ++ } if rangeCheck ( x - 2 , y ) { paper [ x - 2 ] [ y ] ++ } if rangeCheck ( x + 2 , y ) { paper [ x + 2 ] [ y ] ++ } if rangeCheck ( x , y + 2 ) { paper [ x ] [ y + 2 ] ++ } continue } } count := 0 max := - 1 for i := range paper { for j := range paper [ i ] { if paper [ i ] [ j ] == 0 { count ++ } if max >= paper [ i ] [ j ] { max = max } else { max = paper [ i ] [ j ] } } } fmt . Printf ( \" \\n \\n \" , count , max ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) var paper [ 10 ] [ 10 ] int func main ( ) { var x , y , s int for { _ , err := fmt . Scanf ( \" \" , & x , & y , & s ) if err != nil { break } fill ( x , y , s ) } var d , z int for i := 0 ; i < 10 ; i ++ { for j := 0 ; j < 10 ; j ++ { if paper [ i ] [ j ] == 0 { z += 1 } if paper [ i ] [ j ] > d { d += 1 } } } fmt . Printf ( \" \\n \\n \" , z , d ) } func fill ( x int , y int , s int ) { paper [ x ] [ y ] += 1 if x > 0 { paper [ x - 1 ] [ y ] += 1 } if x < 9 { paper [ x + 1 ] [ y ] += 1 } if y > 0 { paper [ x ] [ y - 1 ] += 1 } if y < 9 { paper [ x ] [ y + 1 ] += 1 } if s >= 2 { if x > 0 && y > 0 { paper [ x - 1 ] [ y - 1 ] += 1 } if x > 0 && y < 9 { paper [ x - 1 ] [ y + 1 ] += 1 } if x < 9 && y > 0 { paper [ x + 1 ] [ y - 1 ] += 1 } if x < 9 && y < 9 { paper [ x + 1 ] [ y + 1 ] += 1 } } if s > 2 { if x > 1 { paper [ x - 2 ] [ y ] += 1 } if x < 8 { paper [ x + 2 ] [ y ] += 1 } if y > 1 { paper [ x ] [ y - 2 ] += 1 } if y < 8 { paper [ x ] [ y + 2 ] += 1 } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" Sunday \" \" Monday \" \" Tuesday \" \" Wednesday \" \" Thursday \" \" Friday \" \" Saturday \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" time \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var weeks = [ ] string { \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" } for { var m , d int _ , err := fmt . Scanf ( \" % d % d \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { days := [ 12 ] int { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } weekday := [ 7 ] string { \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" } for { var m , d int fmt . Scan ( & m , & d ) if m == 0 { break } for i := 0 ; i < m - 1 ; i ++ { d += days [ i ] } fmt . Println ( weekday [ d % 7 ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var max int numbers := map [ int ] int { } for { var a int _ , err := fmt . Scan ( & a ) if err != nil { break } numbers [ a ] + + if numbers [ a ] >= max { max = numbers [ a ] } } var modes [ ] int for a , b := range numbers { if b == max { modes = append ( modes , a ) } } sort . Ints ( modes ) for _ , mode := range modes { fmt . Println ( mode ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" fmt \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % 010 b \" \" % d \\n \" , wgt [ i ] ) } else { fmt . Printf ( \" \" , wgt [ i ] ) } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" , \" ) a , _ := strconv . Atoi ( info [ 0 ] ) b , _ := strconv . Atoi ( info [ 1 ] ) c , _ := strconv . Atoi ( info [ 2 ] ) if a * a + b * b == c * c { d ++ } if a == b { e ++ } } fmt . Println ( d ) fmt . Println ( e ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" , \" ) a , _ := strconv . Atoi ( l [ 0 ] ) b , _ := strconv . Atoi ( l [ 1 ] ) c , _ := strconv . Atoi ( l [ 2 ] ) if a * a + b * b == c * c { rectangle ++ } if a == b { diamond ++ } } fmt . Println ( rectangle ) fmt . Println ( diamond ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" YES \" \" NO \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func isOrdered ( a [ ] int ) bool { if len ( a ) <= 1 { return true } for i := 0 ; i + 1 < len ( a ) ; i ++ { if a [ i ] > a [ i + 1 ] { return false } } return true } func main ( ) { var t int fmt . Scan ( & t ) ans := make ( [ ] bool , t ) for i := 0 ; i < t ; i ++ { balls := make ( [ ] int , 10 ) for i := range balls { fmt . Scan ( & balls [ i ] ) } ans [ i ] = false for bits := 0 ; bits < ( 1 << uint ( 10 ) ) ; bits ++ { pipeB := make ( [ ] int , 0 ) pipeC := make ( [ ] int , 0 ) for j := 0 ; j < 10 ; j ++ { if ( bits & ( 1 << uint ( j ) ) ) != 0 { pipeB = append ( pipeB , balls [ j ] ) } else { pipeC = append ( pipeC , balls [ j ] ) } } if isOrdered ( pipeB ) && isOrdered ( pipeC ) { ans [ i ] = true break } } } for i := range ans { if ans [ i ] { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" NO \" \" YES \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" , \" ) for j := 0 ; j < 10 ; j ++ { a [ j ] , _ = strconv . ParseFloat ( info [ j ] , 64 ) } v1 , _ := strconv . ParseFloat ( info [ 10 ] , 64 ) v2 , _ := strconv . ParseFloat ( info [ 11 ] , 64 ) sum := 0.0 for i := 0 ; i < 10 ; i ++ { sum += a [ i ] } match := v1 * ( ( sum / ( v1 + v2 ) ) ) if match == 0 { fmt . Println ( 1 ) } else { sum = 0 for k := 0 ; k < 10 ; k ++ { sum += a [ k ] if match <= sum { fmt . Println ( k + 1 ) break } } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" , \" ) for j := 0 ; j < 8 ; j ++ { a [ j ] , _ = strconv . ParseFloat ( info [ j ] , 64 ) } if check ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 6 ] , a [ 7 ] ) * check ( a [ 4 ] , a [ 5 ] , a [ 2 ] , a [ 3 ] , a [ 6 ] , a [ 7 ] ) < 0 && check ( a [ 6 ] , a [ 7 ] , a [ 0 ] , a [ 1 ] , a [ 4 ] , a [ 5 ] ) * check ( a [ 2 ] , a [ 3 ] , a [ 0 ] , a [ 1 ] , a [ 4 ] , a [ 5 ] ) < 0 { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \" \" \" \" URDL \" \" % s \" \" % s \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" sort \" \" fmt \" \" , \" ) cards := make ( [ ] int , 5 ) for i := range input { cards [ i ] , _ = strconv . Atoi ( input [ i ] ) } sort . Sort ( sort . IntSlice ( cards ) ) if cards [ 0 ] == cards [ 1 ] && cards [ 2 ] == cards [ 3 ] && cards [ 2 ] == cards [ 1 ] { fmt . Println ( \" \" ) } else if cards [ 1 ] == cards [ 2 ] && cards [ 3 ] == cards [ 4 ] && cards [ 3 ] == cards [ 2 ] { fmt . Println ( \" \" ) } else if cards [ 0 ] == cards [ 1 ] && cards [ 1 ] == cards [ 2 ] && cards [ 3 ] == cards [ 4 ] { fmt . Println ( \" \" ) } else if cards [ 0 ] == cards [ 1 ] && cards [ 2 ] == cards [ 3 ] && cards [ 3 ] == cards [ 4 ] { fmt . Println ( \" \" ) } else if cards [ 0 ] == 1 && cards [ 1 ] == 10 && cards [ 2 ] == 11 && cards [ 3 ] == 12 && cards [ 4 ] == 13 { fmt . Println ( \" \" ) } else if cards [ 0 ] + 1 == cards [ 1 ] && cards [ 1 ] + 1 == cards [ 2 ] && cards [ 2 ] + 1 == cards [ 3 ] && cards [ 3 ] + 1 == cards [ 4 ] { fmt . Println ( \" \" ) } else if ( cards [ 0 ] == cards [ 1 ] && cards [ 1 ] == cards [ 2 ] ) || ( cards [ 1 ] == cards [ 2 ] && cards [ 2 ] == cards [ 3 ] ) || ( cards [ 2 ] == cards [ 3 ] && cards [ 3 ] == cards [ 4 ] ) { fmt . Println ( \" \" ) } else if ( ( cards [ 0 ] == cards [ 1 ] ) && ( ( cards [ 2 ] == cards [ 3 ] ) || ( cards [ 3 ] == cards [ 4 ] ) ) ) || ( ( cards [ 1 ] == cards [ 2 ] ) && ( cards [ 3 ] == cards [ 4 ] ) ) { fmt . Println ( \" \" ) } else if cards [ 0 ] == cards [ 1 ] || cards [ 1 ] == cards [ 2 ] || cards [ 2 ] == cards [ 3 ] || cards [ 3 ] == cards [ 4 ] { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" % d % d \\n \" , minPrime [ n ] , maxPrime [ n ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var num int for { _ , err := fmt . Scan ( & num ) if err != nil { break } else { fmt . Printf ( \" \\n \" , ( num * num + num + 2 ) / 2 ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" \" \" % 6 f \\n \" , ThirdRoot ( i [ 0 ] ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % 6 f \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) type Player struct { Name int Score int } type Place [ ] Player func ( p Place ) Len ( ) int { return len ( p ) } func ( p Place ) Swap ( i , j int ) { p [ i ] , p [ j ] = p [ j ] , p [ i ] } func ( p Place ) Less ( i , j int ) bool { if p [ i ] . Score == p [ j ] . Score { return p [ i ] . Name < p [ j ] . Name } else { return p [ i ] . Score > p [ j ] . Score } } func DataEntry ( n int ) Place { var id , sc int var ranking Place var adding Player for i := 0 ; i < n ; i + + { fmt . Scan ( & id , & sc ) adding . Name = id adding . Score = sc ranking = append ( ranking , adding ) } return ranking } func main ( ) { var ranking Place var num int fmt . Scan ( & num ) ranking = DataEntry ( num ) sort . Sort ( Place ( ranking ) ) fmt . Println ( ranking [ 0 ] . Name , ranking [ 0 ] . Score ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" % d \" \" Hoshino \" \" Hoshina \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" Hoshino \" \" Hoshina \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % 5 d \\n \" , yv ) } else { fmt . Printf ( \" % 5 d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % 5 d \" \" % 5 d \\n \" , a [ i ] [ n ] ) } a [ n ] = make ( [ ] int , n + 1 ) for i := 0 ; i <= n ; i ++ { sum := 0 for j := 0 ; j < n ; j ++ { sum += a [ j ] [ i ] } a [ n ] [ i ] = sum fmt . Printf ( \" \" , a [ n ] [ i ] ) } fmt . Println ( ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" % d \" \" HIT \" \" HOMERUN \" \" OUT \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" HIT \" \" HOMERUN \" \" OUT \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" go / token \" \" go / types \" \" os \" \" strconv \" \" strings \" \" = \" ) res , _ := types . Eval ( token . NewFileSet ( ) , nil , token . NoPos , exp ) fmt . Println ( res . Value ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" AAA \" \" AA \" \" A \" \" B \" \" C \" \" D \" \" E \" \" NA \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" AAA \" \" AA \" \" A \" \" B \" \" C \" \" D \" \" E \" \" \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" unicode \" \" strconv \" \" fmt \" \" strings \" \" \" \" > \" for _ , x : = range s { if IsLetter ( x ) { if dir == \" \" { if ! isIn ( ans , x ) { ans = append ( ans , x ) } } else { if ! isIn ( ans , x ) { ans = append ( [ ] string { x } , ans ... ) } } } else if x == \" > \" || x == \" < \" { dir = x } } fmt . Println ( strings . Join ( ans , \" \" ) ) } } func IsLetter ( s string ) bool { for _ , r := range s { if ! unicode . IsLetter ( r ) { return false } } return true } func isIn ( arr [ ] string , target string ) bool { for _ , val := range arr { if val == target { return true } } return false }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" fmt \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" : \" ) h , _ := strconv . Atoi ( input [ 0 ] ) m , _ := strconv . Atoi ( input [ 1 ] ) H , M := ( 30 * h + ( m / 2 ) ) * 2 , ( 6 * m ) * 2 if m & 1 == 1 { H ++ } a := H - M if a < 0 { a = - a } a2 := 720 - a if a2 < a { a = a2 } if a < 60 { fmt . Println ( \" \" ) } else if a >= 180 && a <= 360 { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \" \" \" \" \" \" % d % .2 f \\n \" , race1 [ 0 ] . no , race1 [ 0 ] . time ) fmt . Printf ( \" \\n \" , race1 [ 1 ] . no , race1 [ 1 ] . time ) fmt . Printf ( \" \\n \" , race2 [ 0 ] . no , race2 [ 0 ] . time ) fmt . Printf ( \" \\n \" , race2 [ 1 ] . no , race2 [ 1 ] . time ) fmt . Printf ( \" \\n \" , race3 [ 0 ] . no , race3 [ 0 ] . time ) fmt . Printf ( \" \\n \" , race3 [ 1 ] . no , race3 [ 1 ] . time ) fmt . Printf ( \" \\n \" , rest [ 0 ] . no , rest [ 0 ] . time ) fmt . Printf ( \" \\n \" , rest [ 1 ] . no , rest [ 1 ] . time ) } type player struct { no int time float64 }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" NA \" \" > '\" && s [ len ( s ) - 1 : ] == \" \" { tmp : = s [ 2 : len ( s ) - 1 ] t : = strings . Split ( tmp , \" \" ) if len ( t ) == 2 && len ( t [ 0 ] ) > 0 { valid := true for _ , v := range t [ 0 ] { if string ( v ) != \" \" { valid = false break } } if valid && t [ 0 ] == t [ 1 ] { ans = \" \" } } } else if s [ : 2 ] == \" \" && s [ len ( s ) - 2 : ] == \" \" { t := s [ 2 : len ( s ) - 2 ] if len ( t ) > 0 && len ( t ) % 2 == 0 { valid := true for i := 0 ; i < len ( t ) ; i += 2 { if t [ i : i + 2 ] != \" \" { valid = false break } } if valid { ans = \" \" } } } fmt . Println ( ans ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" \" \" 0 \" } if b == 1 { fmt . Println ( \" # \" ) if a != 0 { fmt . Println ( ) } continue } if b == 2 { fmt . Printf ( \" \\n \\n \" ) if a != 0 { fmt . Println ( ) continue } } row := b - 1 col := 0 dir := 0 l := 0 out [ row ] [ col ] = \" \" for { nrow := row + dy [ dir % 4 ] ncol := col + dx [ dir % 4 ] if dir % 4 == 0 && nrow == 0 || dir % 4 == 3 && ncol == 0 || dir % 4 == 2 && nrow == b - 1 || dir % 4 == 1 && ncol == b - 1 { row = nrow col = ncol out [ row ] [ col ] = \" \" dir + + l = 1 } else if out [ nrow + dy [ dir % 4 ] ] [ ncol + dx [ dir % 4 ] ] == \" \" { if l < 3 { break } dir ++ l = 1 } else { row = nrow col = ncol out [ row ] [ col ] = \" \" l + + } } for i := 0 ; i < b ; i ++ { for j := 0 ; j < b ; j ++ { fmt . Printf ( \" \" , out [ i ] [ j ] ) } fmt . Println ( ) } if a != 0 { fmt . Println ( ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" OK \" \" NG \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" 3 C % 02 d \" \" 3 C % 02 d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" strings \" \" sort \" \" 0 \" + scanner . Text ( ) + \" \" } tmp := make ( [ ] string , n + 2 ) for i := range tmp { tmp [ i ] = \" \" } mp = append ( [ ] string { strings . Join ( tmp , \" \" ) } , mp ... ) mp = append ( mp , strings . Join ( tmp , \" \" ) ) score := make ( [ ] [ ] [ ] int , n + 2 ) for i := range score { score [ i ] = make ( [ ] [ ] int , n + 2 ) for j := range score [ i ] { score [ i ] [ j ] = make ( [ ] int , 4 ) } } max_score := 0 for i := 1 ; i < n + 1 ; i ++ { for j := 1 ; j < n + 1 ; j ++ { tmps := mp [ i ] if string ( tmps [ j ] ) == \" \" { score [ i ] [ j ] [ 0 ] = score [ i - 1 ] [ j ] [ 0 ] + 1 score [ i ] [ j ] [ 1 ] = score [ i ] [ j - 1 ] [ 1 ] + 1 score [ i ] [ j ] [ 2 ] = score [ i - 1 ] [ j - 1 ] [ 2 ] + 1 score [ i ] [ j ] [ 3 ] = score [ i - 1 ] [ j + 1 ] [ 3 ] + 1 max_score = max ( max_score , score [ i ] [ j ] [ 0 ] , score [ i ] [ j ] [ 1 ] , score [ i ] [ j ] [ 2 ] , score [ i ] [ j ] [ 3 ] ) } } } fmt . Println ( max_score ) } } func max ( a , b , c , d , e int ) int { buf := [ ] int { a , b , c , d , e } sort . Ints ( buf ) return buf [ len ( buf ) - 1 ] }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" \" \" % d % d \\n \" , e . id , e . score ) } } } func score ( input [ ] int ) ( int , int ) { id : = input [ 0 ] data : = input [ 1 : ] frame : = 1 scores : = make ( [ ] int , 11 ) for frame <= 10 { if data [ 0 ] == 10 { scores [ frame ] = data [ 0 ] + data [ 1 ] + data [ 2 ] data = data [ 1 : ] frame += 1 } else if data [ 0 ] + data [ 1 ] == 10 { scores [ frame ] = data [ 0 ] + data [ 1 ] + data [ 2 ] data = data [ 2 : ] frame += 1 } else { scores [ frame ] = data [ 0 ] + data [ 1 ] data = data [ 2 : ] frame += 1 } } sum := 0 for i , v := range scores { if i != 0 { sum += v } } return id , sum }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \" \" b \" \" a \" \" c \" \" d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" math \" \" fmt \" \" \" \" \" \" NA \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" sort \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" sort \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / big \" \" os \" \" strconv \" \" Yes \" No = \" No \" YES = \" YES \" NO = \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \" \" % s % d % d \\n \" , name , visitor , income ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" black \" \" blue \" \" lime \" \" aqua \" \" red \" \" fuchsia \" \" yellow \" \" white \" \" \" \" 0 \" { break } r , _ : = strconv . ParseInt ( strings . Join ( buf [ 1 : 3 ] , \" \" ) , 16 , 64 ) g , _ := strconv . ParseInt ( strings . Join ( buf [ 3 : 5 ] , \" \" ) , 16 , 64 ) b , _ := strconv . ParseInt ( strings . Join ( buf [ 5 : ] , \" \" ) , 16 , 64 ) vmin := int64 ( 3 * 0xff * 0xff ) var ans string for _ , c := range colors { d := ( r - c . R ) * ( r - c . R ) + ( g - c . G ) * ( g - c . G ) + ( b - c . B ) * ( b - c . B ) if d < vmin { vmin = d ans = c . name } } fmt . Println ( ans ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" strconv \" \" black \" \" # 000000 \" } , Color { \" blue \" \" # 0000 ff \" \" lime \" \" # 00 ff00 \" \" aqua \" \" # 00 ffff \" \" red \" \" # ff0000 \" \" fuchsia \" \" # ff00ff \" \" yellow \" \" # ffff00 \" \" white \" \" # ffffff \" \" % s \" \" 0 \" { break } name : = colorTable . getNearestColor ( code ) fmt . Println ( name ) fmt . Scanf ( \" % s \" \" Failed to read color strings , color code : % s , err : % v % v % v \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" math \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" fmt \" \" 0 \" { break } bfs ( init ) } } func bfs ( init string ) { dic := make ( map [ string ] int ) que := NewQueue ( ) que . Push ( State { init , 0 } ) length := len ( init ) isSolved := false for ! que . IsEmpty ( ) { state := que . PopLeft ( ) . ( State ) _ , ok := dic [ state . color ] if ok { continue } else { dic [ state . color ] = state . cnt } if isSingleColor ( state . color ) { fmt . Println ( state . cnt ) isSolved = true break } for i := 0 ; i < length - 1 ; i ++ { color1 , color2 := string ( state . color [ i ] ) , string ( state . color [ i + 1 ] ) if color1 != color2 { color3 := other ( color1 , color2 ) if i <= length - 2 { que . Push ( State { state . color [ : i ] + color3 + state . color [ i + 2 : ] , state . cnt + 1 } ) } else { que . Push ( State { state . color [ : i ] + color3 , state . cnt + 1 } ) } } } } if ! isSolved { fmt . Println ( \" \" ) } } func other ( color1 , color2 string ) string { if color1 == \" \" { if color2 == \" \" { return \" \" } else if color2 == \" \" { return \" \" } } else if color1 == \" \" { if color2 == \" \" { return \" \" } else if color2 == \" \" { return \" \" } } else if color1 == \" \" { if color2 == \" \" { return \" \" } else if color2 == \" \" { return \" \" } } return \" \" } func isSingleColor ( color string ) bool { for _ , c := range color { if string ( c ) != string ( color [ 0 ] ) { return false } } return true }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" sort \" \" strconv \" \" strings \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" fmt \" \" bbb \" \" www \" \" 0 \" { break } scanner . Scan ( ) row2 := scanner . Text ( ) scanner . Scan ( ) row3 := scanner . Text ( ) x := make ( [ ] string , 8 ) x [ 0 ] = row1 x [ 1 ] = row2 x [ 2 ] = row3 for i := 0 ; i < 3 ; i ++ { col := make ( [ ] string , 3 ) col [ 0 ] = string ( row1 [ i ] ) col [ 1 ] = string ( row2 [ i ] ) col [ 2 ] = string ( row3 [ i ] ) x [ i + 3 ] = strings . Join ( col , \" \" ) } tmp := make ( [ ] string , 3 ) tmp [ 0 ] = string ( row1 [ 0 ] ) tmp [ 1 ] = string ( row2 [ 1 ] ) tmp [ 2 ] = string ( row3 [ 2 ] ) x [ 6 ] = strings . Join ( tmp , \" \" ) tmp [ 0 ] = string ( row1 [ 2 ] ) tmp [ 1 ] = string ( row2 [ 1 ] ) tmp [ 2 ] = string ( row3 [ 0 ] ) x [ 7 ] = strings . Join ( tmp , \" \" ) flag := false for _ , v := range x { if string ( v ) == allb { fmt . Println ( \" \" ) flag = true break } else if string ( v ) == allw { fmt . Println ( \" \" ) flag = true break } } if ! flag { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" math \" \" \" \" \" \" \" \" kyo \" \" kyo \" \" dai - kichi \" \" chu - kichi \" \" kichi \" \" syo - kichi \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" fmt \" \" strconv \" \" strings \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- \" ) fmt . Printf ( \" \\n \" , board [ 0 ] ) fmt . Printf ( \" \\n \" , board [ 1 ] , board [ 2 ] , board [ 3 ] ) fmt . Printf ( \" \\n \" , board [ 4 ] , board [ 5 ] , board [ 6 ] , board [ 7 ] , board [ 8 ] ) fmt . Printf ( \" \\n \" , board [ 9 ] , board [ 10 ] , board [ 11 ] ) fmt . Printf ( \" \\n \" , board [ 12 ] ) fmt . Println ( \" \" ) } func main ( ) { for scanner . Scan ( ) { p1 , _ := strconv . Atoi ( scanner . Text ( ) ) if p1 == - 1 { break } p [ 0 ] = p1 scanner . Scan ( ) buf1 := strings . Split ( scanner . Text ( ) , \" \" ) p2 , _ := strconv . Atoi ( buf1 [ 0 ] ) p3 , _ := strconv . Atoi ( buf1 [ 1 ] ) p4 , _ := strconv . Atoi ( buf1 [ 2 ] ) p [ 1 ] , p [ 2 ] , p [ 3 ] = p2 , p3 , p4 scanner . Scan ( ) buf2 := strings . Split ( scanner . Text ( ) , \" \" ) p5 , _ := strconv . Atoi ( buf2 [ 0 ] ) p6 , _ := strconv . Atoi ( buf2 [ 1 ] ) p7 , _ := strconv . Atoi ( buf2 [ 2 ] ) p8 , _ := strconv . Atoi ( buf2 [ 3 ] ) p9 , _ := strconv . Atoi ( buf2 [ 4 ] ) p [ 4 ] , p [ 5 ] , p [ 6 ] , p [ 7 ] , p [ 8 ] = p5 , p6 , p7 , p8 , p9 scanner . Scan ( ) buf3 := strings . Split ( scanner . Text ( ) , \" \" ) p10 , _ := strconv . Atoi ( buf3 [ 0 ] ) p11 , _ := strconv . Atoi ( buf3 [ 1 ] ) p12 , _ := strconv . Atoi ( buf3 [ 2 ] ) p [ 9 ] , p [ 10 ] , p [ 11 ] = p10 , p11 , p12 scanner . Scan ( ) p13 , _ := strconv . Atoi ( scanner . Text ( ) ) p [ 12 ] = p13 S := make ( map [ wolf ] struct { } ) st := wolf { } for i := 0 ; i < 13 ; i ++ { st . m [ i ] = p [ i ] } Q := make ( [ ] pair , 0 ) S [ st ] = struct { } { } Q = append ( Q , pair { st , 0 } ) yet := true for len ( Q ) > 0 { at := Q [ 0 ] . first cost := Q [ 0 ] . second Q = Q [ 1 : ] ok := true for i := 1 ; i < 12 ; i ++ { if at . m [ i ] != i { ok = false } } if ok { yet = false fmt . Println ( cost ) break } now := cost for i := 0 ; i < 13 ; i ++ { if at . m [ i ] != 0 { now += abs ( row [ i ] - row [ at . m [ i ] ] ) + abs ( col [ i ] - col [ at . m [ i ] ] ) } } if now > 20 { continue } for i := 0 ; i < 13 ; i ++ { if at . m [ i ] == 0 { for j := 0 ; j < 4 ; j ++ { if ^ g [ i ] [ j ] != 0 { at . m [ i ] , at . m [ g [ i ] [ j ] ] = at . m [ g [ i ] [ j ] ] , at . m [ i ] if _ , ok := S [ at ] ; ! ok { S [ at ] = struct { } { } Q = append ( Q , pair { at , cost + 1 } ) } at . m [ i ] , at . m [ g [ i ] [ j ] ] = at . m [ g [ i ] [ j ] ] , at . m [ i ] } } } } } if yet { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" sort \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" reflect \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" 3 \\n 3 \\n 3 \\n 3 \\n 3 \\n \" ) } else { win := 0 if ! tbl [ 0 ] { win = 2 } if ! tbl [ 1 ] { win = 3 } if ! tbl [ 2 ] { win = 1 } for i := 0 ; i < 5 ; i ++ { if h [ i ] == win { fmt . Println ( 1 ) } else { fmt . Println ( 2 ) } } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \" \" \" \" \" \" \" \" NG \" \" OK \" \" NG \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" sort \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" A \" \" A \" \" A \" \" B \" \" B \" \" C \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" \" \" A \" \" A \" \" A \" \" B \" \" B \" \" C \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" - \" \" * \" \" * \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" math \" \" fmt \" \" % d \" \" . \" \" \\n \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var i int64 var list = [ ] int64 { 13 , 19 , 109 , 199 , 829 , 1489 , 1879 , 2089 , 3259 , 3469 , 5659 , 9439 , 13009 , 15649 , 15739 , 16069 , 18049 , 18919 , 19429 , 21019 , 22279 , 25309 , 31729 , 34849 , 43789 , 51349 , 55339 , 62989 , 67219 , 69499 , 72229 , 77269 , 79699 , 81049 , 82729 , 88819 , 97849 , 99139 , 101119 , 109849 , 116539 , 119299 , 122209 , 135469 , 144169 , 157279 , 165709 , 166849 , 171169 , 187639 , 194869 , 195739 , 201499 , 201829 , 217369 , 225349 , 240049 , 243709 , 247609 , 247999 , 257869 , 260419 , 266689 , 268819 , 276049 , 284749 , 285289 , 294319 , 295879 , 299479 , 300499 , 301999 , 326149 , 334429 , 340939 , 346399 , 347989 , 354259 , 358909 , 361219 , 375259 , 388699 , 389569 , 392269 , 394819 , 397549 , 397759 , 402139 , 402769 , 412039 , 419059 , 420859 , 427249 , 442579 , 444349 , 452539 , 463459 , 465169 , 467479 , 470089 , 477019 , 490579 , 495619 , 500239 , 510619 , 518809 , 536449 , 536779 , 539509 , 549169 , 559219 , 563419 , 570049 , 572659 , 585919 , 594829 , 597679 , 607309 , 622249 , 626629 , 632089 , 632329 , 633469 , 633799 , 654169 , 657499 , 661099 , 663589 , 664669 , 666439 , 680299 , 681259 , 691729 , 705169 , 715159 , 734479 , 736369 , 739399 , 768199 , 773029 , 795799 , 803449 , 814069 , 822169 , 823729 , 829729 , 833719 , 837079 , 845989 , 854929 , 855739 , 857959 , 875269 , 876019 , 881479 , 889879 , 907399 , 930079 , 938059 , 946669 , 954979 , 958549 , 959479 , 976309 , 978079 , 983449 , 1002349 , 1003369 , 1006309 , 1006339 , 1008859 , 1015369 , 1022389 , 1022509 , 1023949 , 1027759 , 1043599 , 1063969 , 1065019 , 1068259 , 1068709 , 1091269 , 1093069 , 1093999 , 1100839 , 1117609 , 1117819 , 1118869 , 1120549 , 1121839 , 1122139 , 1126669 , 1137889 , 1146799 , 1155619 , 1156039 , 1157839 , 1163719 , 1167709 , 1168249 , 1170139 , 1172029 , 1172539 , 1173589 , 1182289 , 1210879 , 1228399 , 1230379 , 1233439 , 1246249 , 1246369 , 1257079 , 1272289 , 1285519 , 1298119 , 1322179 , 1322599 , 1324579 , 1329709 , 1337269 , 1339909 , 1340329 , 1351249 , 1352209 , 1358809 , 1360789 , 1368469 , 1381279 , 1400809 , 1402369 , 1410979 , 1440589 , 1447009 , 1451839 , 1461409 , 1468639 , 1508629 , 1514329 , 1524079 , 1525969 , 1540969 , 1571749 , 1573549 , 1573939 , 1577299 , 1584439 , 1588759 , 1592869 , 1603339 , 1615849 , 1616809 , 1621729 , 1627609 , 1631059 , 1653109 , 1659109 , 1670569 , 1678759 , 1681879 , 1685449 , 1691869 , 1711819 , 1718869 , 1727779 , 1747729 , 1748479 , 1749499 , 1755829 , 1764229 , 1780489 , 1791739 , 1797379 , 1798639 , 1802659 , 1819849 , 1830349 , 1833529 , 1834039 , 1837399 , 1857679 , 1890529 , 1902619 , 1904479 , 1910269 , 1912069 , 1912459 , 1915939 , 1917739 , 1925389 , 1943659 , 1954159 , 1954369 , 1959319 , 1979149 , 1979899 , 2002339 , 2007619 , 2007919 , 2016409 , 2020729 , 2050339 , 2062009 , 2063779 , 2065579 , 2075839 , 2079199 , 2083519 , 2084449 , 2087389 , 2107669 , 2116579 , 2136139 , 2141809 , 2143489 , 2144509 , 2157739 , 2159239 , 2168659 , 2176639 , 2177509 , 2193889 , 2202799 , 2203969 , 2223679 , 2225059 , 2246149 , 2248249 , 2256349 , 2262979 , 2266639 , 2289649 , 2290039 , 2294059 , 2303599 , 2340259 , 2342779 , 2362279 , 2373409 , 2376169 , 2381089 , 2403889 , 2413429 , 2418679 , 2423419 , 2443789 , 2458669 , 2470339 , 2478529 , 2479669 , 2499949 , 2508049 , 2535109 , 2541949 , 2546239 , 2552119 , 2552659 , 2561269 , 2564329 , 2576599 , 2594959 , 2594989 , 2596669 , 2604739 , 2614069 , 2635489 , 2668249 , 2673529 , 2674549 , 2679499 , 2683789 , 2696929 , 2704909 , 2712379 , 2715289 , 2728549 , 2731699 , 2731909 , 2759299 , 2761729 , 2764129 , 2790259 , 2805169 , 2822719 , 2839939 , 2840269 , 2846869 , 2849689 , 2875339 , 2879299 , 2893489 , 2918569 , 2927599 , 2927809 , 2952799 , 2954689 , 2989039 , 2990839 , 3047419 , 3058879 , 3062209 , 3063499 , 3066829 , 3076399 , 3089329 , 3092569 , 3101479 , 3103279 , 3129619 , 3153589 , 3157579 , 3171739 , 3187609 , 3200209 , 3207439 , 3208819 , 3215749 , 3224869 , 3243349 , 3277699 , 3295549 , 3308959 , 3326629 , 3328909 , 3340879 , 3366829 , 3371449 , 3374479 , 3378049 , 3400219 , 3416059 , 3436249 , 3437719 , 3467539 , 3479899 , 3512059 , 3512239 , 3512989 , 3513079 , 3514549 , 3518329 , 3550699 , 3584929 , 3586909 , 3593509 , 3621469 , 3652939 , 3669769 , 3690529 , 3713449 , 3727729 , 3735169 , 3741169 , 3798079 , 3817819 , 3837139 , 3837859 , 3849829 , 3854119 , 3894049 , 3919219 , 3919249 , 3951559 , 3974359 , 3974689 , 3975709 , 3995449 , 3996529 , 4015939 , 4016569 , 4032409 , 4039669 , 4042609 , 4058479 , 4059199 , 4092709 , 4098469 , 4110349 , 4138249 , 4144969 , 4155919 , 4157899 , 4174609 , 4185919 , 4208629 , 4218289 , 4224379 , 4234429 , 4257529 , 4262179 , 4265089 , 4265719 , 4285669 , 4300189 , 4316779 , 4326409 , 4332619 , 4336099 , 4353319 , 4361479 , 4370089 , 4377679 , 4396789 , 4404559 , 4405699 , 4413589 , 4415449 , 4453489 , 4467019 , 4487809 , 4510489 , 4529389 , 4540099 , 4543249 , 4544209 , 4561639 , 4575289 , 4579879 , 4596079 , 4606579 , 4609309 , 4615609 , 4627879 , 4635979 , 4647289 , 4660549 , 4675249 , 4693699 , 4706419 , 4707979 , 4734679 , 4740649 , 4743709 , 4796089 , 4809949 , 4832419 , 4833139 , 4852459 , 4868659 , 4875259 , 4900459 , 4950139 , 4956829 , 4959049 , 4972069 , 4977439 , 4997389 , 5025079 , 5037919 , 5047129 , 5073379 , 5074879 , 5146489 , 5154769 , 5158039 , 5168929 , 5184799 , 5201299 , 5205469 , 5229409 , 5234689 , 5239189 , 5248099 , 5251789 , 5253769 , 5261749 , 5274169 , 5274679 , 5278579 , 5318899 , 5327899 , 5381869 , 5382109 , 5417389 , 5425759 , 5436289 , 5450119 , 5461999 , 5465359 , 5484139 , 5499079 , 5527009 , 5610469 , 5614159 , 5651749 , 5675149 , 5698579 , 5732149 , 5733529 , 5734699 , 5760109 , 5774149 , 5805259 , 5839579 , 5841469 , 5851429 , 5860249 , 5892709 , 5908459 , 5922229 , 5928829 , 5930929 , 5937859 , 5938789 , 5969659 , 5977339 , 5986039 , 6005899 , 6013159 , 6016099 , 6023659 , 6024049 , 6054289 , 6056209 , 6066589 , 6102919 , 6106489 , 6130549 , 6136219 , 6144379 , 6153319 , 6156979 , 6177889 , 6187459 , 6193309 , 6201499 , 6213799 , 6250429 , 6261379 , 6287929 , 6297589 , 6299149 , 6324559 , 6329509 , 6332869 , 6334879 , 6359239 , 6378139 , 6402169 , 6404779 , 6406579 , 6419299 , 6438199 , 6464209 , 6471139 , 6474829 , 6484069 , 6495949 , 6498229 , 6501799 , 6503599 , 6509689 , 6510199 , 6512089 , 6528679 , 6556609 , 6561019 , 6578659 , 6582469 , 6595579 , 6600499 , 6601789 , 6602209 , 6613339 , 6616789 , 6621289 , 6631909 , 6641359 , 6655549 , 6655639 , 6692269 , 6699619 , 6700699 , 6708859 , 6715279 , 6715999 , 6727549 , 6735019 , 6740479 , 6753829 , 6758959 , 6760009 , 6787639 , 6796639 , 6843379 , 6880879 , 6884749 , 6900919 , 6915199 , 6918019 , 6918349 , 6925159 , 6937969 , 6942499 , 6945559 , 6949339 , 7014619 , 7016749 , 7025659 , 7027459 , 7039849 , 7045699 , 7051399 , 7079719 , 7081189 , 7097809 , 7130869 , 7151149 , 7159519 , 7161859 , 7166149 , 7177069 , 7187779 , 7201639 , 7235959 , 7267459 , 7273999 , 7286689 , 7305379 , 7316299 , 7328779 , 7335949 , 7340239 , 7348639 , 7356079 , 7367029 , 7369339 , 7371649 , 7417519 , 7422229 , 7433059 , 7448479 , 7464559 , 7465489 , 7475389 , 7477999 , 7483789 , 7499209 , 7527259 , 7534069 , 7534609 , 7537339 , 7540459 , 7541929 , 7545919 , 7580389 , 7583509 , 7599049 , 7610929 , 7641379 , 7645669 , 7659019 , 7669819 , 7681369 , 7701769 , 7703239 , 7734829 , 7754899 , 7774309 , 7802239 , 7806439 , 7813369 , 7814299 , 7846549 , 7861039 , 7879849 , 7882879 , 7913239 , 7934659 , 7945039 , 7960159 , 7961959 , 7989469 , 8023669 , 8059069 , 8062009 , 8070919 , 8101789 , 8108539 , 8166079 , 8178259 , 8183899 , 8194939 , 8208919 , 8248069 , 8281579 , 8312419 , 8313919 , 8318419 , 8326609 , 8336599 , 8339629 , 8344159 , 8348539 , 8381539 , 8385109 , 8431069 , 8445979 , 8460589 , 8467639 , 8487379 , 8497039 , 8513179 , 8519479 , 8540509 , 8557729 , 8561809 , 8568409 , 8573449 , 8576599 , 8594689 , 8604649 , 8616919 , 8619439 , 8621869 , 8623039 , 8648839 , 8658109 , 8669629 , 8677399 , 8685379 , 8691589 , 8717749 , 8729059 , 8741149 , 8748589 , 8773159 , 8799619 , 8827549 , 8831989 , 8833249 , 8844379 , 8868529 , 8878279 , 8898319 , 8914189 , 8926459 , 9020989 , 9081469 , 9081889 , 9083029 , 9127639 , 9138139 , 9146989 , 9154969 , 9165259 , 9220249 , 9276859 , 9280549 , 9291649 , 9299449 , 9320329 , 9324439 , 9353299 , 9365599 , 9369559 , 9394969 , 9426499 , 9439279 , 9440449 , 9446869 , 9463249 , 9479419 , 9494209 , 9503959 , 9508069 , 9511429 , 9538099 , 9541999 , 9549109 , 9550399 , 9585889 , 9589429 , 9600559 , 9600589 , 9617989 , 9627469 , 9640489 , 9721429 , 9723019 , 9725959 , 9733819 , 9739909 , 9743479 , 9744409 , 9750079 , 9774469 , 9778039 , 9783889 , 9792709 , 9835759 , 9876109 , 9892039 , 9910759 , 9917059 , 9923989 , 9933619 , 9950209 , 9950539 , 9973219 , 9999999999999 } for { fmt . Scan ( & i ) if i == 0 { break } var prev int64 = 0 for _ , v := range list { if v > i { fmt . Println ( prev ) break } prev = v } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" fmt \" \" strconv \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" sort \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strings \" \" strconv \" \" fmt \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" sort \" \" strconv \" \" NA \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a , b float64 fmt . Scanf ( \" % v % v \" , & a , & b ) fmt . Println ( a * b ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" ( \" , p . first , \" , \" , p . second , \" ) \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var num1 , num2 int fmt . Scan ( & num1 , & num2 ) fmt . Println ( ( num1 + num2 ) / 2 ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var m , a , book int fmt . Scan ( & m , & a , & book ) if nokori := m - book ; nokori < 0 { if nokori = nokori + a ; nokori < 0 { fmt . Println ( \" \" ) } else { fmt . Println ( a - nokori ) } } else { fmt . Println ( 0 ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { week := [ ] string { \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" } var day int fmt . Scan ( & day ) dayOfWeek := - 1 for i := 0 ; i < day ; i ++ { if dayOfWeek == 6 { dayOfWeek = - 1 } dayOfWeek ++ } fmt . Println ( week [ dayOfWeek ] ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { week := [ ] string { \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" } var day int fmt . Scan ( & day ) fmt . Println ( week [ ( day + 4 ) % 7 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" time \" \" \" \" mon \" \" tue \" \" wed \" \" thu \" \" fri \" \" sat \" \" sun \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var sTime , fTime , exists , eSTime , eFTime int fmt . Scan ( & sTime , & fTime ) fmt . Scan ( & exists ) var flag bool for i := 0 ; i < exists ; i ++ { fmt . Scan ( & eSTime , & eFTime ) if sTime > eSTime && sTime < eFTime { flag = true } if fTime > eSTime && fTime < eFTime { flag = true } if eSTime >= sTime && eFTime <= fTime { flag = true } } if flag { fmt . Println ( 1 ) } else { fmt . Println ( 0 ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var F int fmt . Scan ( & F ) fmt . Println ( ( F - 30 ) / 2 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % v % v \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var h , a , b int fmt . Scanln ( & h , & a , & b ) hNum := 0 for ; a <= b ; a ++ { if h % a == 0 { hNum ++ } } fmt . Println ( hNum ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , k int fmt . Scanln ( & n , & k ) height := 0 weight := 0 block := 1 for n >= block { if weight <= k * block { height + + n - = block weight += block } else { block + + } } fmt . Println ( height ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" const MAX = 1001 func main ( ) { var n int fmt . Scanln ( & n ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } w := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & w [ i ] ) } l := MAX r := MAX for i := 0 ; i < n ; i ++ { if a [ i ] == 0 { if w [ i ] < r { r = w [ i ] } } else { if w [ i ] < l { l = w [ i ] } } } ans := 0 if l < MAX && r < MAX { ans = l + r } fmt . Println ( ans ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % v \\n \" , total ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var r , b , w , g int fmt . Scanln ( & r , & b , & w , & g ) fmt . Println ( r + b + w + g ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % v \\n \" , result ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func alphabetical ( b byte ) int { if 65 <= b && b <= 90 { return 1 } if 97 <= b && b <= 122 { return 2 } return 0 } func main ( ) { var b byte fmt . Scanln ( & b ) fmt . Println ( alphabetical ( b ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" sort \" \" strconv \" \" strings \" \" \" \" Error : element = % v \\n \" , element ) } parsedLine = append ( parsedLine , n ) } result = append ( result , parsedLine ) } return result } func max ( l , r int64 ) int64 { if l > r { return l } return r } func main ( ) { scanner := bufio . NewScanner ( os . Stdin ) content := [ ] string { } for scanner . Scan ( ) { line := scanner . Text ( ) content = append ( content , line ) } arr := parseToArray2d ( content ) input := arr [ 1 ] sort . Slice ( input , func ( i , j int ) bool { return input [ i ] < input [ j ] } ) var costMin int64 = math . MaxInt64 nMin := input [ 0 ] nMax := input [ len ( input ) - 1 ] for x := nMin ; x <= nMax ; x ++ { costCurrent := max ( x - nMin , nMax - x ) if costCurrent < costMin { costMin = costCurrent } } fmt . Println ( costMin ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , x int fmt . Scanln ( & n ) min , max := 2000 , 0 for ; n > 0 ; n -- { fmt . Scan ( & x ) if x < min { min = x } if x > max { max = x } } fmt . Println ( ( max - min + 1 ) / 2 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" Error : element = % v \\n \" , element ) } parsedLine = append ( parsedLine , n ) } result = append ( result , parsedLine ) } return result } func pop ( stack [ ] int64 ) ( [ ] int64 , int64 ) { lenStack : = len ( stack ) return stack [ 0 : ( lenStack - 1 ) ] , stack [ lenStack - 1 ] } func contains ( s [ ] int64 , e int64 ) bool { for _ , a := range s { if a == e { return true } } return false } func main ( ) { scanner := bufio . NewScanner ( os . Stdin ) content := [ ] string { } for scanner . Scan ( ) { line := scanner . Text ( ) content = append ( content , line ) } arr := parseToArray2d ( content ) input := arr [ 1 ] stack := [ ] int64 { } result := - 1 for i , x := range input { if x > 0 { if contains ( stack , x ) { result = i + 1 break } else { stack = append ( stack , x ) } } else { var top int64 if len ( stack ) == 0 { result = i + 1 break } stack , top = pop ( stack ) if top != - x { result = i + 1 } } } if result < 0 { fmt . Println ( \" \" ) } else { fmt . Println ( result ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) type Game struct { pointA , pointB int } func main ( ) { var n int game := & Game { 0 , 0 } fmt . Scanf ( \" \" , & n ) for n != 0 { game . initGame ( ) game . execGame ( n ) game . printResult ( ) fmt . Scanf ( \" \" , & n ) } } func ( game * Game ) execGame ( n int ) { var a , b int for i := 0 ; i < n ; i ++ { fmt . Scanf ( \" \" , & a ) fmt . Scanf ( \" \" , & b ) switch { case a == b : game . pointA += a game . pointB + = b case a > b : game . pointA += a + b case b > a : game . pointB += a + b } } } func ( game * Game ) initGame ( ) { game . pointA = 0 game . pointB = 0 } func ( game * Game ) printResult ( ) { fmt . Println ( game . pointA , game . pointB ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { for { var a , b , n int fmt . Scanf ( \" % d \" \" % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func max ( x , y int ) int { if x > y { return x } return y } func main ( ) { scanner . Split ( bufio . ScanWords ) a := make ( [ ] int , 8 ) for i := 0 ; i < 8 ; i ++ { a [ i ] = nextInt ( ) } s := 0 for i := 0 ; i < 4 ; i ++ { s += a [ i ] } t := 0 for i := 4 ; i < 8 ; i ++ { t += a [ i ] } fmt . Println ( max ( s , t ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { for true { var n , k int fmt . Scan ( & n , & k ) if n == 0 && k == 0 { return } a := make ( [ ] int , n ) ans := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) if i == 0 { ans [ i ] = a [ i ] } else { ans [ i ] = ans [ i - 1 ] + a [ i ] } } max := 0 for i := k ; i < n ; i ++ { t := ans [ i ] - ans [ i - k ] if max < t { max = t } } fmt . Println ( max ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func calcScore ( n , m [ ] int ) ( int , int ) { sort . Ints ( n ) sort . Ints ( m ) return n [ 9 ] + n [ 8 ] + n [ 7 ] , m [ 9 ] + m [ 8 ] + m [ 7 ] } func main ( ) { var team_W , team_K [ ] int var inp int for i := 0 ; i < 10 ; i ++ { fmt . Scan ( & inp ) team_W = append ( team_W , inp ) } for j := 0 ; j < 10 ; j ++ { fmt . Scan ( & inp ) team_K = append ( team_K , inp ) } fmt . Println ( calcScore ( team_W , team_K ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) var n , k int func perm ( arr [ ] int ) [ ] [ ] int { if len ( arr ) == 1 { return [ ] [ ] int { arr } } p := perm ( arr [ 1 : ] ) var ret [ ] [ ] int for _ , val := range p { for i := 0 ; i <= len ( val ) ; i ++ { tmp := make ( [ ] int , len ( val ) ) copy ( tmp , val ) tmp = append ( tmp , 0 ) copy ( tmp [ i + 1 : ] , tmp [ i : ] ) tmp [ i ] = arr [ 0 ] ret = append ( ret , tmp ) } } return ret } func permutation ( n , k int ) [ ] [ ] int { ret := [ ] [ ] int { } for i := 0 ; i < 1 << uint ( n ) ; i ++ { var selects [ ] int for j := 0 ; j < n ; j ++ { if ( i >> uint ( j ) ) & 1 == 1 { selects = append ( selects , j ) } } if len ( selects ) == k { ret = append ( ret , perm ( selects ) ... ) } } return ret } func main ( ) { for { fmt . Scan ( & n , & k ) if n == 0 && k == 0 { break } cards := make ( [ ] string , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & cards [ i ] ) } ret := permutation ( len ( cards ) , k ) nums := map [ string ] bool { } for _ , val := range ret { var num string for i := 0 ; i < len ( val ) ; i ++ { num += cards [ val [ i ] ] } nums [ num ] = true } fmt . Println ( len ( nums ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" strings \" \" sort \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" sort \" \" % d % d % d % d \" \" % d % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) type node struct { Key string Num int } func main ( ) { var n int fmt . Scan ( & n ) m := make ( map [ string ] int ) for i := 0 ; i < n ; i ++ { var s string var num int fmt . Scan ( & s , & num ) if _ , ok := m [ s ] ; ! ok { m [ s ] = 0 } m [ s ] += num } list := make ( [ ] node , 0 , len ( m ) ) for k , v := range m { list = append ( list , node { Key : k , Num : v } ) } sort . Slice ( list , func ( i , j int ) bool { if len ( list [ i ] . Key ) == len ( list [ j ] . Key ) { return list [ i ] . Key < list [ j ] . Key } else { return len ( list [ i ] . Key ) < len ( list [ j ] . Key ) } } ) for _ , v := range list { fmt . Println ( v . Key , v . Num ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) sum := 0 for i := 0 ; i < 5 ; i ++ { score := nextInt ( ) if score < 40 { sum += 40 } else { sum += score } } fmt . Println ( sum / 5 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func min ( x , y int ) int { if x < y { return x } return y } func main ( ) { scanner . Split ( bufio . ScanWords ) a := nextInt ( ) b := nextInt ( ) c := nextInt ( ) d := nextInt ( ) p := nextInt ( ) priceA := a * p priceB := 0 if p <= c { priceB = b } else { priceB = b + ( p - c ) * d } fmt . Println ( min ( priceA , priceB ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func main ( ) { scanner . Split ( bufio . ScanWords ) points := make ( [ ] int , 6 ) for i := 0 ; i < 6 ; i ++ { points [ i ] = nextInt ( ) } sort . Slice ( points [ : 4 ] , func ( i , j int ) bool { return points [ i ] > points [ j ] } ) points2 := points [ 4 : ] sort . Slice ( points2 , func ( i , j int ) bool { return points2 [ i ] > points2 [ j ] } ) fmt . Println ( points [ 0 ] + points [ 1 ] + points [ 2 ] + points2 [ 0 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" % d \\n \" , ans ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" % + v \" \" ] \" ) } func min ( x , y int ) int { if x < y { return x } return y } func main ( ) { scanner . Split ( bufio . ScanWords ) n , _ := nextInt ( ) a , _ := nextInt ( ) b , _ := nextInt ( ) c , _ := nextInt ( ) d , _ := nextInt ( ) costX := b * int ( math . Ceil ( float64 ( n ) / float64 ( a ) ) ) costY := d * int ( math . Ceil ( float64 ( n ) / float64 ( c ) ) ) fmt . Println ( min ( costX , costY ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" bufio \" \" strings \" \" \" \" % d \\n \" , ans2 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d % d % d % d % d \" \" % d \\n \" , p ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \\n \" , max + 1 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % + v \" \" ] \" ) ) } func main ( ) { scanner . Split ( bufio . ScanWords ) coinDaily , _ := nextInt ( ) coinWeekly , _ := nextInt ( ) coinTarget , _ := nextInt ( ) coinCurrent := 0 i := 0 for i = 0 ; i <= 1000000 ; i ++ { coinCurrent += coinDaily if ( i + 1 ) % 7 == 0 { coinCurrent += coinWeekly } if coinCurrent >= coinTarget { break } } fmt . Println ( i + 1 ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var a , b , c int _ , _ = fmt . Scan ( & a , & b , & c ) fmt . Printf ( \" \\n \" , calc ( a , b , c ) ) } func calc ( a int , b int , c int ) int { var day int for c > 0 { day ++ c -= a if day % 7 == 0 { c -= b } } return day }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var A , B , N int fmt . Scanf ( \" % d % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" bufio \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func calcDay ( daily , bonus , req int ) int { fullWcoin := 7 * daily + bonus sixDaycoin := 6 * daily week := req / fullWcoin day := 0 rem := req % fullWcoin if sixDaycoin < rem && rem < fullWcoin { week + + } else { day = rem / daily if rem % daily > 0 { day + + } } return 7 * week + day } func main ( ) { var daily , bonus , req int fmt . Scanf ( \" % d % d % d \" \" % d \\n \" , calcDay ( daily , bonus , req ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var A , B , C int fmt . Scan ( & A , & B , & C ) weekly := 7 * A + B weeks := C / weekly tmp := C % weekly if tmp > 7 * A { fmt . Println ( weeks * 7 + 7 ) } else { fmt . Println ( weeks * 7 + ( tmp + ( A - 1 ) ) / A ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % + v \" \" ] \" ) ) } func main ( ) { scanner . Split ( bufio . ScanWords ) n , _ := nextInt ( ) x := make ( [ ] int , 2019 + 1 ) for i := range x { x [ i ] = - 1 } for i := 0 ; i < n ; i ++ { p , _ := nextInt ( ) x [ p ] = i + 1 } m , _ := nextInt ( ) a := make ( [ ] int , m ) for i := 0 ; i < m ; i ++ { a [ i ] , _ = nextInt ( ) } for i := 0 ; i < m ; i ++ { ai := a [ i ] for j := 1 ; j < 2019 ; j ++ { if ( x [ j ] == ai ) && ( x [ j + 1 ] == - 1 ) { x [ j ] = - 1 x [ j + 1 ] = ai break } } } for i := 1 ; i <= 2019 ; i ++ { for j := 1 ; j <= 2019 ; j ++ { if x [ j ] == i { fmt . Println ( j ) break } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int _ , _ = fmt . Scan ( & n ) xa := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { _ , _ = fmt . Scan ( & xa [ i ] ) } var m int _ , _ = fmt . Scan ( & m ) ma := make ( [ ] int , m ) for i := 0 ; i < m ; i ++ { _ , _ = fmt . Scan ( & ma [ i ] ) } for _ , v := range calc ( xa , ma ) { fmt . Println ( v ) } } func calc ( xa [ ] int , ma [ ] int ) [ ] int { for _ , v := range ma { if xa [ v - 1 ] < 2019 { if len ( xa ) != v { if xa [ v ] - 1 != xa [ v - 1 ] { xa [ v - 1 ] ++ } } else { xa [ v - 1 ] ++ } } } return xa }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \" \" END OF INPUT \" ; s = getNextString ( scanner ) { ss := strings . Split ( s , \" \" ) for i := 0 ; i < len ( ss ) ; i ++ { fmt . Fprint ( writer , len ( ss [ i ] ) ) } fmt . Fprintln ( writer , \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" END OF INPUT \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \" \" X \" ; s , c = getNextString ( scanner ) , getNextString ( scanner ) { if strings . Index ( s , \" \" ) != - 1 { fmt . Fprintln ( writer , translate ( strings . Split ( s , \" \" ) , c ) ) continue } ss := make ( [ ] string , 0 ) for len ( s ) > 0 { index := nextupper ( s [ 1 : ] ) ss = append ( ss , s [ : index + 1 ] ) s = s [ index + 1 : ] } fmt . Fprintln ( writer , translate ( ss , c ) ) } } func translate ( ss [ ] string , c string ) string { switch c { case \" \" : return u ( ss ) case \" \" : return l ( ss ) case \" \" : return d ( ss ) } return \" \" } func nextupper ( s string ) int { n := len ( s ) for i := 0 ; i < n ; i ++ { if s [ i : i + 1 ] == strings . ToUpper ( s [ i : i + 1 ] ) { return i } } return n } func u ( ss [ ] string ) string { n := len ( ss ) for i := 0 ; i < n ; i ++ { ss [ i ] = fmt . Sprintf ( \" \" , strings . ToUpper ( ss [ i ] [ 0 : 1 ] ) , ss [ i ] [ 1 : ] ) } return strings . Join ( ss , \" \" ) } func l ( ss [ ] string ) string { n := len ( ss ) ss [ 0 ] = strings . ToLower ( ss [ 0 ] ) for i := 1 ; i < n ; i ++ { ss [ i ] = fmt . Sprintf ( \" \" , strings . ToUpper ( ss [ i ] [ 0 : 1 ] ) , ss [ i ] [ 1 : ] ) } return strings . Join ( ss , \" \" ) } func d ( ss [ ] string ) string { n := len ( ss ) for i := 0 ; i < n ; i ++ { ss [ i ] = strings . ToLower ( ss [ i ] ) } return strings . Join ( ss , \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { ans := make ( [ ] int , 0 ) for { var n int fmt . Scan ( & n ) if n == 0 { break } a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } mind := int ( 1e9 ) for bits := 0 ; bits < ( 1 << uint ( n ) ) ; bits ++ { gsum , psum := 0 , 0 for j := 0 ; j < n ; j ++ { if ( bits & ( 1 << uint ( j ) ) ) != 0 { gsum += a [ j ] } else { psum += a [ j ] } } mind = min ( mind , abs ( gsum - psum ) ) } ans = append ( ans , mind ) } for i := range ans { fmt . Println ( ans [ i ] ) } } func abs ( a int ) int { if a >= 0 { return a } return - a } func min ( a , b int ) int { if a < b { return a } return b }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \" \" impossible \" ) break } if grid [ b [ 0 ] ] [ b [ 1 ] ] <= i { fmt . Fprintln ( writer , fmt . Sprintf ( \" \" , i , b [ 0 ] , b [ 1 ] ) ) break } switch move [ i % m ] { case '8' : if b [ 0 ] > 0 { b [ 0 ] -- } case '6' : if b [ 1 ] + 1 < w { b [ 1 ] ++ } case '4' : if b [ 1 ] > 0 { b [ 1 ] -- } case '2' : if b [ 0 ] + 1 < h { b [ 0 ] ++ } } i ++ } } } func makeGrid ( h , w int ) [ ] [ ] int { index := make ( [ ] [ ] int , h , h ) data := make ( [ ] int , h * w , h * w ) for i := 0 ; i < h ; i ++ { index [ i ] = data [ i * w : ( i + 1 ) * w ] } return index }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" 0 0 \" { break } chunks : = strings . Split ( sc . Text ( ) , \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , r int fmt . Scan ( & n , & r ) for n != 0 || r != 0 { arr := make ( [ ] int , n ) for i := range arr { arr [ i ] = len ( arr ) - i } for i := 0 ; i < r ; i ++ { var p , c int fmt . Scan ( & p , & c ) mid , top , last := arr [ : p - 1 ] , arr [ p - 1 : p - 1 + c ] , arr [ p - 1 + c : ] arr = append ( append ( append ( [ ] int { } , top ... ) , mid ... ) , last ... ) } fmt . Println ( arr [ 0 ] ) fmt . Scan ( & n , & r ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" black \" \" red \" \" 0 0 \" { break } chunks := strings . Split ( sc . Text ( ) , \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" math / cmplx \" \" % f % f \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var n int fmt . Scan ( & n ) for n != 0 { arr := make ( [ ] int , n ) for i := range arr { fmt . Scan ( & arr [ i ] ) } sort . Ints ( arr ) sum := 0 for i := 1 ; i < len ( arr ) - 1 ; i ++ { sum += arr [ i ] } fmt . Println ( sum / ( n - 2 ) ) fmt . Scan ( & n ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" 0 0 \" { break } chunks : = strings . Split ( sc . Text ( ) , \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) var w , h int var graph [ ] [ ] string func dfs ( visited [ ] [ ] bool , x , y int ) { visited [ x ] [ y ] = true for i := - 1 ; i <= 1 ; i + + { for j := - 1 ; j <= 1 ; j + + { dx := x + i dy := y + j if 0 <= dx && dx < h && 0 <= dy && dy < w && graph [ dx ] [ dy ] == \" \" && ! visited [ dx ] [ dy ] { dfs ( visited , dx , dy ) } } } } func main ( ) { for { fmt . Scan ( & w , & h ) if w == 0 && h == 0 { break } graph = make ( [ ] [ ] string , h ) for i := range graph { graph [ i ] = make ( [ ] string , w ) } for i := 0 ; i < h ; i ++ { for j := 0 ; j < w ; j ++ { var s string fmt . Scan ( & s ) graph [ i ] [ j ] = s } } visited := make ( [ ] [ ] bool , h ) for i := range visited { visited [ i ] = make ( [ ] bool , w ) } count := 0 for i := range graph { for j := range graph [ i ] { if graph [ i ] [ j ] == \" \" && ! visited [ i ] [ j ] { dfs ( visited , i , j ) count + + } } } fmt . Println ( count ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / big \" \" os \" \" strconv \" \" Yes \" No = \" No \" YES = \" YES \" NO = \" NO \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" MASPY \" \" \" { fp , T HE_HARMONY_OF_PERFECT\")) cn t P Y\") == \" \" { wfp, _ = os. C U S10\")) } scanner := - -- -- -- -- -- -- -- -- -- -\" ) so lv e( sc an ne r ,",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var h , w int for { fmt . Scan ( & w , & h ) if w == 0 && h == 0 { return } matrix := make ( [ ] [ ] int , h ) Sean := make ( [ ] [ ] bool , h ) for i := 0 ; i < h ; i ++ { matrix [ i ] = make ( [ ] int , w ) Sean [ i ] = make ( [ ] bool , w ) for j := 0 ; j < w ; j ++ { fmt . Scan ( & matrix [ i ] [ j ] ) } } var count int for i := 0 ; i < h ; i ++ { for j := 0 ; j < w ; j ++ { if matrix [ i ] [ j ] == 1 && Sean [ i ] [ j ] == false { search ( i , j , h , w , matrix , Sean ) count ++ } } } fmt . Println ( count ) } } func search ( x int , y int , h int , w int , matrix [ ] [ ] int , Sean [ ] [ ] bool ) { if x < 0 || y < 0 || x >= h || y >= w || matrix [ x ] [ y ] == 0 { return } if Sean [ x ] [ y ] == true { return } Sean [ x ] [ y ] = true search ( x + 1 , y , h , w , matrix , Sean ) search ( x - 1 , y , h , w , matrix , Sean ) search ( x , y + 1 , h , w , matrix , Sean ) search ( x , y - 1 , h , w , matrix , Sean ) search ( x + 1 , y - 1 , h , w , matrix , Sean ) search ( x - 1 , y + 1 , h , w , matrix , Sean ) search ( x + 1 , y + 1 , h , w , matrix , Sean ) search ( x - 1 , y - 1 , h , w , matrix , Sean ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" _ \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" . \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" % d \" \" = \" ) } else { io . Printf ( \" \" ) } } io . Println ( score [ 0 ] . index ) } } type Io struct { reader * bufio . Reader writer * bufio . Writer tokens [ ] string nextToken int } func NewIo ( ) * Io { return & Io { reader : bufio . NewReader ( os . Stdin ) , writer : bufio . NewWriter ( os . Stdout ) , } } func ( io * Io ) Flush ( ) { err := io . writer . Flush ( ) if err != nil { panic ( err ) } } func ( io * Io ) NextLine ( ) string { var buff [ ] byte for { line , isPrefix , err := io . reader . ReadLine ( ) if err != nil { panic ( err ) } buff = append ( buff , line ... ) if ! isPrefix { break } } return string ( buff ) } func ( io * Io ) Next ( ) string { for io . nextToken >= len ( io . tokens ) { line := io . NextLine ( ) io . tokens = strings . Fields ( line ) io . nextToken = 0 } s := io . tokens [ io . nextToken ] io . nextToken + + return s } func ( io * Io ) NextInt ( ) int { i , err := strconv . Atoi ( io . Next ( ) ) if err != nil { panic ( err ) } return i } func ( io * Io ) NextFloat ( ) float64 { i , err := strconv . ParseFloat ( io . Next ( ) , 64 ) if err != nil { panic ( err ) } return i } func ( io * Io ) Println ( a ... interface { } ) { fmt . Fprintln ( io . writer , a ... ) } func ( io * Io ) Printf ( format string , a ... interface { } ) { fmt . Fprintf ( io . writer , format , a ... ) } func ( io * Io ) PrintIntSlice ( a [ ] int ) { b := [ ] interface { } { } for _ , x := range a { b = append ( b , x ) } io . Println ( b ... ) } func ( io * Io ) PrintStringSlice ( a [ ] string ) { b := [ ] interface { } { } for _ , x := range a { b = append ( b , x ) } io . Println ( b ... ) } func Log ( name string , value interface { } ) { fmt . Fprintf ( os . Stderr , \" \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" \" \" error \" \" rejected \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" var H , W int type point struct { x , y int } func ( p * point ) add ( q point ) { p . x += q . x p . y + = q . y if p . x < 0 { p . x += H } if p . y < 0 { p . y += W } p . x %= H p . y % = W } func isPalindrome ( str string ) bool { for i , j := 0 , len ( str ) - 1 ; i < j ; i , j = i + 1 , j - 1 { if str [ i ] != str [ j ] { return false } } return true } func magicSpel ( arr [ ] string ) string { var ans string m := map [ string ] int { } for i := range arr { for j := range arr [ i ] { for _ , d := range [ ] point { { - 1 , - 1 } , { - 1 , 0 } , { - 1 , 1 } , { 0 , - 1 } , { 0 , 1 } , { 1 , - 1 } , { 1 , 0 } , { 1 , 1 } } { cur := point { x : i , y : j } str := string ( arr [ cur . x ] [ cur . y ] ) cur . add ( d ) for i != cur . x || j != cur . y { str + = string ( arr [ cur . x ] [ cur . y ] ) cur . add ( d ) if isPalindrome ( str ) { m [ str ] + = 2 } else { m [ str ] + + } } } } } for s , v := range m { if 1 < v { if len ( ans ) < len ( s ) { ans = s } else if len ( ans ) == len ( s ) && s < ans { ans = s } } } if len ( ans ) == 0 { return \" \" } return ans } func main ( ) { for { fmt . Scan ( & H , & W ) if H == 0 && W == 0 { break } var arr [ ] string for i := 0 ; i < H ; i ++ { var s string fmt . Scan ( & s ) arr = append ( arr , s ) } fmt . Println ( magicSpel ( arr ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" [ nil ] n \" ) eturn d = . i ds[ c ur] mt. F printf( w , [ i d: d , alue: d , ize: d , p ]  n\" , s % d . L E FT : \" , s rings.R e peat(\" \" s % d . R i ght:: \" , s rings.R e peat(\" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" strconv \" \" os \" \" strings \" \" math \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" strconv \" \" os \" \" strings \" \" math \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \" \" strings \" \" math \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" fmt \" \" strings \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" sort \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" NONE \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" . \" \" IDENTICAL \" \" \\\" \" ) tt := strings . Split ( t , \" \\\" \" ) if len ( ss ) != len ( tt ) { io . Println ( \" \" ) continue } cnt := 0 for i := 0 ; i < len ( ss ) ; i ++ { if i % 2 == 0 { if ss [ i ] != tt [ i ] { cnt = - 1 break } } else { if ss [ i ] != tt [ i ] { cnt ++ } } } if cnt > 1 || cnt == - 1 { io . Println ( \" \" ) } else { io . Println ( \" \" ) } } } type Io struct { reader * bufio . Reader writer * bufio . Writer tokens [ ] string nextToken int } func NewIo ( ) * Io { return & Io { reader : bufio . NewReader ( os . Stdin ) , writer : bufio . NewWriter ( os . Stdout ) , } } func ( io * Io ) Flush ( ) { err := io . writer . Flush ( ) if err != nil { panic ( err ) } } func ( io * Io ) NextLine ( ) string { var buff [ ] byte for { line , isPrefix , err := io . reader . ReadLine ( ) if err != nil { panic ( err ) } buff = append ( buff , line ... ) if ! isPrefix { break } } return string ( buff ) } func ( io * Io ) Next ( ) string { for io . nextToken >= len ( io . tokens ) { line := io . NextLine ( ) io . tokens = strings . Fields ( line ) io . nextToken = 0 } s := io . tokens [ io . nextToken ] io . nextToken + + return s } func ( io * Io ) NextInt ( ) int { i , err := strconv . Atoi ( io . Next ( ) ) if err != nil { panic ( err ) } return i } func ( io * Io ) NextFloat ( ) float64 { i , err := strconv . ParseFloat ( io . Next ( ) , 64 ) if err != nil { panic ( err ) } return i } func ( io * Io ) Println ( a ... interface { } ) { fmt . Fprintln ( io . writer , a ... ) } func ( io * Io ) Printf ( format string , a ... interface { } ) { fmt . Fprintf ( io . writer , format , a ... ) } func ( io * Io ) PrintIntSlice ( a [ ] int ) { b := [ ] interface { } { } for _ , x := range a { b = append ( b , x ) } io . Println ( b ... ) } func ( io * Io ) PrintStringSlice ( a [ ] string ) { b := [ ] interface { } { } for _ , x := range a { b = append ( b , x ) } io . Println ( b ... ) } func Log ( name string , value interface { } ) { fmt . Fprintf ( os . Stderr , \" \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int a := make ( [ ] float64 , 10004 ) for { fmt . Scan ( & n ) if n == 0 { break } ave_num := 0.0 for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) ave_num += a [ i ] } ave_num /= float64 ( n ) cnt := 0 for i := 0 ; i < n ; i ++ { if a [ i ] <= ave_num { cnt ++ } } fmt . Println ( cnt ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { for ; true ; { var n int fmt . Scan ( & n ) if n == 0 { break } a := make ( [ ] float64 , n ) var sum float64 = 0 for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) sum += float64 ( a [ i ] ) } sum /= float64 ( n ) ans := 0 for i := 0 ; i < n ; i ++ { if a [ i ] <= sum { ans += 1 } } fmt . Println ( ans ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func maxValue ( p [ ] int ) int { highest : = 0 for i : = 0 ; i < len ( p ) ; i ++ { if p [ i ] > highest { highest = p [ i ] } } return highest } func main ( ) { scanner . Split ( bufio . ScanWords ) for { n := nextInt ( ) m := nextInt ( ) if n == 0 && m == 0 { break } pSum := make ( [ ] int , n ) for i := 0 ; i < m ; i ++ { for j := 0 ; j < n ; j ++ { pSum [ j ] += nextInt ( ) } } fmt . Println ( maxValue ( pSum ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } type Position = [ ] int func abs ( x int ) int { if x < 0 { return - x } return x } func main ( ) { scanner . Split ( bufio . ScanWords ) for { h := nextInt ( ) w := nextInt ( ) if h == 0 && w == 0 { break } positions := map [ string ] Position { } for i := 0 ; i < h ; i ++ { row := nextString ( ) for j := 0 ; j < w ; j ++ { pos := [ ] int { i , j } positions [ row [ j : ( j + 1 ) ] ] = pos } } x := 0 y := 0 totalDistance := 0 queryRow := nextString ( ) for i := 0 ; i < len ( queryRow ) ; i ++ { q := queryRow [ i : ( i + 1 ) ] nextPos := positions [ q ] xNext := nextPos [ 0 ] yNext := nextPos [ 1 ] totalDistance += abs ( xNext - x ) + abs ( yNext - y ) + 1 x = xNext y = yNext } fmt . Println ( totalDistance ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" N \" \" S \" \" S \" \" E \" \" W \" \" W \" \" \" \" \" \" No \" \" Yes \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" . , ! ? \" \" abc \" \" def \" \" ghi \" \" jkl \" \" mno \" \" pqrs \" \" tuv \" \" wxyz \" \" 0 \" ) for _ , word := range messageSlice { if word == \" \" { } else { ascii := string ( ( word [ 0 ] ) ) number , _ := strconv . Atoi ( ascii ) count := len ( word ) for count > len ( table [ number ] ) { count -= len ( table [ number ] ) } keys := table [ number ] fmt . Printf ( \" \" , string ( keys [ count - 1 ] ) ) } } fmt . Println ( ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" . , ! ? \" \" abc \" \" def \" \" ghi \" \" jkl \" \" mno \" \" pqrs \" \" tuv \" \" wxyz \" \" % c \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" \" \" . , ! ? \" \" abc \" \" def \" \" ghi \" \" jkl \" \" mno \" \" pqrs \" \" tuv \" \" wxyz \" \" % d \" \" % s \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func main ( ) { var e int for { fmt . Scan ( & e ) if e == 0 { break } var ans float64 = float64 ( e ) for z := 0 ; z <= 101 ; z ++ { for y := 0 ; y <= 1001 ; y ++ { x := e - y * y - z * z * z if ( 0 <= x && x <= 100000 ) { ans = math . Min ( ans , float64 ( x + y + z ) ) ; } } } fmt . Println ( ans ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" _ \" \" \" fmt \" \" os \" \" sort \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" CORRECT \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , m int fmt . Scan ( & n ) u := make ( [ ] string , 300 ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & u [ i ] ) } fmt . Scan ( & m ) is_lock := true for i := 0 ; i < m ; i ++ { var t string fmt . Scan ( & t ) is_include := false for j := 0 ; j < n ; j ++ { if t == u [ j ] { is_include = true break } } if is_include == false { fmt . Printf ( \" \\n \" , t ) } else if ( is_lock ) { fmt . Printf ( \" \\n \" , t ) is_lock = false } else { fmt . Printf ( \" \\n \" , t ) is_lock = true } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) type phrase struct { s , l , p int } const melody_len int = 393 var n , m int func max ( a , b int ) int { if a < b { return b } return a } func main ( ) { fmt . Scan ( & n ) phrases := make ( [ ] phrase , n ) max_count := 0 for i := 0 ; i < n ; i ++ { fmt . Scan ( & phrases [ i ] . s , & phrases [ i ] . l , & phrases [ i ] . p ) max_count += phrases [ i ] . l } dp := make ( [ ] [ ] int , n + 1 ) for i := range dp { dp [ i ] = make ( [ ] int , melody_len + 1 ) } for i := range phrases { s := phrases [ i ] . s l := phrases [ i ] . l p := phrases [ i ] . p for j := range dp [ i ] { for k := s ; k <= l ; k ++ { if 0 <= j - k { dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , max ( dp [ i ] [ j ] , dp [ i + 1 ] [ j - k ] + p ) ) } else { dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) } } } } fmt . Scan ( & m ) var invalid bool var points [ ] int for i := 0 ; i < m ; i ++ { var m int fmt . Scan ( & m ) if dp [ n ] [ m ] == 0 { invalid = true } points = append ( points , dp [ n ] [ m ] ) } if invalid { fmt . Println ( - 1 ) } else { for _ , p := range points { fmt . Println ( p ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" strings \" \" % d / % d \" \" - \" \" . \" ) if i != - 1 { decimalDigit := len ( s ) - i - 1 fr , _ := strconv . Atoi ( strings . Replace ( s , \" \" , \" \" , 1 ) ) return newRational ( fr , int ( math . Pow10 ( decimalDigit ) ) ) } i = strings . Index ( s , \" \" ) if i != - 1 { fr , _ := strconv . Atoi ( s [ 0 : i ] ) de , _ := strconv . Atoi ( s [ i + 1 : len ( s ) ] ) return newRational ( fr , de ) } fr , _ := strconv . Atoi ( s ) return newRational ( fr , 1 ) } func gcd ( a , b int ) int { for b > 0 { t := a / b a , b = b , a - t * b } return a } func nextInt ( sc * bufio . Scanner ) int { sc . Scan ( ) a , _ := strconv . Atoi ( sc . Text ( ) ) return int ( a ) } func nextString ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func resolve ( n int ) int { return n } func scanInt ( sc * bufio . Scanner ) int { sc . Scan ( ) i , _ := strconv . Atoi ( sc . Text ( ) ) return int ( i ) } func scanString ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" ? \" ) ne = append ( ne , strconv . Itoa ( yr - 30 ) ) ne = append ( ne , sd [ 2 ] ) ne = append ( ne , sd [ 3 ] ) return ne } } func main ( ) { for sc . Scan ( ) { str := sc . Text ( ) if str == \" \" { break } sdt := strings . Split ( str , \" \" ) ans := ConvReiwa ( sdt ) fmt . Printf ( \" \\n \" , ans [ 0 ] , ans [ 1 ] , ans [ 2 ] , ans [ 3 ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" HEISEI \" \" ? \" , y - 30 , m , d ) } else { io . Println ( S , y , m , d ) } } } type Io struct { reader * bufio . Reader writer * bufio . Writer tokens [ ] string nextToken int } func NewIo ( ) * Io { return & Io { reader : bufio . NewReader ( os . Stdin ) , writer : bufio . NewWriter ( os . Stdout ) , } } func ( io * Io ) Flush ( ) { err := io . writer . Flush ( ) if err != nil { panic ( err ) } } func ( io * Io ) NextLine ( ) string { var buff [ ] byte for { line , isPrefix , err := io . reader . ReadLine ( ) if err != nil { panic ( err ) } buff = append ( buff , line ... ) if ! isPrefix { break } } return string ( buff ) } func ( io * Io ) Next ( ) string { for io . nextToken >= len ( io . tokens ) { line := io . NextLine ( ) io . tokens = strings . Fields ( line ) io . nextToken = 0 } s := io . tokens [ io . nextToken ] io . nextToken ++ return s } func ( io * Io ) NextInt ( ) int { i , err := strconv . Atoi ( io . Next ( ) ) if err != nil { panic ( err ) } return i } func ( io * Io ) NextFloat ( ) float64 { i , err := strconv . ParseFloat ( io . Next ( ) , 64 ) if err != nil { panic ( err ) } return i } func ( io * Io ) Println ( a ... interface { } ) { fmt . Fprintln ( io . writer , a ... ) } func ( io * Io ) Printf ( format string , a ... interface { } ) { fmt . Fprintf ( io . writer , format , a ... ) } func ( io * Io ) PrintIntSlice ( a [ ] int ) { b := [ ] interface { } { } for _ , x := range a { b = append ( b , x ) } io . Println ( b ... ) } func ( io * Io ) PrintStringSlice ( a [ ] string ) { b := [ ] interface { } { } for _ , x := range a { b = append ( b , x ) } io . Println ( b ... ) } func Log ( name string , value interface { } ) { fmt . Fprintf ( os . Stderr , \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" io \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" . \" \" % 04 d \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" : ( \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s = % + v \\n \" , name , value ) } func ExampleIo ( ) { io := NewIo ( ) defer io . Flush ( ) a := make ( [ ] int , 0 , 3 ) a [ 0 ] , a [ 1 ] , a [ 2 ] = io . NextInt ( ) , io . NextInt ( ) , io . NextInt ( ) io . Println ( a ) io . PrintIntSlice ( a ) Log ( \" \" , a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \" \" A \" ) return } if b == most ( a , b , c ) { fmt . Fprintln ( writer , \" \" ) return } fmt . Fprintln ( writer , \" \" ) } func max ( a , b int ) int { if a > b { return a } return b } func most ( a , b , c int ) int { return max ( a , max ( b , c ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func max ( a , b int ) int { if a < b { return b } return a } func max3 ( a , b , c int ) int { return max ( max ( a , b ) , c ) } func main ( ) { var ( a , b , c int ch byte ) fmt . Scanln ( & a , & b , & c ) m := max3 ( a , b , c ) switch m { case a : ch = 'A' case b : ch = 'B' case c : ch = 'C' } fmt . Printf ( \" \\n \" , ch ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" \" \" A \" \" B \" \" C \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func abs ( a int ) int { if a >= 0 { return a } return - a } func min ( a , b int ) int { if a < b { return a } return b } func main ( ) { var a , b , c , d int fmt . Scan ( & a , & b , & c , & d ) ans := 10000 ans = min ( ans , abs ( ( a + b ) - ( c + d ) ) ) ans = min ( ans , abs ( ( a + c ) - ( b + d ) ) ) ans = min ( ans , abs ( ( a + d ) - ( b + c ) ) ) fmt . Println ( ans ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" var h , w int var maze [ ] [ ] byte var visited [ ] [ ] bool type dice struct { top , bottom , right , left , up , down int } func move ( d * dice , dir byte ) { now := d . top switch dir { case 'N' : d . top = d . down d . down = d . bottom d . bottom = d . up d . up = now case 'S' : d . top = d . up d . up = d . bottom d . bottom = d . down d . down = now case 'W' : d . top = d . right d . right = d . bottom d . bottom = d . left d . left = now case 'E' : d . top = d . left d . left = d . bottom d . bottom = d . right d . right = now } } var dx = [ 4 ] int { 1 , - 1 , 0 , 0 } var dy = [ 4 ] int { 0 , 0 , 1 , - 1 } func dfs ( x , y int , d * dice ) bool { visited [ y ] [ x ] = true if ( y == h - 1 ) && ( x == w - 1 ) { return true } for i := 0 ; i < 4 ; i ++ { nx := x + dx [ i ] ny := y + dy [ i ] dir := [ ] byte { 'E' , 'W' , 'S' , 'N' } dc := * d move ( & dc , dir [ i ] ) if 0 <= nx && nx < w && 0 <= ny && ny < h && maze [ ny ] [ nx ] != '#' && ! visited [ ny ] [ nx ] && dc . bottom == int ( maze [ ny ] [ nx ] - '0' ) { if dfs ( nx , ny , & dc ) { return true } } else { continue } } return false } func main ( ) { fmt . Scan ( & h , & w ) maze = make ( [ ] [ ] byte , h ) visited = make ( [ ] [ ] bool , h ) for i := 0 ; i < h ; i ++ { visited [ i ] = make ( [ ] bool , w ) maze [ i ] = make ( [ ] byte , w ) fmt . Scan ( & maze [ i ] ) } var d dice d . bottom = 6 d . top = 1 d . right = 3 d . left = 4 d . down = 2 d . up = 5 if dfs ( 0 , 0 , & d ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func fibonacci ( ) func ( ) int { x , y := 0 , 1 return func ( ) int { x , y = y , x + y return x } } func main ( ) { var n int fmt . Scan ( & n ) f := fibonacci ( ) for i := 0 ; i < n ; i ++ { f ( ) } fmt . Println ( f ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) x , y := int64 ( 1 ) , int64 ( 1 ) for i := 0 ; i < n ; i ++ { x , y = y , x + y } fmt . Println ( x ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) x , y := int64 ( 1 ) , int64 ( 1 ) for i := 0 ; i < n ; i ++ { x , y = y , x + y } fmt . Println ( x ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" strconv \" \" strings \" \" os \" \" \\n \" ) ) ) solve ( sc ) } func fib ( n int , dp map [ int ] int ) int { if n == 0 || n == 1 { return 1 } if v , ok := dp [ n ] ; ok { return v } r := fib ( n - 1 , dp ) + fib ( n - 2 , dp ) dp [ n ] = r return r } func solve ( sc * bufio . Scanner ) { sc . Split ( bufio . ScanWords ) sc . Scan ( ) n , _ := strconv . Atoi ( sc . Text ( ) ) dp := make ( map [ int ] int ) r := fib ( n , dp ) fmt . Println ( r ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \\n \" ) ) buf . Flush ( ) } func fibonacci_ ( n int ) int { if n == 0 || n == 1 { return 1 } return fibonacci_ ( n - 2 ) + fibonacci_ ( n - 1 ) } func fibonacci ( n int ) int { if n == 0 || n == 1 { F [ n ] = 1 } if F [ n ] > 0 { return F [ n ] } F [ n ] = fibonacci ( n - 2 ) + fibonacci ( n - 1 ) return F [ n ] } const MAX = 50 var F [ MAX ] int func main ( ) { sc . Split ( bufio . ScanWords ) n := nextInt ( ) fmt . Println ( fibonacci ( n ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) const MAX = 45 var dp [ MAX ] int func fin ( n int ) int { if dp [ n ] != 0 { return dp [ n ] } switch n { case 0 : dp [ n ] = 1 case 1 : dp [ n ] = 1 default : dp [ n ] = fin ( n - 1 ) + fin ( n - 2 ) } return dp [ n ] } func main ( ) { var n int fmt . Scan ( & n ) fmt . Println ( fin ( n ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) m := make ( [ ] int , n + 1 ) m [ 0 ] = 1 m [ 1 ] = 1 for i := 2 ; i <= n ; i ++ { m [ i ] = m [ i - 2 ] + m [ i - 1 ] } fmt . Println ( m [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func fibonacci ( n int ) int64 { f := [ ] int64 { 1 , 1 } for i := 2 ; i <= n ; i ++ { f = append ( f , f [ i - 2 ] + f [ i - 1 ] ) } return f [ n ] } func main ( ) { var n int fmt . Scanf ( \" % d \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) f := make ( [ ] int , n + 1 ) fmt . Println ( fib ( n , f ) ) } func fib ( n int , f [ ] int ) int { if n == 0 { f [ n ] = 1 return f [ n ] } if n == 1 { f [ n ] = 1 return 1 } if f [ n ] != 0 { return f [ n ] } f [ n ] = fib ( n - 2 , f ) + fib ( n - 1 , f ) return f [ n ] }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) fibo := make ( [ ] int , n + 1 ) fibo [ 0 ] = 1 fibo [ 1 ] = 1 for i := 2 ; i <= n ; i ++ { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] } fmt . Println ( fibo [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n + 1 ) a [ 0 ] = 1 a [ 1 ] = 1 for i := 2 ; i <= n ; i ++ { a [ i ] = a [ i - 1 ] + a [ i - 2 ] } fmt . Println ( a [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" [ \" ) sep := \" \" for _ , v : = range s { buf . WriteString ( fmt . Sprintf ( \" \" , sep , v ) ) sep = \" , \" } buf . WriteString ( \" ] \" ) return buf . String ( ) } func reverse ( a ints ) ints { r := make ( ints , len ( a ) ) for i := 0 ; i < len ( a ) ; i ++ { r [ i ] = a [ len ( a ) - 1 - i ] } return r } func max ( a ints ) ( int , bool ) { if len ( a ) == 0 { return 0 , false } m := a [ 0 ] for _ , e := range a { if e > m { m = e } } return m , true } func min ( a [ ] int ) int { m := a [ 0 ] for _ , v := range a { if v < m { m = v } } return m } func sum ( a ints ) int { if len ( a ) == 0 { return 0 } sum := 0 for _ , e := range a { sum + = e } return sum } func find ( n int , a ints ) int { for i , v := range a { if n == v { return i } } return - 1 }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" % d \\n \" , ans [ i ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" io \" \" os \" \" strconv \" \" fmt \" \" Scan failed \" \" 0 b \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n , pre1 , pre2 , now int fmt . Scan ( & n ) if n == 0 || n == 1 { fmt . Println ( 1 ) } else { pre1 , pre2 = 1 , 1 for i := 1 ; i < n ; i ++ { now = pre1 + pre2 pre2 = pre1 pre1 = now } fmt . Println ( now ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func answer ( n int ) string { f := [ ] int { 1 , 1 } for i := 2 ; i <= n ; i ++ { f = append ( f , f [ i - 1 ] + f [ i - 2 ] ) } return fmt . Sprintf ( \" \" , f [ n ] ) } func main ( ) { var n int fmt . Scan ( & n ) fmt . Println ( answer ( n ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" cannnot calculate \" \" must not be empty \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \\n \" ) ) buf . Flush ( ) } func matrixChainMultiplication ( ) { for i := 1 ; i <= n ; i ++ { m [ i ] [ i ] = 0 } for l := 2 ; l <= n ; l ++ { for i := 1 ; i <= n - l + 1 ; i ++ { j := i + l - 1 m [ i ] [ j ] = 1 << 21 for k := i ; k <= j - 1 ; k ++ { m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ) } } } } func max ( a , b int ) int { if a > b { return a } else { return b } } func min ( a , b int ) int { if a > b { return b } else { return a } } const MAX = 100 var n int var p [ MAX + 1 ] int var m [ MAX + 1 ] [ MAX + 1 ] int func main ( ) { sc . Split ( bufio . ScanWords ) n = nextInt ( ) for i := 1 ; i <= n ; i ++ { p [ i - 1 ] = nextInt ( ) p [ i ] = nextInt ( ) } matrixChainMultiplication ( ) fmt . Println ( m [ 1 ] [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func min ( x , y int ) int { if x < y { return x } return y } func stringifyArray ( arr [ ] int ) string { return strings . TrimRight ( fmt . Sprintf ( \" \" , arr ) [ 1 : ] , \" \" ) } func main ( ) { scanner . Split ( bufio . ScanWords ) n := nextInt ( ) m := make ( [ ] [ ] int , n ) sizes := make ( [ ] [ ] int , n ) for i := 0 ; i < n ; i ++ { sizes [ i ] = [ ] int { nextInt ( ) , nextInt ( ) } m [ i ] = make ( [ ] int , n ) } for w := 1 ; w < n ; w ++ { for i := 0 ; i < n - w ; i ++ { j := i + w minBetweenIandJ := 10000000 for k := i ; k < j ; k ++ { minBetweenIandJ = min ( minBetweenIandJ , m [ i ] [ k ] + m [ k + 1 ] [ j ] + sizes [ i ] [ 0 ] * sizes [ k ] [ 1 ] * sizes [ j ] [ 1 ] ) } m [ i ] [ j ] = minBetweenIandJ } } fmt . Println ( m [ 0 ] [ n - 1 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" log \" \" math \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" [ \" ) sep := \" \" for _ , v : = range s { buf . WriteString ( fmt . Sprintf ( \" \" , sep , v ) ) sep = \" , \" } buf . WriteString ( \" ] \" ) return buf . String ( ) } func reverse ( a ints ) ints { r := make ( ints , len ( a ) ) for i := 0 ; i < len ( a ) ; i ++ { r [ i ] = a [ len ( a ) - 1 - i ] } return r } func max ( a ints ) ( int , bool ) { if len ( a ) == 0 { return 0 , false } m := a [ 0 ] for _ , e := range a { if e > m { m = e } } return m , true } func sum ( a ints ) int { if len ( a ) == 0 { return 0 } sum := 0 for _ , e := range a { sum + = e } return sum } func find ( n int , a ints ) int { for i , v := range a { if n == v { return i } } return - 1 }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n + 1 ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) fmt . Scan ( & a [ i + 1 ] ) } m := make ( [ ] [ ] int , n + 1 ) for i := 0 ; i <= n ; i ++ { m [ i ] = make ( [ ] int , n + 1 ) } for d := 2 ; d <= n ; d ++ { for s := 0 ; s + d <= n ; s ++ { min := 1 << 30 for j := s + 1 ; j < s + d ; j ++ { val := m [ s ] [ j ] + m [ j ] [ s + d ] + a [ s ] * a [ j ] * a [ s + d ] if val < min { min = val } } m [ s ] [ s + d ] = min } } fmt . Println ( m [ 0 ] [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var nPairs int fmt . Scanln ( & nPairs ) var a , b string for i := 0 ; i < nPairs ; i ++ { fmt . Scanln ( & a ) fmt . Scanln ( & b ) fmt . Println ( lcsSize ( a , b ) ) } } func lcsSize ( sa , sb string ) int { dp := make ( [ ] [ ] int , len ( sa ) + 1 ) for i := 0 ; i <= len ( sa ) ; i ++ { dp [ i ] = make ( [ ] int , len ( sb ) + 1 ) } for a := 1 ; a <= len ( sa ) ; a ++ { for b := 1 ; b <= len ( sb ) ; b ++ { if sa [ a - 1 ] == sb [ b - 1 ] { dp [ a ] [ b ] = dp [ a - 1 ] [ b - 1 ] + 1 } else { dp [ a ] [ b ] = max ( dp [ a ] [ b - 1 ] , dp [ a - 1 ] [ b ] ) } } } return dp [ len ( sa ) ] [ len ( sb ) ] } func max ( a , b int ) int { if a > b { return a } return b }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" bufio \" \" strings \" \" sort \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var q int fmt . Scan ( & q ) for i := 0 ; i < q ; i ++ { var x , y string fmt . Scan ( & x ) fmt . Scan ( & y ) xs := [ ] rune ( x ) ys := [ ] rune ( y ) xn := len ( xs ) yn := len ( ys ) dp := make ( [ ] [ ] int , xn + 1 ) for j := 0 ; j <= xn ; j ++ { dp [ j ] = make ( [ ] int , yn + 1 ) } for j := 1 ; j <= xn ; j ++ { for k := 1 ; k <= yn ; k ++ { dp [ j ] [ k ] = max ( dp [ j - 1 ] [ k ] , dp [ j ] [ k - 1 ] ) if xs [ j - 1 ] == ys [ k - 1 ] { dp [ j ] [ k ] = max ( dp [ j ] [ k ] , dp [ j - 1 ] [ k - 1 ] + 1 ) } else { dp [ j ] [ k ] = max ( dp [ j ] [ k ] , dp [ j - 1 ] [ k - 1 ] ) } } } fmt . Println ( dp [ xn ] [ yn ] ) } } func max ( a , b int ) int { if a < b { return b } else { return a } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) for q := 0 ; q < n ; q ++ { var s1 , s2 string fmt . Scan ( & s1 , & s2 ) s1 , s2 = \" \" + s1 , \" \" + s2 dp := make ( [ ] [ ] int , len ( s1 ) ) for i := range dp { dp [ i ] = make ( [ ] int , len ( s2 ) ) } max := 0 for i := 1 ; i < len ( s1 ) ; i ++ { for j := 1 ; j < len ( s2 ) ; j ++ { if s1 [ i ] == s2 [ j ] { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + 1 } else { dp [ i ] [ j ] = Max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) } max = Max ( max , dp [ i ] [ j ] ) } } fmt . Println ( max ) } } func Max ( n ... int ) int { max := n [ 0 ] for _ , v := range n [ 1 : ] { if v > max { max = v } } return max }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( . \" \" \" math \" \" % d \" \" % s \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var dataNum int var s1 , s2 string fmt . Scanf ( \" % d \" , & dataNum ) for i := 0 ; i < dataNum ; i ++ { fmt . Scanf ( \" \" , & s1 ) fmt . Scanf ( \" \" , & s2 ) lcs := make ( [ ] [ ] int , len ( s1 ) + 1 ) for j := 0 ; j < len ( s1 ) + 1 ; j ++ { lcs [ j ] = make ( [ ] int , len ( s2 ) + 1 ) } for m , vs1 := range s1 { for n , vs2 := range s2 { if vs1 == vs2 { lcs [ m + 1 ] [ n + 1 ] = lcs [ m ] [ n ] + 1 } else if lcs [ m + 1 ] [ n ] > lcs [ m ] [ n + 1 ] { lcs [ m + 1 ] [ n + 1 ] = lcs [ m + 1 ] [ n ] } else { lcs [ m + 1 ] [ n + 1 ] = lcs [ m ] [ n + 1 ] } } } fmt . Println ( lcs [ len ( s1 ) ] [ len ( s2 ) ] ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func initialize_grid ( width int , height int ) [ ] [ ] int { var grid [ ] [ ] int for i := 0 ; i < height + 1 ; i ++ { var grid_row [ ] int for j := 0 ; j < width + 1 ; j ++ { grid_row = append ( grid_row , 0 ) } grid = append ( grid , grid_row [ : ] ) } return grid } func ma ( x int , y int ) int { if x >= y { return x } else { return y } } func main ( ) { var num int var st1 , st2 string var string_pairs [ ] [ ] string fmt . Scan ( & num ) for i := 0 ; i < num ; i ++ { var string_pair [ ] string fmt . Scan ( & st1 ) fmt . Scan ( & st2 ) string_pair = append ( string_pair , st1 , st2 ) string_pairs = append ( string_pairs , string_pair ) } for i := 0 ; i < num ; i ++ { string_1 := string_pairs [ i ] [ 0 ] string_2 := string_pairs [ i ] [ 1 ] dp := initialize_grid ( len ( string_2 ) , len ( string_1 ) ) for j := 1 ; j < len ( string_1 ) + 1 ; j ++ { for k := 1 ; k < len ( string_2 ) + 1 ; k ++ { if string_1 [ j - 1 ] == string_2 [ k - 1 ] { dp [ j ] [ k ] = dp [ j - 1 ] [ k - 1 ] + 1 } else { dp [ j ] [ k ] = ma ( dp [ j - 1 ] [ k ] , dp [ j ] [ k - 1 ] ) } } } fmt . Println ( dp [ len ( string_1 ) ] [ len ( string_2 ) ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \" \" [ \" ) sep := \" \" for _ , v : = range s { buf . WriteString ( fmt . Sprintf ( \" \" , sep , v ) ) sep = \" , \" } buf . WriteString ( \" ] \" ) return buf . String ( ) } func reverse ( a ints ) ints { r := make ( ints , len ( a ) ) for i := 0 ; i < len ( a ) ; i ++ { r [ i ] = a [ len ( a ) - 1 - i ] } return r } func max ( a ints ) ( int , bool ) { if len ( a ) == 0 { return 0 , false } m := a [ 0 ] for _ , e := range a { if e > m { m = e } } return m , true } func min ( a [ ] int ) int { m := a [ 0 ] for _ , v := range a { if v < m { m = v } } return m } func sum ( a ints ) int { if len ( a ) == 0 { return 0 } sum := 0 for _ , e := range a { sum + = e } return sum } func find ( n int , a ints ) int { for i , v := range a { if n == v { return i } } return - 1 }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" fmt \" \" strconv \" \" \" \" \" \" % d \\n \" , lcs ( x , y ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" io \" \" strconv \" \" math \" \" fmt \" \" Scan failed \" \" 0 b \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \\n \" , lcs ( s1 , s2 ) ) ) } return strings . TrimRight ( out . String ( ) , \" \\n \" ) } func main ( ) { fmt . Println ( answer ( os . Stdin ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % .8 f \\n \" , dp [ 0 ] [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func nextFloat64 ( ) ( float64 , error ) { return strconv . ParseFloat ( nextString ( ) , 64 ) } var infty = math . MaxFloat64 func optimalBst ( p [ ] float64 , q [ ] float64 , n int ) ( [ ] [ ] float64 , [ ] [ ] int ) { e := make ( [ ] [ ] float64 , n + 2 ) for i := 0 ; i <= n + 1 ; i + + { e [ i ] = make ( [ ] float64 , n + 1 ) } w := make ( [ ] [ ] float64 , n + 2 ) for i := 0 ; i <= n + 1 ; i + + { w [ i ] = make ( [ ] float64 , n + 1 ) } root := make ( [ ] [ ] int , n + 1 ) for i := 0 ; i <= n ; i + + { root [ i ] = make ( [ ] int , n + 1 ) } for i := 1 ; i <= n + 1 ; i + + { e [ i ] [ i - 1 ] = q [ i - 1 ] w [ i ] [ i - 1 ] = q [ i - 1 ] } for l := 1 ; l <= n ; l + + { for i := 1 ; i <= n - l + 1 ; i + + { j := i + l - 1 e [ i ] [ j ] = infty w [ i ] [ j ] = w [ i ] [ j - 1 ] + p [ j ] + q [ j ] for r := i ; r <= j ; r + + { t := e [ i ] [ r - 1 ] + e [ r + 1 ] [ j ] + w [ i ] [ j ] if t < e [ i ] [ j ] { e [ i ] [ j ] = t root [ i ] [ j ] = r } } } } return e , root } func main ( ) { scanner . Split ( bufio . ScanWords ) n := nextInt ( ) p := make ( [ ] float64 , n + 1 ) q := make ( [ ] float64 , n + 1 ) for i := 1 ; i <= n ; i + + { p [ i ] , _ = nextFloat64 ( ) } for i := 0 ; i <= n ; i + + { q [ i ] , _ = nextFloat64 ( ) } e , _ := optimalBst ( p , q , n ) fmt . Println ( e [ 1 ] [ n ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" math \" \" os \" \" strconv \" \" scan error \" \" % .4 f \\n \" , solve ( n , ps , ds ) ) _ = w . Flush ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) g := make ( [ ] [ ] int , n ) for i := 0 ; i < n ; i ++ { g [ i ] = make ( [ ] int , n ) } for i := 0 ; i < n ; i ++ { var u , k int fmt . Scan ( & u ) fmt . Scan ( & k ) for j := 0 ; j < k ; j ++ { var v int fmt . Scan ( & v ) g [ u - 1 ] [ v - 1 ] = 1 } } for i := 0 ; i < n ; i ++ { fmt . Print ( g [ i ] [ 0 ] ) for j := 1 ; j < n ; j ++ { fmt . Printf ( \" \" , g [ i ] [ j ] ) } fmt . Println ( ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" % d \\n \" , Adj [ i ] [ j ] ) continue } fmt . Printf ( \" \" , Adj [ i ] [ j ] ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" ) ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \\n \" , list [ n - 1 ] ) ) ) buf . Flush ( ) } func max ( a , b int ) int { if a > b { return a } else { return b } } func min ( a , b int ) int { if a > b { return b } else { return a } } const MAX = 100 var n int var A [ MAX + 1 ] [ MAX + 1 ] int func main ( ) { sc . Split ( bufio . ScanWords ) n = nextInt ( ) for i := 0 ; i < n ; i ++ { u , k := nextInt ( ) , nextInt ( ) A [ u - 1 ] [ u - 1 ] = 0 if k > 0 { for j := 0 ; j < k ; j ++ { v := nextInt ( ) A [ u - 1 ] [ v - 1 ] = 1 } } } for i := 0 ; i < n ; i ++ { printList ( A [ i ] [ 0 : n ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } w . Flush ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % v \" \" % v \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var N int fmt . Scan ( & N ) graph := make ( [ ] [ ] int , N ) for i := range graph { graph [ i ] = make ( [ ] int , N ) var u , k int fmt . Scan ( & u , & k ) for j := 0 ; j < k ; j ++ { var v int fmt . Scan ( & v ) v -- graph [ i ] [ v ] = 1 } } for i := 0 ; i < N ; i ++ { for j := 0 ; j < N ; j ++ { if j > 0 { fmt . Print ( \" \" ) } fmt . Print ( graph [ i ] [ j ] ) } fmt . Println ( ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" % d \\n \" , adjMatrix [ i ] [ j ] ) } else { fmt . Printf ( \" % d \" , adjMatrix [ i ] [ j ] ) } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d \" \" 0 \" } } sc : = bufio . NewScanner ( os . Stdin ) for i : = 0 ; i < n ; i + + { sc . Scan ( ) adjList := strings . Split ( sc . Text ( ) , \" \" ) outDegree , _ := strconv . Atoi ( adjList [ 1 ] ) if outDegree > 0 { for k := 0 ; k < outDegree ; k ++ { j , _ := strconv . Atoi ( adjList [ k + 2 ] ) adj [ i ] [ j - 1 ] = \" \" } } } for i := 0 ; i < len ( adj ) ; i ++ { fmt . Println ( strings . Join ( adj [ i ] , \" \" ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" bytes \" \" strconv \" \" strings \" \" % v \" \" ] \" ) + \" \\n \" ) } fmt . Printf ( \" \" , outBuffer . String ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" \" \" % d \" \" \\n \" ) } return strings . TrimRight ( out . String ( ) , \" \\n \" ) } func main ( ) { fmt . Println ( answer ( os . Stdin ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , graph [ i ] [ j ] ) } else { fmt . Printf ( \" \" , graph [ i ] [ j ] ) } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d % d \\n \" , i , starts [ i ] , ends [ i ] ) } w . Flush ( ) } func scanInt ( sc * bufio . Scanner ) int { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) return v }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d % d \\n \" , vertices [ i ] . id , vertices [ i ] . firstVisitAt , vertices [ i ] . finishVisitAt ) } } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { return strconv . Atoi ( nextText ( sc ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) g := make ( [ ] [ ] int , n + 1 ) for i := 0 ; i < n ; i ++ { var u , k int fmt . Scan ( & u ) fmt . Scan ( & k ) g [ u ] = make ( [ ] int , k ) for j := 0 ; j < k ; j ++ { fmt . Scan ( & g [ u ] [ j ] ) } } d := make ( [ ] int , n + 1 ) f := make ( [ ] int , n + 1 ) t := 1 for i := 1 ; i <= n ; i ++ { t = dfs ( & g , & d , & f , i , t ) } for i := 1 ; i <= n ; i ++ { fmt . Printf ( \" \\n \" , i , d [ i ] , f [ i ] ) } } func dfs ( g * [ ] [ ] int , d * [ ] int , f * [ ] int , id int , t int ) int { if ( * d ) [ id ] > 0 { return t } ( * d ) [ id ] = t t += 1 for i := 0 ; i < len ( ( * g ) [ id ] ) ; i + + { t = dfs ( g , d , f , ( * g ) [ id ] [ i ] , t ) } ( * f ) [ id ] = t return t + 1 }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" There is no elements in stack ! \" \" % d % d % d \\n \" , i + 1 , discoverTime [ i ] , finishTime [ i ] ) } } func main ( ) { scanner := bufio . NewScanner ( os . Stdin ) scanner . Split ( bufio . ScanWords ) scanner . Scan ( ) n , _ = strconv . Atoi ( scanner . Text ( ) ) for i := 0 ; i < n ; i ++ { for j := 0 ; j < n ; j ++ { Adj [ i ] [ j ] = 0 } } for i := 0 ; i < n ; i ++ { scanner . Scan ( ) u , _ := strconv . Atoi ( scanner . Text ( ) ) scanner . Scan ( ) k , _ := strconv . Atoi ( scanner . Text ( ) ) u - - for j := 0 ; j < k ; j ++ { scanner . Scan ( ) v , _ := strconv . Atoi ( scanner . Text ( ) ) v - - Adj [ u ] [ v ] = 1 } } DFS ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d % d \\n \" , k + 1 , v . discoverTime , v . finishTime ) } } func findStartNode ( childrenMap [ ] [ ] int , timeRecordMap [ ] TimeRecord ) int { x := - 1 for node , timeRecord := range timeRecordMap { if timeRecord . discoverTime < 0 { x = node + 1 break } } return x } func visit ( currentNode int , timer * int , childrenMap [ ] [ ] int , timeRecordMap [ ] TimeRecord ) { if timeRecordMap [ currentNode - 1 ] . discoverTime > 0 { return } children := childrenMap [ currentNode - 1 ] timeRecordMap [ currentNode - 1 ] = TimeRecord { * timer , timeRecordMap [ currentNode - 1 ] . finishTime } ( * timer ) + + for i := 0 ; i < len ( children ) ; i ++ { visit ( children [ i ] , timer , childrenMap , timeRecordMap ) } timeRecordMap [ currentNode - 1 ] = TimeRecord { timeRecordMap [ currentNode - 1 ] . discoverTime , * timer } ( * timer ) + + } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \\n \" , list [ n - 1 ] ) ) ) buf . Flush ( ) } func max ( a , b int ) int { if a > b { return a } else { return b } } func min ( a , b int ) int { if a > b { return b } else { return a } } const MAX = 100 const WHITE = 0 const GRAY = 1 const BLACK = 2 var time , n int var M [ MAX ] [ MAX ] int var color , d , f [ MAX ] int func dfs_visit ( u int ) { color [ u ] = GRAY time + + d [ u ] = time for v := 0 ; v < n ; v ++ { if M [ u ] [ v ] == 0 { continue } if color [ v ] == WHITE { dfs_visit ( v ) } } color [ u ] = BLACK time + + f [ u ] = time } func dfs ( ) { for u := 0 ; u < n ; u ++ { color [ u ] = WHITE } time = 0 for u := 0 ; u < n ; u ++ { if color [ u ] == WHITE { dfs_visit ( u ) } } for u := 0 ; u < n ; u ++ { fmt . Println ( u + 1 , d [ u ] , f [ u ] ) } } func main ( ) { sc . Split ( bufio . ScanWords ) n = nextInt ( ) for i := 0 ; i < n ; i ++ { u , k := nextInt ( ) , nextInt ( ) M [ u - 1 ] [ u - 1 ] = 0 if k > 0 { for j := 0 ; j < k ; j ++ { v := nextInt ( ) M [ u - 1 ] [ v - 1 ] = 1 } } } dfs ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } var infty = 1000000000 type nodeKey int type DirectedGraphNode struct { key nodeKey adjacents [ ] * DirectedGraphNode visited bool d int f int parent * DirectedGraphNode } type DirectedGraph struct { nodes [ ] * DirectedGraphNode } func ( g * DirectedGraph ) setAdjacency ( l , r nodeKey ) { g . nodes [ l ] . adjacents = append ( g . nodes [ l ] . adjacents , g . nodes [ r ] ) } func newDirectedGraph ( nNodes int ) * DirectedGraph { graph := DirectedGraph { } graph . nodes = make ( [ ] * DirectedGraphNode , nNodes ) for iNodes := 0 ; iNodes < nNodes ; iNodes ++ { graph . nodes [ iNodes ] = & DirectedGraphNode { } graph . nodes [ iNodes ] . key = nodeKey ( iNodes ) graph . nodes [ iNodes ] . visited = false graph . nodes [ iNodes ] . d = infty graph . nodes [ iNodes ] . f = infty graph . nodes [ iNodes ] . parent = nil } return & graph } type QueueEntry struct { node * DirectedGraphNode next * QueueEntry } type Queue struct { head , tail * QueueEntry } func ( q * Queue ) enqueue ( node * DirectedGraphNode ) { entry := QueueEntry { } entry . node = node if q . tail == nil { q . head = & entry q . tail = & entry return } q . tail . next = & entry q . tail = q . tail . next } func ( q * Queue ) dequeue ( ) * QueueEntry { if q . head == nil { return nil } poped := q . head q . head = q . head . next if q . head == nil { q . tail = nil } return poped } func ( q * Queue ) isEmpty ( ) bool { return q . head == nil } var time = 0 func fillDistancesByDepthFirstSearch ( g * DirectedGraph ) { for _ , u := range g . nodes [ 1 : ] { if ! u . visited { dfsVisit ( g , u ) } } } func dfsVisit ( g * DirectedGraph , u * DirectedGraphNode ) { time ++ u . d = time u . visited = true for _ , v := range u . adjacents { if ! v . visited { v . parent = u dfsVisit ( g , v ) } } time ++ u . f = time } func main ( ) { scanner . Split ( bufio . ScanWords ) nNodes := nextInt ( ) g := newDirectedGraph ( nNodes + 1 ) for iNode := 0 ; iNode < nNodes ; iNode ++ { nodeKeyLeft := nodeKey ( nextInt ( ) ) nAdj := nextInt ( ) for iAdj := 0 ; iAdj < nAdj ; iAdj ++ { nodeKeyRight := nodeKey ( nextInt ( ) ) g . setAdjacency ( nodeKeyLeft , nodeKeyRight ) } } fillDistancesByDepthFirstSearch ( g ) for iNode := 1 ; iNode <= nNodes ; iNode ++ { node := g . nodes [ iNode ] fmt . Println ( node . key , node . d , node . f ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" MASPY \" \" \" { fp , T HE_HARMONY_OF_PERFECT\")) cn t P Y\") == \" \" { wfp, _ = os. C U S10\")) } scanner := - -- -- -- -- -- -- -- -- -- -\" ) so lv e( sc an ne r , g . o u d [ i",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % v % v % v \\n \" , ( * nodes [ i ] ) . id , ( * nodes [ i ] ) . s , ( * nodes [ i ] ) . e ) } } var time int func walk ( nid int , nodes * map [ int ] * node , s Stack ) { n := ( * nodes ) [ nid ] if n . s != 0 { return } time ++ n . s = time s . Push ( n ) for _ , v := range n . nexts { walk ( v , nodes , s ) } time + + n . e = time } type node struct { id int nexts [ ] int s int e int } type Stack struct { stack [ ] interface { } } func ( stack * Stack ) Push ( val interface { } ) { stack . stack = append ( stack . stack , val ) } func ( stack * Stack ) Pop ( ) interface { } { val := stack . stack [ len ( stack . stack ) - 1 ] stack . stack = stack . stack [ 0 : len ( stack . stack ) - 1 ] return val }",
    "label": 4
  },
  {
    "code": "package main import \" \" type node struct { id , d , v int adj [ ] node } var n int var seen [ ] bool var graph [ ] node func max ( a , b int ) int { if a > b { return a } return b } func dfs ( v , t int ) int { seen [ v ] = true graph [ v ] . v = t tt := t for _ , vv := range graph [ v ] . adj { if ! seen [ vv . id ] { tt = max ( tt , dfs ( vv . id , tt + 1 ) ) } } graph [ v ] . d = tt + 1 return graph [ v ] . d } func main ( ) { fmt . Scan ( & n ) graph = make ( [ ] node , n + 1 ) for i := 1 ; i <= n ; i + + { var u , k , v int fmt . Scan ( & u , & k ) graph [ u ] . id = u for j := 0 ; j < k ; j + + { fmt . Scan ( & v ) var t node t . id = v graph [ u ] . adj = append ( graph [ u ] . adj , t ) } } seen = make ( [ ] bool , n + 1 ) v , t := 1 , 1 done := false for ! done { tt := dfs ( v , t ) done = true for i := range seen { if ! seen [ i ] { done = false v = graph [ i ] . id t = tt break } } } for i := 1 ; i <= n ; i + + { fmt . Printf ( \" % d % d % d \\n \" , i , graph [ i ] . v , graph [ i ] . d ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" % d % d % d \\n \" , u + 1 , d [ u ] , f [ u ] ) } } func main ( ) { n = ReadInt ( ) for i := 0 ; i < n ; i ++ { u , k := ReadInt2 ( ) u - - nodes := ReadIntSlice ( k ) for j := 0 ; j < k ; j ++ { v := nodes [ j ] - 1 M [ u ] [ v ] = 1 } } dfs ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d \" \" \" \" % d % d % d \\n \" , i + 1 , dg . stime [ i ] , dg . ftime [ i ] ) } } func main ( ) { adj := makeAdjList ( ) colors := make ( [ ] int , len ( adj ) ) stime := make ( [ ] int , len ( adj ) ) ftime := make ( [ ] int , len ( adj ) ) graph := dfsGraph { adj , colors , stime , ftime } graph . dfs ( ) graph . printDfsTime ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" % d % d % d \\n \" , u + 1 , d [ u ] , f [ u ] ) } } func nextInt ( scanner * bufio . Scanner ) int { scanner . Scan ( ) num , _ := strconv . Atoi ( scanner . Text ( ) ) return num } func main ( ) { scanner := bufio . NewScanner ( os . Stdin ) scanner . Split ( bufio . ScanWords ) N = nextInt ( scanner ) color = make ( [ ] int , N ) d = make ( [ ] int , N ) f = make ( [ ] int , N ) A = make ( [ ] [ ] int , N ) for i := 0 ; i < N ; i ++ { A [ i ] = make ( [ ] int , N ) } for i := 0 ; i < N ; i ++ { index := nextInt ( scanner ) - 1 cnt := nextInt ( scanner ) for j := 0 ; j < cnt ; j ++ { v := nextInt ( scanner ) - 1 A [ index ] [ v ] = 1 } } dfs ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" % d % d % d \\n \" , i + 1 , g . d [ i ] , g . f [ i ] ) ) } return strings . TrimRight ( out . String ( ) , \" \\n \" ) } func answer ( reader io . Reader ) string { sc := bufio . NewScanner ( reader ) sc . Split ( bufio . ScanWords ) sc . Scan ( ) n , _ := strconv . Atoi ( sc . Text ( ) ) var g Graph for i := 0 ; i < n ; i ++ { sc . Scan ( ) u , _ := strconv . Atoi ( sc . Text ( ) ) sc . Scan ( ) k , _ := strconv . Atoi ( sc . Text ( ) ) u - - for j := 0 ; j < k ; j ++ { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) v - - g . M [ u ] [ v ] = 1 } } return g . dfs ( n ) } func main ( ) { fmt . Println ( answer ( os . Stdin ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d % d \\n \" , i + 1 , d [ i ] , finish [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , i , paths [ i ] - 1 ) } w . Flush ( ) } func scanInt ( sc * bufio . Scanner ) int { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) return v }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , i , paths [ i ] - 1 ) } w . Flush ( ) } func scanInt ( sc * bufio . Scanner ) int { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) return v }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , vertices [ i ] . id , vertices [ i ] . visitedAt ) } } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { return strconv . Atoi ( nextText ( sc ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) g := make ( [ ] [ ] int , n + 1 ) d := make ( [ ] int , n + 1 ) for i := 0 ; i < n ; i ++ { var u , k int fmt . Scan ( & u ) fmt . Scan ( & k ) g [ u ] = make ( [ ] int , k ) for j := 0 ; j < k ; j ++ { fmt . Scan ( & g [ u ] [ j ] ) } d [ i + 1 ] = - 1 } q := [ ] [ ] int { } q = append ( q , [ ] int { 1 , 0 } ) for len ( q ) > 0 { pop := q [ 0 ] if len ( q ) > 1 { q = q [ 1 : ] } else { q = [ ] [ ] int { } } if d [ pop [ 0 ] ] >= 0 { continue } d [ pop [ 0 ] ] = pop [ 1 ] for j := 0 ; j < len ( g [ pop [ 0 ] ] ) ; j ++ { q = append ( q , [ ] int { g [ pop [ 0 ] ] [ j ] , pop [ 1 ] + 1 } ) } } for i := 1 ; i <= n ; i ++ { fmt . Printf ( \" \\n \" , i , d [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" bufio \" \" os \" \" strconv \" \" % d % d \\n \" , i + 1 , d ) } } func main ( ) { var u , k , v int scanner := bufio . NewScanner ( os . Stdin ) scanner . Split ( bufio . ScanWords ) scanner . Scan ( ) n , _ = strconv . Atoi ( scanner . Text ( ) ) for i := 0 ; i < n ; i ++ { for j := 0 ; j < n ; j ++ { adj [ i ] [ j ] = 0 } } for i := 0 ; i < n ; i ++ { scanner . Scan ( ) u , _ = strconv . Atoi ( scanner . Text ( ) ) u -= 1 scanner . Scan ( ) k , _ = strconv . Atoi ( scanner . Text ( ) ) for j := 0 ; j < k ; j ++ { scanner . Scan ( ) v , _ = strconv . Atoi ( scanner . Text ( ) ) v -= 1 adj [ u ] [ v ] = 1 } } BFS ( 0 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , i , dl . get ( i ) ) } } func bfs ( al * AdjacentList , dl * DistanceList ) { stack := [ ] Position { Position { node : 1 , distance : 0 } } for len ( stack ) > 0 { currentPosition := stack [ 0 ] stack = stack [ 1 : ] if ! dl . isVisited ( currentPosition . node ) { dl . set ( currentPosition . node , currentPosition . distance ) } for _ , v := range al . findAdjacentsFor ( currentPosition . node ) { if ! dl . isVisited ( v ) { stack = append ( stack , Position { node : v , distance : currentPosition . distance + 1 } ) } } } } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \\n \" , list [ n - 1 ] ) ) ) buf . Flush ( ) } func max ( a , b int ) int { if a > b { return a } else { return b } } func min ( a , b int ) int { if a > b { return b } else { return a } } const INFTY = ( 1 << 21 ) const MAX = 100 const WHITE = 0 const GRAY = 1 const BLACK = 2 var time , n int var M [ MAX ] [ MAX ] int var color , d [ MAX ] int func bfs ( s int ) { var q [ ] int q = append ( q , s ) for i := 0 ; i < n ; i ++ { d [ i ] = INFTY } d [ s ] = 0 for len ( q ) > 0 { u := q [ 0 ] q = q [ 1 : ] for v := 0 ; v < n ; v ++ { if M [ u ] [ v ] == 0 { continue } if d [ v ] != INFTY { continue } d [ v ] = d [ u ] + 1 q = append ( q , v ) } } for i := 0 ; i < n ; i ++ { fmt . Printf ( \" \" , i + 1 ) if d [ i ] == INFTY { fmt . Printf ( \" \\n \" , - 1 ) } else { fmt . Printf ( \" \\n \" , d [ i ] ) } } } func main ( ) { sc . Split ( bufio . ScanWords ) n = nextInt ( ) for i := 0 ; i < n ; i ++ { u , k := nextInt ( ) , nextInt ( ) M [ u - 1 ] [ u - 1 ] = 0 if k > 0 { for j := 0 ; j < k ; j ++ { v := nextInt ( ) M [ u - 1 ] [ v - 1 ] = 1 } } } bfs ( 0 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func stringifyArray ( arr [ ] int ) string { return strings . TrimRight ( fmt . Sprintf ( \" % + v \" \" ] \" ) } var infty = 1000000000 type nodeKey int type DirectedGraphNode struct { key nodeKey adjacents [ ] * DirectedGraphNode visited bool d int parent * DirectedGraphNode } type DirectedGraph struct { nodes [ ] DirectedGraphNode } func ( g * DirectedGraph ) setAdjacency ( l , r nodeKey ) { g . nodes [ l ] . adjacents = append ( g . nodes [ l ] . adjacents , & g . nodes [ r ] ) } func newDirectedGraph ( nNodes int ) * DirectedGraph { graph := DirectedGraph { } graph . nodes = make ( [ ] DirectedGraphNode , nNodes ) for iNodes := 0 ; iNodes < nNodes ; iNodes + + { graph . nodes [ iNodes ] . key = nodeKey ( iNodes ) graph . nodes [ iNodes ] . visited = false graph . nodes [ iNodes ] . d = infty graph . nodes [ iNodes ] . parent = nil } return & graph } type QueueEntry struct { node * DirectedGraphNode next * QueueEntry } type Queue struct { head , tail * QueueEntry } func ( q * Queue ) enqueue ( node * DirectedGraphNode ) { entry := QueueEntry { } entry . node = node if q . tail == nil { q . head = & entry q . tail = & entry return } q . tail . next = & entry q . tail = q . tail . next } func ( q * Queue ) dequeue ( ) * QueueEntry { if q . head == nil { return nil } poped := q . head q . head = q . head . next if q . head == nil { q . tail = nil } return poped } func ( q * Queue ) isEmpty ( ) bool { return q . head == nil } func fillDistancesByBreadthFirstSearch ( g * DirectedGraph , startNode * DirectedGraphNode ) { startNode . visited = true startNode . d = 0 queue := Queue { } queue . enqueue ( startNode ) for ! queue . isEmpty ( ) { u := queue . dequeue ( ) . node for _ , adjacent := range u . adjacents { if ! adjacent . visited { adjacent . visited = true adjacent . d = u . d + 1 adjacent . parent = u queue . enqueue ( adjacent ) } } u . visited = true } } func main ( ) { scanner . Split ( bufio . ScanWords ) nNodes := nextInt ( ) g := newDirectedGraph ( nNodes + 1 ) for iNode := 0 ; iNode < nNodes ; iNode + + { nodeKeyLeft := nodeKey ( nextInt ( ) ) nAdj := nextInt ( ) for iAdj := 0 ; iAdj < nAdj ; iAdj + + { nodeKeyRight := nodeKey ( nextInt ( ) ) g . setAdjacency ( nodeKeyLeft , nodeKeyRight ) } } fillDistancesByBreadthFirstSearch ( g , & g . nodes [ 1 ] ) for iNode := 1 ; iNode <= nNodes ; iNode + + { node := g . nodes [ iNode ] distance := node . d if distance == infty { distance = - 1 } fmt . Println ( node . key , distance ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % v % v \\n \" , ( * nodes [ i ] ) . id , ( * nodes [ i ] ) . depth ) } } var time int var record [ 100 ] [ 100 ] bool var q Queue func walk ( nid int , from int , nodes * map [ int ] * node ) { q . Enqueue ( ( * nodes ) [ nid ] ) for ! q . IsEmpty ( ) { n := q . Dequeue ( ) . ( * node ) for _ , v := range n . nexts { n2 := ( * nodes ) [ v ] if n2 . depth != - 1 { continue } n2 . depth = n . depth + 1 q . Enqueue ( ( * nodes ) [ v ] ) } } } type node struct { id int nexts [ ] int depth int } type Queue struct { val [ ] interface { } } func ( queue * Queue ) Enqueue ( val interface { } ) { queue . val = append ( queue . val , val ) } func ( queue * Queue ) Dequeue ( ) interface { } { res := queue . val [ 0 ] queue . val = queue . val [ 1 : len ( queue . val ) ] return res } func ( queue * Queue ) IsEmpty ( ) bool { return len ( queue . val ) == 0 }",
    "label": 4
  },
  {
    "code": "package main import \" \" type container struct { data [ ] int } func ( c * container ) queue ( v int ) { c . data = append ( c . data , v ) } func ( c * container ) dequeue ( p * int ) bool { if p == nil || len ( c . data ) == 0 { return false } * p = c . data [ 0 ] c . data = c . data [ 1 : len ( c . data ) ] return true } func main ( ) { var n int fmt . Scan ( & n ) g := make ( [ ] [ ] int , n + 1 ) d := make ( [ ] int , n + 1 ) for i := 1 ; i <= n ; i ++ { d [ i ] = - 1 var u , k , v int fmt . Scan ( & u , & k ) for j := 0 ; j < k ; j ++ { fmt . Scan ( & v ) g [ u ] = append ( g [ u ] , v ) } } var q container d [ 1 ] = 0 q . queue ( 1 ) for len ( q . data ) > 0 { var v int q . dequeue ( & v ) for i := 0 ; i < len ( g [ v ] ) ; i ++ { nv := g [ v ] [ i ] if d [ nv ] == - 1 { q . queue ( nv ) d [ nv ] = d [ v ] + 1 } } } for i := 1 ; i <= n ; i ++ { fmt . Printf ( \" \\n \" , i , d [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" % d \" \" - 1 \\n \" ) } else { fmt . Printf ( \" % d \\n \" , d [ i ] ) } } } func main ( ) { n = ReadInt ( ) for i := 0 ; i < n ; i ++ { u , k := ReadInt2 ( ) u - - nodes := ReadIntSlice ( k ) for j := 0 ; j < k ; j ++ { v := nodes [ j ] - 1 M [ u ] [ v ] = 1 } } bfs ( 0 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d \" \" \" \" % d % d \\n \" , i + 1 , d ) } } func main ( ) { adj := makeAdjList ( ) bfs ( adj , 0 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" container / list \" \" % d % d \\n \" , i + 1 , d [ i ] ) } } func initVariable ( ) { d = make ( [ ] int , MaxNode ) A = make ( [ ] [ ] int , MaxNode ) l = list . New ( ) for i := 0 ; i < MaxNode ; i ++ { A [ i ] = make ( [ ] int , MaxNode ) d [ i ] = - 1 } } func main ( ) { initVariable ( ) scanner := bufio . NewScanner ( os . Stdin ) scanner . Split ( bufio . ScanWords ) N = nextInt ( scanner ) for i := 0 ; i < N ; i ++ { idx := nextInt ( scanner ) cnt := nextInt ( scanner ) for j := 0 ; j < cnt ; j ++ { node := nextInt ( scanner ) A [ idx - 1 ] [ node - 1 ] = 1 } } bfs ( 0 ) print ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" % d - 1 \\n \" , i + 1 ) ) continue } out . WriteString ( fmt . Sprintf ( \" \\n \" , i + 1 , g . d [ i ] ) ) } return strings . TrimRight ( out . String ( ) , \" \\n \" ) } func answer ( reader io . Reader ) string { sc := bufio . NewScanner ( reader ) sc . Split ( bufio . ScanWords ) sc . Scan ( ) n , _ := strconv . Atoi ( sc . Text ( ) ) var g Graph for i := 0 ; i < n ; i ++ { sc . Scan ( ) u , _ := strconv . Atoi ( sc . Text ( ) ) sc . Scan ( ) k , _ := strconv . Atoi ( sc . Text ( ) ) u - - for j := 0 ; j < k ; j ++ { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) v - - g . M [ u ] [ v ] = 1 } } return g . bfs ( 0 , n ) } func main ( ) { fmt . Println ( answer ( os . Stdin ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" os \" \" strconv \" \" fmt \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \\n \" , list [ n - 1 ] ) ) ) buf . Flush ( ) } func max ( a , b int ) int { if a > b { return a } else { return b } } func min ( a , b int ) int { if a > b { return b } else { return a } } const ( MAX = 100000 NIL = - 1 ) var ( n , m , q , s , t int G [ MAX ] [ ] int color [ MAX ] int ) func dfs ( r int , c int ) { S := list . New ( ) S . PushFront ( r ) color [ r ] = c for S . Len ( ) != 0 { u := S . Remove ( S . Front ( ) ) . ( int ) for i := 0 ; i < len ( G [ u ] ) ; i + + { v := G [ u ] [ i ] if color [ v ] == NIL { color [ v ] = c S . PushFront ( v ) } } } } func assignColor ( ) { id := 1 for i := 0 ; i < n ; i + + { color [ i ] = NIL } for i := 0 ; i < n ; i + + { if color [ i ] == NIL { id + + dfs ( i , id ) } } } func main ( ) { sc . Split ( bufio . ScanWords ) n , m = nextInt ( ) , nextInt ( ) for i := 0 ; i < m ; i + + { s , t = nextInt ( ) , nextInt ( ) if i == 0 { G [ s ] = make ( [ ] int , 0 ) G [ t ] = make ( [ ] int , 0 ) } G [ s ] = append ( G [ s ] , t ) G [ t ] = append ( G [ t ] , s ) } assignColor ( ) q = nextInt ( ) for i := 0 ; i < q ; i + + { s , t = nextInt ( ) , nextInt ( ) if color [ s ] == color [ t ] { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func newGraph ( nNodes int ) * Graph { g := Graph { } g . nodes = make ( [ ] * GraphNode , nNodes ) for iNode := 0 ; iNode < len ( g . nodes ) ; iNode ++ { g . nodes [ iNode ] = & GraphNode { } g . nodes [ iNode ] . key = GraphNodeKey ( iNode ) } return & g } var infty = 1000000000 type GraphNodeKey int type GraphNode struct { key GraphNodeKey adjacents [ ] * GraphNode visited bool d , f int parent * GraphNode cc int } func ( g * Graph ) setAdjacent ( l , r GraphNodeKey ) { g . nodes [ l ] . adjacents = append ( g . nodes [ l ] . adjacents , g . nodes [ r ] ) } type Graph struct { nodes [ ] * GraphNode } func ( g * Graph ) initialize ( ) { for iNode := 0 ; iNode < len ( g . nodes ) ; iNode ++ { g . nodes [ iNode ] . visited = false g . nodes [ iNode ] . d = infty g . nodes [ iNode ] . f = infty g . nodes [ iNode ] . parent = nil g . nodes [ iNode ] . cc = - 1 } } type QueueEntry struct { node * GraphNode next * QueueEntry } type Queue struct { head , tail * QueueEntry } func ( q * Queue ) enqueue ( node * GraphNode ) { entry := QueueEntry { } entry . node = node if q . tail == nil { q . head = & entry q . tail = & entry return } q . tail . next = & entry q . tail = q . tail . next } func ( q * Queue ) dequeue ( ) * QueueEntry { if q . head == nil { return nil } poped := q . head q . head = q . head . next if q . head == nil { q . tail = nil } return poped } func ( q * Queue ) isEmpty ( ) bool { return q . head == nil } var time = 0 func fillDistancesByDepthFirstSearch ( g * Graph ) { g . initialize ( ) time = 0 cc := 0 for _ , u := range g . nodes { if ! u . visited { dfsVisit ( g , u , cc ) cc + + } } } func dfsVisit ( g * Graph , u * GraphNode , cc int ) { time ++ u . d = time u . cc = cc u . visited = true for _ , v := range u . adjacents { if ! v . visited { v . parent = u dfsVisit ( g , v , cc ) } } time + + u . f = time } func main ( ) { scanner . Split ( bufio . ScanWords ) nUsers := nextInt ( ) nEdges := nextInt ( ) graph := newGraph ( nUsers ) for iEdge := 0 ; iEdge < nEdges ; iEdge ++ { l := GraphNodeKey ( nextInt ( ) ) r := GraphNodeKey ( nextInt ( ) ) graph . setAdjacent ( l , r ) graph . setAdjacent ( r , l ) } fillDistancesByDepthFirstSearch ( graph ) nQueries := nextInt ( ) for iQuery := 0 ; iQuery < nQueries ; iQuery ++ { l := GraphNodeKey ( nextInt ( ) ) r := GraphNodeKey ( nextInt ( ) ) if graph . nodes [ l ] . cc == graph . nodes [ r ] . cc { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" yes \" ) } else { fmt . Fprintln ( wtr , \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) var n , m int var g [ ] [ ] int var color [ ] int func main ( ) { fmt . Scan ( & n , & m ) g = make ( [ ] [ ] int , n ) for i := 0 ; i < m ; i ++ { var a , b int fmt . Scan ( & a , & b ) g [ a ] = append ( g [ a ] , b ) g [ b ] = append ( g [ b ] , a ) } color = make ( [ ] int , n ) for i := 0 ; i < len ( color ) ; i ++ { color [ i ] = - 1 } type query struct { s , t int } var Q int fmt . Scan ( & Q ) qs := make ( [ ] query , Q ) for i := 0 ; i < Q ; i ++ { fmt . Scan ( & qs [ i ] . s , & qs [ i ] . t ) } id := 1 for u := 0 ; u < n ; u ++ { if color [ u ] == - 1 { dfs ( u , id ) id ++ } } for i := 0 ; i < Q ; i ++ { if color [ qs [ i ] . s ] == color [ qs [ i ] . t ] { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } } func dfs ( v , c int ) { color [ v ] = c for _ , vv := range g [ v ] { if color [ vv ] == - 1 { dfs ( vv , c ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" yes \" \" no \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" container / list \" \" bytes \" \" yes \\n \" ) } else { outBuffer . WriteString ( \" no \\n \" ) } } fmt . Printf ( \" \" , outBuffer . String ( ) ) } func main ( ) { scanner := bufio . NewScanner ( os . Stdin ) scanner . Split ( bufio . ScanWords ) buildGraph ( scanner ) assignColor ( ) answer ( scanner ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" yes \" \" no \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" math \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) type Edge struct { I int J int A int } func main ( ) { var n int fmt . Scan ( & n ) g := make ( [ ] [ ] int , n ) edges := make ( [ ] Edge , 0 , n * ( n - 1 ) / 2 ) parents := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { g [ i ] = make ( [ ] int , n ) for j := 0 ; j < n ; j ++ { fmt . Scan ( & g [ i ] [ j ] ) if g [ i ] [ j ] >= 0 { edges = append ( edges , Edge { i , j , g [ i ] [ j ] } ) } } parents [ i ] = i } sort . SliceStable ( edges , func ( i , j int ) bool { return edges [ i ] . A >= edges [ j ] . A } ) sum := 0 num := 0 for len ( edges ) > 0 && num < n - 1 { edge := edges [ len ( edges ) - 1 ] edges = edges [ : len ( edges ) - 1 ] if same ( edge . I , edge . J , & parents ) { continue } union ( edge . I , edge . J , & parents ) sum + = edge . A num += 1 } fmt . Println ( sum ) } func root ( id int , parents * [ ] int ) int { if id == ( * parents ) [ id ] { return id } return root ( ( * parents ) [ id ] , parents ) } func union ( i , j int , parents * [ ] int ) { ( * parents ) [ root ( j , parents ) ] = ( * parents ) [ root ( i , parents ) ] } func same ( i , j int , parents * [ ] int ) bool { return root ( i , parents ) == root ( j , parents ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \\n \" , list [ n - 1 ] ) ) ) buf . Flush ( ) } func max ( a , b int ) int { if a > b { return a } else { return b } } func min ( a , b int ) int { if a > b { return b } else { return a } } const ( MAX = 100 INFTY = ( 1 << 21 ) WHITE = 0 GRAY = 1 BLACK = 2 ) var ( n int M [ MAX ] [ MAX ] int color [ MAX ] int p [ MAX ] int d [ MAX ] int ) func prim ( ) int { var u , minv int for i := 0 ; i < n ; i + + { d [ i ] = INFTY p [ i ] = - 1 color [ i ] = WHITE } d [ 0 ] = 0 for { minv = INFTY u = - 1 for i := 0 ; i < n ; i + + { if minv > d [ i ] && color [ i ] != BLACK { u = i minv = d [ i ] } } if u == - 1 { break } color [ u ] = BLACK for v := 0 ; v < n ; v + + { if color [ v ] != BLACK && M [ u ] [ v ] != INFTY { if d [ v ] > M [ u ] [ v ] { d [ v ] = M [ u ] [ v ] p [ v ] = u color [ v ] = GRAY } } } } sum := 0 for i := 0 ; i < n ; i + + { if p [ i ] != - 1 { sum + = M [ i ] [ p [ i ] ] } } return sum } func main ( ) { sc . Split ( bufio . ScanWords ) n = nextInt ( ) for i := 0 ; i < n ; i + + { for j := 0 ; j < n ; j + + { tmp := nextInt ( ) if tmp == - 1 { tmp = INFTY } M [ i ] [ j ] = tmp } } fmt . Println ( prim ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } type ElementKey int type Node struct { key ElementKey parent * Node rank int } func newNode ( key ElementKey ) * Node { node := Node { } node . key = key node . parent = & node node . rank = 0 return & node } func union ( x , y * Node ) { xSet := findSet ( x ) ySet := findSet ( y ) link ( xSet , ySet ) } func link ( x , y * Node ) { if x . rank > y . rank { y . parent = x } else { x . parent = y if x . rank == y . rank { y . rank + + } } } func findSet ( x * Node ) * Node { if x != x . parent { x . parent = findSet ( x . parent ) } return x . parent } func newDisjointSets ( nSets int ) * DisjointSets { sets := DisjointSets { } sets . keyToNode = map [ ElementKey ] * Node { } for i := 0 ; i < nSets ; i ++ { key := ElementKey ( i ) sets . keyToNode [ key ] = newNode ( key ) } return & sets } type DisjointSets struct { keyToNode map [ ElementKey ] * Node } func ( sets * DisjointSets ) union ( x , y ElementKey ) { xNode := sets . keyToNode [ x ] yNode := sets . keyToNode [ y ] union ( xNode , yNode ) } func ( sets DisjointSets ) findSet ( x ElementKey ) * Node { xNode := sets . keyToNode [ x ] return findSet ( xNode ) } type Edge struct { i , j int weight int } func main ( ) { scanner . Split ( bufio . ScanWords ) n := nextInt ( ) sets := newDisjointSets ( n ) edges := [ ] Edge { } a := make ( [ ] [ ] int , n ) for i := 0 ; i < n ; i ++ { a [ i ] = make ( [ ] int , n ) for j := 0 ; j < n ; j ++ { a [ i ] [ j ] = nextInt ( ) if a [ i ] [ j ] >= 0 { e := Edge { i : i , j : j , weight : a [ i ] [ j ] , } edges = append ( edges , e ) } } } sort . Slice ( edges , func ( i , j int ) bool { return edges [ i ] . weight < edges [ j ] . weight } ) totalWeight := 0 for _ , edge := range edges { i := ElementKey ( edge . i ) j := ElementKey ( edge . j ) if sets . findSet ( i ) != sets . findSet ( j ) { totalWeight + = edge . weight sets . union ( i , j ) } } fmt . Println ( totalWeight ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" % d \\n \" , prim ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" fmt \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" io \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" % d % d \\n \" , n . id , n . cost ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , v . getEnd ( ) , v . shortest ) } } func ( si ShortestInfo ) getEnd ( ) int { if len ( si . edges ) == 0 { return 0 } else { return si . edges [ len ( si . edges ) - 1 ] . end } } func createAdjacentMatrix ( n int , sc * bufio . Scanner ) ( [ ] [ ] Neighbor , error ) { adjacentMatrix := make ( [ ] [ ] Neighbor , n ) for i := 0 ; i < n ; i ++ { id , err := nextInt ( sc ) if err != nil { return nil , err } adjacentMatrix [ id ] = [ ] Neighbor { } vertexNum , err := nextInt ( sc ) if err != nil { return nil , err } for j := 0 ; j < vertexNum ; j ++ { v , err := nextInt ( sc ) if err != nil { return nil , err } c , err := nextInt ( sc ) if err != nil { return nil , err } adjacentMatrix [ id ] = append ( adjacentMatrix [ id ] , Neighbor { v , c } ) } } return adjacentMatrix , nil } func sssp ( nodeStack [ ] int , shortestList [ ] ShortestInfo , adjacentMatrix [ ] [ ] Neighbor ) { for len ( nodeStack ) > 0 { currentNode := nodeStack [ 0 ] nodeStack = nodeStack [ 1 : ] currentShortest := getShortest ( currentNode , shortestList ) adjacents := findAdjacents ( currentNode , adjacentMatrix ) for i := 0 ; i < len ( adjacents ) ; i ++ { adj := adjacents [ i ] if currentShortest . shortest + adj . weight < getShortest ( adj . end , shortestList ) . shortest { setShortest ( adj . end , adj , currentShortest , shortestList ) nodeStack = append ( nodeStack , adj . end ) } } } } func getShortest ( node int , shortestList [ ] ShortestInfo ) ShortestInfo { return shortestList [ node ] } func setShortest ( node int , edge Edge , currentShortest ShortestInfo , shortestList [ ] ShortestInfo ) { newEdges := make ( [ ] Edge , len ( currentShortest . edges ) + 1 ) for i := 0 ; i < len ( newEdges ) - 1 ; i ++ { newEdges [ i ] = currentShortest . edges [ i ] } newEdges [ len ( newEdges ) - 1 ] = edge shortestInfo := ShortestInfo { edges : newEdges , shortest : currentShortest . shortest + edge . weight } shortestList [ node ] = shortestInfo } func findAdjacents ( currentNode int , adjacentMatrix [ ] [ ] Neighbor ) [ ] Edge { adjacents := adjacentMatrix [ currentNode ] edges := [ ] Edge { } for _ , neighbor := range adjacents { edges = append ( edges , Edge { start : currentNode , end : neighbor . node , weight : neighbor . weight } ) } return edges } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } var infty = 1000000000 type DirectedGraphNodeID int type NodeKey int func newNode ( key NodeKey ) * Node { node := Node { key : key , degree : 0 , mark : false , } node . left = & node node . right = & node return & node } type Node struct { key NodeKey degree int mark bool graphNode * DirectedGraphNode parent * Node left * Node right * Node child * Node } func ( node * Node ) getAllChildlen ( ) [ ] * Node { children := [ ] * Node { } child := node . child if node . child != nil { for { children = append ( children , child ) child = child . right if child == node . child { break } } } return children } func ( node * Node ) insertLeft ( newNode * Node ) { oldLeft := node . left node . left = newNode node . left . right = node newNode . left = oldLeft newNode . left . right = newNode } func ( node * Node ) insertRight ( r * Node ) { oldRight := node . right node . right = r node . right . left = node r . right = oldRight r . right . left = r } func ( node * Node ) reset ( ) { node . degree = 0 node . parent = nil node . child = nil node . left = nil node . right = nil node . mark = false } func ( p * Node ) appendChild ( c * Node ) { if p . child == nil { c . left = c c . right = c p . child = c } else { firstChild := p . child secondChild := p . child . right firstChild . right = c c . left = firstChild c . right = secondChild secondChild . left = c } c . parent = p p . degree + + } func ( p * Node ) deleteChild ( c * Node ) * Node { if c . right == c { p . child = nil } else { oldLeft := c . left oldRight := c . right oldLeft . right = oldRight oldRight . left = oldLeft p . child = c . left } p . degree - - return c } func ( node * Node ) preorderTreeWalk ( ) string { s := fmt . Sprintf ( \" \" , node . key ) c := node . child for c != nil { s + = \" \" + c . preorderTreeWalk ( ) c = c . right if c == node . child { break } } s += \" \" return s } func ( node * Node ) getAllBrothers ( ) [ ] * Node { brothers := [ ] * Node { node } current := node . right for current != node { brothers = append ( brothers , current ) current = current . right } return brothers } func newFibonacciHeap ( ) * FibonacciHeap { heap := FibonacciHeap { } heap . minimum = nil heap . nNodes = 0 return & heap } type FibonacciHeap struct { minimum * Node nNodes int } func ( heap * FibonacciHeap ) insert ( x * Node ) { x . reset ( ) if heap . minimum == nil { heap . minimum = x x . left = x x . right = x } else { heap . minimum . insertLeft ( x ) if x . key < heap . minimum . key { heap . minimum = x } } heap . nNodes + + } func ( heap * FibonacciHeap ) getMinimum ( ) * Node { return heap . minimum } func ( heap * FibonacciHeap ) extractMinimum ( ) * Node { minimum := heap . minimum if minimum != nil { for _ , child := range minimum . getAllChildlen ( ) { heap . appendRootNode ( child ) } minimum . child = nil minimum . right . left = minimum . left minimum . left . right = minimum . right if minimum == minimum . right { heap . minimum = nil } else { heap . minimum = minimum . right heap . consolidate ( ) } heap . nNodes - - } return minimum } func ( heap * FibonacciHeap ) appendRootNode ( node * Node ) { node . parent = nil heap . minimum . insertLeft ( node ) } func ( heap * FibonacciHeap ) consolidate ( ) { maxDegree := int ( math . Ceil ( math . Log2 ( float64 ( heap . nNodes ) ) / math . Log2 ( 1.61803 ) ) ) degrees := make ( [ ] * Node , maxDegree + 1 ) for _ , root := range heap . minimum . getAllBrothers ( ) { x := root d := x . degree for d < len ( degrees ) && degrees [ d ] != nil { y := degrees [ d ] if x . key > y . key { tmp := x x = y y = tmp } heap . linkRootElements ( y , x ) degrees [ d ] = nil d ++ } degrees [ d ] = x } heap . minimum = nil for _ , node := range degrees { if node != nil { if heap . minimum == nil { node . left = node node . right = node heap . minimum = node } else { heap . minimum . insertRight ( node ) if node . key < heap . minimum . key { heap . minimum = node } } } } } func ( heap * FibonacciHeap ) deleteNodeFromRoots ( target * Node ) * Node { if target . parent != nil { panic ( \" \" ) } if target == target . right { heap . minimum = nil } else { target . right . left = target . left target . left . right = target . right target . left = nil target . right = nil } return target } func ( heap * FibonacciHeap ) linkRootElements ( child , parent * Node ) { heap . deleteNodeFromRoots ( child ) parent . appendChild ( child ) child . mark = true } func ( this * FibonacciHeap ) unionWith ( other * FibonacciHeap ) { if this . minimum == nil { this . minimum = other . minimum } else { this . minimum . insertRight ( other . minimum ) if other . minimum != nil && other . minimum . key < this . minimum . key { this . minimum = other . minimum } } this . nNodes + = other . nNodes } func ( heap * FibonacciHeap ) decreaseKey ( target * Node , keyNew NodeKey ) * Node { if keyNew > target . key { panic ( \" \" ) } target . key = keyNew parent := target . parent if parent != nil && target . key < parent . key { heap . cut ( target , parent ) heap . cascadingCut ( parent ) } if target . key < heap . minimum . key { heap . minimum = target } return target } func ( heap * FibonacciHeap ) cut ( c , p * Node ) { p . deleteChild ( c ) heap . appendRootNode ( c ) c . parent = nil c . mark = false } func ( heap * FibonacciHeap ) cascadingCut ( target * Node ) { parent := target . parent if parent != nil { if target . mark { heap . cut ( target , parent ) heap . cascadingCut ( parent ) } else { target . mark = true } } } func ( heap * FibonacciHeap ) delete ( target * Node ) * Node { heap . decreaseKey ( target , NodeKey ( - infty ) ) deletedElement := heap . extractMinimum ( ) return deletedElement } func ( heap * FibonacciHeap ) print ( ) { root := heap . minimum if root == nil { return } for { fmt . Print ( root . key , \" \" , root . preorderTreeWalk ( ) , \" \\n \" ) root = root . right if root == heap . minimum { break } } } type DirectedGraphNode struct { key DirectedGraphNodeID heapNode * Node adjacents [ ] * DirectedGraphNode costs [ ] int distance int predecessor * DirectedGraphNode } func newDirectedGraph ( nNodes int ) * DirectedGraph { graph := DirectedGraph { } graph . nodes = make ( [ ] * DirectedGraphNode , nNodes ) for i := 0 ; i < nNodes ; i + + { node := DirectedGraphNode { } node . key = DirectedGraphNodeID ( i ) node . distance = infty graph . nodes [ i ] = & node } return & graph } type DirectedGraph struct { nodes [ ] * DirectedGraphNode } func ( g * DirectedGraph ) setAdjacency ( i , j DirectedGraphNodeID , cost int ) { g . nodes [ i ] . adjacents = append ( g . nodes [ i ] . adjacents , g . nodes [ j ] ) g . nodes [ i ] . costs = append ( g . nodes [ i ] . costs , cost ) } func ( g * DirectedGraph ) print ( ) { for i := 0 ; i < len ( g . nodes ) ; i + + { node := g . nodes [ i ] key := node . key strings := [ ] string { strconv . Itoa ( int ( key ) ) , strconv . Itoa ( node . distance ) } for j := 0 ; j < len ( node . adjacents ) ; j + + { nodeJ := fmt . Sprintf ( \" ( % v , % v ) \" , node . adjacents [ j ] . key , node . costs [ j ] ) strings = append ( strings , nodeJ ) } fmt . Printf ( \" % v \\n \" , strings ) } } func ( g * DirectedGraph ) relaxEdge ( l , r * DirectedGraphNode , w int ) { if r . distance > l . distance + w { r . distance = l . distance + w r . predecessor = l } } func main ( ) { scanner . Split ( bufio . ScanWords ) nNodes := nextInt ( ) graph := newDirectedGraph ( nNodes ) for i := 0 ; i < nNodes ; i + + { iNode := DirectedGraphNodeID ( nextInt ( ) ) nAdjacent := nextInt ( ) for j := 0 ; j < nAdjacent ; j + + { jNode := DirectedGraphNodeID ( nextInt ( ) ) cost := nextInt ( ) graph . setAdjacency ( iNode , jNode , cost ) } } graph . nodes [ 0 ] . distance = 0 heap := newFibonacciHeap ( ) for _ , graphNode := range graph . nodes { heapNode := newNode ( NodeKey ( infty ) ) heapNode . graphNode = graphNode graphNode . heapNode = heapNode heap . insert ( heapNode ) } graph . nodes [ 0 ] . heapNode . key = NodeKey ( 0 ) for heap . nNodes > 0 { nodeLeft := heap . extractMinimum ( ) . graphNode for iAdjacent := 0 ; iAdjacent < len ( nodeLeft . adjacents ) ; iAdjacent + + { nodeRight := nodeLeft . adjacents [ iAdjacent ] cost := nodeLeft . costs [ iAdjacent ] if nodeLeft . distance + cost < nodeRight . distance { heap . decreaseKey ( nodeRight . heapNode , NodeKey ( nodeLeft . distance + cost ) ) graph . relaxEdge ( nodeLeft , nodeRight , cost ) } } } for iNode := 0 ; iNode < len ( graph . nodes ) ; iNode + + { node := graph . nodes [ iNode ] fmt . Println ( node . key , node . distance ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" % v % v \\n \" , i , v ) } } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) sc . Scan ( ) n , _ = strconv . Atoi ( sc . Text ( ) ) for i := 0 ; i < n ; i ++ { sc . Scan ( ) u , _ := strconv . Atoi ( sc . Text ( ) ) sc . Scan ( ) k , _ := strconv . Atoi ( sc . Text ( ) ) for j := 0 ; j < k ; j ++ { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) sc . Scan ( ) c , _ := strconv . Atoi ( sc . Text ( ) ) adj [ u ] = append ( adj [ u ] , pair { v , c } ) } } dijkstra ( ) } type PriorityQueue [ ] pair func ( h PriorityQueue ) Len ( ) int { return len ( h ) } func ( h PriorityQueue ) Less ( i , j int ) bool { return h [ i ] . v1 < h [ j ] . v1 } func ( h PriorityQueue ) Swap ( i , j int ) { h [ i ] , h [ j ] = h [ j ] , h [ i ] } func ( h * PriorityQueue ) Push ( x interface { } ) { * h = append ( * h , x . ( pair ) ) } func ( h * PriorityQueue ) Pop ( ) interface { } { old := * h n := len ( old ) x := old [ n - 1 ] * h = old [ 0 : n - 1 ] return x }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strings \" \" strconv \" \" % d \" \" \" \" % d % d \\n \" , i , result [ i ] ) ; } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , i , v ) } } func main ( ) { g := constructgraph ( ) d := g . dijkstra ( 0 ) printShortestPath ( d ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" container / heap \" \" \" \" \\n \" ) } wr . Flush ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d % d \\n \" , i , cost ) } w . Flush ( ) } func scanInt ( sc * bufio . Scanner ) int { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) return v } type Heap struct { size int heap [ ] Path isHigh func ( a , b Path ) bool } func NewHeap ( isHigh func ( a , b Path ) bool ) Heap { heap := make ( [ ] Path , 1 ) return Heap { size : 0 , heap : heap , isHigh : isHigh } } func ( h * Heap ) insert ( v Path ) { h . size += 1 if h . size > len ( h . heap ) - 1 { h . heap = append ( h . heap , v ) } else { h . heap [ h . size ] = v } for i := h . size ; i > 1 ; { parent := i / 2 if h . isHigh ( h . heap [ parent ] , h . heap [ i ] ) { break } h . heap [ i ] , h . heap [ parent ] = h . heap [ parent ] , h . heap [ i ] i = parent } } func ( h * Heap ) extractMax ( ) Path { if h . size <= 0 { panic ( \" cannot extract from empty heap \" ) } max := h . heap [ 1 ] h . heap [ 1 ] = h . heap [ h . size ] h . size -= 1 h . maxHeapify ( 1 ) return max } func ( h * Heap ) maxHeapify ( idx int ) { left := idx * 2 right := left + 1 largest := idx if left <= h . size { if h . isHigh ( h . heap [ left ] , h . heap [ idx ] ) { largest = left } if right <= h . size && h . isHigh ( h . heap [ right ] , h . heap [ largest ] ) { largest = right } } if largest != idx { h . heap [ idx ] , h . heap [ largest ] = h . heap [ largest ] , h . heap [ idx ] h . maxHeapify ( largest ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" not found 0 \" ) } func up ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos > 2 { in [ pos ] , in [ pos - 3 ] = in [ pos - 3 ] , in [ pos ] } else { return false , in } return true , in } func down ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos < 6 { in [ pos ] , in [ pos + 3 ] = in [ pos + 3 ] , in [ pos ] } else { return false , in } return true , in } func left ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 0 && pos != 3 && pos != 6 { in [ pos ] , in [ pos - 1 ] = in [ pos - 1 ] , in [ pos ] } else { return false , in } return true , in } func right ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 2 && pos != 5 && pos != 8 { in [ pos ] , in [ pos + 1 ] = in [ pos + 1 ] , in [ pos ] } else { return false , in } return true , in } func next ( ) int { sc . Scan ( ) i , _ := strconv . Atoi ( sc . Text ( ) ) return i } var goal = [ 9 ] byte { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 } func pp ( s [ 9 ] byte ) { for i := 0 ; i < 3 ; i ++ { fmt . Printf ( \" \\n \" , s [ 0 + 3 * i ] , s [ 1 + 3 * i ] , s [ 2 + 3 * i ] ) } fmt . Println ( \" \" ) } type item struct { d * [ 9 ] byte c int } var queue = [ ] item { } var closed = map [ [ 9 ] byte ] bool { } func bfs ( cost int ) int { for { top := queue [ 0 ] queue = queue [ 1 : ] if * top . d == goal { return top . c } closed [ * top . d ] = true ok , ur := up ( * top . d ) ok2 , _ := closed [ ur ] if ok && ! ok2 { queue = append ( queue , item { & ur , top . c + 1 } ) } ok , dr := down ( * top . d ) ok2 , _ = closed [ dr ] if ok && ! ok2 { queue = append ( queue , item { & dr , top . c + 1 } ) } ok , lr := left ( * top . d ) ok2 , _ = closed [ lr ] if ok && ! ok2 { queue = append ( queue , item { & lr , top . c + 1 } ) } ok , rr := right ( * top . d ) ok2 , _ = closed [ rr ] if ok && ! ok2 { queue = append ( queue , item { & rr , top . c + 1 } ) } } } func main ( ) { sc . Split ( bufio . ScanWords ) var state [ 9 ] byte for i := 0 ; i < 9 ; i ++ { state [ i ] = byte ( next ( ) ) } queue = append ( queue , item { & state , 0 } ) cost := bfs ( 0 ) fmt . Println ( cost ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" not found 0 \" ) } func up ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos > 2 { in [ pos ] , in [ pos - 3 ] = in [ pos - 3 ] , in [ pos ] } else { return false , in } return true , in } func down ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos < 6 { in [ pos ] , in [ pos + 3 ] = in [ pos + 3 ] , in [ pos ] } else { return false , in } return true , in } func left ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 0 && pos != 3 && pos != 6 { in [ pos ] , in [ pos - 1 ] = in [ pos - 1 ] , in [ pos ] } else { return false , in } return true , in } func right ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 2 && pos != 5 && pos != 8 { in [ pos ] , in [ pos + 1 ] = in [ pos + 1 ] , in [ pos ] } else { return false , in } return true , in } func next ( ) int { sc . Scan ( ) i , _ := strconv . Atoi ( sc . Text ( ) ) return i } var goal = [ 9 ] byte { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 } func pp ( s [ 9 ] byte ) { for i := 0 ; i < 3 ; i ++ { fmt . Printf ( \" \\n \" , s [ 0 + 3 * i ] , s [ 1 + 3 * i ] , s [ 2 + 3 * i ] ) } fmt . Println ( \" \" ) } type item struct { d * [ 9 ] byte c int } var queue = [ ] item { } var closed = map [ [ 9 ] byte ] bool { } func bfs ( cost int ) int { for { top := queue [ 0 ] queue = queue [ 1 : ] if * top . d == goal { return top . c } closed [ * top . d ] = true ok , ur := up ( * top . d ) ok2 , _ := closed [ ur ] if ok && ! ok2 { queue = append ( queue , item { & ur , top . c + 1 } ) } ok , dr := down ( * top . d ) ok2 , _ = closed [ dr ] if ok && ! ok2 { queue = append ( queue , item { & dr , top . c + 1 } ) } ok , lr := left ( * top . d ) ok2 , _ = closed [ lr ] if ok && ! ok2 { queue = append ( queue , item { & lr , top . c + 1 } ) } ok , rr := right ( * top . d ) ok2 , _ = closed [ rr ] if ok && ! ok2 { queue = append ( queue , item { & rr , top . c + 1 } ) } } } func main ( ) { sc . Split ( bufio . ScanWords ) var state [ 9 ] byte for i := 0 ; i < 9 ; i ++ { state [ i ] = byte ( next ( ) ) } queue = append ( queue , item { & state , 0 } ) cost := bfs ( 0 ) fmt . Println ( cost ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" not found 0 \" ) } func up ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos > 2 { in [ pos ] , in [ pos - 3 ] = in [ pos - 3 ] , in [ pos ] } else { return false , in } return true , in } func down ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos < 6 { in [ pos ] , in [ pos + 3 ] = in [ pos + 3 ] , in [ pos ] } else { return false , in } return true , in } func left ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 0 && pos != 3 && pos != 6 { in [ pos ] , in [ pos - 1 ] = in [ pos - 1 ] , in [ pos ] } else { return false , in } return true , in } func right ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 2 && pos != 5 && pos != 8 { in [ pos ] , in [ pos + 1 ] = in [ pos + 1 ] , in [ pos ] } else { return false , in } return true , in } func next ( ) int { sc . Scan ( ) i , _ := strconv . Atoi ( sc . Text ( ) ) return i } var goal = [ 9 ] byte { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 } type item struct { d * [ 9 ] byte c int } var queue = [ ] item { } var closed = map [ [ 9 ] byte ] bool { } func bfs ( ) int { for { top := queue [ 0 ] queue = queue [ 1 : ] if * top . d == goal { return top . c } closed [ * top . d ] = true ok , ur := up ( * top . d ) ok2 , _ := closed [ ur ] if ok && ! ok2 { queue = append ( queue , item { & ur , top . c + 1 } ) } ok , dr := down ( * top . d ) ok2 , _ = closed [ dr ] if ok && ! ok2 { queue = append ( queue , item { & dr , top . c + 1 } ) } ok , lr := left ( * top . d ) ok2 , _ = closed [ lr ] if ok && ! ok2 { queue = append ( queue , item { & lr , top . c + 1 } ) } ok , rr := right ( * top . d ) ok2 , _ = closed [ rr ] if ok && ! ok2 { queue = append ( queue , item { & rr , top . c + 1 } ) } } } func main ( ) { sc . Split ( bufio . ScanWords ) var state [ 9 ] byte for i := 0 ; i < 9 ; i ++ { state [ i ] = byte ( next ( ) ) } queue = append ( queue , item { & state , 0 } ) cost := bfs ( ) fmt . Println ( cost ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" emptyPostion must not be empty \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" emptyPostion must not be empty \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } type Puzzle struct { numbers [ ] int iZero int pathHistory string } func ( p Puzzle ) toString ( ) string { s := \" \" for i := 0 ; i < len ( p . numbers ) ; i ++ { s += strconv . Itoa ( p . numbers [ i ] ) } return s } func newPuzzle ( size int ) Puzzle { puzzle := Puzzle { } puzzle . numbers = make ( [ ] int , size ) return puzzle } func ( p * Puzzle ) isSolved ( ) bool { for i := 0 ; i <= 7 ; i ++ { if p . numbers [ i ] != i + 1 { return false } } return true } func ( p * Puzzle ) swap ( i , j int ) { p . numbers [ i ] , p . numbers [ j ] = p . numbers [ j ] , p . numbers [ i ] } func copy ( p1 , p2 * Puzzle ) { p1 . numbers = append ( [ ] int { } , p2 . numbers ... ) p1 . iZero = p2 . iZero p1 . pathHistory = p2 . pathHistory } var d = [ ] int { 1 , - 3 , - 1 , 3 } func newQueue ( ) Queue { queue := Queue { } queue . array = [ ] Puzzle { } return queue } type Queue struct { array [ ] Puzzle } func ( q * Queue ) push ( p Puzzle ) { q . array = append ( q . array , p ) } func ( q * Queue ) pop ( ) Puzzle { p := q . array [ 0 ] q . array = q . array [ 1 : len ( q . array ) ] return p } func ( q * Queue ) isEmpty ( ) bool { return len ( q . array ) == 0 } func bfs ( start Puzzle ) string { queue := newQueue ( ) queue . push ( start ) history := map [ string ] bool { } history [ start . toString ( ) ] = true for ! queue . isEmpty ( ) { u := queue . pop ( ) if u . isSolved ( ) { return u . pathHistory } for i := 0 ; i < 4 ; i ++ { di := d [ i ] iZeroOld := u . iZero iZeroNew := u . iZero + di if iZeroNew < 0 || iZeroNew >= 9 || ( di == - 1 && iZeroOld % 3 == 0 ) || ( di == 1 && iZeroOld % 3 == 2 ) { continue } v := Puzzle { } copy ( & v , & u ) v . swap ( iZeroOld , iZeroNew ) if ! history [ v . toString ( ) ] { history [ v . toString ( ) ] = true v . iZero = iZeroNew v . pathHistory + = strconv . Itoa ( iZeroOld ) queue . push ( v ) } } } return \" \" } func main ( ) { scanner . Split ( bufio . ScanWords ) puzzle := newPuzzle ( 9 ) for j := 0 ; j < 9 ; j ++ { puzzle . numbers [ j ] = nextInt ( ) if puzzle . numbers [ j ] == 0 { puzzle . iZero = j } } nUpdates := bfs ( puzzle ) fmt . Println ( len ( nUpdates ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) type Board = [ 9 ] int type Puzzle struct { Brd Board Zero int Moved int } var FINISH_STATE Board = Board { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 } func ( this * Puzzle ) IsDone ( ) bool { return this . Brd == FINISH_STATE } func FindZero ( board * Board ) int { for i , v := range board { if v == 0 { return i } } fmt . Println ( \" \" ) return - 1 } func ( this * Puzzle ) CanUp ( ) bool { return 2 < this . Zero } func ( this * Puzzle ) CanDown ( ) bool { return this . Zero < 6 } func ( this * Puzzle ) CanLeft ( ) bool { return this . Zero % 3 != 0 } func ( this * Puzzle ) CanRight ( ) bool { return this . Zero % 3 != 2 } func ( this * Puzzle ) Up ( ) Puzzle { return Puzzle { Move ( this . Brd , this . Zero , - 3 ) , this . Zero - 3 , this . Moved + 1 } } func ( this * Puzzle ) Down ( ) Puzzle { return Puzzle { Move ( this . Brd , this . Zero , + 3 ) , this . Zero + 3 , this . Moved + 1 } } func ( this * Puzzle ) Left ( ) Puzzle { return Puzzle { Move ( this . Brd , this . Zero , - 1 ) , this . Zero - 1 , this . Moved + 1 } } func ( this * Puzzle ) Right ( ) Puzzle { return Puzzle { Move ( this . Brd , this . Zero , 1 ) , this . Zero + 1 , this . Moved + 1 } } func Move ( board Board , zero int , direction int ) Board { board [ zero ] , board [ zero + direction ] = board [ zero + direction ] , board [ zero ] return board } type Memo struct { Data map [ int ] [ ] Board } func NewMemo ( ) Memo { return Memo { make ( map [ int ] [ ] Board ) } } func ( m * Memo ) Add ( board Board ) { index := board [ 0 ] * 10000 + board [ 1 ] * 1000 + board [ 2 ] * 100 + board [ 3 ] * 10 + board [ 4 ] * 1 m . Data [ index ] = append ( m . Data [ index ] , board ) } func ( m * Memo ) HasTried ( board * Board ) bool { index := board [ 0 ] * 10000 + board [ 1 ] * 1000 + board [ 2 ] * 100 + board [ 3 ] * 10 + board [ 4 ] * 1 for _ , state := range m . Data [ index ] { if state == * board { return true } } return false } func Solve ( board Board ) int { queue := make ( [ ] Puzzle , 0 ) pzl := Puzzle { board , FindZero ( & board ) , 0 } queue = append ( queue , pzl ) memo := NewMemo ( ) count := 0 for len ( queue ) != 0 { count + + e := queue [ 0 ] queue = queue [ 1 : ] if e . IsDone ( ) { return e . Moved } else { memo . Add ( e . Brd ) } if e . CanUp ( ) { newPzl := e . Up ( ) if ! memo . HasTried ( & newPzl . Brd ) { queue = append ( queue , newPzl ) } } if e . CanDown ( ) { newPzl := e . Down ( ) if ! memo . HasTried ( & newPzl . Brd ) { queue = append ( queue , newPzl ) } } if e . CanLeft ( ) { newPzl := e . Left ( ) if ! memo . HasTried ( & newPzl . Brd ) { queue = append ( queue , newPzl ) } } if e . CanRight ( ) { newPzl := e . Right ( ) if ! memo . HasTried ( & newPzl . Brd ) { queue = append ( queue , newPzl ) } } } return - 1 } func main ( ) { var board Board for i := 0 ; i < 9 ; i ++ { var v int fmt . Scanf ( \" \" , & v ) board [ i ] = v } result := Solve ( board ) fmt . Println ( result ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" 123456780 \" { ans = p . c break } for i : = 0 ; i < 9 ; i + + { if p . path [ i ] == '0' { if i - 3 >= 0 { ap : = swap ( p . path , i , i - 3 ) if _ , ok := visited [ ap ] ; ok == false { q = append ( q , Pair { path : ap , c : p . c + 1 , } ) visited [ ap ] = 1 } } if i + 3 < 9 { ap := swap ( p . path , i , i + 3 ) if _ , ok := visited [ ap ] ; ok == false { q = append ( q , Pair { path : ap , c : p . c + 1 , } ) visited [ ap ] = 1 } } if i % 3 != 0 { ap := swap ( p . path , i , i - 1 ) if _ , ok := visited [ ap ] ; ok == false { q = append ( q , Pair { path : ap , c : p . c + 1 , } ) visited [ ap ] = 1 } } if i % 3 != 2 { ap := swap ( p . path , i , i + 1 ) if _ , ok := visited [ ap ] ; ok == false { q = append ( q , Pair { path : ap , c : p . c + 1 , } ) visited [ ap ] = 1 } } break } } } fmt . Fprintln ( writer , ans ) writer . Flush ( ) } type Pair struct { path string c int } func swap ( s string , i , j int ) string { sp := strings . Split ( s , \" \" ) sp [ i ] , sp [ j ] = sp [ j ] , sp [ i ] return strings . Join ( sp , \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) type State struct { Puzzle [ ] int Zero int Prev int Turn int Dis int Cost int } type PriorityQueue [ ] * State func ( pq PriorityQueue ) Len ( ) int { return len ( pq ) } func ( pq PriorityQueue ) Less ( i , j int ) bool { return pq [ i ] . Cost < pq [ j ] . Cost } func ( pq PriorityQueue ) Swap ( i , j int ) { pq [ i ] , pq [ j ] = pq [ j ] , pq [ i ] } func ( pq * PriorityQueue ) Push ( x interface { } ) { * pq = append ( * pq , x . ( * State ) ) } func ( pq * PriorityQueue ) Pop ( ) interface { } { n := len ( * pq ) pop := ( * pq ) [ n - 1 ] * pq = ( * pq ) [ 0 : n - 1 ] return pop } func main ( ) { n := 9 puzzle := make ( [ ] int , n ) var zero int for i := 0 ; i < n ; i ++ { fmt . Scan ( & puzzle [ i ] ) if puzzle [ i ] == 0 { puzzle [ i ] = n zero = i } } turn := 0 dis := dist ( & puzzle ) if dis == 0 { fmt . Println ( turn ) return } que := PriorityQueue { & State { puzzle , zero , - 1 , turn , dis , turn + dis } } heap . Init ( & que ) dir := [ ] int { - 3 , - 1 , 1 , 3 } for que . Len ( ) > 0 { pop := heap . Pop ( & que ) . ( * State ) for i := 0 ; i < len ( dir ) ; i ++ { next := ( * pop ) . Zero + dir [ i ] if next == ( * pop ) . Prev { continue } if next < 0 || n <= next { continue } if ( next % 3 - ( * pop ) . Zero % 3 ) * dir [ i ] < 0 { continue } p := make ( [ ] int , n ) copy ( p , ( * pop ) . Puzzle ) p [ next ] , p [ ( * pop ) . Zero ] = p [ ( * pop ) . Zero ] , p [ next ] turn = ( * pop ) . Turn + 1 dis = dist ( & p ) if dis == 0 { fmt . Println ( turn ) return } heap . Push ( & que , & State { p , next , ( * pop ) . Zero , turn , dis , turn + dis } ) } } } func dist ( p * [ ] int ) int { sum := 0 n := len ( * p ) for i := 0 ; i < n ; i ++ { v := ( * p ) [ i ] - 1 sum += abs ( v / 3 - i / 3 ) sum += abs ( v % 3 - i % 3 ) } return sum / 2 } func abs ( x int ) int { if x < 0 { return - x } return x }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" % d % d % d \\n \" , & sState [ i ] [ 0 ] , & sState [ i ] [ 1 ] , & sState [ i ] [ 2 ] ) } getPoint ( ) j := getHeuristic ( sState ) i := - 1 for ans = j ; ; ans ++ { if solve ( sState , blank_row , blank_column , 0 , i , j ) { break } } for k := 0 ; k < ans ; k ++ { move ( sState , movesHistory [ k ] ) } fmt . Fprintln ( out , STEP_SUM ) out . Flush ( ) } func getPoint ( ) { for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { if sState [ i ] [ j ] == 0 { blank_row = i ; blank_column = j ; break ; } } } for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { targetPoints [ tState [ i ] [ j ] ] [ 0 ] = i ; targetPoints [ tState [ i ] [ j ] ] [ 1 ] = j ; } } } func getHeuristic ( state [ ] [ ] int ) int { heuristic := 0 ; for i := 0 ; i < len ( state ) ; i ++ { for j := 0 ; j < len ( state [ i ] ) ; j ++ { if state [ i ] [ j ] != 0 { heuristic = heuristic + int ( math . Abs ( float64 ( targetPoints [ state [ i ] [ j ] ] [ 0 ] - i ) ) + math . Abs ( float64 ( targetPoints [ state [ i ] [ j ] ] [ 1 ] - j ) ) ) } } } return heuristic ; } func solve ( state [ ] [ ] int , blank_row , blank_column , dep , d , h int ) bool { isSolved := true for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { if state [ i ] [ j ] != tState [ i ] [ j ] { isSolved = false } } } if isSolved { return true } if dep == ans { return false } blank_row1 := blank_row blank_column1 := blank_column state2 := make ( [ ] [ ] int , size ) for i , _ := range state2 { state2 [ i ] = make ( [ ] int , size ) } for direction := 0 ; direction < 4 ; direction ++ { for i := 0 ; i < len ( state ) ; i ++ { for j := 0 ; j < len ( state ) ; j ++ { state2 [ i ] [ j ] = state [ i ] [ j ] } } if direction != d && ( d % 2 == direction % 2 ) { continue } if direction == UP { blank_row1 = blank_row + up [ 0 ] blank_column1 = blank_column + up [ 1 ] } else if direction == DOWN { blank_row1 = blank_row + down [ 0 ] blank_column1 = blank_column + down [ 1 ] } else if direction == LEFT { blank_row1 = blank_row + left [ 0 ] blank_column1 = blank_column + left [ 1 ] } else { blank_row1 = blank_row + right [ 0 ] blank_column1 = blank_column + right [ 1 ] } if blank_column1 < 0 || blank_column1 == size || blank_row1 < 0 || blank_row1 == size { continue } state2 [ blank_row ] [ blank_column ] = state2 [ blank_row1 ] [ blank_column1 ] state2 [ blank_row1 ] [ blank_column1 ] = 0 var h1 int if direction == DOWN && blank_row1 > targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 0 ] { h1 = h - 1 } else if direction == UP && blank_row1 < targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 0 ] { h1 = h - 1 } else if direction == RIGHT && blank_column1 > targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 1 ] { h1 = h - 1 } else if direction == LEFT && blank_column1 < targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 1 ] { h1 = h - 1 } else { h1 = h + 1 } if h1 + dep + 1 > ans { continue } movesHistory [ dep ] = direction if solve ( state2 , blank_row1 , blank_column1 , dep + 1 , direction , h1 ) { return true } } return false } func move ( state [ ] [ ] int , direction int ) { row := 0 column := 0 for i := 0 ; i < len ( state ) ; i ++ { for j := 0 ; j < len ( state ) ; j ++ { if state [ i ] [ j ] == 0 { row = i column = j } } } switch direction { case UP : state [ row ] [ column ] = state [ row - 1 ] [ column ] state [ row - 1 ] [ column ] = 0 break case DOWN : state [ row ] [ column ] = state [ row + 1 ] [ column ] state [ row + 1 ] [ column ] = 0 break case LEFT : state [ row ] [ column ] = state [ row ] [ column - 1 ] state [ row ] [ column - 1 ] = 0 break case RIGHT : state [ row ] [ column ] = state [ row ] [ column + 1 ] state [ row ] [ column + 1 ] = 0 break } STEP_SUM ++ }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" not found 0 \" ) } func Up ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos > 2 { in [ pos ] , in [ pos - 3 ] = in [ pos - 3 ] , in [ pos ] } else { return false , in } return true , in } func Down ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos < 6 { in [ pos ] , in [ pos + 3 ] = in [ pos + 3 ] , in [ pos ] } else { return false , in } return true , in } func Left ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 0 && pos != 3 && pos != 6 { in [ pos ] , in [ pos - 1 ] = in [ pos - 1 ] , in [ pos ] } else { return false , in } return true , in } func Right ( in [ 9 ] byte ) ( bool , [ 9 ] byte ) { pos := search ( in ) if pos != 2 && pos != 5 && pos != 8 { in [ pos ] , in [ pos + 1 ] = in [ pos + 1 ] , in [ pos ] } else { return false , in } return true , in } func nextInt ( ) int { sc . Scan ( ) i , _ := strconv . Atoi ( sc . Text ( ) ) return i } var goal = [ 9 ] byte { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 } type item struct { d * [ 9 ] byte c int } var queue = [ ] item { } var closed = map [ [ 9 ] byte ] bool { } func bfs ( cost int ) int { for { top := queue [ 0 ] queue = queue [ 1 : ] if * top . d == goal { return top . c } closed [ * top . d ] = true ok , ur := Up ( * top . d ) ok2 , _ := closed [ ur ] if ok && ! ok2 { queue = append ( queue , item { & ur , top . c + 1 } ) } ok , dr := Down ( * top . d ) ok2 , _ = closed [ dr ] if ok && ! ok2 { queue = append ( queue , item { & dr , top . c + 1 } ) } ok , lr := Left ( * top . d ) ok2 , _ = closed [ lr ] if ok && ! ok2 { queue = append ( queue , item { & lr , top . c + 1 } ) } ok , rr := Right ( * top . d ) ok2 , _ = closed [ rr ] if ok && ! ok2 { queue = append ( queue , item { & rr , top . c + 1 } ) } } } func main ( ) { sc . Split ( bufio . ScanWords ) var state [ 9 ] byte for i := 0 ; i < 9 ; i ++ { state [ i ] = byte ( nextInt ( ) ) } queue = append ( queue , item { & state , 0 } ) cost := bfs ( 0 ) fmt . Println ( cost ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" bufio \" \" os \" \" % d % d % d % d \\n \" , & t [ i ] [ 0 ] , & t [ i ] [ 1 ] , & t [ i ] [ 2 ] , & t [ i ] [ 3 ] ) } for i := 0 ; i < N ; i ++ { for j := 0 ; j < N ; j ++ { if t [ i ] [ j ] == 0 { py = i ; px = j ; } } } Solve ( py , px ) ; } func getH ( ) ( int ) { sum , x , i , j := 0 , 0 , 0 , 0 for i = 0 ; i < N ; i ++ { for j = 0 ; j < N ; j ++ { if t [ i ] [ j ] == 0 { continue } x = t [ i ] [ j ] - 1 sum += int ( math . Abs ( float64 ( int ( x / N ) - i ) ) + math . Abs ( float64 ( int ( x % N ) - j ) ) ) } } return sum } func dfs ( depth int , prev int , py int , px int ) ( bool ) { h := getH ( ) ; if h + depth > limit { return false } if h == 0 { return true } for i := 0 ; i < N ; i ++ { if int ( math . Abs ( float64 ( i - prev ) ) ) == 2 { continue } ty , tx := py + dy [ i ] , px + dx [ i ] if ty < 0 || tx < 0 || ty >= N || tx >= N { continue } t [ ty ] [ tx ] , t [ py ] [ px ] = t [ py ] [ px ] , t [ ty ] [ tx ] if dfs ( depth + 1 , i , ty , tx ) { return true } t [ ty ] [ tx ] , t [ py ] [ px ] = t [ py ] [ px ] , t [ ty ] [ tx ] } return false } func Solve ( py int , px int ) { for limit = 0 ; ; limit ++ { if dfs ( 0 , 99 , py , px ) { fmt . Println ( limit ) return } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" % d % d % d % d \\n \" , & sState [ i ] [ 0 ] , & sState [ i ] [ 1 ] , & sState [ i ] [ 2 ] , & sState [ i ] [ 3 ] ) } getPoint ( ) j := getHeuristic ( sState ) i := - 1 for ans = j ; ; ans ++ { if solve ( sState , blank_row , blank_column , 0 , i , j ) { break } } for k := 0 ; k < ans ; k ++ { move ( sState , movesHistory [ k ] ) } fmt . Fprintln ( out , STEP_SUM ) out . Flush ( ) } func getPoint ( ) { for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { if sState [ i ] [ j ] == 0 { blank_row = i ; blank_column = j ; break ; } } } for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { targetPoints [ tState [ i ] [ j ] ] [ 0 ] = i ; targetPoints [ tState [ i ] [ j ] ] [ 1 ] = j ; } } } func getHeuristic ( state [ ] [ ] int ) int { heuristic := 0 ; for i := 0 ; i < len ( state ) ; i ++ { for j := 0 ; j < len ( state [ i ] ) ; j ++ { if state [ i ] [ j ] != 0 { heuristic = heuristic + int ( math . Abs ( float64 ( targetPoints [ state [ i ] [ j ] ] [ 0 ] - i ) ) + math . Abs ( float64 ( targetPoints [ state [ i ] [ j ] ] [ 1 ] - j ) ) ) } } } return heuristic ; } func solve ( state [ ] [ ] int , blank_row , blank_column , dep , d , h int ) bool { isSolved := true for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { if state [ i ] [ j ] != tState [ i ] [ j ] { isSolved = false } } } if isSolved { return true } if dep == ans { return false } blank_row1 := blank_row blank_column1 := blank_column state2 := make ( [ ] [ ] int , size ) for i , _ := range state2 { state2 [ i ] = make ( [ ] int , size ) } for direction := 0 ; direction < 4 ; direction ++ { for i := 0 ; i < len ( state ) ; i ++ { for j := 0 ; j < len ( state ) ; j ++ { state2 [ i ] [ j ] = state [ i ] [ j ] } } if direction != d && ( d % 2 == direction % 2 ) { continue } if direction == UP { blank_row1 = blank_row + up [ 0 ] blank_column1 = blank_column + up [ 1 ] } else if direction == DOWN { blank_row1 = blank_row + down [ 0 ] blank_column1 = blank_column + down [ 1 ] } else if direction == LEFT { blank_row1 = blank_row + left [ 0 ] blank_column1 = blank_column + left [ 1 ] } else { blank_row1 = blank_row + right [ 0 ] blank_column1 = blank_column + right [ 1 ] } if blank_column1 < 0 || blank_column1 == size || blank_row1 < 0 || blank_row1 == size { continue } state2 [ blank_row ] [ blank_column ] = state2 [ blank_row1 ] [ blank_column1 ] state2 [ blank_row1 ] [ blank_column1 ] = 0 var h1 int if direction == DOWN && blank_row1 > targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 0 ] { h1 = h - 1 } else if direction == UP && blank_row1 < targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 0 ] { h1 = h - 1 } else if direction == RIGHT && blank_column1 > targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 1 ] { h1 = h - 1 } else if direction == LEFT && blank_column1 < targetPoints [ state [ blank_row1 ] [ blank_column1 ] ] [ 1 ] { h1 = h - 1 } else { h1 = h + 1 } if h1 + dep + 1 > ans { continue } movesHistory [ dep ] = direction if solve ( state2 , blank_row1 , blank_column1 , dep + 1 , direction , h1 ) { return true } } return false } func move ( state [ ] [ ] int , direction int ) { row := 0 column := 0 for i := 0 ; i < len ( state ) ; i ++ { for j := 0 ; j < len ( state ) ; j ++ { if state [ i ] [ j ] == 0 { row = i column = j } } } switch direction { case UP : state [ row ] [ column ] = state [ row - 1 ] [ column ] state [ row - 1 ] [ column ] = 0 break case DOWN : state [ row ] [ column ] = state [ row + 1 ] [ column ] state [ row + 1 ] [ column ] = 0 break case LEFT : state [ row ] [ column ] = state [ row ] [ column - 1 ] state [ row ] [ column - 1 ] = 0 break case RIGHT : state [ row ] [ column ] = state [ row ] [ column + 1 ] state [ row ] [ column + 1 ] = 0 break } STEP_SUM ++ }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" \\n \" ) ) stdoutBuffer = [ ] string { } } q = piCache [ q ] } } if len ( stdoutBuffer ) > 0 { fmt . Println ( strings . Join ( stdoutBuffer , \" \\n \" ) ) } } func main ( ) { var t , p string fmt . Scan ( & t ) fmt . Scan ( & p ) KMPMatch ( t , p ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" MASPY \" \" \" { fp , T HE_HARMONY_OF_PERFECT\")) } i P Y\") == \" \" { wfp, _ = os. C U S10\")) } scanner :=",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" 0 \\n \" ) } for i := 1 ; i <= n - m ; i ++ { th = th * B + uint64 ( ts [ i + m - 1 ] ) - uint64 ( ts [ i - 1 ] ) * bm if th == ph { wr . WriteString ( strconv . Itoa ( i ) + \" \\n \" ) } } wr . Flush ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" io \" \" strconv \" \" strings \" \" \\n \" ) ) } } } func isToAs ( is [ ] int ) [ ] string { as := make ( [ ] string , len ( is ) ) for i := 0 ; i < len ( is ) ; i ++ { as [ i ] = strconv . Itoa ( is [ i ] ) } return as }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" \" \" \\n \" ) } } } wr . Flush ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \" \" strings \" \" pattern should have more than one rows \" \" \" \" \\n \" ) ) } } func nextInt ( sc * bufio . Scanner ) ( int , error ) { return strconv . Atoi ( nextText ( sc ) ) } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" index / suffixarray \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" io \" \" bufio \" \" bytes \" \" sort \" \" math \" \" EOF \" \" $ \" l := len ( t ) sa := make ( [ ] int , l ) rank := make ( [ ] int , l ) temp := make ( [ ] int , l ) for i := 0 ; i < l ; i ++ { sa [ i ] = i rank [ i ] = int ( t [ i ] ) } for k := 1 ; k < l ; k *= 2 { sort . SliceStable ( sa , func ( lhs , rhs int ) bool { if rank [ sa [ lhs ] ] != rank [ sa [ rhs ] ] { return rank [ sa [ lhs ] ] < rank [ sa [ rhs ] ] } else { li := - 1 if sa [ lhs ] + k < l { li = rank [ sa [ lhs ] + k ] } ri := - 1 if sa [ rhs ] + k < l { ri = rank [ sa [ rhs ] + k ] } return li < ri } } ) temp [ sa [ 0 ] ] = 0 for i := 1 ; i < l ; i ++ { if Compare ( & rank , & sa , i - 1 , i , k ) { temp [ sa [ i ] ] = temp [ sa [ i - 1 ] ] + 1 } else { temp [ sa [ i ] ] = temp [ sa [ i - 1 ] ] } } for i := 0 ; i < l ; i ++ { rank [ i ] = temp [ i ] } } return SuffixArray { sa , & t } } var sa SuffixArray func IsExists ( text * string , pattern * string ) bool { return sa . Search ( pattern ) != - 1 } func main ( ) { lines , err := ReadLongLines ( 1 ) if err != nil { fmt . Println ( err ) return } t := lines [ 0 ] sa = NewSuffixArray ( & t ) var q int fmt . Scanf ( \" \" , & q ) lines , err = ReadLongLines ( q ) if err != nil { fmt . Println ( err ) return } for _ , p := range lines { if IsExists ( & t , & p ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" math \" \" S \" \" L \" \" 1 \" } else { result [ i ] = \" 0 \" } } fmt . Println ( strings . Join ( result , \" \\n \" ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) count := 0 count += n / 25 n = n % 25 count += n / 10 n = n % 10 count += n / 5 n = n % 5 count += n fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" io \" \" bufio \" \" bytes \" \" fmt \" \" EOF \" \" % d \" \" % d \\n \" , solve ( change ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) coins := [ ] int { 25 , 10 , 5 , 1 } num := 0 for i := 0 ; i < len ( coins ) ; i ++ { cn := n / coins [ i ] n -= cn * coins [ i ] num + = cn } fmt . Println ( num ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" strconv . Atoi failed : % v \\n \" , err ) } return n } func nextFloat64 ( ) ( float64 , error ) { return strconv . ParseFloat ( nextString ( ) , 64 ) } func stringifyArray ( arr [ ] int ) string { return strings . TrimRight ( fmt . Sprintf ( \" \" , arr ) [ 1 : ] , \" \" ) } func main ( ) { scanner . Split ( bufio . ScanWords ) n := nextInt ( ) t := make ( [ ] [ ] int , n ) for i := 0 ; i < n ; i ++ { t [ i ] = [ ] int { nextInt ( ) , nextInt ( ) , } } sort . Slice ( t , func ( i , j int ) bool { return t [ i ] [ 1 ] < t [ j ] [ 1 ] } ) tMax := - 1 nActivities := 0 for i := 0 ; i < n ; i ++ { if tMax < t [ i ] [ 0 ] { tMax = t [ i ] [ 1 ] nActivities + + } } fmt . Println ( nActivities ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" io \" \" bufio \" \" bytes \" \" fmt \" \" strings \" \" strconv \" \" sort \" \" EOF \" \" % d \" \" \" \" % d \\n \" , result ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" sort \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" io \" \" bufio \" \" bytes \" \" fmt \" \" sort \" \" EOF \" \" % d \\n \" , result ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" { \" \" , \" \" } \" } func walk ( item * Item , code string , m map [ rune ] string ) { if item . left != nil { walk ( item . left , code + \" \" , m ) } if item . right != nil { walk ( item . right , code + \" \" , m ) } if item . value != '-' { m [ item . value ] = code } return } func huffman ( pq PriorityQueue ) * Item { heap . Init ( & pq ) for pq . Len ( ) > 1 { item := & Item { value : '-' , priority : 0 , index : - 1 , left : nil , right : nil , } left := heap . Pop ( & pq ) . ( * Item ) right := heap . Pop ( & pq ) . ( * Item ) item . left = left item . right = right item . priority = right . priority + left . priority pq . Push ( item ) } return heap . Pop ( & pq ) . ( * Item ) } func anser ( item * Item ) { } func main ( ) { str := readLine ( ) items := counter ( str ) pq := makeQueue ( items ) item := huffman ( pq ) codeMap := map [ rune ] string { } walk ( item , \" \" , codeMap ) sum := 0 for k , v := range codeMap { sum + = items [ k ] * len ( v ) } if len ( items ) != 1 { fmt . Println ( sum ) } else { fmt . Println ( len ( str ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) type Node struct { C rune H int P * Node C0 * Node C1 * Node } type Npq [ ] * Node func ( npq Npq ) Len ( ) int { return len ( npq ) } func ( npq Npq ) Swap ( i , j int ) { npq [ i ] , npq [ j ] = npq [ j ] , npq [ i ] } func ( npq Npq ) Less ( i , j int ) bool { return npq [ i ] . H < npq [ j ] . H } func ( npq * Npq ) Push ( x interface { } ) { * npq = append ( * npq , x . ( * Node ) ) } func ( npq * Npq ) Pop ( ) interface { } { n := len ( * npq ) item := ( * npq ) [ n - 1 ] * npq = ( * npq ) [ 0 : n - 1 ] return item } func main ( ) { var s string fmt . Scan ( & s ) ss := [ ] rune ( s ) m := make ( map [ rune ] int ) for i := 0 ; i < len ( ss ) ; i ++ { if _ , ok := m [ ss [ i ] ] ; ! ok { m [ ss [ i ] ] = 0 } m [ ss [ i ] ] += 1 } n := len ( m ) var npq Npq = make ( [ ] * Node , n ) i := 0 for k , v := range m { npq [ i ] = & Node { k , v , nil , nil , nil } i + + } heap . Init ( & npq ) for len ( npq ) > 1 { n1 := heap . Pop ( & npq ) . ( * Node ) n2 := heap . Pop ( & npq ) . ( * Node ) node := & Node { C : - 1 , H : n1 . H + n2 . H , P : nil , C0 : n1 , C1 : n2 } n1 . P = node n2 . P = node heap . Push ( & npq , node ) } que := make ( [ ] * Node , 1 , 2 ) que [ 0 ] = heap . Pop ( & npq ) . ( * Node ) if que [ 0 ] . C0 == nil && que [ 0 ] . C1 == nil { fmt . Println ( que [ 0 ] . H ) return } val , d := 0 , 0 for len ( que ) > 0 { size := len ( que ) for j := 0 ; j < size ; j + + { node := que [ j ] if node . C != - 1 { val + = d * node . H } if node . C0 != nil { que = append ( que , node . C0 ) } if node . C1 != nil { que = append ( que , node . C1 ) } } if len ( que ) == size { break } que = que [ size : ] d + + } fmt . Println ( val ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } printa ( a ) for i := 1 ; i < n ; i ++ { key := a [ i ] j := i - 1 for j >= 0 && a [ j ] > key { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = key printa ( a ) } } func printa ( a [ ] int ) { for i := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var N int fmt . Scan ( & N ) A := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & A [ i ] ) } trace ( A , N ) for i := 1 ; i < N ; i ++ { key := A [ i ] j := i - 1 for j >= 0 && A [ j ] > key { A [ j + 1 ] = A [ j ] j - - } A [ j + 1 ] = key trace ( A , N ) } } func trace ( A [ ] int , n int ) { for i := 0 ; i < n ; i ++ { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , A [ i ] ) } fmt . Printf ( \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" % s % d \" \" \" \\n \" \\r \\n \" ) } func eGetInt ( r * bufio . Reader ) int { line := eGetLine ( r ) return eAtoi ( line ) } func eGetInts ( r * bufio . Reader ) [ ] int { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) var ints [ ] int for _ , f := range fields { ints = append ( ints , eAtoi ( f ) ) } return ints } func eAtoi ( s string ) int { n , err := strconv . Atoi ( s ) if err != nil { log . Fatal ( err ) } return n }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \\n \" ) } func stringToInt ( arr [ ] string ) ( arr2 [ ] int ) { for _ , val := range arr { val2 , _ := strconv . Atoi ( val ) arr2 = append ( arr2 , val2 ) } return } func insertionSort ( arr [ ] int ) { for i := 0 ; i < len ( arr ) ; i + + { v := arr [ i ] j := i - 1 for { if j < 0 || arr [ j ] <= v { break } arr [ j + 1 ] = arr [ j ] j - - } arr [ j + 1 ] = v printLine ( arr ) } return } func main ( ) { var n int fmt . Scan ( & n ) line := nextLine ( ) arrString := strings . Split ( line , \" \" ) arr := stringToInt ( arrString ) insertionSort ( arr ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := [ ] int { } for i := 0 ; i < n ; i ++ { var aa int fmt . Scan ( & aa ) a = append ( a , aa ) } sortWithPrint ( n , a ) } func sortWithPrint ( n int , a [ ] int ) { for i := 0 ; i < n ; i ++ { v := a [ i ] j := i - 1 for ; j >= 0 && a [ j ] > v ; j -- { a [ j + 1 ] = a [ j ] } a [ j + 1 ] = v fmt . Print ( a [ 0 ] ) for k := 1 ; k < n ; k ++ { fmt . Printf ( \" \" , a [ k ] ) } fmt . Println ( ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } printIntArray ( a , \" \" ) for i := 1 ; i < n ; i ++ { for j := i - 1 ; j >= 0 ; j -- { if a [ j ] > a [ j + 1 ] { a [ j ] , a [ j + 1 ] = a [ j + 1 ] , a [ j ] } else { break } } printIntArray ( a , \" \" ) } } func printIntArray ( n [ ] int , d string ) { for _ , i := range n [ : len ( n ) - 1 ] { fmt . Print ( i , d ) } fmt . Println ( n [ len ( n ) - 1 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" % d \" \" \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \\n \" ) arr = strings . Split ( arr [ 1 ] , \" \" ) var arr2 [ ] int for _ , v := range arr { v , err := strconv . ParseInt ( v , 10 , 32 ) if err != nil { os . Exit ( 1 ) } arr2 = append ( arr2 , int ( v ) ) } insertSort ( arr2 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) type ints [ ] int func ( is ints ) insertionSort ( ) { for i := 1 ; i < len ( is ) ; i ++ { v := is [ i ] j := i - 1 for j >= 0 && is [ j ] > v { is [ j + 1 ] = is [ j ] j - - } is [ j + 1 ] = v is . printme ( ) } } func ( is ints ) printme ( ) { for i , v := range is { fmt . Print ( v ) if i < len ( is ) - 1 { fmt . Print ( \" \" ) } } fmt . Println ( ) } func main ( ) { var n int fmt . Scan ( & n ) var numbers ints for i := 0 ; i < n ; i ++ { var x int fmt . Scan ( & x ) numbers = append ( numbers , x ) } numbers . printme ( ) numbers . insertionSort ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func printSlice ( src [ ] int ) { for i , v := range src { if i == len ( src ) - 1 { fmt . Printf ( \" \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } } func insertionSort ( src [ ] int , len int ) [ ] int { for i := 1 ; i < len ; i ++ { v := src [ i ] j := i - 1 for j >= 0 && src [ j ] > v { src [ j + 1 ] = src [ j ] j - - } src [ j + 1 ] = v printSlice ( src ) } return src } func main ( ) { var n int fmt . Scan ( & n ) target := make ( [ ] int , n ) for i := range target { fmt . Scan ( & target [ i ] ) } printSlice ( target ) target = insertionSort ( target , len ( target ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func insertSort ( buf [ ] int ) { for i := 1 ; i <= len ( buf ) ; i ++ { for j := 0 ; j < len ( buf ) ; j ++ { if j < ( len ( buf ) - 1 ) { fmt . Printf ( \" \" , buf [ j ] ) } else { fmt . Printf ( \" \\n \" , buf [ j ] ) } } if i == len ( buf ) { break } v := buf [ i ] for j := 0 ; j < i ; j ++ { if buf [ j ] > v { for k := i ; k - 1 >= j ; k -- { buf [ k ] = buf [ k - 1 ] } buf [ j ] = v break } } } } func main ( ) { var length int fmt . Scanln ( & length ) buf := make ( [ ] int , length ) for i := range buf { fmt . Scanf ( \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \\n \\n \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var e , v int var a [ ] int fmt . Scan ( & e ) for i := 0 ; i < e ; i ++ { fmt . Scan ( & v ) a = append ( a , v ) } for i := 0 ; i < e ; i ++ { if a [ i ] == a [ e - 1 ] { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Print ( \" \\n \" ) for i := 1 ; i < e ; i ++ { key := a [ i ] j := i - 1 for j >= 0 && a [ j ] > key { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = key for i := 0 ; i < e ; i + + { if a [ i ] == a [ e - 1 ] { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Print ( \" \\n \" ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var e , v int var a [ 100 ] int fmt . Scan ( & e ) for i := 0 ; i < e ; i ++ { fmt . Scan ( & v ) a [ i ] = v } for i := 0 ; i < e ; i ++ { if a [ i ] == a [ e - 1 ] { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Print ( \" \\n \" ) for i := 1 ; i < e ; i ++ { key := a [ i ] j := i - 1 for j >= 0 && a [ j ] > key { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = key for i := 0 ; i < e ; i + + { if a [ i ] == a [ e - 1 ] { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Print ( \" \\n \" ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var e , v int var a [ 100 ] int fmt . Scan ( & e ) for i := 0 ; i < e ; i ++ { fmt . Scan ( & v ) a [ i ] = v } for i := 0 ; i < e ; i ++ { if a [ i ] == a [ e - 1 ] { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Print ( \" \\n \" ) for i := 1 ; i < e ; i ++ { key := a [ i ] j := i - 1 for j >= 0 && a [ j ] > key { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = key for i := 0 ; i < e ; i + + { if a [ i ] == a [ e - 1 ] { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Print ( \" \\n \" ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) pas := make ( [ ] interface { } , n ) for i := range a { pas [ i ] = & a [ i ] } fmt . Scan ( pas ... ) for i , e := range a { fmt . Print ( e ) if i != n - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } for i := 1 ; i < n ; i ++ { v := a [ i ] j := i - 1 for j >= 0 && a [ j ] > v { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = v for i , e := range a { fmt . Print ( e ) if i != n - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % v \" \" [ ] \" ) fmt . Println ( str ) v := A [ i ] j := i - 1 for j >= 0 && A [ j ] > v { A [ j + 1 ] = A [ j ] j - - } A [ j + 1 ] = v } str := fmt . Sprintf ( \" \" , A ) str = strings . Trim ( str , \" \" ) fmt . Println ( str ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \" \" \\n \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \" for _ , inz := range intArray { reducedString += \" \" + strconv . FormatInt ( int64 ( inz ) , 10 ) } return strings . Trim ( reducedString , \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func insertionsort ( nums [ ] int ) { for i := 1 ; i < len ( nums ) ; i ++ { v := nums [ i ] j := i - 1 for j >= 0 && nums [ j ] > v { nums [ j + 1 ] = nums [ j ] j - - } nums [ j + 1 ] = v for k := 0 ; k < len ( nums ) ; k + + { fmt . Print ( nums [ k ] ) if k != len ( nums ) - 1 { fmt . Print ( \" \" ) } } fmt . Println ( \" \" ) } } func main ( ) { var n int fmt . Scan ( & n ) nums := make ( [ ] int , n ) for i := 0 ; i < len ( nums ) ; i ++ { fmt . Scan ( & nums [ i ] ) } for k := 0 ; k < len ( nums ) ; k ++ { fmt . Print ( nums [ k ] ) if k != len ( nums ) - 1 { fmt . Print ( \" \" ) } } fmt . Println ( \" \" ) insertionsort ( nums ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func trace ( A [ ] int , N int ) { for i := 0 ; i < N ; i ++ { if i > 0 { fmt . Print ( \" \" ) } fmt . Printf ( \" \" , A [ i ] ) } fmt . Println ( \" \" ) } func insertionSort ( A [ ] int , N int ) { var i , j , v int for i = 1 ; i < N ; i ++ { v = A [ i ] j = i - 1 for j >= 0 && A [ j ] > v { A [ j + 1 ] = A [ j ] j - - } A [ j + 1 ] = v trace ( A , N ) } } func main ( ) { var N int fmt . Scan ( & N ) A := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & A [ i ] ) } trace ( A , N ) insertionSort ( A , N ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" os \" \" bufio \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scanf ( \" % d \\n \" , & n ) buff := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scanf ( \" \" , & buff [ i ] ) } for i := 0 ; i < n ; i ++ { v := buff [ i ] j := i - 1 for j >= 0 && buff [ j ] > v { buff [ j + 1 ] = buff [ j ] j - - } buff [ j + 1 ] = v for k := 0 ; k < n ; k + + { fmt . Printf ( \" \" , buff [ k ] ) if k < n - 1 { fmt . Print ( \" \" ) } } fmt . Print ( \" \\n \" ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func insertionSort ( a [ ] int ) { for i := 1 ; i < len ( a ) ; i ++ { printArr ( a ) v := a [ i ] j := i - 1 for ; j >= 0 && a [ j ] > v ; j -- { a [ j + 1 ] = a [ j ] } a [ j + 1 ] = v } } func main ( ) { var n int fmt . Scan ( & n ) var a [ ] int for i := 0 ; i < n ; i ++ { var e int fmt . Scan ( & e ) a = append ( a , e ) } insertionSort ( a ) printArr ( a ) } func printArr ( a [ ] int ) { for i := 0 ; i < len ( a ) ; i ++ { if i != 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" % d \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" scan failed \" \" I \" \" IronMan \" \" END_GAME \" \" -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } func insertionSort ( n int , xs [ ] int ) { printArray ( xs ) for i := 1 ; i < n ; i ++ { x := xs [ i ] for j := i - 1 ; j >= 0 ; j -- { if xs [ j ] > x { tmp := xs [ j ] xs [ j ] = x xs [ j + 1 ] = tmp } } printArray ( xs ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" strconv \" \" % d \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) v := A [ i ] j := i - 1 for ; j >= 0 && A [ j ] > v ; j -- { A [ j + 1 ] = A [ j ] } A [ j + 1 ] = v } fmt . Println ( strings . Trim ( fmt . Sprint ( A ) , \" \" ) ) return A }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var num int fmt . Scan ( & num ) nums := make ( [ ] int , num ) for i := range nums { fmt . Scan ( & nums [ i ] ) } insertSort ( nums ) } func insertSort ( nums [ ] int ) { output ( nums ) for i := 1 ; i < len ( nums ) ; i ++ { for j := i - 1 ; j >= 0 ; j -- { if nums [ j + 1 ] < nums [ j ] { tmp := nums [ j + 1 ] nums [ j + 1 ] = nums [ j ] nums [ j ] = tmp } else { break } } output ( nums ) } } func output ( nums [ ] int ) { for k := 0 ; k < len ( nums ) ; k ++ { if k != len ( nums ) - 1 { fmt . Print ( nums [ k ] , \" \" ) } else { fmt . Println ( nums [ k ] ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func showArray ( a [ ] int ) { for i := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) } func isort ( a [ ] int ) { n := len ( a ) showArray ( a ) for i := 1 ; i < n ; i ++ { v := a [ i ] j := i - 1 for j >= 0 && v < a [ j ] { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = v showArray ( a ) } } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } isort ( a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) for i := 1 ; i < n ; i ++ { v := sort [ i ] j := i - 1 for j >= 0 && sort [ j ] > v { sort [ j + 1 ] = sort [ j ] j - - } sort [ j + 1 ] = v fmt . Println ( strings . Trim ( fmt . Sprint ( sort ) , \" \" ) ) } } func scanInt ( sc * bufio . Scanner ) int { t := sc . Text ( ) i , err := strconv . Atoi ( t ) if err != nil { panic ( err ) } return i } func scanIntArray ( sc * bufio . Scanner ) [ ] int { t := sc . Text ( ) ss := strings . Split ( t , \" \" ) is := [ ] int { } for _ , s := range ss { i , err := strconv . Atoi ( s ) if err != nil { panic ( err ) } is = append ( is , i ) } return is }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" [ ] \" ) fmt . Println ( s ) } func checkErr ( e error ) { if e != nil { log . Fatalln ( e ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( arr [ ] int ) { for i , e := range arr { if i == len ( arr ) - 1 { fmt . Printf ( \" \\n \" , e ) } else { fmt . Printf ( \" \" , e ) } } } func insertionSort ( arr [ ] int ) { for i , e := range arr { j := i - 1 for ; j >= 0 && arr [ j ] > e ; j -- { arr [ j + 1 ] = arr [ j ] } arr [ j + 1 ] = e trace ( arr ) } } func main ( ) { var n int fmt . Scan ( & n ) arr := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & arr [ i ] ) } insertionSort ( arr ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" % d \" \" % d \" \" \" \" [ ] \" ) ) } func main ( ) { _ , slice := scanInput ( ) printSlice ( slice ) solve ( slice ) } func solve ( nums [ ] int ) { l := len ( nums ) for i := 1 ; i < l ; i + + { v := nums [ i ] j := i - 1 for j >= 0 && nums [ j ] > v { nums [ j + 1 ] = nums [ j ] j - - } nums [ j + 1 ] = v printSlice ( nums ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } } func insertionSort ( a [ ] int , n int ) { var v int var j int listPrint ( a ) for i := 1 ; i < n ; i ++ { v = a [ i ] j = i - 1 for j >= 0 && a [ j ] > v { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = v listPrint ( a ) } } func main ( ) { sc = bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { a [ i ] = nextInt ( ) } insertionSort ( a , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" Error : element = % v \\n \" , element ) } parsedLine = append ( parsedLine , n ) } result = append ( result , parsedLine ) } return result } func printArray ( arr [ ] int64 ) { separator : = \" \" for j , element : = range arr { fmt . Print ( element ) if j < len ( arr ) - 1 { fmt . Print ( separator ) } } fmt . Print ( \" \\n \" ) } func insertionSort ( arr [ ] int64 ) { n := len ( arr ) printArray ( arr ) for i := 1 ; i < n ; i ++ { v := arr [ i ] j := i - 1 for j >= 0 && arr [ j ] > v { arr [ j + 1 ] = arr [ j ] j - - } arr [ j + 1 ] = v printArray ( arr ) } } func main ( ) { scanner := bufio . NewScanner ( os . Stdin ) content := [ ] string { } for scanner . Scan ( ) { line := scanner . Text ( ) content = append ( content , line ) } arr := parseToArray2d ( content ) [ 1 ] insertionSort ( arr ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" strings \" \" % v \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) target := make ( [ ] int , n ) for i := range target { fmt . Scan ( & target [ i ] ) } printSlice ( target ) insertSort ( target ) } func insertSort ( data [ ] int ) { for i := 1 ; i < len ( data ) ; i ++ { v := data [ i ] j := i - 1 for j >= 0 && data [ j ] > v { data [ j + 1 ] = data [ j ] j - - } data [ j + 1 ] = v printSlice ( data ) } } func printSlice ( input [ ] int ) { for i , v := range input { if i == len ( input ) - 1 { fmt . Printf ( \" \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func report ( a [ ] int ) { for i , l := 0 , len ( a ) ; i < l ; i ++ { if i < l - 1 { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Println ( a [ i ] ) } } } func main ( ) { var n int fmt . Scanln ( & n ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } report ( a ) for i := 1 ; i <= len ( a ) - 1 ; i ++ { key := a [ i ] j := i - 1 for j >= 0 && a [ j ] > key { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = key report ( a ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var N int fmt . Scan ( & N ) arr := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & arr [ i ] ) } for i := 1 ; i < N ; i ++ { print ( arr , N ) v := arr [ i ] j := i - 1 for ; j >= 0 && arr [ j ] > v ; j -- { arr [ j + 1 ] = arr [ j ] } arr [ j + 1 ] = v } print ( arr , N ) } func print ( arr [ ] int , num int ) { for i := 0 ; i < num ; i ++ { if i != num - 1 { fmt . Printf ( \" \" , arr [ i ] ) } else { fmt . Printf ( \" \\n \" , arr [ i ] ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var ( n int list [ ] int ) fmt . Scan ( & n ) list = make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & list [ i ] ) } list_print ( list ) insertion_sort ( list , n ) } func insertion_sort ( a [ ] int , n int ) { var v , i , j int for i = 1 ; i < n ; i ++ { v = a [ i ] for j = i - 1 ; j >= 0 && a [ j ] > v ; j -- { a [ j + 1 ] = a [ j ] } a [ j + 1 ] = v list_print ( a ) } } func list_print ( list [ ] int ) { var i int for i = 0 ; i < len ( list ) ; i ++ { if i == 0 { fmt . Print ( list [ i ] ) } else { fmt . Print ( \" \" , list [ i ] ) } } fmt . Print ( \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } for i = 1 ; i < n ; i ++ { v = a [ i ] j = i - 1 for j >= 0 && a [ j ] > v { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = v for k , p := range a { fmt . Printf ( \" \" , p ) if k == len ( a ) - 1 { fmt . Printf ( \" \\n \" ) } else { fmt . Print ( \" \" ) } } } } func main ( ) { var n int var s string var sc = bufio . NewScanner ( os . Stdin ) sc . Scan ( ) n , _ = strconv . Atoi ( sc . Text ( ) ) sc . Scan ( ) s = sc . Text ( ) var a = make ( [ ] int , n ) for i , t := range strings . Split ( s , \" \" ) { a [ i ] , _ = strconv . Atoi ( t ) } insertionSort ( a , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % v \\n \" , strings . Join ( strValues , \" \" ) ) } func insertionSort ( values [ ] int ) { for i := 1 ; i < len ( values ) ; i ++ { v := values [ i ] j := i - 1 for { if ( j < 0 ) || ( values [ j ] <= v ) { break } values [ j + 1 ] = values [ j ] j - - } values [ j + 1 ] = v printIntArray ( values ) } } func main ( ) { var arraySize int fmt . Scan ( & arraySize ) values := make ( [ ] int , arraySize ) sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) for i := 0 ; i < arraySize ; i ++ { sc . Scan ( ) s := sc . Text ( ) values [ i ] , _ = strconv . Atoi ( s ) } printIntArray ( values ) insertionSort ( values ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \\n \" ) } func insertionSort ( list [ ] int ) [ ] int { for i := 1 ; i < len ( list ) ; i ++ { v := list [ i ] j := i - 1 for j >= 0 && list [ j ] > v { list [ j + 1 ] = list [ j ] j - - } list [ j + 1 ] = v printSlice ( list ) } return list } func main ( ) { scanInt ( ) sort := scanSlice ( ) printSlice ( sort ) insertionSort ( sort ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" % d \" \" \" \" \\n \" ) } func insertionSort ( array [ ] int ) { printArray ( array ) n := len ( array ) for i := 1 ; i < n ; i ++ { a_i := array [ i ] j := i - 1 for j >= 0 && array [ j ] > a_i { array [ j + 1 ] = array [ j ] j - - } array [ j + 1 ] = a_i printArray ( array ) } } func main ( ) { var n int if _ , err := fmt . Scan ( & n ) ; err != nil { fmt . Printf ( \" \\n \" , err ) os . Exit ( 1 ) } array := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { if _ , err := fmt . Scan ( & array [ i ] ) ; err != nil { fmt . Printf ( \" \\n \" , err ) os . Exit ( 1 ) } } insertionSort ( array ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" % v \\n \" , strings . Trim ( fmt . Sprint ( e ) , \" \" ) ) for i := 1 ; i < n ; i ++ { v := e [ i ] j := i - 1 for j >= 0 && e [ j ] > v { e [ j + 1 ] = e [ j ] j - - } e [ j + 1 ] = v fmt . Printf ( \" \\n \" , strings . Trim ( fmt . Sprint ( e ) , \" \" ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func printSlice ( a [ ] int ) { for i , e := range a { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , e ) } fmt . Printf ( \" \\n \" ) } func sort ( a [ ] int ) { for i , e := range a { j := i - 1 for 0 <= j && e < a [ j ] { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = e printSlice ( a ) } } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } sort ( a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func trace ( a [ ] int ) { for i , v := range a { if i == 0 { fmt . Printf ( \" \" , v ) } else { fmt . Printf ( \" \" , v ) } } fmt . Println ( \" \" ) } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } trace ( a ) for i := 1 ; i < n ; i ++ { v := a [ i ] j := i - 1 for j >= 0 && a [ j ] > v { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = v trace ( a ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func printArray ( arr [ ] int ) { for i := 0 ; i < len ( arr ) ; i ++ { fmt . Print ( arr [ i ] ) if i == len ( arr ) - 1 { fmt . Println ( ) } else { fmt . Print ( \" \" ) } } } func InsertionSort ( arr [ ] int ) [ ] int { for i , v := range arr { j := i - 1 for j >= 0 && arr [ j ] > v { arr [ j + 1 ] = arr [ j ] j - - } arr [ j + 1 ] = v printArray ( arr ) } return arr } func main ( ) { var n int fmt . Scan ( & n ) arr := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & arr [ i ] ) } InsertionSort ( arr ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var N int fmt . Scan ( & N ) nums := insertionSort ( scanNums ( N ) , N ) printNums ( nums ) } func insertionSort ( nums [ ] int , n int ) [ ] int { for i := 1 ; i < n ; i ++ { printNums ( nums ) v := nums [ i ] var j int for j = i - 1 ; j >= 0 && nums [ j ] > v ; j -- { nums [ j + 1 ] = nums [ j ] } nums [ j + 1 ] = v } return nums } func scanNums ( len int ) ( nums [ ] int ) { var num int for i := 0 ; i < len ; i ++ { fmt . Scan ( & num ) nums = append ( nums , num ) } return } func printNums ( nums [ ] int ) { for k := 0 ; k < len ( nums ) - 1 ; k ++ { fmt . Printf ( \" \" , nums [ k ] ) } fmt . Println ( nums [ len ( nums ) - 1 ] ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func disp_array ( arr [ ] int ) { for i := 0 ; i < len ( arr ) ; i ++ { fmt . Print ( arr [ i ] ) if i != len ( arr ) - 1 { fmt . Print ( \" \" ) } } fmt . Println ( \" \" ) } func ins_sort ( arr [ ] int , n int ) [ ] int { disp_array ( arr ) for i := 1 ; i <= n - 1 ; i ++ { v := arr [ i ] j := i - 1 for j >= 0 && arr [ j ] > v { arr [ j + 1 ] = arr [ j ] j - - } arr [ j + 1 ] = v disp_array ( arr ) } return arr } func main ( ) { var n int var num int var data [ ] int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \" \" % d \\n \" , a ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" log \" \" % d \" \" % d \" \" % d \" \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" [ ] \" ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func insertionSort ( a [ ] int ) { printSlice ( a ) for i := 1 ; i < len ( a ) ; i ++ { v := a [ i ] j := i - 1 for j >= 0 && a [ j ] > v { a [ j + 1 ] = a [ j ] j - - } a [ j + 1 ] = v printSlice ( a ) } } func printSlice ( s [ ] int ) { for i , v := range s { fmt . Print ( v ) if i < len ( s ) - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } } func main ( ) { var n int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var num , elem int var elems [ ] int fmt . Scan ( & num ) for i := 0 ; i < num ; i ++ { fmt . Scan ( & elem ) elems = append ( elems , elem ) } for i := 0 ; i < num ; i ++ { v := elems [ i ] j := i - 1 for j >= 0 && elems [ j ] > v { elems [ j + 1 ] = elems [ j ] elems [ j ] = v j - - } for i , elem2 := range elems { if i + 1 == len ( elems ) { fmt . Println ( elem2 ) } else { fmt . Printf ( \" \" , elem2 ) } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % v \\n \" , strings . Trim ( fmt . Sprint ( ary ) , \" \" ) ) } func insertionSort ( ary [ ] int , n int ) { for i := 1 ; i < n ; i ++ { v := ary [ i ] j := i - 1 for 0 <= j && v < ary [ j ] { ary [ j + 1 ] = ary [ j ] j - - } ary [ j + 1 ] = v print ( ary ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) A := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & A [ i ] ) } for i := 1 ; i <= n ; i ++ { for k := 0 ; k < n ; k ++ { fmt . Print ( A [ k ] ) if k == n - 1 { fmt . Print ( \" \\n \" ) } else { fmt . Print ( \" \" ) } } if i == n { break } key := A [ i ] j := i - 1 for j >= 0 && A [ j ] > key { A [ j + 1 ] = A [ j ] j - - } A [ j + 1 ] = key } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" strconv \" \" % d \" \" % s \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var a , b int fmt . Scan ( & a , & b ) if b > a { a , b = b , a } for { if a % b == 0 { break } a , b = b , a % b } fmt . Println ( b ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a , b int fmt . Scan ( & a , & b ) fmt . Println ( gcd ( a , b ) ) } func gcd ( a , b int ) int { if a % b == 0 { return b } if a >= b { return gcd ( b , a % b ) } else { return gcd ( a , b % a ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a , b int fmt . Scan ( & a , & b ) ans := gcd ( a , b ) fmt . Println ( ans ) } func gcd ( a , b int ) int { if b == 0 { return a } return gcd ( b , a % b ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var x , y int32 fmt . Scan ( & x ) fmt . Scan ( & y ) if x < y { fmt . Println ( gcd ( y , x ) ) } else { fmt . Println ( gcd ( x , y ) ) } } func gcd ( b , s int32 ) int32 { if b % s == 0 { return s } return gcd ( s , b - s * ( b / s ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func gcd ( a , b int ) int { if b == 0 { return a } return gcd ( b , a % b ) } func main ( ) { x := 0 y := 0 fmt . Scan ( & x , & y ) fmt . Println ( gcd ( x , y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var x , y int fmt . Scan ( & x , & y ) if x < y { x , y = y , x } for x % y != 0 { x , y = y , x % y } fmt . Println ( y ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" bufio \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var x , y int fmt . Scan ( & x , & y ) ans := gcd ( x , y ) fmt . Println ( ans ) } func gcd ( x , y int ) ( ret int ) { if x < y { gcd ( y , x ) } for 0 < y { x , y = y , x % y } return x }",
    "label": 4
  },
  {
    "code": "package main import \" \" func getGCD ( x , y int ) int { if x < y { x , y = y , x } if y == 0 { return x } else { return getGCD ( y , x % y ) } } func main ( ) { var x , y int fmt . Scan ( & x , & y ) fmt . Println ( getGCD ( x , y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func min ( a , b int ) int { if a < b { return a } else { return b } } func abs ( a , b int ) int { if a < b { return b - a ; } else { return a - b ; } } func main ( ) { var x , y int fmt . Scanln ( & x , & y ) for { if x == y { break } z := abs ( x , y ) x = min ( x , y ) y = z } fmt . Println ( x ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func min ( x , y int ) int { if x < y { return x } else { return y } } func abs ( x , y int ) int { if x < y { return y - x ; } else { return x - y ; } } func gcd ( x , y int ) int { for { if x == y { return x } z := abs ( x , y ) x = min ( x , y ) y = z } } func main ( ) { var x , y int fmt . Scanln ( & x , & y ) fmt . Println ( gcd ( x , y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func gcd ( x , y int ) int { if y == 0 { return x } return gcd ( y , x % y ) } func main ( ) { var x , y int fmt . Scan ( & x , & y ) fmt . Println ( gcd ( x , y ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var a , b int fmt . Scan ( & a , & b ) if a > b { fmt . Println ( gcd ( a , b ) ) } else { fmt . Println ( gcd ( b , a ) ) } } func gcd ( a , b int ) int { if b == 0 { return a } else { return gcd ( b , a % b ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d % d \" \" % d \\n \" , m ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var x , y int fmt . Scan ( & x , & y ) fmt . Println ( gcd ( x , y ) ) } func gcd ( a , b int ) int { if a < b { tmp := a a = b b = tmp } r := a % b for r != 0 { a = b b = r r = a % b } return b }",
    "label": 4
  },
  {
    "code": "package main import \" \" func gcd ( a , b int ) int { if b == 0 { return a } return gcd ( b , a % b ) } func main ( ) { var a , b int fmt . Scan ( & a , & b ) if a > b { fmt . Println ( gcd ( a , b ) ) } else { fmt . Println ( gcd ( b , a ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var x , y int fmt . Scanf ( \" % d % d \" \" % d \\n \" , ans ) } func gcd ( x int , y int ) int { var a , b int if x > y { a , b = x , y } else { a , b = y , x } for b > 0 { r := a % b a = b b = r } return a }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var x , y int fmt . Scan ( & x , & y ) fmt . Println ( gcd ( x , y ) ) } func gcd ( x , y int ) int { if y == 0 { return x } return gcd ( y , x % y ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func gcd ( a , b int ) int { if a % b == 0 { return b } return gcd ( b , a % b ) } func main ( ) { var a , b int fmt . Scan ( & a , & b ) fmt . Println ( gcd ( a , b ) ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var a , b int fmt . Scan ( & a , & b ) if a > b { a , b = b , a } for b % a != 0 { a , b = b % a , a } fmt . Println ( a ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func gcd ( x , y int ) int { if y == 0 { return x } return gcd ( y , x % y ) } func main ( ) { var x , y int fmt . Scan ( & x , & y ) fmt . Println ( gcd ( x , y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func gcd ( a , b int ) int { if b == 0 { return a } return gcd ( b , a % b ) } func main ( ) { var a , b int fmt . Scanln ( & a , & b ) fmt . Println ( gcd ( a , b ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func gcd ( x , y int ) int { if y == 0 { return x } return gcd ( y , x % y ) } func main ( ) { var x , y int fmt . Scan ( & x , & y ) fmt . Println ( gcd ( x , y ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func f ( n , m uint ) uint { for m > 0 { t := n n = m m = t % m } return n } func main ( ) { var n , m uint fmt . Scanf ( \" % d % d \" , & n , & m ) if m < n { fmt . Println ( f ( n , m ) ) } else { fmt . Println ( f ( m , n ) ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" ) func gcd ( m , n uint64 ) uint64 { x := new ( big . Int ) y := new ( big . Int ) z := new ( big . Int ) a := new ( big . Int ) . SetUint64 ( m ) b := new ( big . Int ) . SetUint64 ( n ) return z . GCD ( x , y , a , b ) . Uint64 ( ) } func main ( ) { var a , b uint64 fmt . Scan ( & a , & b ) fmt . Println ( gcd ( a , b ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var x , y int fmt . Scan ( & x , & y ) for { if x < y { x , y = y , x } x , y = y , x % y if y <= 0 { break } } fmt . Println ( x ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func gojo ( x , y int ) int { if x < y { x , y = y , x } amari := x % y if amari == 0 { return y } return gojo ( amari , y ) } func main ( ) { var x , y int fmt . Scanf ( \" % d % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" math \" \" % d % d \" \" % d \\n \" , ans ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var num1 , num2 int fmt . Scan ( & num1 , & num2 ) fmt . Println ( gcd ( num1 , num2 ) ) } func gcd ( a , b int ) int { if b > a { tmp := b b = a a = tmp } if remainder := a % b ; remainder == 0 { return b } else { return gcd ( b , remainder ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var x , y int fmt . Scan ( & x , & y ) if x < y { x , y = y , x } for { if x == 0 { fmt . Println ( y ) break } else if y == 0 { fmt . Println ( x ) break } x , y = y , x % y } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var a , b int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \" \" % d \" \" \\n % d \\n \" , count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } s := bubble ( a ) for i := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) fmt . Println ( s ) } func bubble ( a [ ] int ) int { s := 0 for i := 0 ; i < len ( a ) ; i ++ { for j := len ( a ) - 1 ; j >= i + 1 ; j -- { if a [ j - 1 ] > a [ j ] { a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] s + + } } } return s }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( A [ ] int , n int ) { for i := 0 ; i < n ; i ++ { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , A [ i ] ) } fmt . Printf ( \" \\n \" ) } func main ( ) { var N int fmt . Scan ( & N ) A := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & A [ i ] ) } count := 0 for i := 0 ; i <= N - 1 ; i ++ { for j := N - 1 ; j >= i + 1 ; j -- { if A [ j ] < A [ j - 1 ] { A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] count + + } } } trace ( A , N ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" % s % d \" \" \" \\n \" \\r \\n \" ) } func eGetInt ( r * bufio . Reader ) int { line := eGetLine ( r ) return eAtoi ( line ) } func eGetInts ( r * bufio . Reader ) [ ] int { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) var ints [ ] int for _ , f := range fields { ints = append ( ints , eAtoi ( f ) ) } return ints } func eAtoi ( s string ) int { n , err := strconv . Atoi ( s ) if err != nil { log . Fatal ( err ) } return n }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n , a int fmt . Scan ( & n ) arr := [ ] int { } for i := 0 ; i < n ; i ++ { fmt . Scan ( & a ) arr = append ( arr , a ) } c := 0 flag := 1 for flag > 0 { flag = 0 for j := n - 1 ; j > 0 ; j -- { if arr [ j - 1 ] > arr [ j ] { arr [ j - 1 ] , arr [ j ] = arr [ j ] , arr [ j - 1 ] c + + flag = 1 } } } fmt . Print ( arr [ 0 ] ) for i := 1 ; i < n ; i ++ { fmt . Print ( \" \" ) fmt . Print ( arr [ i ] ) } fmt . Println ( ) fmt . Println ( c ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } flag := true sortedIndex := 0 swapCount := 0 for flag { flag = false for i := n - 1 ; i > sortedIndex ; i -- { if a [ i ] < a [ i - 1 ] { a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] flag = true swapCount + + } } sortedIndex ++ } str := fmt . Sprint ( a ) fmt . Println ( str [ 1 : len ( str ) - 1 ] ) fmt . Println ( swapCount ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func bubbleSort ( a [ ] int , n int ) ( [ ] int , int ) { var cnt int flag := true for flag { flag = false for i := n - 1 ; i > 0 ; i -- { if a [ i - 1 ] > a [ i ] { a [ i - 1 ] , a [ i ] = a [ i ] , a [ i - 1 ] cnt + + flag = true } } } return a , cnt } func main ( ) { var n , cnt int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } a , cnt = bubbleSort ( a , len ( a ) ) for i , v := range a { if i == len ( a ) - 1 { fmt . Printf ( \" \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \\n \" , val ) } else { fmt . Printf ( \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \\n \" ) } else { fmt . Printf ( \" \" , a [ i ] ) } } fmt . Println ( count ) } var sc = bufio . NewScanner ( os . Stdin ) func nextInt ( ) int { sc . Scan ( ) i , e := strconv . Atoi ( sc . Text ( ) ) if e != nil { panic ( e ) } return i } func main ( ) { sc . Split ( bufio . ScanWords ) n := nextInt ( ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { a [ i ] = nextInt ( ) } bubleSort ( a , n ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , change , count int var a [ 100 ] int fmt . Scan ( & n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } k := 1 flag := true for flag == true { flag = false for j := n - 1 ; j >= k ; j -- { if a [ j ] < a [ j - 1 ] { change = a [ j ] a [ j ] = a [ j - 1 ] a [ j - 1 ] = change count + + flag = true } } k ++ } for i := 0 ; i < n - 1 ; i ++ { fmt . Printf ( \" \" , a [ i ] ) } fmt . Println ( a [ n - 1 ] ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , change , count int var a [ 100 ] int fmt . Scan ( & n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } k := 1 flag := true for flag == true { flag = false for j := n - 1 ; j >= k ; j -- { if a [ j ] < a [ j - 1 ] { change = a [ j ] a [ j ] = a [ j - 1 ] a [ j - 1 ] = change count + + flag = true } } k ++ } for i := 0 ; i < n - 1 ; i ++ { fmt . Printf ( \" \" , a [ i ] ) } fmt . Println ( a [ n - 1 ] ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % v \" \" [ ] \" ) fmt . Println ( str ) } func main ( ) { N := stdInInt ( ) A := stdInNumSlice ( ) i := 0 s := 0 for i < N { for j := N - 1 ; j >= 1 ; j -- { if A [ j ] < A [ j - 1 ] { tmp := A [ j ] A [ j ] = A [ j - 1 ] A [ j - 1 ] = tmp s + + } } i ++ } stdOutList ( & A ) fmt . Println ( s ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \" \" \\n % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \" for _ , inz := range intArray { reducedString += \" \" + strconv . FormatInt ( int64 ( inz ) , 10 ) } return strings . Trim ( reducedString , \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) s := make ( [ ] int , n ) for i := range s { fmt . Scan ( & s [ i ] ) } cnt := bubble_sort ( s ) for i , e := range s { fmt . Print ( e ) if i < n - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } fmt . Println ( cnt ) } func bubble_sort ( s [ ] int ) int { if cnt := step ( s ) ; cnt > 0 { return cnt + bubble_sort ( s ) } return 0 } func step ( s [ ] int ) int { if len ( s ) < 2 { return 0 } var cnt int s [ 0 ] , s [ 1 ] , cnt = swap ( s [ 0 ] , s [ 1 ] ) return cnt + step ( s [ 1 : ] ) } func swap ( a , b int ) ( int , int , int ) { if a > b { return b , a , 1 } return a , b , 0 }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) nums := make ( [ ] int , n ) for i := 0 ; i < len ( nums ) ; i ++ { fmt . Scan ( & nums [ i ] ) } bubbleSort ( nums ) } func bubbleSort ( nums [ ] int ) { count := 0 for i := 0 ; i < len ( nums ) ; i ++ { for j := len ( nums ) - 1 ; j > i ; j -- { if nums [ j - 1 ] > nums [ j ] { tmp := nums [ j ] nums [ j ] = nums [ j - 1 ] nums [ j - 1 ] = tmp count + + } } } for k := 0 ; k < len ( nums ) ; k ++ { fmt . Print ( nums [ k ] ) if k != len ( nums ) - 1 { fmt . Print ( \" \" ) } } fmt . Println ( \" \" ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" bufio \" \" os \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func bubbleSort ( a [ ] int ) ( count int ) { if len ( a ) <= 1 { return 0 } for i := 0 ; i < len ( a ) - 1 ; i ++ { if a [ i ] > a [ i + 1 ] { a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] count + + } } return count + bubbleSort ( a [ : len ( a ) - 1 ] ) } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , 0 , n ) for i := 0 ; i < n ; i ++ { var e int fmt . Scan ( & e ) a = append ( a , e ) } count := bubbleSort ( a ) for i , e := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( e ) } fmt . Println ( ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } func sort ( n int , as [ ] int ) { count := 0 flag := true for flag { flag = false for j := n - 1 ; j > 0 ; j - - { if as [ j ] < as [ j - 1 ] { a := as [ j ] as [ j ] = as [ j - 1 ] as [ j - 1 ] = a flag = true count = count + 1 } } } printArray ( as ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) } func bubbleSort ( A [ ] int , N int ) ( [ ] int , int ) { finished := true cnt := 0 for finished { finished = false for i := N - 1 ; i > 0 ; i -- { if A [ i ] < A [ i - 1 ] { A [ i ] , A [ i - 1 ] = A [ i - 1 ] , A [ i ] finished = true cnt + + } } } return A , cnt }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \\n % d \\n \" , input [ length - 1 ] , count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , v ) } else { fmt . Printf ( \" % d \" , v ) } } } func bubbleSort ( a [ ] int ) ( int , [ ] int ) { left := 0 n := len ( a ) ans := 0 for left < n - 1 { for i := n - 1 ; i >= left + 1 ; i -- { v := a [ i ] if v < a [ i - 1 ] { a [ i ] = a [ i - 1 ] a [ i - 1 ] = v ans ++ } } left ++ } return ans , a }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var num int fmt . Scan ( & num ) nums := make ( [ ] int , num ) for i := range nums { fmt . Scan ( & nums [ i ] ) } insertSort ( nums ) } func insertSort ( nums [ ] int ) { var count int for i := 0 ; i < len ( nums ) - 1 ; i ++ { for j := len ( nums ) - 1 ; j > i ; j -- { if nums [ j ] < nums [ j - 1 ] { tmp := nums [ j ] nums [ j ] = nums [ j - 1 ] nums [ j - 1 ] = tmp count + + } } } output ( nums , count ) } func output ( nums [ ] int , count int ) { for k := 0 ; k < len ( nums ) ; k ++ { if k != len ( nums ) - 1 { fmt . Print ( nums [ k ] , \" \" ) } else { fmt . Println ( nums [ k ] ) } } fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func bsort ( a [ ] int ) ( c int ) { flag := true n := len ( a ) for flag { flag = false for j := n - 1 ; j >= 1 ; j -- { if a [ j ] < a [ j - 1 ] { a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] flag = true c + + } } } return } func bsortx ( a [ ] int ) ( c int ) { n , i := len ( a ) , 0 flag := true for flag { flag = false for j := n - 1 ; j >= i + 1 ; j - - { if a [ j ] < a [ j - 1 ] { a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] flag = true c + + } } i + + } return } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } c := bsortx ( a ) for i := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) fmt . Println ( c ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) fmt . Println ( c ) } func scanInt ( sc * bufio . Scanner ) int { t := sc . Text ( ) i , err := strconv . Atoi ( t ) if err != nil { panic ( err ) } return i } func scanIntArray ( sc * bufio . Scanner ) [ ] int { t := sc . Text ( ) ss := strings . Split ( t , \" \" ) is := [ ] int { } for _ , s := range ss { i , err := strconv . Atoi ( s ) if err != nil { panic ( err ) } is = append ( is , i ) } return is }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" [ ] \" ) fmt . Println ( s ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( arr [ ] int ) { for i , e := range arr { if i == len ( arr ) - 1 { fmt . Printf ( \" \\n \" , e ) } else { fmt . Printf ( \" \" , e ) } } } func bubbleSort ( arr [ ] int , len int ) { count := 0 change := true for i := 0 ; change ; i ++ { change = false for j := len - 1 ; j > i ; j -- { if arr [ j - 1 ] > arr [ j ] { arr [ j - 1 ] , arr [ j ] = arr [ j ] , arr [ j - 1 ] change = true count + + } } } trace ( arr ) fmt . Println ( count ) } func main ( ) { var n int fmt . Scan ( & n ) arr := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & arr [ i ] ) } bubbleSort ( arr , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" convert error \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } } func babbleSort ( a [ ] int ) ( [ ] int , int ) { count := 0 flag := true for flag { flag = false for i := len ( a ) - 1 ; i >= 1 ; i -- { if a [ i ] < a [ i - 1 ] { a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] flag = true count + + } } } return a , count } func main ( ) { sc = bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( ) a := make ( [ ] int , n ) for i , _ := range a { a [ i ] = nextInt ( ) } a , count := babbleSort ( a ) printList ( a ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } fmt . Println ( exchangeCnt ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scanln ( & n ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } swapNum := 0 for i := 0 ; i < n ; i ++ { for j := n - 1 ; j >= i + 1 ; j -- { if a [ j ] < a [ j - 1 ] { a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] swapNum + + } } } for i := 0 ; i < n ; i ++ { if i < n - 1 { fmt . Printf ( \" \" , a [ i ] ) } else { fmt . Println ( a [ i ] ) } } fmt . Println ( swapNum ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var N int fmt . Scan ( & N ) nums := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & nums [ i ] ) } var count int flag := true for flag { flag = false for i := N - 1 ; 0 < i ; i -- { if nums [ i ] < nums [ i - 1 ] { nums [ i ] , nums [ i - 1 ] = nums [ i - 1 ] , nums [ i ] count + + flag = true } } } for i , v := range nums { if i != 0 { fmt . Print ( \" \" ) } fmt . Print ( v ) } fmt . Println ( ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var ( n , count int list [ ] int ) fmt . Scan ( & n ) list = make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & list [ i ] ) } count = bubble_sort ( list , n ) list_print ( list ) fmt . Println ( count ) } func bubble_sort ( a [ ] int , n int ) ( count int ) { var ( flag bool = true ) count = 0 for flag { flag = false for i := n - 1 ; i > 0 ; i - - { if a [ i ] < a [ i - 1 ] { a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] flag = true count + + } } } return } func list_print ( list [ ] int ) { var i int for i = 0 ; i < len ( list ) ; i + + { if i == 0 { fmt . Print ( list [ i ] ) } else { fmt . Print ( \" \" , list [ i ] ) } } fmt . Print ( \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % v \\n \" , strings . Join ( strValues , \" \" ) ) } func bubbleSort ( values [ ] int ) int { flag := true count := 0 for { if ! flag { break } flag = false for j := len ( values ) - 1 ; j >= 1 ; j -- { if values [ j ] < values [ j - 1 ] { tmp := values [ j ] values [ j ] = values [ j - 1 ] values [ j - 1 ] = tmp count + + flag = true } } } return count } func main ( ) { var arraySize int fmt . Scan ( & arraySize ) values := make ( [ ] int , arraySize ) sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) for i := 0 ; i < arraySize ; i ++ { sc . Scan ( ) s := sc . Text ( ) values [ i ] , _ = strconv . Atoi ( s ) } count := bubbleSort ( values ) printIntArray ( values ) fmt . Printf ( \" \\n \" , count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( A [ ] int , N int ) { for i := 0 ; i < N ; i ++ { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , A [ i ] ) } fmt . Printf ( \" \\n \" ) } func bubbleSort ( A [ ] int , N int ) { exchangeCount := 0 flag := true for flag { flag = false for j := N - 1 ; j > 0 ; j - - { if A [ j ] < A [ j - 1 ] { A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] exchangeCount + + flag = true } } } trace ( A , N ) fmt . Println ( exchangeCount ) } func main ( ) { var length int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \\n \" ) } func main ( ) { N := scanInt ( ) var target [ ] int sc . Scan ( ) str := strings . Split ( sc . Text ( ) , \" \" ) for i := 0 ; i < N ; i ++ { strInt , _ := strconv . Atoi ( str [ i ] ) target = append ( target , strInt ) } sorted , counter := bubbleSort ( target ) printSlice ( sorted ) fmt . Println ( counter ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func scanNums ( len int ) ( nums [ ] int ) { var num int for i := 0 ; i < len ; i ++ { fmt . Scan ( & num ) nums = append ( nums , num ) } return } func bubbleSort ( A [ ] int , N int ) int { cnt := 0 sortRequired := true for sortRequired { sortRequired = false for j := N - 1 ; j > 0 ; j -- { if A [ j ] < A [ j - 1 ] { A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] sortRequired = true cnt + + } } } return cnt } func main ( ) { var N int fmt . Scan ( & N ) nums := scanNums ( N ) cnt := bubbleSort ( nums , N ) fmt . Print ( nums [ 0 ] ) for i := 1 ; i < N ; i ++ { fmt . Print ( \" \" ) fmt . Print ( nums [ i ] ) } fmt . Print ( \" \\n \" ) fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" % v \\n % d \\n \" , strings . Trim ( fmt . Sprint ( a ) , \" \" ) , c ) } func bubbleSort ( e [ ] int , n int ) ( [ ] int , int ) { flag := true c := 0 for flag { flag = false for j := n - 1 ; j > 0 ; j -- { if e [ j ] < e [ j - 1 ] { tmp := e [ j ] e [ j ] = e [ j - 1 ] e [ j - 1 ] = tmp flag = true c + + } } } return e , c }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) } func nextString ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) int64 { i , err := strconv . ParseInt ( nextString ( sc ) , 10 , 64 ) if err != nil { panic ( err ) } return i }",
    "label": 4
  },
  {
    "code": "package main import \" \" func sort ( a [ ] int ) int { done := true n := len ( a ) c := 0 for done { done = false for j := n - 1 ; j >= 1 ; j -- { if a [ j ] < a [ j - 1 ] { a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] c + + done = true } } } return c } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } x := sort ( a ) for i , e := range a { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , e ) } fmt . Printf ( \" \\n \" ) fmt . Println ( x ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func BubbleSort ( a [ ] int ) ( [ ] int , int ) { var count int flag := true for flag { flag = false for i := len ( a ) - 1 ; i > 0 ; i -- { if a [ i ] < a [ i - 1 ] { a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] flag = true count + + } } } return a , count } func printArray ( b [ ] int ) { for i , v := range b { fmt . Print ( v ) if i < len ( b ) - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } b , count := BubbleSort ( a ) printArray ( b ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \\n \" ) } func bubbleSort ( arr [ ] int ) ( arr2 [ ] int , count int ) { flag := 1 for { if flag == 0 { break } flag = 0 for i := len ( arr ) - 1 ; i > 0 ; i -- { if arr [ i ] < arr [ i - 1 ] { tmp := arr [ i ] arr [ i ] = arr [ i - 1 ] arr [ i - 1 ] = tmp flag = 1 count + + } } } arr2 = arr return } func main ( ) { var n int fmt . Scan ( & n ) line := nextLine ( ) arrString := strings . Split ( line , \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" \" \" \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" log \" \" % d \" \" % d \" \" % d \" \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func bubbleSort ( a [ ] int , n int ) { flag := true count := 0 for flag { flag = false for i := n - 1 ; i > 0 ; i -- { if a [ i ] < a [ i - 1 ] { tmp := a [ i ] a [ i ] = a [ i - 1 ] a [ i - 1 ] = tmp flag = true count + + } } } for i := 0 ; i < n ; i ++ { fmt . Print ( a [ i ] ) if i != n - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } fmt . Println ( count ) } func main ( ) { var n int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { flag := 0 var temp int var counter int fmt . Scanf ( \" % d \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" err : \" , err ) os . Exit ( 1 ) } bc . Scan ( ) arrayStr := strings . Fields ( bc . Text ( ) ) var arrayInt [ ] int for _ , elem := range arrayStr { newElem , err := strconv . Atoi ( elem ) if err != nil { fmt . Println ( \" \" , err ) } arrayInt = append ( arrayInt , newElem ) } for i := len ; 0 < i ; i -- { for j := 0 ; j < i - 1 ; j ++ { if arrayInt [ j ] > arrayInt [ j + 1 ] { tmp = arrayInt [ j ] arrayInt [ j ] = arrayInt [ j + 1 ] arrayInt [ j + 1 ] = tmp changeTime + + } } } for i , elem := range arrayInt { if i != len - 1 { fmt . Printf ( \" \" , elem ) } else { fmt . Printf ( \" \\n \" , elem ) } } fmt . Println ( changeTime ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \" \" strings \" \" \" \" \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func BubbleSort ( A [ ] int ) int { var cnt int for i := 0 ; i < len ( A ) - 1 ; i ++ { for j := len ( A ) - 1 ; j >= i + 1 ; j -- { if A [ j ] < A [ j - 1 ] { A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] cnt + + } } } return cnt } func main ( ) { var n int fmt . Scan ( & n ) A := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & A [ i ] ) } cnt := BubbleSort ( A ) for i := 0 ; i < n ; i ++ { fmt . Print ( A [ i ] ) if i == n - 1 { fmt . Print ( \" \\n \" ) } else { fmt . Print ( \" \" ) } } fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \" \" % d \" \" \\n % d \\n \" , count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" bufio \" \" os \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } s := selection ( a ) for i := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) fmt . Println ( s ) } func bubble ( a [ ] int ) int { s := 0 for i := 0 ; i < len ( a ) ; i ++ { for j := len ( a ) - 1 ; j >= i + 1 ; j -- { if a [ j - 1 ] > a [ j ] { a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] s + + } } } return s } func selection ( a [ ] int ) int { s := 0 for i := 0 ; i < len ( a ) ; i ++ { mini := i for j := i ; j < len ( a ) ; j ++ { if a [ j ] < a [ mini ] { mini = j } } if i != mini { a [ i ] , a [ mini ] = a [ mini ] , a [ i ] s + + } } return s }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( A [ ] int , n int ) { for i := 0 ; i < n ; i ++ { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , A [ i ] ) } fmt . Printf ( \" \\n \" ) } func main ( ) { var N int fmt . Scan ( & N ) A := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & A [ i ] ) } count := 0 for i := 0 ; i < N ; i ++ { min_i := i for j := i ; j < N ; j ++ { if A [ j ] < A [ min_i ] { min_i = j } } if i != min_i { A [ i ] , A [ min_i ] = A [ min_i ] , A [ i ] count + + } } trace ( A , N ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := [ ] int { } for i := 0 ; i < n ; i ++ { var aa int fmt . Scan ( & aa ) a = append ( a , aa ) } c := 0 for i := 0 ; i < n ; i ++ { minj := i for j := i + 1 ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } if i != minj { a [ i ] , a [ minj ] = a [ minj ] , a [ i ] c + + } } fmt . Print ( a [ 0 ] ) for i := 1 ; i < n ; i ++ { fmt . Print ( \" \" ) fmt . Print ( a [ i ] ) } fmt . Println ( ) fmt . Println ( c ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } swapCount := 0 for i := 0 ; i < n ; i ++ { minIndex := i for j := i ; j < n ; j ++ { if a [ j ] < a [ minIndex ] { minIndex = j } } if a [ i ] > a [ minIndex ] { swapCount + + a [ i ] , a [ minIndex ] = a [ minIndex ] , a [ i ] } } str := fmt . Sprint ( a ) fmt . Println ( str [ 1 : len ( str ) - 1 ] ) fmt . Println ( swapCount ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } func nextInt ( sc * bufio . Scanner ) int { sc . Scan ( ) n , err := strconv . Atoi ( sc . Text ( ) ) if err != nil { panic ( err ) } return n } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( sc ) as := [ ] int { } for i := 0 ; i < n ; i ++ { x := nextInt ( sc ) as = append ( as , x ) } SelectionSort ( n , as ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % v \" \" [ ] \" ) fmt . Println ( arrStr ) fmt . Println ( swapCnt ) } func main ( ) { sc . Split ( bufio . ScanWords ) arrNum := nextInt ( ) arr := make ( [ ] int , arrNum ) for i := range arr { arr [ i ] = nextInt ( ) } selectionSort ( arr ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func selectionSort ( a [ ] int , n int ) ( [ ] int , int ) { var cnt int for i := 0 ; i < n ; i ++ { minj := i for j := i ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } a [ i ] , a [ minj ] = a [ minj ] , a [ i ] if i != minj { cnt + + } } return a , cnt } func main ( ) { var n , cnt int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } a , cnt = selectionSort ( a , len ( a ) ) for i , v := range a { if i == len ( a ) - 1 { fmt . Printf ( \" \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % d \\n \" , val ) } else { fmt . Printf ( \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" ) ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) } func nextInts ( num int , sc * bufio . Scanner ) ( [ ] int , error ) { res := make ( [ ] int , num ) for i , _ := range res { x , err := nextInt ( sc ) if err != nil { return nil , err } res [ i ] = x } return res , nil }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n , change , count int var a [ 100 ] int fmt . Scan ( & n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } for i := 0 ; i < n ; i ++ { minj := i for j := i ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } change = a [ i ] a [ i ] = a [ minj ] a [ minj ] = change if i != minj { count + + } } for i := 0 ; i < n - 1 ; i ++ { fmt . Printf ( \" \" , a [ i ] ) } fmt . Println ( a [ n - 1 ] ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % v \" \" [ ] \" ) fmt . Println ( str ) } func main ( ) { N := stdInInt ( ) A := stdInNumSlice ( ) i := 0 s := 0 for i < N - 1 { min := i for j := i ; j < N ; j ++ { if A [ j ] < A [ min ] { min = j } } if A [ min ] != A [ i ] { tmp := A [ min ] A [ min ] = A [ i ] A [ i ] = tmp s + + } i + + } stdOutList ( & A ) fmt . Println ( s ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % d \" \" \\n % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \" for _ , inz := range intArray { reducedString += \" \" + strconv . FormatInt ( int64 ( inz ) , 10 ) } return strings . Trim ( reducedString , \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) v := make ( [ ] int , n ) for i := range v { fmt . Scan ( & v [ i ] ) } p , c := selectionSort ( v ) for i , e := range p { fmt . Print ( e ) if i < len ( p ) - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } fmt . Println ( c ) } func selectionSort ( v [ ] int ) ( [ ] int , int ) { if len ( v ) == 0 { return [ ] int { } , 0 } a , p , c := step ( v , v [ 0 ] ) pp , cc := selectionSort ( p [ 1 : ] ) return append ( [ ] int { a } , pp ... ) , c + cc } func step ( v [ ] int , s int ) ( int , [ ] int , int ) { if len ( v ) == 0 { return s , v , 0 } a , p , _ := step ( v [ 1 : ] , s ) if v [ 0 ] > a { return a , append ( [ ] int { v [ 0 ] } , p ... ) , 1 } return v [ 0 ] , append ( [ ] int { s } , v [ 1 : ] ... ) , 0 }",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var n int fmt . Scan ( & n ) nums := make ( [ ] int , n ) for i := 0 ; i < len ( nums ) ; i ++ { fmt . Scan ( & nums [ i ] ) } selectionSort ( nums ) } func selectionSort ( nums [ ] int ) { count := 0 for i := 0 ; i < len ( nums ) ; i ++ { minj := i for j := i ; j < len ( nums ) ; j ++ { if nums [ j ] < nums [ minj ] { minj = j } } if i != minj { nums [ i ] , nums [ minj ] = nums [ minj ] , nums [ i ] count + + } } for i := 0 ; i < len ( nums ) ; i ++ { fmt . Print ( nums [ i ] ) if i == len ( nums ) - 1 { fmt . Println ( \" \" ) } else { fmt . Print ( \" \" ) } } fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" bufio \" \" os \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func selectionSort ( a [ ] int ) ( count int ) { if len ( a ) <= 1 { return } minI := minIndex ( a ) if minI != 0 { a [ 0 ] , a [ minI ] = a [ minI ] , a [ 0 ] count + + } count + = selectionSort ( a [ 1 : ] ) return } func minIndex ( a [ ] int ) ( index int ) { min := a [ 0 ] for i , e := range a { if min > e { min = e index = i } } return } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } count := selectionSort ( a ) for i , e := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( e ) } fmt . Println ( ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } func sort ( as [ ] int , n int ) { cnt := 0 for i := 0 ; i < n ; i ++ { minIndex := i for j := i ; j < n ; j ++ { a := as [ j ] if as [ minIndex ] > a { minIndex = j } } if minIndex != i { tmp := as [ i ] as [ i ] = as [ minIndex ] as [ minIndex ] = tmp cnt = cnt + 1 } } printArray ( as ) fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) } func selectionSort ( A [ ] int , N int ) ( [ ] int , int ) { var cnt int for i := 0 ; i < N ; i ++ { minj := i for j := i ; j < N ; j ++ { if A [ j ] < A [ minj ] { minj = j } } if A [ i ] != A [ minj ] { A [ i ] , A [ minj ] = A [ minj ] , A [ i ] cnt + + } } return A , cnt }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , v ) } else { fmt . Printf ( \" % d \" , v ) } } } func selectionSort ( a [ ] int , n int ) ( [ ] int , int ) { ans := 0 for i := 0 ; i < n - 1 ; i ++ { mini := i for j := i ; j < n ; j ++ { if a [ mini ] > a [ j ] { mini = j } } minv := a [ mini ] a [ mini ] = a [ i ] a [ i ] = minv if i != mini { ans ++ } } return a , ans }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var num int fmt . Scan ( & num ) nums := make ( [ ] int , num ) for i := range nums { fmt . Scan ( & nums [ i ] ) } selectSort ( nums ) } func selectSort ( nums [ ] int ) { var count int for i := 0 ; i < len ( nums ) ; i ++ { min := nums [ i ] minPosition := i for j := i ; j < len ( nums ) ; j ++ { if min > nums [ j ] { min = nums [ j ] minPosition = j } } if i != minPosition { tmp := nums [ i ] nums [ i ] = nums [ minPosition ] nums [ minPosition ] = tmp count + + } } output ( nums , count ) } func output ( nums [ ] int , count int ) { for k := 0 ; k < len ( nums ) ; k ++ { if k != len ( nums ) - 1 { fmt . Print ( nums [ k ] , \" \" ) } else { fmt . Println ( nums [ k ] ) } } fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func min ( a , b int ) int { if a < b { return a } return b } func ssort ( a [ ] int ) ( sw int ) { n := len ( a ) for i := 0 ; i < n ; i ++ { minv := a [ i ] mini := i for j := i + 1 ; j < n ; j ++ { if minv > a [ j ] { minv = a [ j ] mini = j } } if i != mini { a [ mini ] , a [ i ] = a [ i ] , a [ mini ] sw + + } } return } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } sw := ssort ( a ) for i := range a { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( a [ i ] ) } fmt . Println ( ) fmt . Println ( sw ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" [ ] \" ) fmt . Println ( s ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( arr [ ] int ) { for i , e := range arr { if i == len ( arr ) - 1 { fmt . Printf ( \" \\n \" , e ) } else { fmt . Printf ( \" \" , e ) } } } func selectionSort ( arr [ ] int , len int ) { count := 0 for i := 0 ; i < len ; i ++ { minIndex := i for j := i + 1 ; j < len ; j ++ { if arr [ j ] < arr [ minIndex ] { minIndex = j } } if i != minIndex { arr [ i ] , arr [ minIndex ] = arr [ minIndex ] , arr [ i ] count + + } } trace ( arr ) fmt . Println ( count ) } func main ( ) { var n int fmt . Scan ( & n ) arr := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & arr [ i ] ) } selectionSort ( arr , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } } func selectionSort ( a [ ] int ) ( [ ] int , int ) { count := 0 minj := 0 for i := range a { minj = i for j := i ; j < len ( a ) ; j ++ { if a [ minj ] > a [ j ] { minj = j } } if i != minj { a [ i ] , a [ minj ] = a [ minj ] , a [ i ] count + + } } return a , count } func main ( ) { sc = bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( ) a := make ( [ ] int , n ) for i := range a { a [ i ] = nextInt ( ) } a , count := selectionSort ( a ) printList ( a ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , v ) } else { fmt . Printf ( \" \" , v ) } } fmt . Println ( exchangeCnt ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var N int fmt . Scan ( & N ) arr := make ( [ ] int , N ) for i := 0 ; i < N ; i ++ { fmt . Scan ( & arr [ i ] ) } var count int for i := 0 ; i < N ; i ++ { min := i for j := i ; j < N ; j ++ { if arr [ j ] < arr [ min ] { min = j } } if i != min { arr [ i ] , arr [ min ] = arr [ min ] , arr [ i ] count + + } } for i , v := range arr { if i != 0 { fmt . Print ( \" \" ) } fmt . Print ( v ) } fmt . Println ( ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var ( n , count int list [ ] int ) fmt . Scan ( & n ) list = make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & list [ i ] ) } count = selection_sort ( list , n ) list_print ( list ) fmt . Println ( count ) } func selection_sort ( a [ ] int , n int ) ( count int ) { var minj int for i , _ := range a { minj = i for j := i ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } a [ i ] , a [ minj ] = a [ minj ] , a [ i ] if ( minj != i ) { count ++ } } return } func list_print ( list [ ] int ) { for i , val := range list { if i == 0 { fmt . Print ( val ) } else { fmt . Print ( \" \" , val ) } } fmt . Println ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } fmt . Println ( count ) } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Scan ( ) n , _ := strconv . Atoi ( sc . Text ( ) ) sc . Scan ( ) var sl = make ( [ ] int , n ) for i , s := range strings . Split ( sc . Text ( ) , \" \" ) { sl [ i ] , _ = strconv . Atoi ( s ) } SelectionSort ( sl , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % v \\n \" , strings . Join ( strValues , \" \" ) ) } func selectionSort ( values [ ] int ) int { count := 0 for i := 0 ; i < len ( values ) ; i ++ { minj := i for j := i ; j < len ( values ) ; j ++ { if values [ j ] < values [ minj ] { minj = j } } if i != minj { tmp := values [ i ] values [ i ] = values [ minj ] values [ minj ] = tmp count + + } } return count } func main ( ) { var arraySize int fmt . Scan ( & arraySize ) values := make ( [ ] int , arraySize ) sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) for i := 0 ; i < arraySize ; i ++ { sc . Scan ( ) s := sc . Text ( ) values [ i ] , _ = strconv . Atoi ( s ) } count := selectionSort ( values ) printIntArray ( values ) fmt . Printf ( \" \\n \" , count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func trace ( A [ ] int , N int ) { for i := 0 ; i < N ; i ++ { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , A [ i ] ) } fmt . Printf ( \" \\n \" ) } func selectionSort ( A [ ] int , N int ) { var exchangeCount int for i := 0 ; i < N ; i ++ { minj := i for j := i ; j < N ; j ++ { if A [ j ] < A [ minj ] { minj = j } } if i != minj { A [ i ] , A [ minj ] = A [ minj ] , A [ i ] exchangeCount + + } } trace ( A , N ) fmt . Println ( exchangeCount ) } func main ( ) { var length int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" \\n \" ) } func main ( ) { N := scanInt ( ) var unSorted [ ] int sc . Scan ( ) line := strings . Split ( sc . Text ( ) , \" \" ) for i := 0 ; i < N ; i ++ { number , e := strconv . Atoi ( line [ i ] ) if e != nil { log . Fatal ( e ) } unSorted = append ( unSorted , number ) } sorted , counter := selectionSort ( unSorted ) printSlice ( sorted ) fmt . Println ( counter ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" % v \\n % d \\n \" , strings . Trim ( fmt . Sprint ( a ) , \" \" ) , c ) } func selectionSort ( e [ ] int , n int ) ( [ ] int , int ) { cnt := 0 for i := 0 ; i < n ; i ++ { minj := i for j := i ; j < n ; j ++ { if e [ j ] < e [ minj ] { minj = j } } if i != minj { tmp := e [ i ] e [ i ] = e [ minj ] e [ minj ] = tmp cnt + + } } return e , cnt }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) } func nextString ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) int64 { i , err := strconv . ParseInt ( nextString ( sc ) , 10 , 64 ) if err != nil { panic ( err ) } return i }",
    "label": 4
  },
  {
    "code": "package main import \" \" func sort ( a [ ] int ) int { n := len ( a ) c := 0 for i := range a { minj := i for j := i ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } a [ i ] , a [ minj ] = a [ minj ] , a [ i ] if minj != i { c + + } } return c } func main ( ) { n := 0 fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := range a { fmt . Scan ( & a [ i ] ) } x := sort ( a ) for i , e := range a { if i > 0 { fmt . Printf ( \" \" ) } fmt . Printf ( \" \" , e ) } fmt . Printf ( \" \\n \" ) fmt . Println ( x ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" func SelectionSort ( a [ ] int ) ( [ ] int , int ) { var minj , count int n := len ( a ) for i := 0 ; i < n ; i ++ { minj = i for j := i ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } if a [ i ] > a [ minj ] { a [ i ] , a [ minj ] = a [ minj ] , a [ i ] count + + } } return a , count } func printArray ( b [ ] int ) { for i , v := range b { fmt . Print ( v ) if i < len ( b ) - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } } func main ( ) { var n int fmt . Scan ( & n ) a := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & a [ i ] ) } b , count := SelectionSort ( a ) printArray ( b ) fmt . Println ( count ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % d \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" \" \" \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" % s % d \" \" \" \\n \" \\r \\n \" ) } func eGetInt ( r * bufio . Reader ) int { line := eGetLine ( r ) return eAtoi ( line ) } func eGetInts ( r * bufio . Reader ) [ ] int { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) var ints [ ] int for _ , f := range fields { ints = append ( ints , eAtoi ( f ) ) } return ints } func eAtoi ( s string ) int { n , err := strconv . Atoi ( s ) if err != nil { log . Fatal ( err ) } return n }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" log \" \" % d \" \" % d \" \" % d \" \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func selectionSort ( a [ ] int , n int ) { var count int for i := 0 ; i < n ; i ++ { minj := i for j := i ; j < n ; j ++ { if a [ j ] < a [ minj ] { minj = j } } if minj != i { tmp := a [ i ] a [ i ] = a [ minj ] a [ minj ] = tmp count + + } } for i := 0 ; i < n ; i ++ { fmt . Print ( a [ i ] ) if i < n - 1 { fmt . Print ( \" \" ) } else { fmt . Println ( ) } } fmt . Println ( count ) } func main ( ) { var n int fmt . Scanf ( \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var counter , temp , flag int fmt . Scanf ( \" % d \" \" % d \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" err : \" , err ) os . Exit ( 1 ) } bc . Scan ( ) arrayStr := strings . Fields ( bc . Text ( ) ) var arrayInt [ ] int for _ , elem := range arrayStr { newElem , err := strconv . Atoi ( elem ) if err != nil { fmt . Println ( \" \" , err ) } arrayInt = append ( arrayInt , newElem ) } change := SelectSort ( arrayInt ) for i , elem := range arrayInt { if i != len - 1 { fmt . Printf ( \" \" , elem ) } else { fmt . Printf ( \" \\n \" , elem ) } } fmt . Println ( change ) } func SelectSort ( elems [ ] int ) int { var len = len ( elems ) var change , count int for i := 0 ; i < len - 1 ; i ++ { min := i for j := i + 1 ; j < len ; j ++ { if elems [ j ] < elems [ min ] { min = j change = 1 } } if change == 1 { tmp := elems [ i ] elems [ i ] = elems [ min ] elems [ min ] = tmp count + + change = 0 } } return count }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" Stable \" \" Not stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" Stable \" \" Stable \" \" Not stable \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" reflect \" \" strconv \" \" strings \" \" \" \" % s % d \" \" % s % d \" \" \\n Stable \" \" \\n Not stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" \" \" Stable \" \" \" \" Stable \" \" Not stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" Stable \" \" Not stable \" \" Stable \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" ) func main ( ) { var n int fmt . Scan ( & n ) arr := [ ] string { } for i := 0 ; i < n ; i ++ { var str string fmt . Scan ( & str ) arr = append ( arr , str ) } arr2 := make ( [ ] string , len ( arr ) ) copy ( arr2 , arr ) flag := 1 for flag > 0 { flag = 0 for j := n - 1 ; j > 0 ; j -- { if arr [ j - 1 ] [ 1 ] > arr [ j ] [ 1 ] { arr [ j - 1 ] , arr [ j ] = arr [ j ] , arr [ j - 1 ] flag = 1 } } } fmt . Print ( arr [ 0 ] ) for i := 1 ; i < n ; i ++ { fmt . Print ( \" \" ) fmt . Print ( arr [ i ] ) } fmt . Println ( ) fmt . Println ( \" \" ) for i := 0 ; i < n ; i ++ { minj := i for j := i + 1 ; j < n ; j ++ { if arr2 [ j ] [ 1 ] < arr2 [ minj ] [ 1 ] { minj = j } } arr2 [ i ] , arr2 [ minj ] = arr2 [ minj ] , arr2 [ i ] } stable := true fmt . Print ( arr2 [ 0 ] ) stable = stable && arr [ 0 ] == arr2 [ 0 ] for i := 1 ; i < n ; i ++ { fmt . Print ( \" \" ) fmt . Print ( arr2 [ i ] ) stable = stable && arr [ i ] == arr2 [ i ] } fmt . Println ( ) if stable { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" Stable \" \" Stable \" \" Not stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" \" \" Stable \" \" Stable \" \" Not stable \" \" \" \" % v % v \\n \" , n [ len ( n ) - 1 ] . mark , n [ len ( n ) - 1 ] . num ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" Stable \" \" Stable \" \" Not stable \" \" [ ] \" ) ) } func nextInt ( sc * bufio . Scanner ) int { sc . Scan ( ) n , err := strconv . Atoi ( sc . Text ( ) ) if err != nil { panic ( err ) } return n } func nextStr ( sc * bufio . Scanner ) string { sc . Scan ( ) s := sc . Text ( ) return s } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( sc ) var as [ ] string for i := 0 ; i < n ; i ++ { a := nextStr ( sc ) as = append ( as , a ) } stableSort ( n , as ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" Stable \" \" Not stable \" \" Stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" \" \" % s % d \\n \" , card . mark , card . num ) } else { fmt . Printf ( \" \" , card . mark , card . num ) } } if isStable ( Bdeck , Bdeck ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } for i , card := range Sdeck { if i == len ( Sdeck ) - 1 { fmt . Printf ( \" \\n \" , card . mark , card . num ) } else { fmt . Printf ( \" \" , card . mark , card . num ) } } if isStable ( Bdeck , Sdeck ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" reflect \" \" Stable \" \" Stable \" \" Not stable \" \" % s % d \" \" % s % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" reflect \" \" Stable \" \" Stable \" \" Not stable \" \" % s % d \" \" % s % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" Stable \" \" Not stable \" \" Stable \" \" Not stable \" \" \" for _ , card := range cardArray { reducedString += \" \" + card . label } return strings . Trim ( reducedString , \" \" ) } type Card struct { label string } func ( c * Card ) toInt ( ) int { num , _ := strconv . Atoi ( string ( [ ] rune ( c . label ) [ 1 : ] ) ) return num } func ( c * Card ) toMark ( ) string { return string ( [ ] rune ( c . label ) [ 1 : ] ) } func isStable ( cardArray [ ] Card , formattedCardArray [ ] Card ) bool { checkedCardLabels := make ( [ ] string , 0 ) for _ , card := range formattedCardArray { for _ , otherCard := range cardArray { if otherCard . label == card . label { checkedCardLabels = append ( checkedCardLabels , card . label ) break } if otherCard . toInt ( ) == card . toInt ( ) && ! arrayContains ( checkedCardLabels , otherCard . label ) { return false } } } return true } func arrayContains ( arr [ ] string , str string ) bool { for _ , v := range arr { if v == str { return true } } return false }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % v \" \" [ ] \" ) fmt . Println ( str ) } func BubbleSort ( A [ ] string , N int ) { i := 0 s := 0 for i < N { for j := N - 1 ; j >= 1 ; j -- { if getNum ( A [ j ] ) < getNum ( A [ j - 1 ] ) { tmp := A [ j ] A [ j ] = A [ j - 1 ] A [ j - 1 ] = tmp s + + } } i ++ } } func getNum ( str string ) int { n , _ := strconv . Atoi ( str [ 1 : 2 ] ) return n } func getSuit ( str string ) string { return str [ 0 : 1 ] } func SelectionSort ( A [ ] string , N int ) { i := 0 s := 0 for i < N - 1 { min := i for j := i ; j < N ; j ++ { if getNum ( A [ j ] ) < getNum ( A [ min ] ) { min = j } } if getNum ( A [ min ] ) != getNum ( A [ i ] ) { tmp := A [ min ] A [ min ] = A [ i ] A [ i ] = tmp s + + } i + + } } func isStable ( A1 [ ] string , A2 [ ] string , N int ) bool { for i := 0 ; i < N ; i + + { if getSuit ( A1 [ i ] ) != getSuit ( A2 [ i ] ) { return false } } return true } func main ( ) { N := stdInInt ( ) A := stdInSlice ( ) A2 := make ( [ ] string , N ) copy ( A2 , A ) BubbleSort ( A , N ) stdOutList ( & A ) fmt . Println ( \" Stable \" \" Stable \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import \" \" func bubbleSort ( c [ ] Card ) { for i := 0 ; i < len ( c ) ; i ++ { for j := len ( c ) - 1 ; j > i ; j -- { if c [ j ] . num < c [ j - 1 ] . num { c [ j ] , c [ j - 1 ] = c [ j - 1 ] , c [ j ] } } } } func selectionSort ( c [ ] Card ) { for i := 0 ; i < len ( c ) ; i ++ { minj := i for j := i ; j < len ( c ) ; j ++ { if c [ j ] . num < c [ minj ] . num { minj = j } } c [ i ] , c [ minj ] = c [ minj ] , c [ i ] } } type Card struct { suit byte num int } func ( c Card ) String ( ) string { return fmt . Sprintf ( \" \" , c . suit , c . num ) } func main ( ) { var n int fmt . Scan ( & n ) c := make ( [ ] Card , n ) for i := range c { fmt . Scanf ( \" % c % d \" \" Stable \" ) } else { fmt . Println ( \" \" ) } c2 := make ( [ ] Card , n ) copy ( c2 , c ) selectionSort ( c2 ) printCards ( c2 ) if isSortedStably ( c , c2 ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } func printCards ( c [ ] Card ) { for i , e := range c { if i > 0 { fmt . Print ( \" \" ) } fmt . Print ( e ) } fmt . Println ( ) } func isSortedStably ( orig , res [ ] Card ) bool { if len ( res ) < 2 { return true } if res [ 0 ] . num == res [ 1 ] . num { if indexOf ( orig , res [ 0 ] ) > indexOf ( orig , res [ 1 ] ) { return false } } return isSortedStably ( orig , res [ 1 : ] ) } func indexOf ( c [ ] Card , card Card ) int { for i , e := range c { if e . suit == card . suit && e . num == card . num { return i } } return - 1 }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" Stable \" \" Stable \" \" Not stable \" \" [ ] \" ) ) } func toInt ( a string ) int { x , err := strconv . Atoi ( a [ 1 : 2 ] ) if err != nil { panic ( err ) } return x } func bubbleSort ( as [ ] string , n int ) [ ] string { for fixed := 0 ; fixed < n ; fixed + + { for j := n - 1 ; j > fixed ; j - - { if toInt ( as [ j - 1 ] ) > toInt ( as [ j ] ) { tmp := as [ j - 1 ] as [ j - 1 ] = as [ j ] as [ j ] = tmp } } } printArray ( as ) return as } func selectionSort ( as [ ] string , n int ) [ ] string { for i := 0 ; i < n ; i + + { min := i for j := i ; j < n ; j + + { if toInt ( as [ min ] ) > toInt ( as [ j ] ) { min = j } } tmp := as [ i ] as [ i ] = as [ min ] as [ min ] = tmp } printArray ( as ) return as }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" % d \" \" % s \" \" Stable \" \" Stable \" \" Not stable \" \" % s % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" [ ] \" ) ) fmt . Println ( isStable ( src , bS ) ) fmt . Println ( strings . Trim ( fmt . Sprint ( sS ) , \" \" ) ) fmt . Println ( isStable ( src , sS ) ) } func bubbleSort ( A [ ] string , N int ) [ ] string { for i := 0 ; i < N ; i ++ { for j := N - 1 ; j > i ; j -- { if A [ j ] [ 1 ] < A [ j - 1 ] [ 1 ] { A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] } } } return A } func selectionSort ( A [ ] string , N int ) [ ] string { for i := 0 ; i < N ; i ++ { minj := i for j := i ; j < N ; j ++ { if A [ j ] [ 1 ] < A [ minj ] [ 1 ] { minj = j } } if A [ i ] [ 1 ] != A [ minj ] [ 1 ] { A [ i ] , A [ minj ] = A [ minj ] , A [ i ] } } return A } func isStable ( in [ ] string , out [ ] string ) string { N := len ( in ) for i := 0 ; i < N ; i ++ { for j := i + 1 ; j < N ; j ++ { for a := 0 ; a < N ; a ++ { for b := a + 1 ; b < N ; b ++ { if in [ i ] [ 1 ] == in [ j ] [ 1 ] && in [ i ] == out [ b ] && in [ j ] == out [ a ] { return \" \" } } } } } return \" \" }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" Stable \" \" Stable \" \" Not stable \" \" % s \\n \" , v ) } else { fmt . Printf ( \" % s \" , v ) } } } func bubbleSort ( a [ ] string , n int ) [ ] string { left := 0 ans := 0 for left < n - 1 { for i := n - 1 ; i >= left + 1 ; i -- { v := a [ i ] if v [ 1 ] < a [ i - 1 ] [ 1 ] { a [ i ] = a [ i - 1 ] a [ i - 1 ] = v ans ++ } } left ++ } return a } func selectionSort ( a [ ] string , n int ) [ ] string { for i := 0 ; i < n - 1 ; i ++ { mini := i for j := i ; j < n ; j ++ { if a [ mini ] [ 1 ] > a [ j ] [ 1 ] { mini = j } } minv := a [ mini ] a [ mini ] = a [ i ] a [ i ] = minv } return a }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" Not stable \" \" Stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" Stable \" \" Not stable \" \" Stable \" \" \" \" % s % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" Stable \" \" Stable \" \" Not stable \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" reflect \" \" strconv \" \" strings \" \" Stable \" \" Not stable \" \" [ ] \" ) ) fmt . Println ( \" \" ) } func selectSort ( n int , a [ ] string ) { for i := 0 ; i < n ; i ++ { minj := i for j := i ; j < n ; j ++ { if intCard ( a [ j ] ) < intCard ( a [ minj ] ) { minj = j } } tmp := a [ minj ] a [ minj ] = a [ i ] a [ i ] = tmp } fmt . Println ( strings . Trim ( fmt . Sprint ( a ) , \" \" ) ) } func intCard ( s string ) int { return int ( [ ] rune ( s ) [ 1 ] - '0' ) } func scanInt ( sc * bufio . Scanner ) int { t := sc . Text ( ) i , err := strconv . Atoi ( t ) if err != nil { panic ( err ) } return i } func scanArray ( sc * bufio . Scanner ) [ ] string { t := sc . Text ( ) ss := strings . Split ( t , \" \" ) return ss }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" reflect \" \" % c % d \" \" \" \" Stable \" \" Stable \" \" Not stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" Stable \" \" Not stable \" \" Stable \" \" Not stable \" \" [ ] \" ) , ) } type Card struct { Source string } func ( c * Card ) String ( ) string { return c . Source } func ( c * Card ) Value ( ) int { i , e := strconv . Atoi ( string ( c . Source [ 1 ] ) ) checkErr ( e ) return i } func checkErr ( e error ) { if e != nil { log . Fatalln ( e ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" reflect \" \" strconv \" \" strings \" \" \" \" Stable \" \" Not stable \" \" Stable \" \" Not stable \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" % s \\n \" , card . inspect ( ) ) } else { fmt . Printf ( \" \" , card . inspect ( ) ) } } } func isEqual ( a , b [ ] Card ) bool { for i , e := range a { if e . inspect ( ) != b [ i ] . inspect ( ) { return false } } return true } func bubbleSort ( arr [ ] Card , len int ) [ ] Card { change := true for i := 0 ; change ; i + + { change = false for j := len - 1 ; j > i ; j - - { if arr [ j ] . value < arr [ j - 1 ] . value { arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] change = true } } } trace ( arr ) return arr } func selectionSort ( arr [ ] Card , len int ) [ ] Card { for i := 0 ; i < len ; i + + { minIndex := i for j := i + 1 ; j < len ; j + + { if arr [ j ] . value < arr [ minIndex ] . value { minIndex = j } } arr [ i ] , arr [ minIndex ] = arr [ minIndex ] , arr [ i ] } trace ( arr ) return arr } func main ( ) { var n int fmt . Scan ( & n ) cards := make ( [ ] Card , n ) var tmp string for i := 0 ; i < n ; i + + { fmt . Scan ( & tmp ) suit := string ( tmp [ 0 ] ) value , _ := strconv . Atoi ( string ( tmp [ 1 ] ) ) cards [ i ] = Card { suit , value } } bubble := make ( [ ] Card , n ) copy ( bubble , cards ) bubble = bubbleSort ( bubble , n ) fmt . Println ( \" Stable \" ) selection := make ( [ ] Card , n ) copy ( selection , cards ) selection = selectionSort ( selection , n ) if isEqual ( bubble , selection ) { fmt . Println ( \" Stable \" ) } else { fmt . Println ( \" Not stable \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } } type trump struct { kind string value int } func selectionSort ( a [ ] trump ) ( [ ] trump , int ) { count := 0 minj := 0 for i := range a { minj = i for j := i ; j < len ( a ) ; j ++ { if a [ minj ] . value > a [ j ] . value { minj = j } } if i != minj { a [ i ] , a [ minj ] = a [ minj ] , a [ i ] count + + } } return a , count } func babbleSort ( a [ ] trump ) ( [ ] trump , int ) { count := 0 flag := true for flag { flag = false for i := len ( a ) - 1 ; i >= 1 ; i -- { if a [ i ] . value < a [ i - 1 ] . value { a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] flag = true count + + } } } return a , count } func sliceEqual ( a , b [ ] trump ) bool { flag := true for i , v := range a { if v . kind != b [ i ] . kind || v . value != b [ i ] . value { flag = false break } } return flag } func main ( ) { sc = bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( ) a := make ( [ ] trump , n ) b := make ( [ ] trump , len ( a ) ) var input string for i := range a { input = nextString ( ) a [ i ] . kind = input [ : 1 ] a [ i ] . value , _ = strconv . Atoi ( input [ 1 : ] ) } copy ( b , a ) a , _ = babbleSort ( a ) b , _ = selectionSort ( b ) printList ( a ) fmt . Println ( \" \" ) printList ( b ) if sliceEqual ( a , b ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" reflect \" \" strconv \" \" strings \" \" % + v \" \" ] \" ) ) } func printStableorNot ( arr1 , arr2 [ ] string ) { if reflect . DeepEqual ( arr1 , arr2 ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } func main ( ) { scanner . Split ( bufio . ScanWords ) size , _ := nextInt ( ) arr := make ( [ ] string , size ) for i := 0 ; i < size ; i ++ { arr [ i ] = nextString ( ) } arrInsertion := insertionSort ( arr ) arrBubble := bubbleSort ( arr ) printArr ( arrBubble ) printStableorNot ( arrInsertion , arrBubble ) arrSelection := selectionSort ( arr ) printArr ( arrSelection ) printStableorNot ( arrInsertion , arrSelection ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" Stable \" \" Not stable \" \" Stable \" \" Not stable \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" type card struct { suite byte num int } func bsort ( c [ ] card ) { for i := 0 ; i < len ( c ) ; i ++ { for j := len ( c ) - 1 ; j > i ; j -- { if c [ j - 1 ] . num > c [ j ] . num { c [ j - 1 ] , c [ j ] = c [ j ] , c [ j - 1 ] } } } } func ssort ( c [ ] card ) { for i := 0 ; i < len ( c ) ; i ++ { minv := c [ i ] . num mini := i for j := i + 1 ; j < len ( c ) ; j ++ { if minv > c [ j ] . num { minv = c [ j ] . num mini = j } } c [ i ] , c [ mini ] = c [ mini ] , c [ i ] } } func printcards ( c [ ] card ) { for i := 0 ; i < len ( c ) ; i ++ { fmt . Printf ( \" \" , c [ i ] . suite , c [ i ] . num ) if i != len ( c ) - 1 { fmt . Printf ( \" \" ) } } fmt . Println ( ) } func main ( ) { var n int fmt . Scan ( & n ) cards := make ( [ ] card , n ) cardsb := make ( [ ] card , n ) cardss := make ( [ ] card , n ) for i := range cards { var s string fmt . Scan ( & s ) cards [ i ] . suite = s [ 0 ] cards [ i ] . num = int ( s [ 1 ] - '0' ) } copy ( cardsb , cards ) copy ( cardss , cards ) bsort ( cardsb ) printcards ( cardsb ) fmt . Println ( \" \" ) ssort ( cardss ) printcards ( cardss ) for i := 0 ; i < n ; i ++ { if cardss [ i ] . suite != cardsb [ i ] . suite { fmt . Println ( \" \" ) return } } fmt . Println ( \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" Stable \" \" Not stable \" \" Stable \" \" Not stable \" \" \" \" % s \\n \" , C [ i ] . ToString ( ) ) } else { fmt . Printf ( \" % s \" , C [ i ] . ToString ( ) ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s % d \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Scan ( ) n , _ := strconv . Atoi ( sc . Text ( ) ) cards1 := make ( [ ] Card , n ) cards2 := make ( [ ] Card , n ) sc . Scan ( ) for i , s := range strings . Split ( sc . Text ( ) , \" \" ) { num , _ := strconv . Atoi ( string ( s [ 1 ] ) ) card := Card { Sym : string ( s [ 0 ] ) , Num : num } cards1 [ i ] = card } copy ( cards2 , cards1 ) BubbleSort03_5 ( cards1 , n ) PrintNoParenthesis03_5 ( cards1 ) fmt . Println ( \" \" ) SelectionSort03_5 ( cards2 , n ) PrintNoParenthesis03_5 ( cards2 ) isStable := true for i , _ := range cards1 { if cards1 [ i ] != cards2 [ i ] { isStable = false break } } if isStable { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" \" \" Stable \" \" Stable \" \" Not stable \" \" \" , value ) } } fmt . Println ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s % d \" \" % v \" \" % v \\n \" , strings . Join ( strValues , \" \" ) ) } func bubbleSort ( tr [ ] trump ) int { flag := true count := 0 for { if ! flag { break } flag = false for j := len ( tr ) - 1 ; j >= 1 ; j -- { if tr [ j ] . value < tr [ j - 1 ] . value { tmp := tr [ j ] tr [ j ] = tr [ j - 1 ] tr [ j - 1 ] = tmp count + + flag = true } } } return count } func selectionSort ( tr [ ] trump ) int { count := 0 for i := 0 ; i < len ( tr ) ; i ++ { minj := i for j := i ; j < len ( tr ) ; j ++ { if tr [ j ] . value < tr [ minj ] . value { minj = j } } if i != minj { tmp := tr [ i ] tr [ i ] = tr [ minj ] tr [ minj ] = tmp count + + } } return count } func isStable ( in [ ] trump , out [ ] trump ) bool { for i := 0 ; i < len ( in ) ; i ++ { if in [ i ] . suit != out [ i ] . suit { return false } } return true } func printStable ( isStable bool ) { if isStable { fmt . Println ( \" \" ) return } fmt . Println ( \" \" ) } func main ( ) { var arraySize int fmt . Scan ( & arraySize ) values := make ( [ ] trump , arraySize ) sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) for i := 0 ; i < arraySize ; i ++ { sc . Scan ( ) s := sc . Text ( ) v , _ := strconv . Atoi ( s [ 1 : 2 ] ) t := trump { suit : s [ 0 : 1 ] , value : v } values [ i ] = t } values1 := append ( [ ] trump { } , values ... ) values2 := append ( [ ] trump { } , values ... ) bubbleSort ( values1 ) printTrumpArray ( values1 ) stable := isStable ( values , values1 ) printStable ( true ) selectionSort ( values2 ) printTrumpArray ( values2 ) stable = isStable ( values1 , values2 ) printStable ( stable ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" unicode \" \" \" \" \" for _ , ss := range sortedBubble { sb = sb + ss + \" \" } sb = strings . TrimRight ( sb , \" \" ) fmt . Println ( sb ) isStable ( checks , sortedBubble ) sortedSelect := selectionSort ( listForSelect ) ss := \" \" for _ , sss := range sortedSelect { ss = ss + sss + \" \" } ss = strings . TrimRight ( ss , \" \" ) fmt . Println ( ss ) isStable ( checks , sortedSelect ) } func bubbleSort ( list [ ] string ) [ ] string { for i := 0 ; i < len ( list ) ; i ++ { for j := len ( list ) - 1 ; j > i ; j -- { pre , err := strconv . Atoi ( strings . TrimLeftFunc ( list [ j - 1 ] , func ( r rune ) bool { return unicode . IsUpper ( r ) } ) ) if err != nil { panic ( err ) } crr , err := strconv . Atoi ( strings . TrimLeftFunc ( list [ j ] , func ( r rune ) bool { return unicode . IsUpper ( r ) } ) ) if err != nil { panic ( err ) } if pre > crr { tmp := list [ j - 1 ] list [ j - 1 ] = list [ j ] list [ j ] = tmp } } } return list } func selectionSort ( list [ ] string ) [ ] string { for i := 0 ; i < len ( list ) ; i ++ { min := i for j := i ; j < len ( list ) ; j ++ { minv , err := strconv . Atoi ( strings . TrimLeftFunc ( list [ min ] , func ( r rune ) bool { return unicode . IsUpper ( r ) } ) ) if err != nil { panic ( err ) } jv , err := strconv . Atoi ( strings . TrimLeftFunc ( list [ j ] , func ( r rune ) bool { return unicode . IsUpper ( r ) } ) ) if err != nil { panic ( err ) } if jv < minv { min = j } } tmp := list [ i ] list [ i ] = list [ min ] list [ min ] = tmp } return list } func isStable ( checks [ ] [ ] string , target [ ] string ) { for _ , check := range checks { pre := - 1 for _ , c := range check { for i , t := range target { if strings . Contains ( t , c ) { if pre > i { fmt . Println ( \" \" ) return } pre = i break } } } } fmt . Println ( \" \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" \" \" % s \" \" \\n \" ) } func nextString ( ) string { sc . Scan ( ) return sc . Text ( ) } func BubbleSort ( A [ ] string , N int ) [ ] string { bs := append ( [ ] string { } , A ... ) for i := 0 ; i < N ; i + + { for j := N - 1 ; j > i ; j - - { num1 := getNumberOfCard ( bs [ j ] ) num2 := getNumberOfCard ( bs [ j - 1 ] ) if num1 < num2 { bs [ j ] , bs [ j - 1 ] = bs [ j - 1 ] , bs [ j ] } } } return bs } func SelectionSort ( A [ ] string , N int ) [ ] string { ss := append ( [ ] string { } , A ... ) for i := 0 ; i < N ; i + + { minj := i for j := i ; j < N ; j + + { num1 := getNumberOfCard ( ss [ j ] ) num2 := getNumberOfCard ( ss [ minj ] ) if num1 < num2 { minj = j } } ss [ i ] , ss [ minj ] = ss [ minj ] , ss [ i ] } return ss } func getNumberOfCard ( card string ) int { num , _ := strconv . Atoi ( card [ 1 : ] ) return num } func isStable ( in , out [ ] string , N int ) { for i := 0 ; i < N ; i + + { for j := i + 1 ; j < N ; j + + { for a := 0 ; a < N ; a + + { for b := a + 1 ; b < N ; b + + { num1 := getNumberOfCard ( in [ i ] ) num2 := getNumberOfCard ( in [ j ] ) if num1 == num2 && in [ i ] == out [ b ] && in [ j ] == out [ a ] { fmt . Println ( \" Not stable \" \" Stable \" ) return } func main ( ) { sc . Split ( bufio . ScanWords ) ns := nextString ( ) length , _ := strconv . Atoi ( ns ) array := make ( [ ] string , length ) for i := 0 ; i < length ; i ++ { array [ i ] = nextString ( ) } bubbleSorted := BubbleSort ( array , length ) selectionSorted := SelectionSort ( array , length ) trace ( bubbleSorted , length ) isStable ( array , bubbleSorted , length ) trace ( selectionSorted , length ) isStable ( array , selectionSorted , length ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" \" \" \" \" \\n \" ) } func main ( ) { sc . Scan ( ) cardsString := splitInputLine ( ) var cards1 , cards2 [ ] Card for i := 0 ; i < len ( cardsString ) ; i ++ { str := cardsString [ i ] card := Card { str [ : 1 ] , str [ 1 : 2 ] } cards1 = append ( cards1 , card ) cards2 = append ( cards2 , card ) } sortedBubble := bubbleSort ( cards1 ) sortedSelection := selectionSort ( cards2 ) printCardsSlice ( sortedBubble ) fmt . Println ( \" \" ) stable := isStable ( sortedBubble , sortedSelection ) printCardsSlice ( sortedSelection ) if stable { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" Stable \" \" Stable \" \" Not stable \" \" % c \" \" % d \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" Not stable \" \" Stable \" \" % v % d \\n \" , out [ x ] . suit , out [ x ] . value ) } else { fmt . Printf ( \" \" , out [ x ] . suit , out [ x ] . value ) } } fmt . Printf ( \" \\n \" , isStable ( in , out ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s % d \" \" % s % d \" \" [ ] \" ) ) fmt . Println ( \" \" ) fmt . Println ( strings . Trim ( fmt . Sprint ( s ) , \" \" ) ) if isSame { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } } func bubbleSort ( n int64 , sa [ ] int64 , ss [ ] string ) ( [ ] int64 , [ ] string ) { a := make ( [ ] int64 , cap ( sa ) ) copy ( a , sa ) s := make ( [ ] string , cap ( ss ) ) copy ( s , ss ) isIncomp := true for isIncomp { isIncomp = false for j := n - 1 ; j >= 1 ; j -- { if a [ j ] < a [ j - 1 ] { t := a [ j - 1 ] a [ j - 1 ] = a [ j ] a [ j ] = t ts := s [ j - 1 ] s [ j - 1 ] = s [ j ] s [ j ] = ts isIncomp = true } } } return a , s } func selectionSort ( n int64 , sa [ ] int64 , ss [ ] string ) ( [ ] int64 , [ ] string ) { a := make ( [ ] int64 , cap ( sa ) ) copy ( a , sa ) s := make ( [ ] string , cap ( ss ) ) copy ( s , ss ) for i := int64 ( 0 ) ; i <= n - 1 ; i + + { minJ := i for j := int64 ( i ) ; j <= n - 1 ; j + + { if a [ j ] < a [ minJ ] { minJ = j } } t := a [ minJ ] a [ minJ ] = a [ i ] a [ i ] = t ts := s [ minJ ] s [ minJ ] = s [ i ] s [ i ] = ts } return a , s } func nextString ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) int64 { i , err := strconv . ParseInt ( nextString ( sc ) , 10 , 64 ) if err != nil { panic ( err ) } return i }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" \" \" % c % d \" \" \\n \" ) } func isStable ( a [ ] node , b [ ] node ) bool { for i , e := range a { e2 := b [ i ] if e . g != e2 . g || e . v != e2 . v { return false } } return true } func main ( ) { n := 0 fmt . Scan ( & n ) a := make ( [ ] node , n ) var s string for i := range a { fmt . Scan ( & s ) a [ i ] . g = rune ( s [ 0 ] ) a [ i ] . v , _ = strconv . Atoi ( s [ 1 : ] ) } b := make ( [ ] node , n ) copy ( b , a ) bubblesort ( a ) selectsort ( b ) printSlice ( a ) fmt . Println ( \" \" ) printSlice ( b ) if isStable ( a , b ) { fmt . Println ( \" \" ) } else { fmt . Println ( \" \" ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" % c % d \" \" \" \" Stable \" \" Not stable \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" % s % s % d \" \" \" \" \" \" \" \" Stable \" \" Stable \" \" Not stable \" \\n \" \\r \\n \" ) } func eGetInt ( r * bufio . Reader ) int { line := eGetLine ( r ) return eAtoi ( line ) } func eGetInts ( r * bufio . Reader ) [ ] int { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) var ints [ ] int for _ , f := range fields { ints = append ( ints , eAtoi ( f ) ) } return ints } func eAtoi ( s string ) int { n , err := strconv . Atoi ( s ) if err != nil { log . Fatal ( err ) } return n }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" log \" \" reflect \" \" strconv \" \" % d \" \" % s \" \" Stable \" \" Stable \" \" Not stable \" \" % s \" \" \\n \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" % s % d \" \" \" \" \" \" \" \" Not stable \" \" Stable \" \" % d \" \" % s \"",
    "label": 4
  },
  {
    "code": "package main import \" \" func main ( ) { var counter , temp int fmt . Scanf ( \" % d \" \" % c % d \" \" % c % d \" \" % c % d \" \" Not stable \" \" Stable \" ) } func findstable ( arr [ ] int , char [ ] byte ) ( [ ] byte , [ ] int ) { arrtemp := make ( [ ] int , len ( arr ) , 1000 ) chartemp := make ( [ ] byte , len ( char ) , 1000 ) copy ( arrtemp , arr ) copy ( chartemp , char ) var dytararr [ ] int var dytarbyte [ ] byte var temp int = - 1 for i := 0 ; i < len ( arrtemp ) ; i ++ { if arrtemp [ i ] == 0 { continue } for j := i + 1 ; j < len ( arrtemp ) ; j ++ { if temp == arrtemp [ j ] { arrtemp [ j ] = 0 } if arrtemp [ i ] != 0 && arrtemp [ i ] == arrtemp [ j ] { dytararr = append ( dytararr , arrtemp [ i ] ) dytarbyte = append ( dytarbyte , chartemp [ i ] ) temp = arrtemp [ i ] arrtemp [ j ] = 0 } } } return dytarbyte , dytararr }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , arr [ i ] ) } } func fprintArray ( arr [ ] int ) { for i := 0 ; i < len ( arr ) ; i ++ { if i == 0 { fmt . Fprintf ( wtr , \" \" , arr [ len ( arr ) - i - 1 ] ) } else { fmt . Fprintf ( wtr , \" \" , arr [ len ( arr ) - i - 1 ] ) } } fmt . Fprintln ( wtr ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strconv \" \" strings \" \" bufio \" \" os \" \" \" \" \\n \" ) ) } func formatIs ( elems [ ] int , sep string ) string { n := len ( elems ) as := make ( [ ] string , n ) for i := 0 ; i < n ; i ++ { as [ i ] = strconv . Itoa ( elems [ i ] ) } return strings . Join ( as , sep ) } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { return strconv . Atoi ( nextText ( sc ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" \" \" % d \" \" \\n \" ) } func printA ( A [ ] int ) { for i := 0 ; i < len ( A ) ; i ++ { fmt . Printf ( \" \\n \" , A [ i ] ) } } func main ( ) { n := nextLine ( ) A := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { A [ i ] = nextLine ( ) } shellSort ( A , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } func nextInt ( sc * bufio . Scanner ) int { sc . Scan ( ) n , err := strconv . Atoi ( sc . Text ( ) ) if err != nil { panic ( err ) } return n } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( sc ) var as [ ] int for i := 0 ; i < n ; i ++ { a := nextInt ( sc ) as = append ( as , a ) } shellSort ( n , as ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) } func Stringln ( A [ ] int ) string { text := strings . Trim ( fmt . Sprint ( A ) , \" \" ) return strings . Replace ( text , \" \" , \" \\n \" , - 1 ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" strings \" \" [ ] \" ) } func Stringln ( A [ ] int ) string { text := strings . Trim ( fmt . Sprint ( A ) , \" \" ) return strings . Replace ( text , \" \" , \" \\n \" , - 1 ) } func main ( ) { n := 0 scanner := bufio . NewScanner ( os . Stdin ) if scanner . Scan ( ) { n , _ = strconv . Atoi ( scanner . Text ( ) ) } a := make ( [ ] int , n ) for i := range a { if ! scanner . Scan ( ) { break } a [ i ] , _ = strconv . Atoi ( scanner . Text ( ) ) } g , count := [ ] int { } , 0 a , g , count = shellSort ( a , n ) fmt . Println ( len ( g ) ) fmt . Println ( String ( g ) ) fmt . Println ( count ) fmt . Println ( Stringln ( a ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" fmt \" \" strings \" \" [ ] \" ) } func Stringln ( A [ ] int ) string { text := strings . Trim ( fmt . Sprint ( A ) , \" \" ) return strings . Replace ( text , \" \" , \" \\n \" , - 1 ) } func main ( ) { n := 0 scanner := bufio . NewScanner ( os . Stdin ) if scanner . Scan ( ) { n , _ = strconv . Atoi ( scanner . Text ( ) ) } a := make ( [ ] int , n ) for i := range a { if ! scanner . Scan ( ) { break } a [ i ] , _ = strconv . Atoi ( scanner . Text ( ) ) } g , count := [ ] int { } , 0 a , g , count = shellSort ( a , n ) fmt . Println ( len ( g ) ) fmt . Println ( String ( g ) ) fmt . Println ( count ) fmt . Println ( Stringln ( a ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \" for _ , num := range numArray { reducedString += \" \" + strconv . FormatInt ( int64 ( num ) , 10 ) } return strings . Trim ( reducedString , \" \" ) } func getspan ( N int ) [ ] int { var spans [ ] int for span := 1 ; span <= N ; { spans = append ( [ ] int { span } , spans ... ) span = 3 * span + 1 } return spans }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" illegal length : % d \\n \" , length ) return nil , err } n : = length - 1 g : = [ ] int { } for n > 1 { g = append ( g , n ) n = n / 2 } g = append ( g , 1 ) return g , nil } func insertionSort ( elems [ ] int , g int ) Result { n := len ( elems ) count := 0 for i := g - 1 ; i < n ; i ++ { v := elems [ i ] vi := i for j := i - g ; j >= 0 ; j = j - g { if elems [ j ] > v { elems [ j + g ] = elems [ j ] vi = j count + + } else { break } } elems [ vi ] = v } return Result { elems , count } } func shellSort ( elems [ ] int ) ( Result , [ ] int ) { g , _ := calcG ( len ( elems ) ) count := 0 for _ , v := range g { result := insertionSort ( elems , v ) count += result . count elems = result . elems } return Result { elems , count } , g } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n , err := nextInt ( sc ) if err != nil { panic ( err ) } elems := make ( [ ] int , n ) for i := 0 ; i < len ( elems ) ; i ++ { x , err := nextInt ( sc ) if err != nil { panic ( err ) } elems [ i ] = x } result , g := shellSort ( elems ) fmt . Println ( len ( g ) ) fmt . Println ( strings . Join ( isToAs ( g ) , \" \" ) ) fmt . Println ( result . count ) for _ , v := range result . elems { fmt . Println ( v ) } } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) } func isToAs ( is [ ] int ) [ ] string { as := make ( [ ] string , len ( is ) ) for i := 0 ; i < len ( as ) ; i ++ { as [ i ] = strconv . Itoa ( is [ i ] ) } return as }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" illegal length : % d \\n \" , length ) return nil , err } n : = length - 1 g : = [ ] int { } for n > 1 { g = append ( g , n ) n = n / 2 } g = append ( g , 1 ) return g , nil } func insertionSort ( elems [ ] int , g int ) Result { n := len ( elems ) count := 0 for i := g - 1 ; i < n ; i ++ { v := elems [ i ] vi := i for j := i - g ; j >= 0 ; j = j - g { if elems [ j ] > v { elems [ j + g ] = elems [ j ] vi = j count + + } else { break } } elems [ vi ] = v } return Result { elems , count } } func shellSort ( elems [ ] int ) ( Result , [ ] int ) { g , _ := calcG ( len ( elems ) ) count := 0 for _ , v := range g { result := insertionSort ( elems , v ) count += result . count elems = result . elems } return Result { elems , count } , g } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n , err := nextInt ( sc ) if err != nil { panic ( err ) } elems := make ( [ ] int , n ) for i := 0 ; i < len ( elems ) ; i ++ { x , err := nextInt ( sc ) if err != nil { panic ( err ) } elems [ i ] = x } result , g := shellSort ( elems ) fmt . Println ( len ( g ) ) fmt . Println ( strings . Join ( isToAs ( g ) , \" \" ) ) fmt . Println ( result . count ) fmt . Println ( strings . Join ( isToAs ( result . elems ) , \" \\n \" ) ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) } func isToAs ( is [ ] int ) [ ] string { as := make ( [ ] string , len ( is ) ) for i := 0 ; i < len ( as ) ; i ++ { as [ i ] = strconv . Itoa ( is [ i ] ) } return as }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) } var cnt = 0 func insertionSort ( as [ ] int , n int , g int ) { for i := g ; i < n ; i ++ { v := as [ i ] j := i - g for j >= 0 && as [ j ] > v { as [ j + g ] = as [ j ] j = j - g cnt + + } as [ j + g ] = v } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" ) ) for i := 0 ; i < m ; i ++ { cnt += insertionSort ( A , n , G [ m - i - 1 ] ) } fmt . Println ( cnt ) for _ , a := range A { fmt . Println ( a ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) for _ , v := range A { fmt . Println ( v ) } } func nextInt ( ) int { sc . Scan ( ) i , e := strconv . Atoi ( sc . Text ( ) ) if e != nil { panic ( e ) } return i }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \\n \" , m ) for i : = m - 1 ; i > 0 ; i - - { fmt . Printf ( \" % d \" \" % d \\n \" , G [ 0 ] ) fmt . Printf ( \" \\n \" , count ) for i := 0 ; i < length ; i ++ { fmt . Printf ( \" \\n \" , input [ i ] ) } } func insertionSort ( input [ ] int , length , gap int ) [ ] int { var v , j int for i := gap ; i < length ; i ++ { v = input [ i ] j = i - gap for ; j >= 0 && input [ j ] > v ; { input [ j + gap ] = input [ j ] j = j - gap count + + } input [ j + gap ] = v } return input }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / rand \" \" os \" \" strconv \" \" strings \" \" time \" \" [ ] \" ) ) fmt . Println ( cnt ) for _ , v := range a { fmt . Println ( v ) } } func shellSort ( a [ ] int , n int ) ( int , [ ] int ) { m , g := calcInterval ( n ) for _ , v := range g { insertSort ( a , n , v ) } return m , g } func calcInterval ( n int ) ( int , [ ] int ) { rg := [ ] int { } m := 0 for v := 1 ; v <= n ; v = 3 * v + 1 { m ++ rg = append ( rg , v ) } g := [ ] int { } for i := len ( rg ) - 1 ; i >= 0 ; i -- { g = append ( g , rg [ i ] ) } return m , g } func insertSort ( a [ ] int , n , g int ) { for i := g ; i < n ; i ++ { v := a [ i ] j := i - g for j >= 0 && a [ j ] > v { a [ j + g ] = a [ j ] j = j - g cnt + + } a [ j + g ] = v } } func scanIntArray ( stdin * bufio . Scanner ) [ ] int { is := [ ] int { } for stdin . Scan ( ) { i := scanInt ( stdin ) is = append ( is , i ) } return is } func scanInt ( sc * bufio . Scanner ) int { t := sc . Text ( ) i , err := strconv . Atoi ( t ) if err != nil { panic ( err ) } return i }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) for i := 0 ; i < n ; i ++ { fmt . Println ( a [ i ] ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \" \" \" \" \" \" % d \" \" \" \" % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) } func Stringln ( arr [ ] int ) string { text := strings . Trim ( fmt . Sprint ( arr ) , \" \" ) return strings . Replace ( text , \" \" , \" \\n \" , - 1 ) } func insertionSort ( arr [ ] int , len , g int ) int { cnt := 0 for i := g ; i < len ; i + + { v := arr [ i ] j := i - g for j >= 0 && arr [ j ] > v { arr [ j + g ] = arr [ j ] j -= g cnt ++ } arr [ j + g ] = v } return cnt } func shellSort ( arr [ ] int , l int ) { var g [ ] int for i := 1 ; i <= l ; i = 3 * i + 1 { g = append ( g , 0 ) copy ( g [ 1 : ] , g [ 0 : ] ) g [ 0 ] = i } cnt := 0 for _ , e := range g { cnt + = insertionSort ( arr , l , e ) } fmt . Println ( len ( g ) ) fmt . Println ( String ( g ) ) fmt . Println ( cnt ) fmt . Println ( Stringln ( arr ) ) } func main ( ) { n := scanInt ( ) arr := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { arr [ i ] = scanInt ( ) } shellSort ( arr , n ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" \\n \" ) } else { fmt . Print ( \" \" ) } } } var cnt int func insertionSort ( a [ ] int , n int , g int ) [ ] int { var v int var j int for i := g ; i < n ; i ++ { v = a [ i ] j = i - g for j >= 0 && a [ j ] > v { a [ j + g ] = a [ j ] j - = g cnt + + } a [ j + g ] = v } return a } func shellSort ( a [ ] int , n int ) [ ] int { cnt = 0 m := int ( math . Log ( float64 ( n ) ) / math . Ln2 ) + 1 G := make ( [ ] int , m ) for i := range G { G [ i ] = int ( math . Pow ( 2 , float64 ( m - 1 - i ) ) ) a = insertionSort ( a , n , G [ i ] ) } fmt . Println ( m ) printList ( G ) fmt . Println ( cnt ) return a } func main ( ) { sc = bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n := nextInt ( ) a := make ( [ ] int , n ) for i := range a { a [ i ] = nextInt ( ) } a = shellSort ( a , n ) for _ , v := range a { fmt . Println ( v ) } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % + v \" \" ] \" ) } func main ( ) { scanner . Split ( bufio . ScanWords ) size , _ := nextInt ( ) arr := make ( [ ] int , size ) for i := 0 ; i < size ; i ++ { arr [ i ] , _ = nextInt ( ) } arrShell , cnt , g := shellSort ( arr ) fmt . Println ( len ( g ) ) fmt . Println ( stringifyArray ( g ) ) fmt . Println ( cnt ) fmt . Println ( strings . Replace ( stringifyArray ( arrShell ) , \" \" , \" \\n \" , - 1 ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strconv \" \" \" \" % d \" \" \\n \" ) } func traceln ( A [ ] int , N int ) { for i := 0 ; i < N ; i ++ { fmt . Println ( A [ i ] ) } } func nextInt ( ) int { sc . Scan ( ) v , _ := strconv . Atoi ( sc . Text ( ) ) return v } func insertionSort ( A [ ] int , N , g int ) { for i := g ; i < N ; i ++ { tmp := A [ i ] j := i - g for j >= 0 && A [ j ] > tmp { A [ j + g ] = A [ j ] j = j - g count + + } A [ j + g ] = tmp } } func ShellSort ( A [ ] int , N int , m int , G [ ] int ) [ ] int { sorted := append ( [ ] int { } , A ... ) for i := m - 1 ; i >= 0 ; i - - { insertionSort ( sorted , N , G [ i ] ) } return sorted } func main ( ) { sc . Split ( bufio . ScanWords ) length := nextInt ( ) array := make ( [ ] int , length ) for i := 0 ; i < length ; i + + { array [ i ] = nextInt ( ) } var G [ ] int h := 1 for h <= length { G = append ( G , h ) h = 3 * h + 1 } sorted := ShellSort ( array , length , len ( G ) , G ) fmt . Println ( len ( G ) ) trace ( G , len ( G ) ) fmt . Println ( count ) traceln ( sorted , length ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % v \" \" [ ] \" ) ) fmt . Fprintln ( writer , cnt ) for i := 0 ; i < n ; i ++ { fmt . Fprintln ( writer , aa [ i ] ) } writer . Flush ( ) } func insertionSort ( aa [ ] int , n , g int ) int { cnt := 0 for i := g ; i < n ; i ++ { v := aa [ i ] j := i - g for j >= 0 && aa [ j ] > v { aa [ j + g ] = aa [ j ] j - = g cnt + + } aa [ j + g ] = v } return cnt } func shellSort ( aa [ ] int , n int ) ( int , [ ] int ) { cnt := 0 gg := make ( [ ] int , 0 ) for g := 1 ; g <= n ; g = 3 * g + 1 { gg = append ( gg , g ) } l := len ( gg ) for i := 0 ; i * 2 < l ; i + + { gg [ i ] , gg [ l - 1 - i ] = gg [ l - 1 - i ] , gg [ i ] } for i := 0 ; i < l ; i + + { cnt + = insertionSort ( aa , n , gg [ i ] ) } return cnt , gg }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \\n \" , - 1 ) ) } func trimBracket ( s string ) string { return strings . Trim ( s , \" \" ) } func insertionSort ( e [ ] int , g int ) int { cnt := 0 for i := g ; i < len ( e ) ; i + + { v := e [ i ] j := i - g for j >= 0 && e [ j ] > v { e [ j + g ] = e [ j ] j = j - g cnt ++ } e [ j + g ] = v } return cnt } func shellSort ( e [ ] int ) ( [ ] int , int ) { cnt := 0 g := [ ] int { } for i := 1 ; i <= len ( e ) ; i = 3 * i + 1 { g = append ( g , 0 ) copy ( g [ 1 : ] , g [ 0 : ] ) g [ 0 ] = i } for j := 0 ; j < len ( g ) ; j + + { cnt + = insertionSort ( e , g [ j ] ) } return g , cnt }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" [ ] \" ) ) fmt . Println ( cnt ) for i := int64 ( 0 ) ; i < n ; i ++ { fmt . Println ( a [ i ] ) } } func shellSort ( a [ ] int64 , n int64 ) ( int64 , [ ] int64 , int64 ) { var cnt int64 m , g := calcM ( n ) for i := int64 ( 0 ) ; i < m ; i ++ { cnt = insertionSort ( a , n , g [ i ] , cnt ) } return m , g , cnt } func insertionSort ( a [ ] int64 , n int64 , g int64 , cnt int64 ) int64 { for i := g ; i <= n - 1 ; i ++ { v := a [ i ] j := i - g for j >= 0 && a [ j ] > v { a [ j + g ] = a [ j ] j = j - g cnt + + } a [ j + g ] = v } return cnt } func calcM ( n int64 ) ( int64 , [ ] int64 ) { if n == 1 { return 1 , [ ] int64 { 0 } } var cnt int64 c := int64 ( 1 ) var g [ ] int64 for c < n { g = append ( g , c ) c = c * 3 + 1 cnt + + } for i := len ( g ) / 2 - 1 ; i >= 0 ; i -- { opp := len ( g ) - 1 - i g [ i ] , g [ opp ] = g [ opp ] , g [ i ] } return cnt , g } func nextString ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) int64 { i , err := strconv . ParseInt ( nextString ( sc ) , 10 , 64 ) if err != nil { panic ( err ) } return i }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" log \" \" os \" \" strconv \" \" strings \" \" \" \" % s % d \" \" \" \" % d \\n \" , v ) ) } fmt . Print ( buf . String ( ) ) } func shellSortForJudge ( a ints ) ( [ ] int , int ) { ms := reverse ( createG ( len ( a ) ) ) cnt := 0 for _ , m := range ms { insertionSortForJudge ( a , m , & cnt ) } return ms , cnt } func reverse ( a ints ) ints { r := make ( ints , len ( a ) ) for i := 0 ; i < len ( a ) ; i ++ { r [ i ] = a [ len ( a ) - 1 - i ] } return r } func main ( ) { reader := bufio . NewReader ( os . Stdin ) n := eGetInt ( reader ) a := make ( [ ] int , 0 , n ) for i := 0 ; i < n ; i ++ { a = append ( a , eGetInt ( reader ) ) } ms , cnt := shellSortForJudge ( a ) printAnswer ( a , ms , cnt ) } func eGetLine ( r * bufio . Reader ) string { s , err := r . ReadString ( byte ( '\\n' ) ) if err != nil { if err != io . EOF { log . Fatal ( err . Error ( ) ) } return s } return strings . TrimRight ( s , \" \\r \\n \" ) } func eGetInt ( r * bufio . Reader ) int { line := eGetLine ( r ) return eAtoi ( line ) } func eGetInts ( r * bufio . Reader ) [ ] int { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) var ints [ ] int for _ , f := range fields { ints = append ( ints , eAtoi ( f ) ) } return ints } func eAtoi ( s string ) int { n , err := strconv . Atoi ( s ) if err != nil { log . Fatal ( err ) } return n }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" log \" \" os \" \" strconv \" \" \" \" scan error \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \\n \" \\n \" , \" \" , - 1 ) temp , err = strconv . Atoi ( input ) A := make ( [ ] int , temp , 1000000 ) for i := 0 ; i < temp ; i ++ { input , err = inputReader . ReadString ( '\\n' ) input = strings . Replace ( input , \" \\n \" , \" \" , - 1 ) A [ i ] , err = strconv . Atoi ( input ) } shellSort ( A , temp ) } func shellSort ( A [ ] int , n int ) { var m int G := make ( [ ] int , n , 1000000 ) G1 := make ( [ ] int , n , 1000000 ) j := 0 for m = 1 ; ; m ++ { temp := ( int ( math . Pow ( float64 ( 3 ) , float64 ( m ) ) ) - 1 ) / 2 if ( temp > n ) { break } G1 [ j ] = temp j + + } for i := 0 ; i < j ; i ++ { G [ i ] = G1 [ j - i - 1 ] } m = m - 1 fmt . Println ( m ) for i := 0 ; i < m ; i ++ { fmt . Printf ( \" \" , G [ i ] ) insertionSort ( A , n , G [ i ] ) } fmt . Println ( ) fmt . Println ( cnt ) for i := 0 ; i < n ; i ++ { fmt . Println ( A [ i ] ) } } func insertionSort ( A [ ] int , n int , g int ) { for i := g ; i < n ; i ++ { v := A [ i ] j := i - g for ; j >= 0 && A [ j ] > v ; { A [ j + g ] = A [ j ] j = j - g cnt + + } A [ j + g ] = v } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import \" \" type task struct { name string time int } func main ( ) { var ( n , q int tq [ ] task ) fmt . Scan ( & n , & q ) tq = make ( [ ] task , n ) for i := range tq { var ( name string time int ) fmt . Scan ( & name , & time ) tq [ i ] = task { name , time } } var totalTime = 0 for len ( tq ) > 0 { var t task t , tq = tq [ 0 ] , tq [ 1 : ] if t . time > q { totalTime + = q t . time - = q tq = append ( tq , t ) } else { totalTime + = t . time fmt . Println ( t . name , totalTime ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" % s % d \\n \" , v . name , sum ) } } } func min ( a , b int ) int { if a < b { return a } return b }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % s % d \\n \" , queue [ 0 ] . name , processedTime ) queue = queue [ 1 : ] } else { queue = append ( queue [ 1 : ] , queue [ 0 ] ) queue [ len ( queue ) - 1 ] . time = restTime processedTime = processedTime + quantum } if len ( queue ) == 0 { break } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" strconv \" \" os \" \" % s % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math \" \" os \" \" strconv \" \" strings \" \" % s % d \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" empty \" \" \" \" \" \" % s % d \\n \" , p . name , all_time ) ; } else { q . EnQueue ( p . name , p . time - time ) all_time += time } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bufio \" \" os \" \" strings \" \" strconv \" \" Empty . \" \" \" \" \" \" % s % d \\n \" , processing . name , ans ) } else { q . enqueue ( processing . name , processing . time - timeSlice ) ans + = timeSlice } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \\n \" , process . name , time ) processes = processes [ 1 : ] } else { process . remains = process . remains - q time += q processes = append ( processes [ 1 : ] , * process ) } } } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) } func nextStr ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) }",
    "label": 4
  },
  {
    "code": "package main import \" \" type Queue struct { name string time int } type Queues [ MAX ] Queue var q Queues var head , tail int const MAX = 100000 func main ( ) { var c , n , t , extime int initialize ( ) fmt . Scan ( & n , & t ) for i := 1 ; i <= n ; i ++ { fmt . Scan ( & q [ i ] . name , & q [ i ] . time ) } head = 1 tail = n + 1 for { if head == tail { break } x := dequeue ( ) c = comp ( t , x . time ) x . time - = c extime += c if x . time > 0 { enqueue ( x ) } else { fmt . Printf ( \" \\n \" , x . name , extime ) } } } func comp ( t , u int ) int { if t <= u { return t } return u } func initialize ( ) { head = 0 tail = 0 } func dequeue ( ) Queue { if err := isEmpty ( ) ; err != nil { fmt . Println ( err ) } x := q [ head ] if head + 1 == MAX { head = 0 } else { head ++ } return x } func enqueue ( x Queue ) { if err := isFull ( ) ; err != nil { fmt . Println ( err ) } q [ tail ] = x if tail + 1 == MAX { tail = 0 } else { tail ++ } } func isFull ( ) error { if head == ( tail + 1 ) % MAX { return fmt . Errorf ( \" \" ) } return nil } func isEmpty ( ) error { if head == tail { return fmt . Errorf ( \" \" ) } return nil }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / bits \" \" os \" \" sort \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" math / bits \" \" os \" \" sort \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \" \" \" \" % s % d \\n \" , p . name , total ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" sort \" \" strconv \" \" stack is empty \" \" stack is empty \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" % s % d \\n \" , p . name , elapsedtime ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \\n \" , inName [ i ] , total ) continue } else if inTime [ i ] > 0 && isFirst { total += q } if inTime [ i ] > 0 && ! isFirst { total + = q inTime [ i ] , inTime [ i - progress ] = inTime [ i - progress ] , inTime [ i ] inName [ i ] , inName [ i - progress ] = inName [ i - progress ] , inName [ i ] } else if inTime [ i ] < 1 && ! isFirst { total += q + inTime [ i ] fmt . Printf ( \" \\n \" , inName [ i ] , total ) progress + + } } isFirst = true fin += progress progress = 0 if n == fin { break } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \\n \" , p . name , totalTime ) } } } func min ( x , y int ) int { if x < y { return x } return y }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" Empty \" \" \" \" \" \" % s % d \\n \" , processing . name , cpu ) } else { q . enqueue ( processing . name , processing . time - time_slice ) cpu + = time_slice } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" type Process struct { name string time int } func shift ( q [ ] Process ) ( Process , [ ] Process ) { return q [ 0 ] , q [ 1 : ] } func main ( ) { var n , q int fmt . Scan ( & n , & q ) queue := make ( [ ] Process , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & queue [ i ] . name , & queue [ i ] . time ) } var p Process var t int for len ( queue ) > 0 { t += q queue [ 0 ] . time - = q p , queue = shift ( queue ) if p . time <= 0 { t += p . time fmt . Println ( p . name , t ) } else { queue = append ( queue , p ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \\n \" , fprocs [ i ] . name , fprocs [ i ] . ptime ) } wtr . Flush ( ) } func nextInt ( sc * bufio . Scanner ) int { sc . Scan ( ) t , _ := strconv . Atoi ( sc . Text ( ) ) return t } func min ( a , b int ) int { if a < b { return a } return b }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s % d \\n \" , p . name , rb . time ) } return } type processQueue struct { queue [ ] * process firstIdx int lastIdx int } func ( pq * processQueue ) enqueue ( p * process ) { pq . queue [ pq . lastIdx ] = p pq . lastIdx ++ if pq . lastIdx >= len ( pq . queue ) { pq . lastIdx = 0 } } func ( pq * processQueue ) dequeue ( ) * process { p := pq . queue [ pq . firstIdx ] pq . queue [ pq . firstIdx ] = nil pq . firstIdx + + if pq . firstIdx >= len ( pq . queue ) { pq . firstIdx = 0 } return p } func ( pq * processQueue ) isEmpty ( ) bool { return pq . queue [ pq . firstIdx ] == nil } func initProcessQueue ( l int ) * processQueue { return & processQueue { queue : make ( [ ] * process , l ) , firstIdx : 0 , lastIdx : 0 , } } func initRoudRobin ( line string ) * roundRobin { in := strings . Split ( line , \" \" ) l , err := strconv . Atoi ( in [ 0 ] ) if err != nil { panic ( err ) } pq := initProcessQueue ( l ) q , err := strconv . Atoi ( in [ 1 ] ) if err != nil { panic ( err ) } return & roundRobin { quantum : q , time : 0 , pQueue : pq , } } func initProcess ( line string ) * process { in := strings . Split ( line , \" \" ) t , err := strconv . Atoi ( in [ 1 ] ) if err != nil { panic ( err ) } return & process { name : in [ 0 ] , time : t , } } func main ( ) { stdin := bufio . NewScanner ( os . Stdin ) stdin . Scan ( ) rb := initRoudRobin ( stdin . Text ( ) ) for stdin . Scan ( ) { p := initProcess ( stdin . Text ( ) ) rb . pQueue . enqueue ( p ) } rb . run ( ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \\n \" , task . name , total ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % + v \" \" ] \" ) } func dropEmptyTasks ( names [ ] string , time [ ] int ) ( [ ] string , [ ] int ) { namesNew := [ ] string { } timeNew := [ ] int { } for i := range time { if time [ i ] > 0 { namesNew = append ( namesNew , names [ i ] ) timeNew = append ( timeNew , time [ i ] ) } } return namesNew , timeNew } func main ( ) { scanner . Split ( bufio . ScanWords ) n , _ := nextInt ( ) q , _ := nextInt ( ) names := make ( [ ] string , n ) time := make ( [ ] int , n ) for i := 0 ; i < n ; i ++ { names [ i ] = nextString ( ) time [ i ] , _ = nextInt ( ) } currentTask := 0 currentTime := 0 for { if time [ currentTask ] > 0 { if time [ currentTask ] > q { currentTime += q time [ currentTask ] - = q } else { currentTime += time [ currentTask ] time [ currentTask ] = 0 } if time [ currentTask ] == 0 { fmt . Println ( names [ currentTask ] , currentTime ) } } hasNonzeroProcess := false for i := 0 ; i < len ( names ) ; i ++ { if time [ i ] > 0 { hasNonzeroProcess = true break } } if ! hasNonzeroProcess { break } currentTask = ( currentTask + 1 ) % len ( names ) if currentTask == 0 { names , time = dropEmptyTasks ( names , time ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" const LEN = 100005 type item struct { Name string Time int } type Queue struct { head int tail int length int items [ LEN ] item } func ( q * Queue ) enqueue ( x item ) { q . items [ q . tail ] = x q . tail + = 1 if q . tail == LEN { q . tail = 0 } } func ( q * Queue ) dequeue ( ) item { tmp := q . head if q . head + 1 == LEN { q . head = 0 } else { q . head ++ } return q . items [ tmp ] } func min ( a , b int ) int { if a < b { return a } return b } func main ( ) { var n , q int fmt . Scan ( & n , & q ) var items [ LEN ] item queue := & Queue { 0 , 0 , n , items } for i := 0 ; i < n ; i ++ { fmt . Scan ( & items [ i ] . Name , & items [ i ] . Time ) queue . enqueue ( items [ i ] ) } var a item var totalTime int var t int queue . head = 0 queue . tail = n for queue . head != queue . tail { a = queue . dequeue ( ) t = min ( q , a . Time ) a . Time - = t totalTime += t if a . Time == 0 { fmt . Printf ( \" \\n \" , a . Name , totalTime ) } else { queue . enqueue ( a ) } } }",
    "label": 4
  },
  {
    "code": "package main import \" \" type process struct { name string time int } type queue struct { arr [ ] process } func ( q * queue ) enqueue ( p process ) { q . arr = append ( q . arr , p ) } func ( q * queue ) dequeue ( ) process { res := q . arr [ 0 ] q . arr = q . arr [ 1 : ] return res } func ( q * queue ) isEmpty ( ) bool { return len ( q . arr ) == 0 } func main ( ) { var N , quantum , totalTime int var q queue fmt . Scan ( & N , & quantum ) for i := 0 ; i < N ; i ++ { var name string var time int fmt . Scan ( & name , & time ) q . enqueue ( process { name , time } ) } for ! q . isEmpty ( ) { p := q . dequeue ( ) t := min ( quantum , p . time ) p . time - = t totalTime += t if p . time > 0 { q . enqueue ( p ) } else { fmt . Printf ( \" \\n \" , p . name , totalTime ) } } } func min ( x , y int ) int { if x < y { return x } return y }",
    "label": 4
  },
  {
    "code": "package main import \" \" type proc struct { name string time int } type container struct { data [ ] proc } func ( c * container ) queue ( p proc ) { c . data = append ( c . data , p ) } func ( c * container ) dequeue ( p * proc ) bool { if len ( c . data ) > 0 { * p = c . data [ 0 ] c . data = c . data [ 1 : ] return true } return false } func min ( a , b int ) int { if a < b { return a } return b } func main ( ) { var n , q int fmt . Scan ( & n , & q ) var queue container for i := 0 ; i < n ; i ++ { var p proc fmt . Scan ( & p . name , & p . time ) queue . queue ( p ) } var t int for len ( queue . data ) > 0 { var p proc queue . dequeue ( & p ) rt := min ( q , p . time ) t += rt if p . time - rt == 0 { fmt . Printf ( \" \\n \" , p . name , t ) } else { p . time = p . time - rt queue . queue ( p ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" io \" \" math \" \" os \" \" strconv \" \" Scan failed \" \" % b \" \" [ argument error ] : PowInt does not accept negative integers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Gcd only accepts two NATURAL numbers \" \" [ argument error ] : Strtoi only accepts integer string \" \" % s % d \\n \" , t . name , tsum ) } else { tsum += q t . time -= q tq . Enqueue ( t ) } } } const MAX_QUEUE_SIZE = 2000000 type Queue struct { dat [ MAX_QUEUE_SIZE ] Task head , tail int } func NewQueue ( ) * Queue { q := new ( Queue ) q . head , q . tail = 0 , 0 return q } func ( q * Queue ) IsEmpty ( ) bool { return q . head == q . tail } func ( q * Queue ) IsFull ( ) bool { return q . head == ( q . tail + 1 ) % MAX_QUEUE_SIZE } func ( q * Queue ) Enqueue ( x Task ) { q . dat [ q . tail ] = x if q . tail + 1 == MAX_QUEUE_SIZE { q . tail = 0 } else { q . tail ++ } } func ( q * Queue ) Dequeue ( ) Task { x := q . dat [ q . head ] if q . head + 1 == MAX_QUEUE_SIZE { q . head = 0 } else { q . head ++ } return x }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" errors \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" queue is full \" \" can 't dequeue case empty \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % s % d \\n \" , u . name , elasp ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" % s % d \\n \" , p . name , progress ) if len ( q ) == 0 { close ( q ) } } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" bufio \" \" strconv \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" % s % d \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % v % d \\n \" , p . name , cnt ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" overflow \" \" empty \"",
    "label": 4
  },
  {
    "code": "package main import \" \" type Process struct { name string time int } func shift ( q [ ] Process ) ( Process , [ ] Process ) { return q [ 0 ] , q [ 1 : ] } func main ( ) { var n , q int fmt . Scan ( & n , & q ) queue := make ( [ ] Process , n ) for i := 0 ; i < n ; i ++ { fmt . Scan ( & queue [ i ] . name , & queue [ i ] . time ) } var p Process var t int for len ( queue ) > 0 { t += q queue [ 0 ] . time - = q p , queue = shift ( queue ) if p . time <= 0 { t += p . time fmt . Println ( p . name , t ) } else { queue = append ( queue , p ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" io \" \" log \" \" os \" \" strconv \" \" strings \" \" queue is full . \" \" queue is empty . \" \" \" \" % s % s \" \" \" \" head [ % d ] tail [ % d ] elem [ % s ] \" , q . head , q . tail , buf . String ( ) ) } type Process struct { Name string Time int } func ( p Process ) String ( ) string { return fmt . Sprintf ( \" \" , p . Name , p . Time ) } func schedule ( quant int , queue * Queue ) string { var output bytes . Buffer total := 0 for ! queue . isEmpty ( ) { p := queue . dequeue ( ) q , ok := p . ( * Process ) if ! ok { panic ( \" \" ) } if q . Time <= quant { output . WriteString ( fmt . Sprintf ( \" \\n \" , q . Name , total + q . Time ) ) total += q . Time } else { q . Time -= quant queue . enqueue ( q ) total += quant } } return output . String ( ) } func main ( ) { reader := bufio . NewReader ( os . Stdin ) nq := eGetInts ( reader ) n , q := nq [ 0 ] , nq [ 1 ] queue := NewQueue ( n ) for i := 0 ; i < n ; i ++ { pInfo := eGetFields ( reader ) queue . enqueue ( & Process { pInfo [ 0 ] , eAtoi ( pInfo [ 1 ] ) } ) } fmt . Print ( schedule ( q , queue ) ) } func eGetLine ( r * bufio . Reader ) string { s , err := r . ReadString ( byte ( '\\n' ) ) if err != nil { if err != io . EOF { log . Fatal ( err . Error ( ) ) } return s } return strings . TrimRight ( s , \" \\r \\n \" ) } func eGetInt ( r * bufio . Reader ) int { line := eGetLine ( r ) return eAtoi ( line ) } func eGetFields ( r * bufio . Reader ) [ ] string { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) return fields } func eGetInts ( r * bufio . Reader ) [ ] int { line := eGetLine ( r ) fields := strings . Split ( line , \" \" ) var ints [ ] int for _ , f := range fields { ints = append ( ints , eAtoi ( f ) ) } return ints } func eAtoi ( s string ) int { n , err := strconv . Atoi ( s ) if err != nil { log . Fatal ( err ) } return n } type ints [ ] int func ( s ints ) String ( ) string { var buf bytes . Buffer sep := \" \" for _ , v := range s { buf . WriteString ( fmt . Sprintf ( \" % s % d \" , sep , v ) ) sep = \" \" } return buf . String ( ) } func reverse ( a ints ) ints { r := make ( ints , len ( a ) ) for i := 0 ; i < len ( a ) ; i ++ { r [ i ] = a [ len ( a ) - 1 - i ] } return r }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" % v % v \\n \" , t . name , total ) } else { t . time - = q total + = q que = append ( que , t ) } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" % s % d \\n \" , data . Name , data . Time + currentTime ) currentTime += data . Time } else { data . Time - = q qu . enqueue ( data ) currentTime += q } } }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" bufio \" \" strings \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" deleteFirst \" \" deleteLast \" \" \" \" insert \" \" delete \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" deleteFirst \" \" deleteLast \" \" \" \" insert \" \" delete \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strings \" \" \" \" insert \" \" delete \" \" deleteFirst \" \" \" \" deleteLast \" \" % s \" \" % s \" \" \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" fmt \" \" bufio \" \" os \" \" \" \" insert \" \" delete \" \" deleteFirst \" \" deleteLast \" \" invalid command : % s \\n \" , command ) ) } } fmt . Println ( l ) } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { return strconv . Atoi ( nextText ( sc ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" strings \" \" fmt \" \" bufio \" \" os \" \" \" \" insert \" \" delete \" \" deleteFirst \" \" deleteLast \" \" invalid command : % s \\n \" , command ) ) } } fmt . Println ( l ) } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { return strconv . Atoi ( nextText ( sc ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" \" \" deleteFirst \" \" deleteLast \" \" insert \" \" delete \"",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" bytes \" \" fmt \" \" os \" \" strconv \" \" strings \" \" \" \" insert \" \" delete \" \" deleteFirst \" \" deleteLast \" \" specify the command form the following list : \\ \" insert < key > \\\" , \\ \" delete < key > \\\" , \\ \" deleteFirst \\\" , \\ \" deleteLast \\\" \" ) os . Exit ( 1 ) } } fmt . Println ( printList ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" os \" \" strconv \" \" strings \" \" fmt \" \" bytes \" \" \" \" \" \" insert \" \" delete \" \" deleteFirst \" \" deleteLast \" \" specify the command form the following list : \\ \" insert < key > \\\" , \\ \" delete < key > \\\" , \\ \" deleteFirst \\\" , \\ \" deleteLast \\\" \" ) os . Exit ( 1 ) } } fmt . Println ( printList ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" not found value : % s \\n \" , value ) } if node . prev != nil { node . prev . next = node . next } else { list . first = node . next } if node . next != nil { node . next . prev = node . prev } else { list . last = node . prev } list . length -= 1 return nil } func deleteFirst ( list * DoublyLinkedList ) error { if list . first == nil { return fmt . Errorf ( \" \\n \" ) } if list . length == 1 { list . first = nil list . last = nil list . length = 0 return nil } list . first . next . prev = nil list . first = list . first . next list . length - = 1 return nil } func deleteLast ( list * DoublyLinkedList ) error { if list . last == nil { return fmt . Errorf ( \" \\n \" ) } if list . length == 1 { list . first = nil list . last = nil list . length = 0 return nil } list . last . prev . next = nil list . last = list . last . prev list . length - = 1 return nil } func main ( ) { sc := bufio . NewScanner ( os . Stdin ) sc . Split ( bufio . ScanWords ) n , _ := nextInt ( sc ) list := & DoublyLinkedList { } for i := 0 ; i < n ; i ++ { command := nextText ( sc ) switch command { case \" \" : value := nextText ( sc ) insert ( value , list ) case \" \" : value := nextText ( sc ) delete ( value , list ) case \" \" : deleteFirst ( list ) case \" \" : deleteLast ( list ) default : panic ( fmt . Errorf ( \" \\n \" , command ) ) } } results := make ( [ ] string , list . length ) node := list . first for i := 0 ; i < len ( results ) ; i ++ { results [ i ] = node . value node = node . next } if node != nil { panic ( \" \" ) } fmt . Println ( strings . Join ( results , \" \" ) ) } func nextText ( sc * bufio . Scanner ) string { sc . Scan ( ) return sc . Text ( ) } func nextInt ( sc * bufio . Scanner ) ( int , error ) { sc . Scan ( ) return strconv . Atoi ( sc . Text ( ) ) }",
    "label": 4
  },
  {
    "code": "package main import ( \" \" \" fmt \" \" os \" \" strconv \" \" strings \" \" prev : % d , value : % d , next : % d \" \" % d \" \" \" \" insert \" \" delete \" \" deleteFirst \" \" deleteLast \"",
    "label": 4
  },
  {
    "code": "i = 0 x = [ ] 10 . times do x [ i ] = gets . to_i i += 1 end a = x . sort puts a [ 9 ] puts a [ 8 ] puts a [ 7 ]",
    "label": 5
  },
  {
    "code": "@ar = $stdin . read . split ( \" \\n \" ) . map ( & :to_i ) puts @ar . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "val = [ ] for i in 0 .. 9 val [ i ] = gets . chomp . to_i end val . sort! . reverse! for i in 0 .. 2 puts val [ i ] end",
    "label": 5
  },
  {
    "code": "h = [ ] for i in 0 .. 9 h [ i ] = gets . to_i end puts ( h . sort . reverse ) [ 0 .. 2 ] . join ( \" \\n \" )",
    "label": 5
  },
  {
    "code": "puts readlines . map ( & :to_i ) . sort . reverse . take ( 3 ) . inject { | a , b | a . to_s + \" \\n \" + b . to_s }",
    "label": 5
  },
  {
    "code": "puts AS = 10 . times . map { gets . to_i } . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "puts AS = 10 . times . map { gets . to_i } . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "height = [ ] for i in 0 .. 9 height [ i ] = gets . to_i end height . sort! { | a , b | b <=> a } for i in 0 .. 2 puts height [ i ] end",
    "label": 5
  },
  {
    "code": "a = [ ] b = [ ] 10 . times do a << gets . to_i end a . sort! . reverse! 3 . times do | i | puts a [ i ] end",
    "label": 5
  },
  {
    "code": "high = [ ] 10 . times do high . push gets . to_i end high . sort! { | a , b | b <=> a } 3 . times do | i | puts high [ i ] end",
    "label": 5
  },
  {
    "code": "s = Array . new ( 0 ) 10 . times { s . push ( gets . to_i ) } s . sort! s . reverse! 3 . times { puts s . shift }",
    "label": 5
  },
  {
    "code": "puts $< . sort_by { | x | - x . to_i } [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "tail = [ ] 10 . times do | i | tail [ i ] = gets . to_i end tail . sort! tail . reverse! 3 . times do | i | puts tail [ i ] end",
    "label": 5
  },
  {
    "code": "list_of_height = [ ] while gets list_of_height . push $_ . to_i end puts list_of_height . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "h = Array . new 10 . times { h . push ( gets ( ) . to_i ) } h . sort! h . reverse! for num in 0 .. 2 puts h [ num ] end",
    "label": 5
  },
  {
    "code": "inputs = [ ] 10 . times do inputs << gets . to_i end puts inputs . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr << gets . to_i end puts arr . sort [ - 3 .. - 1 ] . reverse",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a << gets . to_i end a . sort! . reverse! p a [ 0 ] p a [ 1 ] p a [ 2 ]",
    "label": 5
  },
  {
    "code": "arr = [ ] ( 0 .. 9 ) . each do | i | arr [ i ] = gets . to_i end arr . sort! . reverse! puts arr [ 0 ] , arr [ 1 ] , arr [ 2 ]",
    "label": 5
  },
  {
    "code": "a = 0 ; b = 0 ; c = 0 while n = gets do n = n . to_i if a < n then c = b ; b = a ; a = n elsif b < n then c = b ; b = n elsif c < n then c = n end end puts a ; puts b ; puts c",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { gets . to_i } . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "puts STDIN . readlines . map ( & :to_i ) . sort . reverse . first ( 3 )",
    "label": 5
  },
  {
    "code": "mountain = Array . new ( 10 , 0 ) for i in 0 .. 9 mountain [ i ] = gets . to_i end mountain . sort! { | a , b | b <=> a } for i in 0 .. 2 puts mountain [ i ] end",
    "label": 5
  },
  {
    "code": "arr = [ ] while line = gets do arr . push line . split . map ( & :to_i ) end arr . sort! do | a , b | b <=> a end 3 . times do | i | puts arr [ i ] end",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times do mountains << gets . chomp . to_i end mountains = mountains . sort . reverse 3 . times do | i | puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "a = [ ] for i in 0 ... 10 a . push ( gets . to_i ) end a . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for i in 0 ... 3 puts ( a [ i ] ) end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times { a . push ( gets . to_i ) } def max_idx ( a , i ) max = a [ i ] max_idx = i ( i + 1 .. a . length - 1 ) . each { | k | if a [ k ] > max max = a [ k ] max_idx = k end } max_idx end ( 0 .. a . length - 1 ) . each { | i | max_idx = max_idx ( a , i ) v = a [ i ] a [ i ] = a [ max_idx ] a [ max_idx ] = v } ( 0 .. 2 ) . each { | i | puts a [ i ] }",
    "label": 5
  },
  {
    "code": "mts = [ ] 10 . times do mts << gets . chomp . to_i end mts . sort! puts mts [ - 1 ] puts mts [ - 2 ] puts mts [ - 3 ]",
    "label": 5
  },
  {
    "code": "p = Array . new ( ) ; for i in 0 ... 10 p [ i ] = gets ( ) . to_i ( ) ; end p . sort! ( ) ; p . reverse! ( ) ; for i in 0 ... 3 print ( p [ i ] , \" \\n \" ) ; end",
    "label": 5
  },
  {
    "code": "puts $< . map ( & :to_i ) . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "p * $< . map ( & :to_i ) . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "mountain = Array . new ( 10 ) 10 . times do | i | mountain [ i ] = gets . to_i end mountain . sort! puts mountain [ - 1 ] puts mountain [ - 2 ] puts mountain [ - 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a << gets . chomp . to_i end a = a . sort . reverse 3 . times do | i | puts a [ i ] end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a << gets . chomp . to_i end a . sort! { | x , y | y <=> x } 3 . times do | i | puts a [ i ] end",
    "label": 5
  },
  {
    "code": "ary = [ ] 10 . times do ary . push gets . to_i end ary . sort! . reverse 3 . times do puts ary . pop end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times { a << gets . to_i } a . sort! . tap { 3 . times { p a . pop } }",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { a = gets . to_i } . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "ARGF . each_line . map ( & :to_i ) . sort { | a , b | b <=> a } . take ( 3 ) . each { | v | puts v }",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a << gets . to_i end a . sort! . reverse! 3 . times do | i | puts a [ i ] end",
    "label": 5
  },
  {
    "code": "mountains = Array . new ( 10 ) 10 . times do | i | height = gets . chomp . to_i mountains [ i ] = height end mountains . sort! { | a , b | b <=> a } 3 . times do puts mountains . shift end",
    "label": 5
  },
  {
    "code": "data = [ ] 10 . times do data << gets . to_i end data . sort! p data [ 9 ] p data [ 8 ] p data [ 7 ]",
    "label": 5
  },
  {
    "code": "mountain_high = Array . new ( 10 ) 10 . times do | count | mountain_high [ count ] = gets . to_i end mountain_high = mountain_high . sort 1 . upto ( 3 ) do | count | puts mountain_high [ - count ] end",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 .. 9 num [ i ] = gets . to_i end num . sort! ; num . reverse! for i in 0 .. 2 puts num [ i ] end",
    "label": 5
  },
  {
    "code": "a = [ ] while c = gets a << c . to_i end a . sort! 3 . times { puts a . pop }",
    "label": 5
  },
  {
    "code": "mountains = [ ] while s = STDIN . gets mountains . push ( s . to_i ) end mountains . sort! { | a , b | b <=> a } ( 0 .. 2 ) . each { | i | puts mountains [ i ] }",
    "label": 5
  },
  {
    "code": "f , s , t , i = 0 , 0 , 0 , 0 10 . times do m = gets . to_i if f < m m , f = f , m end if s < m m , s = s , m end if t < m m , t = t , m end end puts \"",
    "label": 5
  },
  {
    "code": "ary = Array . new ( 1 .. 10 ) . each { | i | ary << gets . to_i } ary = ary . sort . reverse ( ) ( 0 ... 3 ) . each { | i | puts ary [ i ] }",
    "label": 5
  },
  {
    "code": "arr = [ ] 10 . times do arr << gets . to_i end arr . sort! puts \" puts \" puts \"",
    "label": 5
  },
  {
    "code": "array = [ ] 10 . times do | i | array << gets . to_i end puts array . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "val = [ ] for i in 0 .. 9 val . push ( gets . to_i ( ) ) end val . sort! val . reverse! for i in 0 .. 2 puts val [ i ] . to_s ( ) end",
    "label": 5
  },
  {
    "code": "height = Array . new 10 . times { height <<gets . chomp! . to_i } height . sort! { | a , b | b <=> a } 3 . times { | i | p height [ i ] }",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times { height . push ( gets . to_i ) } puts height . sort { | i , j | j <=> i } [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "m = [ ] 10 . times do m . push gets . to_i end m . sort! { | a , b | - ( a <=> b ) } puts m . first ( 3 )",
    "label": 5
  },
  {
    "code": "d = [ ] 10 . times do d << gets . to_i end sd = d . sort puts sd [ - 1 ] puts sd [ - 2 ] puts sd [ - 3 ]",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { gets . to_i } . sort . last ( 3 ) . reverse",
    "label": 5
  },
  {
    "code": "args = [ ] while x = gets do args << x . to_i end p * args . sort . reverse . take ( 3 )",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times { | i | h << gets . to_i } h . sort! . reverse! 3 . times { | i | puts h [ i ] }",
    "label": 5
  },
  {
    "code": "data = [ ] while line = gets data . unshift ( line . chomp . to_i ) end puts data . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "height_num = [ ] input_roop = 10 output_roop = 2 for input in 1 .. input_roop do height = gets . to_i height_num . push ( height ) end heighest3 = height_num . sort . reverse for output in 0 .. output_roop do puts heighest3 [ output ] end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times { a << gets . to_i } a . sort! 3 . times { puts a . pop }",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times { a << gets . to_i } a . sort! 9 . downto ( 7 ) { | i | puts a [ i ] }",
    "label": 5
  },
  {
    "code": "h1 = gets . chomp h2 = gets . chomp h3 = gets . chomp h4 = gets . chomp h5 = gets . chomp h6 = gets . chomp h7 = gets . chomp h8 = gets . chomp h9 = gets . chomp h10 = gets . chomp height = [ h1 . to_i , h2 . to_i , h3 . to_i , h4 . to_i , h5 . to_i , h6 . to_i , h7 . to_i , h8 . to_i , h9 . to_i , h10 . to_i ] height2 = height . sort puts height2 [ 9 ] puts height2 [ 8 ] puts height2 [ 7 ]",
    "label": 5
  },
  {
    "code": "puts $< . map ( & :to_i ) . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "yama = $stdin . read . split ( ?\\n ) . map ( & :to_i ) yama = yama . sort 3 . times do puts yama . pop end",
    "label": 5
  },
  {
    "code": "puts ( 0 .. 9 ) . map { gets . to_i } . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "i = 0 a = [ ] b = [ ] c = [ ] while i <= 9 a [ i ] = gets ( ) b [ i ] = a [ i ] . to_i i += 1 end c = b . sort puts c [ 9 ] , c [ 8 ] , c [ 7 ]",
    "label": 5
  },
  {
    "code": "list = [ ] 10 . times { list << gets . chomp . to_i } list . sort . reverse . each_with_index { | x , i | break if i >= 3 ; puts x }",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end puts a [ 0 ] puts a [ 1 ] puts a [ 2 ]",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end puts a [ 0 ] puts a [ 1 ] puts a [ 2 ]",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do | i | n_i = gets . chomp . to_i a [ i ] = n_i end a . sort! { | x , y | y <=> x } puts a [ 0 ] puts a [ 1 ] puts a [ 2 ]",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do | i | a [ i ] = gets . chomp . to_i end a . sort! { | x , y | y <=> x } puts a [ 0 ] puts a [ 1 ] puts a [ 2 ]",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end print a [ 0 ] , \" \\n \" , a [ 1 ] , \" \\n \" , a [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "height1 = gets . chomp . to_i height2 = gets . chomp . to_i height3 = gets . chomp . to_i height4 = gets . chomp . to_i height5 = gets . chomp . to_i height6 = gets . chomp . to_i height7 = gets . chomp . to_i height8 = gets . chomp . to_i height9 = gets . chomp . to_i height10 = gets . chomp . to_i a = [ height1 , height2 , height3 , height4 , height5 , height6 , height7 , height8 , height9 , height10 ] b = a . sort puts b [ 9 ] puts b [ 8 ] puts b [ 7 ]",
    "label": 5
  },
  {
    "code": "i = 0 height = [ ] while i < 10 height << gets . chomp . to_i i += 1 end height . sort! height . reverse! i = 0 while i < 3 puts height [ i ] i += 1 end",
    "label": 5
  },
  {
    "code": "i = 0 height = [ ] while i < 10 height << gets . chomp . to_i i += 1 end height . sort! height . reverse! i = 0 while i < 3 puts height [ i ] i += 1 end",
    "label": 5
  },
  {
    "code": "arr = [ ] ; 10 . times do arr . push ( gets . chomp . to_i ) ; end arr . sort! { | x , y | y <=> x } puts arr [ 0 ] , arr [ 1 ] , arr [ 2 ]",
    "label": 5
  },
  {
    "code": "nums = [ ] 10 . times do nums << gets . to_i end puts nums . sort . reverse . slice ( 0 , 3 ) . join ( \" \\n \" )",
    "label": 5
  },
  {
    "code": "MOUNTAIN_NUM = 10 HIGHER_NUM = 3 mountain_arr = [ ] MOUNTAIN_NUM . times do mountain_arr << gets . to_i end mountain_arr . sort! { | a , b | b <=> a } 0 . upto ( HIGHER_NUM - 1 ) do | i | puts mountain_arr [ i ] end",
    "label": 5
  },
  {
    "code": "arr = [ ] while line = gets do arr << line . to_i end arr . sort! for i in 1 .. 3 do puts arr [ - i ] end",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times do mountains << gets . chop . to_i end mountains . sort! . reverse! 3 . times do | i | puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "height = Array ( 10 ) for i in 0 .. 9 height [ i ] = gets . chomp . to_i end ans = height . sort for j in 1 .. 3 puts ans [ - 1 * j ] end",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { gets . to_i } . sort . reverse . first ( 3 )",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times do mountains << gets . chomp . to_i end mountains . sort! . reverse! 3 . times do | i | puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "puts ARGF . each . map ( & :to_i ) . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "mountain = [ ] ARGF . each_line do | line | mountain << line end mountain . sort! { | a , b | b . to_i <=> a . to_i } puts mountain [ 0 ] puts mountain [ 1 ] puts mountain [ 2 ]",
    "label": 5
  },
  {
    "code": "ary = [ ] ARGF . each do | line | ary << line . to_i end ary . sort! 3 . times { puts ary . pop }",
    "label": 5
  },
  {
    "code": "mt = Array . new while hight = gets do mt << hight . to_i end mt . sort! puts mt . pop puts mt . pop puts mt . pop",
    "label": 5
  },
  {
    "code": "mountains = [ ] while line = gets do mountains . push ( line . to_i ) end mountains . sort! { | a , b | b <=> a } 3 . times do | i | puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "mt = [ ] for i in ( 0 .. 9 ) mt [ i ] = gets . to_i end mt . sort! . reverse! for j in ( 0 .. 2 ) puts mt [ j ] end",
    "label": 5
  },
  {
    "code": "arr = Array . new ( 10 ) for i in 0 .. 9 do arr [ i ] = gets . chomp . to_i end arr . sort! . reverse! puts arr [ 0 ] puts arr [ 1 ] puts arr [ 2 ]",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 .. 9 do num [ i ] = gets . to_i end num . sort! . reverse! for i in 0 .. 2 do puts num [ i ] end",
    "label": 5
  },
  {
    "code": "num = Array . new for i in 0 .. 9 do num [ i ] = gets . to_i end num . sort! . reverse! for i in 0 .. 2 do puts num [ i ] end",
    "label": 5
  },
  {
    "code": "counts = 1 array = [ ] loop { array << gets . to_i counts = counts + 1 if counts > 10 then break end } array . sort! { | a , b | b <=> a } puts array [ 0 ] puts array [ 1 ] puts array [ 2 ]",
    "label": 5
  },
  {
    "code": "a = Array . new ( 10 ) for i in 0 .. 9 a [ i ] = gets . to_i end puts a . sort [ 9 ] puts a . sort [ 8 ] puts a . sort [ 7 ]",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr . push ( gets . chomp . to_i ) end arr . sort! 3 . times do | i | puts arr [ - 1 * ( i + 1 ) ] end",
    "label": 5
  },
  {
    "code": "heights = [ ] 10 . times do | i | heights [ i ] = gets . to_i end heights . sort! . reverse! puts heights [ 0 ] puts heights [ 1 ] puts heights [ 2 ]",
    "label": 5
  },
  {
    "code": "h = [ ] * 10 0 . upto ( 9 ) do | i | h [ i ] = gets . to_i end h . puts h [ 9 ] puts h [ 8 ] puts h [ 7 ]",
    "label": 5
  },
  {
    "code": "input_ary = [ ] while line = gets input_ary << line . to_i end puts input_ary . sort_by { | num | - num } . first ( 3 )",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times do mountains << gets . to_i end mountains . sort! { | a , b | b <=> a } 0 . upto ( 2 ) do | n | puts mountains [ n ] end",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { mountains . push ( gets . chomp . to_i ) } mountains . sort! . reverse! for i in 0 .. 2 do puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times { | i | height [ i ] = gets . to_i } height . sort! . reverse! 3 . times { | i | p height [ i ] }",
    "label": 5
  },
  {
    "code": "puts $< . sort_by { | x | x . to_i } . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = Array . new 10 . times { | i | a << gets . to_i } a . sort! 3 . times { | i | puts a [ - i - 1 ] }",
    "label": 5
  },
  {
    "code": "a = Array . new 10 . times { | i | a << gets . to_i } a . sort! { | a , b | b <=> a } 3 . times { | i | puts a [ i ] }",
    "label": 5
  },
  {
    "code": "hs = [ ] while n = gets hs << n . to_i end hs = hs . sort { | a , b | b <=> a } ( 0 .. 2 ) . each do | i | puts hs [ i ] end",
    "label": 5
  },
  {
    "code": "numbers = Array . new ( 10 ) for i in 0 .. 9 numbers [ i ] = gets . to_i end numbers = numbers . sort { | a , b | b <=> a } for i in 0 .. 2 puts numbers [ i ] end",
    "label": 5
  },
  {
    "code": "numbers = Array . new ( 10 ) for i in 0 .. 9 numbers [ i ] = gets . to_i end numbers = numbers . sort { | a , b | b <=> a } for j in 0 .. 2 do print ( numbers [ j ] , \" \\n \" ) end",
    "label": 5
  },
  {
    "code": "numbers = Array . new ( 10 ) for i in 0 .. 9 numbers [ i ] = gets . to_i end numbers = numbers . sort { | a , b | b <=> a } for j in 0 .. 2 do print ( numbers [ j ] , \" \\n \" ) end",
    "label": 5
  },
  {
    "code": "count = 0 mountains = [ ] while count <= 9 do mountains . push ( STDIN . gets . to_i ) count += 1 end puts mountains . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "data = [ ] 10 . times do data << gets . to_i end puts data . sort . reverse . take ( 3 ) . join ( \" \\n \" )",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 .. 9 do num [ i ] = gets . to_i end num . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for i in 0 .. 2 print ( num [ i ] , \" \\n \" ) end",
    "label": 5
  },
  {
    "code": "puts $< . to_a . map ( & :to_i ) . sort { | a , b | b <=> a } [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "mountain = [ ] 10 . times do mountain << gets . to_i end mountain . sort! puts mountain [ - 1 ] puts mountain [ - 2 ] puts mountain [ - 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] for i in 1 .. 10 a . push ( gets . chomp . to_i ) end a . sort! . reverse! for i in 0 ... 3 puts a [ i ] end",
    "label": 5
  },
  {
    "code": "height = Array . new 10 . times do height . push ( gets . to_i ) end height . sort! 9 . downto ( 7 ) do | i | puts height [ i ] end",
    "label": 5
  },
  {
    "code": "data = [ ] 10 . times do data . push gets . to_i end data . sort! . reverse! 3 . times do | i | puts data [ i ] end",
    "label": 5
  },
  {
    "code": "a = Array . new ; while s = gets do a << s . to_i ; end a . sort! { | a , b | b <=> a } puts a [ 0 ] ; puts a [ 1 ] ; puts a [ 2 ] ;",
    "label": 5
  },
  {
    "code": "data = [ ] for i in 0 .. 9 data [ i ] = gets . to_i end data . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for i in 0 .. 2 print \" end",
    "label": 5
  },
  {
    "code": "10 . times . inject ( [ ] ) { | a , i | a << gets . to_i ; a } . sort { | a , b | b <=> a } [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "10 . times . each_with_object ( [ ] ) { | _ , a | a << gets . to_i ; a } . sort { | a , b | b <=> a } [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "10 . times . each_with_object ( [ ] ) { | _ , a | a << gets . to_i } . sort { | a , b | b <=> a } [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "a = [ ] ; ( i = gets . to_i ) . between? ( 0 , 10_000 ) ? a << i : next while a . length < 11 ; a . sort { | a , b | b <=> a } [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "a = [ ] ; ( s = gets . to_i ) . between? ( 0 , 10_000 ) ? a << s : next while a . length < 11 ; a . sort { | i , j | j <=> i } [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "hills = [ ] STDIN . each_line { | l | hills . push ( l . to_i ) } hills . sort! hills [ - 3 , 3 ] . reverse_each { | v | p v }",
    "label": 5
  },
  {
    "code": "arr = [ ] while buf = gets arr <<buf . to_i end arr . sort! 3 . times { puts arr . pop }",
    "label": 5
  },
  {
    "code": "arr = [ ] 10 . times do | input | input = gets . chomp . to_i arr << input end arr . sort! { | a , b | b <=> a } 3 . times do | i | puts arr [ i ] end",
    "label": 5
  },
  {
    "code": "t = Array . new ( 10 ) 10 . times do | i | t [ i ] = gets . to_i end t . sort! { | a , b | b <=> a } p t [ 0 ] ; p t [ 1 ] ; p t [ 2 ]",
    "label": 5
  },
  {
    "code": "list = Array . new ( 3 , 0 ) 10 . times { t = gets . to_i ex = false list . each { | a | ex = true if t > a } if ex list . unshift ( t ) . pop list . sort! . reverse! end } list . each { | t | puts t }",
    "label": 5
  },
  {
    "code": "arry = Array . new for i in 1 .. 10 do arry << gets . chomp . to_i end arry . sort! arry . reverse! puts arry . take ( 3 )",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times { height << gets . to_i } puts height . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "arr = [ ] 10 . times { arr << gets . to_i } puts arr . sort { | a , b | b <=> a } [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "n = [ ] i = 0 while i < 10 n [ i ] = gets . to_i i += 1 end arr = n . sort { | a , b | b <=> a } 3 . times { | j | puts arr [ j ] }",
    "label": 5
  },
  {
    "code": "class Main def initialize fh = STDIN f = [ ] 0 . upto ( 9 ) { | i | f . push ( fh . gets . to_i ) } puts f . sort { | a , b | b <=> a } . take ( 3 ) . map { | x | x . to_s } end end if $0 == __FILE__ then Main . new end",
    "label": 5
  },
  {
    "code": "m_list = [ ] 10 . times { | n | m_list << gets . to_i } m_list . sort! { | a , b | b <=> a } 3 . times { | i | p m_list [ i ] }",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 .. 9 num [ i ] = gets . to_i end for i in 0 .. 2 ans = 0 for j in 0 .. 9 if ans < num [ j ] ans = num [ j ] set = j end end puts ans num [ set ] = 0 end",
    "label": 5
  },
  {
    "code": "ary = [ ] 10 . times do ary << gets . to_i end ary . sort! puts ary [ 9 ] puts ary [ 8 ] puts ary [ 7 ]",
    "label": 5
  },
  {
    "code": "i = [ ] 10 . times do i . push gets . to_i end i . sort . reverse . take ( 3 ) . each do | v | p v end",
    "label": 5
  },
  {
    "code": "ary = [ ] i = 0 while ( i < 10 ) ary . push ( gets . to_i ) i += 1 end s = ary . sort [ - 3 , 3 ] puts s . reverse",
    "label": 5
  },
  {
    "code": "hs = [ ] while ( h = gets . to_i ) != 0 hs << h end hs . sort { | a , b | b <=> a } . first ( 3 ) . each do | h1 | puts h1 end",
    "label": 5
  },
  {
    "code": "num = [ ] i = 0 while i < 10 num [ i ] = gets . to_i i += 1 end num . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for n in 0 .. 2 puts \" end",
    "label": 5
  },
  {
    "code": "m = [ ] while line = gets m . push line . to_i end m . sort! . reverse! puts m [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "a = [ ] for i in 0 .. 9 a << gets . to_i end for i in 0 .. 2 puts ( a . max ) a . delete_at ( a . index ( a . max ) ) end",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times { h << gets . to_i } h . sort . reverse . take ( 3 ) . each { | hh | puts hh }",
    "label": 5
  },
  {
    "code": "readlines . map ( & :to_i ) . sort . reverse [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "readlines . map ( & :to_i ) . sort . reverse [ 0 .. 2 ] . each { | i | puts i }",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { mountain = gets . to_i ( mountains ) . push ( mountain ) } mountains = mountains . sort { | a , b | b <=> a } puts mountains [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { mountain = gets . to_i ( mountains ) . push ( mountain ) } mountains . sort! { | a , b | b <=> a } puts mountains [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "a = Array . new ( 10 ) 10 . times do | i | a [ i ] = gets . to_i end a . sort! { | a , b | b <=> a } 3 . times do | i | puts \" end",
    "label": 5
  },
  {
    "code": "top3 = [ 0 , 0 , 0 ] 10 . times do n = gets . chomp . to_i if n > top3 [ 0 ] then top3 [ 0 ] = n top3 . sort! end end for n in top3 . sort { | a , b | b <=> a } do puts ( n ) end",
    "label": 5
  },
  {
    "code": "$stdin . readlines . map ( & :to_i ) . sort . reverse [ 0 , 3 ] . each { | a | puts a }",
    "label": 5
  },
  {
    "code": "$< . map ( & :to_i ) . sort . reverse [ 0 , 3 ] . each { | a | puts a }",
    "label": 5
  },
  {
    "code": "num = [ ] 10 . times do num << gets . to_i end num . sort! puts \" puts \" puts \"",
    "label": 5
  },
  {
    "code": "height = Array . new 10 . times do | i | height . push ( gets . to_i ) end height . sort! p height [ 9 ] , height [ 8 ] , height [ 7 ]",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { | i | mountains << gets . to_i } mountains . sort! { | a , b | b <=> a } 3 . times { | i | puts mountains [ i ] }",
    "label": 5
  },
  {
    "code": "puts readlines . map ( & :to_i ) . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "heights = Array . new while height = STDIN . gets heights . push ( height . chomp . to_i ) end heights . sort! 3 . times do puts heights . pop end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a << gets . to_i end a = a . sort puts a [ 9 ] puts a [ 8 ] puts a [ 7 ]",
    "label": 5
  },
  {
    "code": "arr = ( 1 .. 10 ) . map { gets . to_i } puts arr . sort . reverse [ 0 .. 2 ] . join ( \" \\n \" )",
    "label": 5
  },
  {
    "code": "INPUT_NUM = 10 array = [ ] INPUT_NUM . times do | i | array [ i ] = gets . to_i end array = array . sort 3 . times do | i | print \" end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a <<gets . to_i end a = a . sort p a [ 9 ] ; p a [ 8 ] ; p a [ 7 ]",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times { h << gets . chomp . to_i } h . sort! puts h . pop puts h . pop puts h . pop",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 .. 9 do a = gets . to_i num . push ( a ) end num . sort! for i in 0 .. 2 do puts num [ 9 - i ] end",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times do | i | h [ i ] = gets . chomp . to_i end max1 = 0 max2 = 0 max3 = 0 10 . times do | i | if max1 <= h [ i ] max3 = max2 max2 = max1 max1 = h [ i ] elsif max2 <= h [ i ] max3 = max2 max2 = h [ i ] elsif max3 <= h [ i ] max3 = h [ i ] end end puts max1 puts max2 puts max3",
    "label": 5
  },
  {
    "code": "line = [ ] while l = gets line <<l . to_i end line = line . sort puts line [ 9 ] puts line [ 8 ] puts line [ 7 ]",
    "label": 5
  },
  {
    "code": "data = Array . new ( 10 ) { STDIN . gets . chomp! . to_i } data . sort! { | a , b | b <=> a } for i in 0 .. 2 do puts data [ i ] end",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times do height . push ( gets . chomp . to_i ) end height . sort! . reverse! 3 . times { | i | puts height [ i ] }",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { | i | mountains [ i ] = gets . chomp . to_i } mountains . sort! . reverse! 3 . times { | i | puts mountains [ i ] }",
    "label": 5
  },
  {
    "code": "ary = [ ] 10 . times do input = gets . chomp . to_i ary . push ( input ) end 3 . times do max = ary . max index = ary . index ( max ) puts ary [ index ] ary . delete_at ( index ) end",
    "label": 5
  },
  {
    "code": "temp = 0 height = Array . new ( 10 , 0 ) for i in 1 .. 10 do height [ i ] = gets . to_i end for i in 1 .. 10 do for j in i + 1 .. 10 do if height [ i ] < height [ j ] then temp = height [ i ] height [ i ] = height [ j ] height [ j ] = temp end end end for i in 1 .. 3 do print ( height [ i ] , \" \\n \" ) end",
    "label": 5
  },
  {
    "code": "max_1 = 0 max_2 = 0 max_3 = 0 10 . times do x = gets . chomp . to_i if x > max_3 max_3 = x if max_3 > max_2 max_2 , max_3 = max_3 , max_2 if max_2 > max_1 max_1 , max_2 = max_2 , max_1 end end end end puts max_1 puts max_2 puts max_3",
    "label": 5
  },
  {
    "code": "x = [ ] 10 . times do x << gets . to_i end y = x . sort . reverse puts y [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "hills = Array . new ARGF . each_line do | line | line = line . chomp hills . push ( line . to_i ) end hills = hills . sort { | x , y | y <=> x } hills = hills . slice ( 0 , 3 ) puts \"",
    "label": 5
  },
  {
    "code": "list = Array . new for i in 0 .. 9 list . push ( gets . to_i ) end list . sort! { | a , b | b <=> a } puts list [ 0 ] puts list [ 1 ] puts list [ 2 ]",
    "label": 5
  },
  {
    "code": "lines = $stdin . read array = lines . split ( \" \\n \" ) . map ( & :to_i ) . sort . reverse puts array [ 0 ] puts array [ 1 ] puts array [ 2 ]",
    "label": 5
  },
  {
    "code": "hs = [ ] while line = gets hs . push ( line . to_i ) end hs . sort! { | a , b | b - a } puts hs [ 0 ] puts hs [ 1 ] puts hs [ 2 ]",
    "label": 5
  },
  {
    "code": "h = [ - 1 , - 1 , - 1 ] 10 . times { it = gets . to_i if h [ 0 ] < it h = [ it , h [ 0 ] , h [ 1 ] ] elsif h [ 1 ] < it h = [ h [ 0 ] , it , h [ 1 ] ] elsif h [ 2 ] < it h = [ h [ 0 ] , h [ 1 ] , it ] end } 3 . times { | i | puts h [ i ] }",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times { | i | h [ i ] = gets . to_i } hs = h . sort { | a , b | b <=> a } 3 . times { | i | puts hs [ i ] }",
    "label": 5
  },
  {
    "code": "mounts = [ ] 10 . times do mounts << gets . chomp . to_i end mounts = mounts . sort puts mounts . pop puts mounts . pop puts mounts . pop",
    "label": 5
  },
  {
    "code": "height_array = [ 0 , 0 , 0 ] for i in 1 .. 10 new_height = gets . to_i if height_array [ 0 ] <= new_height height_array [ 2 ] = height_array [ 1 ] height_array [ 1 ] = height_array [ 0 ] height_array [ 0 ] = new_height elsif height_array [ 1 ] <= new_height height_array [ 2 ] = height_array [ 1 ] height_array [ 1 ] = new_height elsif height_array [ 2 ] <= new_height height_array [ 2 ] = new_height else end end height_array . each do | height | puts height end",
    "label": 5
  },
  {
    "code": "puts $< . map ( & :to_i ) . sort . reverse . shift ( 3 )",
    "label": 5
  },
  {
    "code": "list = [ ] while line = STDIN . gets list . push ( line . to_i ) end puts list . sort . reverse . slice ( 0 , 3 )",
    "label": 5
  },
  {
    "code": "heights = [ ] 10 . times do heights . push ( gets . chomp . to_i ) end heights . sort! { | a , b | b <=> a } 3 . times do | i | p heights [ i ] end",
    "label": 5
  },
  {
    "code": "array = [ ] while str = gets do array << str . chomp . to_i end array = array . sort . reverse puts array [ 0 ] puts array [ 1 ] puts array [ 2 ]",
    "label": 5
  },
  {
    "code": "input = [ ] 10 . times { input << gets . to_i } input . sort! 3 . times { puts input . pop }",
    "label": 5
  },
  {
    "code": "input = [ ] 10 . times { input << gets . to_i } input . sort! 3 . times { puts input . pop }",
    "label": 5
  },
  {
    "code": "STDIN . map ( & :to_i ) . sort { | a , b | b <=> a } . first ( 3 ) . each { | s | puts s }",
    "label": 5
  },
  {
    "code": "mountains = [ ] while line = gets mountains << line . chomp! . to_i end mountains . sort! 3 . times { puts mountains . pop }",
    "label": 5
  },
  {
    "code": "mountains_heights = [ ] 10 . times do mountains_heights << gets . to_i end mountains_heights . sort! . reverse! puts mountains_heights [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "arr = [ ] 10 . times { arr << gets . to_i } puts arr . sort { | a , b | b <=> a } [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "puts gets ( nil ) . split ( \" \\n \" ) . map ( & :to_i ) . sort . reverse . take ( 3 )",
    "label": 5
  },
  {
    "code": "input = $stdin . read . split ( \" \\n \" ) puts input . map ( & :to_i ) . sort { | a , b | b <=> a } [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "arr = Array . new ( ) 10 . times do arr . push ( gets . to_i ( ) ) end arr . sort! 3 . times do | i | puts arr [ arr . size - i - 1 ] end",
    "label": 5
  },
  {
    "code": "height_mountain = Array . new while line = gets height_mountain . push ( line . to_i ) end height_mountain . sort! . reverse! 3 . times { | idx | puts height_mountain [ idx ] }",
    "label": 5
  },
  {
    "code": "puts $stdin . read . split ( \" \\n \" ) . map ( & :to_i ) . sort! . reverse! . first ( 3 )",
    "label": 5
  },
  {
    "code": "arr = [ ] while input = gets do arr . push ( input . to_i ) end arr . sort! { | a , b | b <=> a } puts arr [ 0 ] , arr [ 1 ] , arr [ 2 ]",
    "label": 5
  },
  {
    "code": "val = [ ] for i in 0 .. 9 val . push ( gets . to_i ( ) ) end val . sort! for i in 0 .. 2 puts val [ 9 - i ] end",
    "label": 5
  },
  {
    "code": "n = readlines . map { | item | item . to_i } . sort! puts n [ 9 ] , n [ 8 ] , n [ 7 ]",
    "label": 5
  },
  {
    "code": "heights = STDIN . read . each_line . map ( & :to_i ) puts heights . sort_by { | e | - e } . take ( 3 )",
    "label": 5
  },
  {
    "code": "s = [ 0 , 0 , 0 ] 10 . times do | i | x = gets . chomp . to_i if s [ 0 ] < x s [ 2 ] = s [ 1 ] s [ 1 ] = s [ 0 ] s [ 0 ] = x elsif s [ 1 ] < x s [ 2 ] = s [ 1 ] s [ 1 ] = x elsif s [ 2 ] < x s [ 2 ] = x end end puts s",
    "label": 5
  },
  {
    "code": "mt_array = [ ] 10 . times { mt_array << gets . to_i } 3 . times { puts mt_array . sort! . pop }",
    "label": 5
  },
  {
    "code": "nums = [ ] 10 . times { nums << gets . to_i } nums . sort! . reverse! 3 . times { | i | puts nums [ i ] }",
    "label": 5
  },
  {
    "code": "input = [ ] 10 . times do input . push ( gets . to_i ) end puts input . sort . reverse . take ( 3 )",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr << gets . to_i end puts arr . sort [ - 3 .. - 1 ] . reverse",
    "label": 5
  },
  {
    "code": "mount = [ ] while high = gets mount << high . to_i end mount . sort! { | a , b | - ( a <=> b ) } ( 0 .. 2 ) . each { | i | puts mount [ i ] }",
    "label": 5
  },
  {
    "code": "v = [ ] ; v << $_ . to_i while gets ; 3 . times { | i | p v . sort . reverse [ i ] }",
    "label": 5
  },
  {
    "code": "array = Array . new 10 . times { array << gets . to_i } array . sort! 3 . times { puts array . pop }",
    "label": 5
  },
  {
    "code": "puts gets ( p ) . map ( & :to_i ) . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times { a <<gets . to_i } a . sort! 3 . times { puts a . pop }",
    "label": 5
  },
  {
    "code": "Thread . new do v = 10 . times . map { gets . to_i } . sort! puts v [ 9 ] , v [ 8 ] , v [ 7 ] end sleep 10",
    "label": 5
  },
  {
    "code": "t = Thread . new do v = 10 . times . map { gets . to_i } . sort! puts v [ 9 ] , v [ 8 ] , v [ 7 ] sleep 2 end t . join",
    "label": 5
  },
  {
    "code": "a = Array . new while c = gets a . push ( c . to_i ) end a . sort! . reverse! puts a [ 0 ] , a [ 1 ] , a [ 2 ]",
    "label": 5
  },
  {
    "code": "h = [ ] ; 10 . times . each { h . push ( STDIN . gets . to_i ) } ; h . sort . reverse [ 0 .. 2 ] . each { | x | puts x }",
    "label": 5
  },
  {
    "code": "h = readlines . map ( & :to_i ) . sort! { | x , y | y <=> x } 3 . times { | i | puts h [ i ] }",
    "label": 5
  },
  {
    "code": "a = [ ] ; 10 . times { a <<gets . to_i } ; puts a . sort { | a , b | b <=> a } [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] ; 10 . times { a <<eval ( gets ) } ; puts a . sort [ 7 , 3 ] . reverse",
    "label": 5
  },
  {
    "code": "a = [ ] ; 10 . times { a <<gets . to_i } ; puts a . sort [ 7 , 3 ] . reverse",
    "label": 5
  },
  {
    "code": "puts ( 0 .. 9 ) . inject ( [ ] ) { | a , | a <<gets . to_i } . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] ; a << $_ . to_i while gets ; puts a . sort { | a , b | b - a } [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "puts readlines . map ( & :to_i ) . sort { | a , b | b - a } [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = readlines . map ( & :to_i ) . sort ; 3 . times { p a . pop }",
    "label": 5
  },
  {
    "code": "puts * $< . map ( & :to_i ) . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "puts * $< . sort_by { | x | - x . to_i } [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] i = 0 while j = gets a [ i ] = j i += 1 end a . sort! { | x , y | y . to_i <=> x . to_i } 3 . times { | i | puts ( a [ i ] ) }",
    "label": 5
  },
  {
    "code": "mt = [ ] 10 . times { mt . push ( STDIN . gets . to_i ) } mt . sort! puts mt [ - 1 ] puts mt [ - 2 ] puts mt [ - 3 ]",
    "label": 5
  },
  {
    "code": "ms = Array . new ( 10 ) 10 . times { | i | ms [ i ] = Integer ( gets ) } ms = ms . sort . reverse 3 . times { | i | puts ms [ i ] }",
    "label": 5
  },
  {
    "code": "if __FILE__ == $0 heights = Array . new while line = gets heights . push line . to_i end result = heights . sort . reverse puts result [ 0 ] puts result [ 1 ] puts result [ 2 ] end",
    "label": 5
  },
  {
    "code": "array = [ 10 ] result = [ 10 ] 10 . times { | i | array [ i ] = gets . to_i } result = array . sort result = result . reverse 3 . times { | j | puts result [ j ] }",
    "label": 5
  },
  {
    "code": "num = [ ] i = 0 while i < 10 num [ i ] = gets . to_i i += 1 end num . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for n in 0 .. 2 puts \" end",
    "label": 5
  },
  {
    "code": "a = [ ] for i in 1 .. 10 do d = gets ; a . push ( d . to_i ) end a . sort! ; a . reverse! for i in 0 .. 2 do p a [ i ] end",
    "label": 5
  },
  {
    "code": "hoge = [ ] for i in 1 .. 10 a = gets . to_i hoge . push ( a ) hoge . sort! ; hoge . reverse! end for i in 0 .. 2 puts hoge [ i ] end",
    "label": 5
  },
  {
    "code": "line = [ ] while l = gets line <<l . to_i end line = line . sort puts line [ 9 ] puts line [ 8 ] puts line [ 7 ]",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times { height . push ( STDIN . gets . to_i ) } height . sort! puts height [ - 1 ] puts height [ - 2 ] puts height [ - 3 ]",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times { height . push ( STDIN . gets . to_i ) } height . sort! p height [ - 1 ] p height [ - 2 ] p height [ - 3 ]",
    "label": 5
  },
  {
    "code": "height = [ ] 10 . times { height . push ( STDIN . gets . to_i ) } height . sort! p height [ - 1 ] p height [ - 2 ] p height [ - 3 ]",
    "label": 5
  },
  {
    "code": "mt = [ ] 10 . times { | n | mt << gets . to_i } mt . sort! . reverse! 3 . times { | n | puts mt [ n ] }",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a << gets . to_i end a = a . sort puts a [ 9 ] puts a [ 8 ] puts a [ 7 ]",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times do mountains << gets . to_i end mountains . sort! . reverse! 3 . times do | i | puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "-> ( ) { Array . new ( 10 ) . map { gets . to_i } } . call . sort . reverse [ 0 .. 2 ] . each { | v | p v }",
    "label": 5
  },
  {
    "code": "numMountains = 10 mountain = Array . new ( numMountains ) . fill ( 0 , 0 ... numMountains ) for i in 0 ... numMountains mountain [ i ] = gets . to_i end mountain . sort! { | x , y | y . to_i <=> x . to_i } for i in 0 ... 3 puts mountain [ i ] end",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { $stdin . gets . chomp . to_i } . sort { | a , b | b <=> a } . take ( 3 )",
    "label": 5
  },
  {
    "code": "mountains = [ ] while mountain = gets mountains << mountain . chomp . to_i end puts mountains . sort . reverse . take ( 3 ) . join ( \" \\n \" )",
    "label": 5
  },
  {
    "code": "puts readlines . map ( & :to_i ) . sort . reverse . first ( 3 )",
    "label": 5
  },
  {
    "code": "ary = [ ] 10 . times { ary << gets . to_i } ary . sort { | a , b | b <=> a } [ 0 .. 2 ] . map { | e | puts e }",
    "label": 5
  },
  {
    "code": "class Fuji def run arr = [ ] ; while ( s = gets ( ) ) do arr << s . to_i end arr . sort! ( ) 3 . times do puts arr . pop ( ) end end end Fuji :: new . run ( )",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr << gets . to_i end arr . sort! - 1 . downto ( - 3 ) { | i | puts arr [ i ] }",
    "label": 5
  },
  {
    "code": "rec = Array . new 10 . times { n = gets . to_i rec . push ( n ) } rec . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for i in 0 .. 2 puts rec [ i ] end",
    "label": 5
  },
  {
    "code": "rec = Array . new 10 . times { rec << gets . to_i } rec . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for i in 0 .. 2 puts rec [ i ] end",
    "label": 5
  },
  {
    "code": "hs = [ ] while h = gets . to_i hs . push ( h ) if ( hs . size == 10 ) break ; end end hs . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for x in 0 .. 2 puts hs [ x ] end",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr << gets . to_i end arr . sort! - 1 . downto ( - 3 ) { | i | puts arr [ i ] }",
    "label": 5
  },
  {
    "code": "arr = [ ] for cnt in 0 ... 10 arr . push ( gets . chomp . to_i ( ) ) end arr . sort! . for cnt in 0 ... 3 puts ( arr [ cnt ] ) end",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { gets . to_i } . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "puts $< . map ( & :to_i ) . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "ary = [ ] 10 . times do ary << gets . to_i end ary . sort_by! { | v | v } ( 1 .. 3 ) . each do | i | puts ary [ ary . size - i ] end",
    "label": 5
  },
  {
    "code": "array = Array . new ( 10 ) i = 0 while i < 10 array [ i ] = gets . to_i i += 1 end array . sort! for i in 0 .. 2 puts ( array [ array . size - 1 - i ] ) end",
    "label": 5
  },
  {
    "code": "num = Array . new ( 2 , nil ) height = Array . new ( 10 , nil ) for num [ 0 ] in 0 .. 9 do height [ num [ 0 ] ] = gets . to_i end height . sort! { | a , b | b <=> a } for num [ 0 ] in 0 .. 2 do puts height [ num [ 0 ] ] end",
    "label": 5
  },
  {
    "code": "array = [ ] 10 . times do array <<gets . to_i end arr = array . sort . reverse for i in 0 .. 2 puts ( arr [ i ] ) end",
    "label": 5
  },
  {
    "code": "a = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] for num in 0 .. 9 do a [ num ] = gets . to_i end n = a . size - 1 for i in 0 .. n for j in 0 .. n - i - 1 if a [ j ] > a [ j + 1 ] tmp = a [ j ] a [ j ] = a [ j + 1 ] a [ j + 1 ] = tmp end end end puts a [ 9 ] puts a [ 8 ] puts a [ 7 ]",
    "label": 5
  },
  {
    "code": "a = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] for num in 0 .. 9 do a [ num ] = gets . to_i end n = a . size - 1 for i in 0 .. n for j in 0 .. n - i - 1 if a [ j ] > a [ j + 1 ] tmp = a [ j ] a [ j ] = a [ j + 1 ] a [ j + 1 ] = tmp end end end puts a [ 9 ] puts a [ 8 ] puts a [ 7 ]",
    "label": 5
  },
  {
    "code": "mountains = Array . new ( 10 ) 10 . times do | i | mountains [ i ] = gets . to_i end mountains . sort! 9 . downto ( 7 ) do | i | puts mountains [ i ] end",
    "label": 5
  },
  {
    "code": "list = [ ] for num in 0 ... 10 list . push ( gets . to_i ) end list . sort! . for n in 0 .. 2 puts list [ n ] end",
    "label": 5
  },
  {
    "code": "a = Array . new while b = gets if b == \" \\n \" break else a . push ( b . to_i ) end end a . sort! 3 . times do | i | p a [ a . size - i - 1 ] end",
    "label": 5
  },
  {
    "code": "a = Array . new 10 . times do | i | a . push ( gets . to_i ) end a . sort! 3 . times do | i | p a [ a . size - i - 1 ] end",
    "label": 5
  },
  {
    "code": "a = Array . new ( ) 10 . times do | i | a [ i ] = gets . to_i end n = a . sort { | a , b | - ( a <=> b ) } 3 . times do | i | puts n [ i ] . to_s + \" \\n \" end",
    "label": 5
  },
  {
    "code": "arr = [ ] 10 . times { | i | arr << gets . to_i } arr . sort! arr . reverse! 3 . times { | i | puts arr [ i ] }",
    "label": 5
  },
  {
    "code": "i = 0 h = - 1 c = - 1 l = - 1 while i < 10 x = gets . to_i if x > l if x > c if x > h l = c c = h h = x else l = c c = x end else l = x end end i = i + 1 end puts h puts c puts l",
    "label": 5
  },
  {
    "code": "hills = [ 0 , 0 , 0 ] 10 . times { x = gets . to_i if x > hills [ 2 ] hills [ 0 ] = hills [ 1 ] hills [ 1 ] = hills [ 2 ] hills [ 2 ] = x elsif x > hills [ 1 ] hills [ 0 ] = hills [ 1 ] hills [ 1 ] = x elsif x > hills [ 0 ] hills [ 0 ] = x end } 3 . times do | i | puts hills [ 2 - i ] end",
    "label": 5
  },
  {
    "code": "heights = ARGF . each_line . map { | line | line . to_i } . sort . reverse heights [ 0 .. 2 ] . each { | height | puts height }",
    "label": 5
  },
  {
    "code": "height = [ ] for i in 0 .. 9 do height [ i ] = gets . to_i end height . sort! { | a , b | ( - 1 ) * ( a <=> b ) } for n in 0 .. 2 puts \" end",
    "label": 5
  },
  {
    "code": "def main height = [ ] while str = gets height << str . chomp . to_i end height . sort . reverse [ 0 .. 2 ] . each do | h | puts h end end main",
    "label": 5
  },
  {
    "code": "puts $stdin . read . split . map { | e | e . to_i } . sort { | a , b | b <=> a } [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "s = [ ] 10 . times { | i | s [ i ] = gets . to_i } s . sort! { | a , b | ( - 1 ) * ( a <=> b ) } 3 . times { | i | puts \" }",
    "label": 5
  },
  {
    "code": "height = [ ] for i in 0 .. 9 do height [ i ] = gets . to_i end height = height . sort { | a , b | - ( a <=> b ) } puts \"",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { mountains << gets . chomp . to_i } 3 . times { puts mountains . sort! . pop }",
    "label": 5
  },
  {
    "code": "num = Array . new ( 10 ) for i in 0 .. 9 do num [ i ] = gets . chomp . to_i end num = num . sort { | a , b | b <=> a } print num [ 0 ] , \" \\n \" , num [ 1 ] , \" \\n \" , num [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { mountains << gets . to_i } 3 . times { puts mountains . sort! . pop }",
    "label": 5
  },
  {
    "code": "n = 0 ; h = [ ] ; while n < 10 ; h <<gets . to_i ; n += 1 ; end ; h . sort! { | a , b | b <=> a } ; n = 0 ; while n < 3 ; puts h [ n ] ; n += 1 ; end",
    "label": 5
  },
  {
    "code": "mountains = [ ] 10 . times { mountains << gets . to_i } 3 . times { puts mountains . sort! . pop }",
    "label": 5
  },
  {
    "code": "puts STDIN . read . split . sort_by ( & :to_i ) [ - 3 , 3 ] . reverse",
    "label": 5
  },
  {
    "code": "puts STDIN . read . split . sort_by ( & :to_i ) . last ( 3 ) . reverse",
    "label": 5
  },
  {
    "code": "puts STDIN . each_line . sort_by ( & :to_i ) . last ( 3 ) . reverse",
    "label": 5
  },
  {
    "code": "max1 = gets . to_i max2 = - 1 max3 = - 1 for i in 2 .. 10 do a = gets . to_i if ( a > max1 ) max3 = max2 max2 = max1 max1 = a elsif ( a > max2 ) max3 = max2 max2 = a elsif ( a > max3 ) max3 = a end end print max1 , \" \\n \" , max2 , \" \\n \" , max3 , \" \\n \" ;",
    "label": 5
  },
  {
    "code": "a = [ ] while gets do a << $_ . to_i end puts a . sort { | i , j | j <=> i } . first ( 3 )",
    "label": 5
  },
  {
    "code": "a = Array . new ( 10 ) 10 . times { | i | a [ i ] = gets . to_i } a . sort! p a [ - 1 ] p a [ - 2 ] p a [ - 3 ]",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { | i | gets . to_i } . sort . reverse . take ( 3 )",
    "label": 5
  },
  {
    "code": "data = [ ] 10 . times { | i | data << gets . to_i } data . sort! { | a , b | b <=> a } 3 . times { | i | puts data [ i ] }",
    "label": 5
  },
  {
    "code": "x = [ ] 10 . times { x += [ gets ( ) . to_i ] } x . sort! . reverse! puts ( x [ 0 ] , x [ 1 ] , x [ 2 ] )",
    "label": 5
  },
  {
    "code": "out = [ ] def out . higher? ( v ) return true if self . size < 3 self . each do | h | return true if v > h end return false end def out . push ( v ) if self . size < 3 self << v return end min = 10000 min_i = 3 self . each_with_index do | h , i | min , min_i = h , i if min > h end self [ min_i ] = v end def out . puts_desc order = [ ] 3 . times do max = 0 max_i = 3 self . each_with_index do | h , i | max , max_i = h , i if max < h end order << max self . delete_at ( max_i ) end order . each do | v | puts v end end 10 . times do | count | num = readline . to_i if out . higher? num out . push num end end out . puts_desc",
    "label": 5
  },
  {
    "code": "out = [ ] def out . higher? ( v ) return true if self . size < 3 self . each do | h | return true if v > h end return false end def out . push ( v ) if self . size < 3 self << v return end min = 10000 min_i = 3 self . each_with_index do | h , i | min , min_i = h , i if min > h end self [ min_i ] = v end def out . puts_desc order = [ ] 3 . times do max = 0 max_i = 3 self . each_with_index do | h , i | max , max_i = h , i if max < h end order << max self . delete_at ( max_i ) end order . each do | v | puts v end end 10 . times do | count | num = readline . to_i if out . higher? num out . push num end end out . puts_desc",
    "label": 5
  },
  {
    "code": "array = [ ] for count in 1 .. 10 array . push gets . chomp . to_i end count = 1 while count < 10 if array [ count - 1 ] < array [ count ] spare = array [ count - 1 ] array [ count - 1 ] = array [ count ] array [ count ] = spare count = 1 else count += 1 end end puts array [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "out = [ ] def out . higher? ( v ) return true if self . size < 3 self . each do | h | return true if v > h end return false end def out . push ( v ) if self . size < 3 self << v return end min = 10000 min_i = 3 self . each_with_index do | h , i | min , min_i = h , i if min > h end self [ min_i ] = v end def out . puts_desc order = [ ] 3 . times do max = 0 max_i = 3 self . each_with_index do | h , i | max , max_i = h , i if max < h end order << max self . delete_at ( max_i ) end order . each do | v | puts v end end 10 . times do | count | num = readline . to_i if out . higher? num out . push num end end out . puts_desc",
    "label": 5
  },
  {
    "code": "out = [ ] def out . higher? ( v ) return true if self . size < 3 self . each do | h | return true if v > h end return false end def out . push ( v ) if self . size < 3 self << v return end min = 10000 min_i = 3 self . each_with_index do | h , i | min , min_i = h , i if min > h end self [ min_i ] = v end def out . puts_desc order = [ ] 3 . times do max = 0 max_i = 3 self . each_with_index do | h , i | max , max_i = h , i if max < h end order << max self . delete_at ( max_i ) end order . each do | v | puts v end end 10 . times do | count | num = readline . to_i if out . higher? num out . push num end end out . puts_desc",
    "label": 5
  },
  {
    "code": "out = [ ] def out . higher? ( v ) return true if self . size < 3 self . each do | h | return true if v > h end return false end def out . push ( v ) if self . size < 3 self << v return end min = 10000 min_i = 3 self . each_with_index do | h , i | min , min_i = h , i if min > h end self [ min_i ] = v end def out . puts_desc order = [ ] 3 . times do max = 0 max_i = 3 self . each_with_index do | h , i | max , max_i = h , i if max < h end order << max self . delete_at ( max_i ) end order . each do | v | puts v end end 10 . times do | count | num = readline . to_i if out . higher? num out . push num end end out . puts_desc",
    "label": 5
  },
  {
    "code": "out = [ ] def out . higher? ( v ) return true if self . size < 3 self . each do | h | return true if v > h end return false end def out . push ( v ) if self . size < 3 self << v return end min = 10000 min_i = 3 self . each_with_index do | h , i | min , min_i = h , i if min > h end self [ min_i ] = v end def out . puts_desc order = [ ] 3 . times do max = 0 max_i = 3 self . each_with_index do | h , i | max , max_i = h , i if max < h end order << max self . delete_at ( max_i ) end order . each do | v | puts v end end 10 . times do | count | num = readline . to_i if out . higher? num out . push num end end out . puts_desc",
    "label": 5
  },
  {
    "code": "a = Array . new 10 . times do n = gets . to_i a . push n end a . sort! p a . pop p a . pop p a . pop",
    "label": 5
  },
  {
    "code": "first = 0 second = 0 third = 0 10 . times do tmp = STDIN . gets . to_i if tmp > third then if tmp > second then if tmp > first then third = second second = first first = tmp else third = second second = tmp end else third = tmp end end end STDOUT . puts ( first ) STDOUT . puts ( second ) STDOUT . puts ( third )",
    "label": 5
  },
  {
    "code": "ary = Array . new ( 10 ) for i in 0 .. 9 do ary [ i ] = gets . to_i end ary . sort! . reverse! p ary [ 0 ] p ary [ 1 ] p ary [ 2 ]",
    "label": 5
  },
  {
    "code": "class Mountain @data def initialize @data = [ ] while input = gets @data << input . to_i end end def sort_data @data . sort! . reverse! end def get_data return @data end end class Main def run m = Mountain . new m . sort_data d = m . get_data flg = 0 d . map { | hoge | flg = flg + 1 p hoge if ( flg == 3 ) break end } end end Main . new . run ;",
    "label": 5
  },
  {
    "code": "first = 0 second = 0 third = 0 for i in 1 .. 10 do inp = gets . to_i if first < inp then third = second second = first first = inp elsif second < inp then third = second second = inp elsif third < inp then third = inp end end print ( first , \" \\n \" , second , \" \\n \" , third , \" \\n \" )",
    "label": 5
  },
  {
    "code": "puts STDIN . read . lines . map ( & :to_i ) . sort . reverse . first ( 3 )",
    "label": 5
  },
  {
    "code": "input = gets ( nil ) m = input . split . map ( & :to_i ) . sort ( m . size - 1 ) . downto ( m . size - 3 ) do | i | puts m [ i ] end",
    "label": 5
  },
  {
    "code": "heights = [ ] 10 . times do | i | heights << gets . chomp . to_i end puts heights . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "def quick_sort ( array , left_pos , right_pos ) return array if array . size == 0 if left_pos < right_pos i , j = left_pos , right_pos pivot = array [ ( left_pos + right_pos ) / 2 ] while i <= j while array [ i ] < pivot i = i + 1 end while array [ j ] > pivot j = j - 1 end if i <= j array [ i ] , array [ j ] = array [ j ] , array [ i ] i = i + 1 j = j - 1 end end quick_sort ( array , left_pos , j ) quick_sort ( array , i , right_pos ) end return array end str = [ ] for i in 0 .. 9 do str . push ( gets . to_i ) end str1 = [ 1819 , 2003 , 876 , 2840 , 1723 , 1673 , 3776 , 2848 , 1592 , 922 ] ans = quick_sort ( str , 0 , str . size - 1 ) puts ans [ 9 ] puts ans [ 8 ] puts ans [ 7 ]",
    "label": 5
  },
  {
    "code": "hills = [ ] 10 . times do hills << gets . chomp . to_i end hills . sort! { | x , y | y <=> x } 3 . times do | idx | puts hills [ idx ] end",
    "label": 5
  },
  {
    "code": "num = [ ] while num . count < 10 num . push ( gets . to_i ) end num = num . sort . reverse 3 . times do | i | puts num [ i ] end",
    "label": 5
  },
  {
    "code": "ary = [ ] 10 . times do ary . push gets . to_i end ary . sort! { | a , b | b <=> a } for num in 0 .. 2 do puts ary [ num ] end",
    "label": 5
  },
  {
    "code": "heights = [ ] while line = ARGF . gets do heights << line . to_i end heights . sort . reverse [ 0 .. 2 ] . each { | h | puts h }",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end print a [ 0 ] , \" \\n \" , a [ 1 ] , \" \\n \" , a [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "puts Array . new ( 10 ) { gets . to_i } . sort . reverse [ 0 .. 2 ] * \" \\n \"",
    "label": 5
  },
  {
    "code": "heights = Array . new ( ) 10 . times do heights . push ( gets ( ) . chomp! . to_i ) end heights = heights . sort { | a , b | - ( a <=> b ) } for num in 0 .. 2 do puts heights [ num ] end",
    "label": 5
  },
  {
    "code": "array = [ ] STDIN . each_line do | line | array . push ( line . to_i ) end array . sort { | a , b | b <=> a } [ 0 , 3 ] . each do | elm | puts elm end",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { gets . to_i } . sort { | a , b | b - a } . take ( 3 )",
    "label": 5
  },
  {
    "code": "mountain = Array . new while line = gets do mountain . push ( line . to_i ) end top = mountain . sort_by { | i | - i } for i in 0 .. 2 puts top [ i ] end",
    "label": 5
  },
  {
    "code": "a = Array . new 0 . upto ( 9 ) do | i | a . push ( gets . chomp! . to_i ) end a . sort! . reverse! a [ 0 .. 2 ] . each do | i | p i end",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a . push ( gets . to_i ) end a . sort! { | a , b | b <=> a } 3 . times do | i | puts a [ i ] end",
    "label": 5
  },
  {
    "code": "array = [ ] 10 . times do array << gets . to_i end array . sort_by! { | a | - a } 3 . times do | i | puts array [ i ] end",
    "label": 5
  },
  {
    "code": "i = 0 array = [ ] while i < 10 word = gets . chomp array . push word . to_i i = i + 1 end array = array . sort array = array . reverse puts array [ 0 ] puts array [ 1 ] puts array [ 2 ]",
    "label": 5
  },
  {
    "code": "input = $stdin . read . split ( / \\R / ) . map ( & :to_i ) newinput = input . sort j = newinput . length i = 1 while i < 4 do p newinput [ j - i ] i += 1 end",
    "label": 5
  },
  {
    "code": "har = Array . new i = 0 10 . times do h = gets . to_i if h >= 0 and h <= 10000 then har [ i ] = h i += 1 end end puts har . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "inputs = readlines inputs . map ( & :chomp ) . map ( & :to_i ) . sort . reverse . first ( 3 ) . each { | n | puts n }",
    "label": 5
  },
  {
    "code": "mountains = Array . new 10 . times do mountains << gets . to_i end puts mountains . sort . reverse [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr << gets . to_i end puts arr . sort [ - 3 .. - 1 ] . reverse",
    "label": 5
  },
  {
    "code": "arr = Array . new 10 . times do arr << gets . to_i end puts arr . sort [ - 3 .. - 1 ] . reverse",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end print a [ 0 ] , \" \\n \" , a [ 1 ] , \" \\n \" , a [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "n = 10 high = [ ] n . times do high << gets . chomp . to_i end high . sort! . reverse! puts high [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "puts 10 . times . map { gets . to_i } . sort . reverse [ 0 , 3 ]",
    "label": 5
  },
  {
    "code": "a = [ ] for i in 0 .. 9 a [ i ] = gets . chomp . to_i end a . sort! . p a [ 0 ] p a [ 1 ] p a [ 2 ]",
    "label": 5
  },
  {
    "code": "x = [ ] n = 3 for i in 0 .. 9 x [ i ] = gets . chomp . to_i end x . sort! for i in 0 .. ( n - 1 ) puts \" end",
    "label": 5
  },
  {
    "code": "i = 0 first = 1 second = 1 third = 1 while i < 10 mt = gets . to_i if mt > third if mt > second if mt > first third = second second = first first = mt else third = second second = mt end else third = mt end end i = i + 1 end puts first puts second puts third",
    "label": 5
  },
  {
    "code": "height = [ ] for i in 0 .. 9 height [ i ] = gets . chomp . to_i end height = height . sort for i in 0 .. 2 puts height [ height . length - i - 1 ] end",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 .. 9 do num . push ( gets . to_i ) end sorted_num = num . sort . reverse for i in 0 .. 2 do printf ( \" %d \\n \" , sorted_num [ i ] ) end",
    "label": 5
  },
  {
    "code": "m = [ ] for i in 0 .. 9 m [ i ] = gets . chomp . to_i end for i in 0 .. ( m . length - 1 ) j = m . length - 1 while j >= i if m [ j - 1 ] <= m [ j ] t = m [ j ] m [ j ] = m [ j - 1 ] m [ j - 1 ] = t end j -= 1 end end for i in 0 .. 2 print m [ i ] , \" \\n \" end",
    "label": 5
  },
  {
    "code": "data = [ ] 10 . times do | i | data [ i ] = gets . chomp . to_i end data . sort! data . reverse! puts ( data [ 0 ] ) puts ( data [ 1 ] ) puts ( data [ 2 ] )",
    "label": 5
  },
  {
    "code": "heights = 10 . times . map { gets . to_i } . sort! puts heights [ - 1 ] , heights [ - 2 ] , heights [ - 3 ]",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times do h . push ( gets . chomp . split . map ( & :to_i ) ) end h . sort! puts h [ - 1 ] puts h [ - 2 ] puts h [ - 3 ]",
    "label": 5
  },
  {
    "code": "list = [ ] while line = gets value = line . chomp list << value . to_i end count = 0 list . sort! list . reverse_each do | val | if ( count == 3 ) break end count += 1 puts val end",
    "label": 5
  },
  {
    "code": "mountains = Array . new ( 0 .. 9 ) . each do | | mountains . push ( ARGF . readline . to_i ) end mountains . sort [ 7 .. 9 ] . reverse . each do | mountain | puts mountain end",
    "label": 5
  },
  {
    "code": "array = [ ] 10 . times { array << gets . to_i } array . sort! . reverse! ( 0 .. 2 ) . each { | i | puts array [ i ] }",
    "label": 5
  },
  {
    "code": "a = [ ] while s = STDIN . gets a << s . strip . to_i end b = a . sort puts b . pop puts b . pop puts b . pop",
    "label": 5
  },
  {
    "code": "puts $< . readlines . map ( & :to_i ) . sort { | a , b | b <=> a } . take ( 3 )",
    "label": 5
  },
  {
    "code": "a = [ ] 10 . times do a <<gets . to_i end a . sort! p a [ 9 ] p a [ 8 ] p a [ 7 ]",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end print a [ 0 ] , \" \\n \" , a [ 1 ] , \" \\n \" , a [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end print a [ 0 ] , \" \\n \" , a [ 1 ] , \" \\n \" , a [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "a = Array . new ( 4 , 0 ) 10 . times do a [ 3 ] = gets . chomp . to_i 3 . times do | i | if a [ 2 - i ] < a [ 3 - i ] a [ 2 - i ] , a [ 3 - i ] = a [ 3 - i ] , a [ 2 - i ] else break end end end print a [ 0 ] , \" \\n \" , a [ 1 ] , \" \\n \" , a [ 2 ] , \" \\n \"",
    "label": 5
  },
  {
    "code": "h = [ ] high = [ 0 , 0 , 0 ] 10 . times do | i | h [ i ] = gets . chomp . to_i end 10 . times do | i | if high [ 2 ] < h [ i ] high [ 2 ] = h [ i ] if high [ 1 ] < h [ i ] high [ 2 ] = high [ 1 ] high [ 1 ] = h [ i ] if high [ 0 ] < h [ i ] high [ 1 ] = high [ 0 ] high [ 0 ] = h [ i ] end end end end 3 . times do | i | puts high [ i ] end",
    "label": 5
  },
  {
    "code": "val = [ ] for i in 0 .. 9 val [ i ] = gets . to_i end val . sort! val . reverse! for i in 0 .. 2 puts val [ i ] . to_s end",
    "label": 5
  },
  {
    "code": "data = [ ] i = 0 while n = gets data [ i ] = n . chomp . to_i i += 1 end b = 0 for a in 0 .. i - 2 for b in 0 .. i - 2 if data [ b ] < data [ b + 1 ] data [ b ] , data [ b + 1 ] = data [ b + 1 ] , data [ b ] end end end for i in 0 .. 2 puts data [ i ] end",
    "label": 5
  },
  {
    "code": "h = [ ] ( 0 ... 10 ) . each do | i | h [ i ] = gets . chomp . to_i end h . sort! . reverse! ( 0 ... 3 ) . each do | i | puts h [ i ] end",
    "label": 5
  },
  {
    "code": "h = [ ] 10 . times do h . push ( gets . chomp . split . map ( & :to_i ) ) end h . sort! puts h [ - 1 ] puts h [ - 2 ] puts h [ - 3 ]",
    "label": 5
  },
  {
    "code": "n = [ ] 10 . times { | i | n [ i ] = gets . to_i } s = n . sort! . reverse! puts s [ 0 .. 2 ]",
    "label": 5
  },
  {
    "code": "a = [ ] i = 0 while i < 10 x = gets . to_i a [ i ] = x i += 1 end b = a . sort . reverse puts b [ 0 ] puts b [ 1 ] puts b [ 2 ]",
    "label": 5
  },
  {
    "code": "a = 0 ; b = 0 ; c = 0 10 . times do line = gets datum = line . chomp! . to_i if datum > a c = b ; b = a ; a = datum elsif datum > b c = b ; b = datum elsif datum > c c = datum end end puts a puts b puts c",
    "label": 5
  },
  {
    "code": "line = $stdin . read . split . map ( & :to_i ) line = line . sort . reverse for i in 0 .. 2 puts line [ i ] end",
    "label": 5
  },
  {
    "code": "data = Array . new 1 . upto ( 10 ) { n = $stdin . gets . to_i data << n } data . sort! { | a , b | b <=> a } puts data [ 0 ] puts data [ 1 ] puts data [ 2 ]",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . chomp . split ( ) . map ( & :to_i ) . sort ( ) puts a ** 2 + b ** 2 == c ** 2 ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "gets while gets b , c , d = $_ . split . map ( & :to_i ) . sort if c * c + b * b == d * d puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "( $stdin . gets . to_i ) . times do a , b , c = $stdin . gets . split . map ( & :to_i ) . sort puts Math . sqrt ( a ** 2 + b ** 2 ) == c ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split ( \" \" ) . map ( & :to_i ) . sort if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { input = gets . chomp . split ( \" \" ) a = input [ 0 ] . to_i b = input [ 1 ] . to_i c = input [ 2 ] . to_i if ( a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b ) then puts ( \" YES \" ) else puts ( \" NO \" ) end }",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort if c * c == a * a + b * b puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "i = gets . to_i i . times do a = gets . chomp . split ( \" \" ) s1 = a [ 0 ] . to_i s2 = a [ 1 ] . to_i s3 = a [ 2 ] . to_i if s1 * s1 + s2 * s2 == s3 * s3 || s1 * s1 + s3 * s3 == s2 * s2 || s3 * s3 + s2 * s2 == s1 * s1 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "input_lines = gets . to_i input_lines . times { s = gets . chomp . split ( \" \" ) s . map! { | x | x . to_i } if ( s [ 0 ] ** 2 + s [ 1 ] ** 2 == s [ 2 ] ** 2 ) || ( s [ 1 ] ** 2 + s [ 2 ] ** 2 == s [ 0 ] ** 2 ) || ( s [ 2 ] ** 2 + s [ 0 ] ** 2 == s [ 1 ] ** 2 ) then puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "num_of_data = gets . chomp data = Array . new ( num_of_data . to_i ) num_of_data . to_i . times do | i | each_sides = gets . split each_sides . length . times do | j | each_sides [ j ] = each_sides [ j ] . to_i end data [ i ] = each_sides . sort end num_of_data . to_i . times do | i | if data [ i ] [ 0 ] ** 2 + data [ i ] [ 1 ] ** 2 == data [ i ] [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "num = gets threeLines = Array . new num . to_i . times do threeLines . push ( gets ) end num . to_i . times do | cnt | lineArray = threeLines [ cnt ] . split ( \" \" ) lineArray . map! ( & :to_i ) lineArray . sort! lineArray . reverse! if ( lineArray [ 0 ] . to_i ** 2 == lineArray [ 1 ] . to_i ** 2 + lineArray [ 2 ] . to_i ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split ( \" \" ) . map ( & :to_i ) . sort if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets $< . map { | l | puts l . split . reduce ( 0 ) { | s , n | s ^ n . to_i ** 2 } > 0 ? :NO : \" YES \" }",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do l = gets ll = l . split if ll [ 0 ] . to_i ** 2 + ll [ 1 ] . to_i ** 2 == ll [ 2 ] . to_i ** 2 puts \" YES \" elsif ll [ 1 ] . to_i ** 2 + ll [ 2 ] . to_i ** 2 == ll [ 0 ] . to_i ** 2 puts \" YES \" elsif ll [ 2 ] . to_i ** 2 + ll [ 0 ] . to_i ** 2 == ll [ 1 ] . to_i ** 2 then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets while line = gets do a = Array . new ( 3 ) { | i | } a [ 0 ] , a [ 1 ] , a [ 2 ] = line . split . map ( & :to_i ) a = a . sort if a [ 2 ] ** 2 == a [ 1 ] ** 2 + a [ 0 ] ** 2 then puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i for i in 1 .. n a , b , c = gets . split ( \" \" ) . map ( & :to_i ) . sort! puts a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i for i in 1 .. n nums = gets . split ( ) . map { | num | num . to_i } nums . sort! if nums [ 0 ] ** 2 + nums [ 1 ] ** 2 == nums [ 2 ] ** 2 puts ( \" YES \" ) else puts ( \" NO \" ) end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { input = gets . split ( \" \" ) . map ( & :to_i ) . sort if input [ 2 ] ** 2 == input [ 0 ] ** 2 + input [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "module Input def numread ( ) s = gets ( ) . split ( ) p = Array . new ( ) for i in 0 ... s . size ( ) p [ i ] = s [ i ] . to_i ( ) end return p end module_function : numread end include Input n = numread ( ) [ 0 ] for i in 0 ... n if ( STDIN . eof ( ) ) break end w = numread ( ) w . sort! ( ) if ( w [ 0 ] ** 2 + w [ 1 ] ** 2 == w [ 2 ] ** 2 ) print ( \" YES \\n \" ) ; else print ( \" NO \\n \" ) ; end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do nums = gets . chomp . split . map ( & :to_i ) . sort if nums [ 2 ] ** 2 == nums [ 0 ] ** 2 + nums [ 1 ] ** 2 puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "dataset = gets . to_i dataset . times do | i | data = gets c = data . split ( nil ) if c [ 0 ] . to_i ** 2 + c [ 1 ] . to_i ** 2 == c [ 2 ] . to_i ** 2 or c [ 1 ] . to_i ** 2 + c [ 2 ] . to_i ** 2 == c [ 0 ] . to_i ** 2 or c [ 2 ] . to_i ** 2 + c [ 0 ] . to_i ** 2 == c [ 1 ] . to_i ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do a , b , c = gets . split . map ( & :to_i ) if a * a + b * b == c * c || b * b + c * c == a * a || c * c + a * a == b * b puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . chomp . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort if a * a + b * b == c * c puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "a = [ ] gets . to_i . times do a << gets . split . map ( & :to_i ) . sort end a . each do | i | puts ( i [ 0 ] ** 2 + i [ 1 ] ** 2 ) == i [ 2 ] ** 2 ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts :YES else puts :NO end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts :YES else puts :NO end end",
    "label": 5
  },
  {
    "code": "class TriangleChecker def initialize @triangles = [ ] end def add ( triangle ) @triangles << triangle end def check @triangles . each { | triangle | triangle . Line . sort! if ( triangle . Line [ 0 ] ** 2 ) + ( triangle . Line [ 1 ] ** 2 ) == ( triangle . Line [ 2 ] ** 2 ) then puts \" YES \" else puts \" NO \" end } end end class Triangle attr_accessor :Line end inputs = gets . chomp . split ( nil ) dataCount = inputs [ 0 ] . to_i checker = TriangleChecker . new for i in 1 .. dataCount inputs = gets . chomp . split ( nil ) line1 = inputs [ 0 ] . to_i line2 = inputs [ 1 ] . to_i line3 = inputs [ 2 ] . to_i triangle = Triangle . new triangle . Line = [ line1 , line2 , line3 ] ; checker . add ( triangle ) end checker . check",
    "label": 5
  },
  {
    "code": "class TriangleChecker def initialize @triangles = [ ] end def add ( triangle ) @triangles << triangle end def check @triangles . each { | triangle | triangle . Line . sort! puts ( ( triangle . Line [ 0 ] ** 2 ) + ( triangle . Line [ 1 ] ** 2 ) == ( triangle . Line [ 2 ] ** 2 ) ) ? \" YES \" : \" NO \" } end end class Triangle attr_accessor :Line end inputs = gets . chomp . split ( nil ) dataCount = inputs [ 0 ] . to_i checker = TriangleChecker . new dataCount . times { | i | inputs = gets . chomp . split ( nil ) line = inputs . map ( & :to_i ) triangle = Triangle . new triangle . Line = line checker . add ( triangle ) } checker . check",
    "label": 5
  },
  {
    "code": "def judge_right ( x , y , z ) a = x ** 2 + y ** 2 b = y ** 2 + z ** 2 c = z ** 2 + x ** 2 if a == z ** 2 || b == x ** 2 || c == y ** 2 return true else return false end end N = gets . chomp . to_i N . times do x , y , z = gets . chomp . split ( \" \" ) . map { | item | item . to_i } if judge_right ( x , y , z ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do data = gets . split . map ( & :to_i ) . sort if data [ 2 ] ** 2 == data [ 0 ] ** 2 + data [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do trinagle_array = gets . split ( ) . map ( & :to_i ) . sort ( ) if trinagle_array [ 2 ] ** 2 == trinagle_array [ 0 ] ** 2 + trinagle_array [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "num = [ ] for i in 0 ... gets . to_i a = gets num = a . split ( nil ) num . collect! { | n | n . to_i } num . sort! if num [ 2 ] ** 2 == ( num [ 0 ] ** 2 ) + ( num [ 1 ] ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == b ** 2 + a ** 2 puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "dataset_count = STDIN . gets . to_i dataset_count . times { | i | point = STDIN . gets . split ( \" \" ) point . map! { | p | p . to_i } a , b , c = point . sort if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets . to_i data = [ ] n . times do data << gets . split . map ( & :to_i ) end data . each do | sides | a , b , c = sides . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? %w( YES ) : %w( NO ) end",
    "label": 5
  },
  {
    "code": "n = gets . to_i data = [ ] n . times do data << gets . split . map ( & :to_i ) end data . each do | sides | a , b , c = sides . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? %w( YES ) : %w( NO ) end",
    "label": 5
  },
  {
    "code": "trinum = gets trinum = trinum . to_i trinum . times do a = gets num = a . split ( ' ' ) num . sort! { | x , y | x . to_i <=> y . to_i } if num [ 0 ] . to_i ** 2 + num [ 1 ] . to_i ** 2 == num [ 2 ] . to_i ** 2 then print \" YES \\n \" else print \" NO \\n \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do s = gets . scan ( / \\d + / ) . map ( & :to_i ) . sort if s [ 2 ] * s [ 2 ] == s [ 0 ] * s [ 0 ] + s [ 1 ] * s [ 1 ] puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i for i in 0 ... n nums = gets . split . map ( & :to_i ) nums . sort! . reverse! if nums [ 0 ] ** 2 == nums [ 1 ] ** 2 + nums [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "args = [ ] line_count = gets . to_i line_count . times do | i | line = gets x = line . split . sort . map ( & :to_i ) . sort! if ( x [ 0 ] ** 2 + x [ 1 ] ** 2 == x [ 2 ] ** 2 ) puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a , b , c = gets . split . map ( & :to_i ) . sort if a ** 2 + b ** 2 == c ** 2 then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a = gets . split . map ( & :to_i ) . sort ( ) puts a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "count = 0 loop = gets . to_i line = [ ] for input in loop . times do input_line = gets lines = input_line . split ( \" \" ) lines_int = lines . map ( & :to_i ) line = lines_int . sort triangle_check = line [ 0 ] ** 2 + line [ 1 ] ** 2 == line [ 2 ] ** 2 if triangle_check == true then puts \" YES \" else puts \" NO \" end count += 1 if count > 1000 then puts \" ????????????1000???????????????????????\" reak nd nd",
    "label": 5
  },
  {
    "code": "noData = gets . to_i noData . times do a , b , c = gets . split . map ( & :to_i ) . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? ' YES ' : ' NO ' ; end",
    "label": 5
  },
  {
    "code": "num = gets . to_i for i in 1 .. num abc = gets . split . map ( & :to_i ) abc . sort! if abc [ 0 ] ** 2 + abc [ 1 ] ** 2 == abc [ 2 ] ** 2 puts ( \" YES \" ) else puts ( \" NO \" ) end end",
    "label": 5
  },
  {
    "code": "gets while gets a , b , c = $_ . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "class Integer def square return self ** 2 end end judge = -> ( ary ) { if ary . last . square == ary [ 0 ] . square + ary [ 1 ] . square puts \" YES \" break else puts \" NO \" end } n = gets . to_i n . times do | i | ary = gets . split ( \" \" ) . map ( & :to_i ) . sort judge . call ( ary ) end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do i = gets a , b , c = i . chomp . split a , b , c = a . to_i , b . to_i , c . to_i if ( a ** 2 == ( b ** 2 + c ** 2 ) || b ** 2 == ( a ** 2 + c ** 2 ) || c ** 2 == ( a ** 2 + b ** 2 ) ) puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do l = gets . chomp . split 3 . times do | i | l [ i ] = l [ i ] . to_i end l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do l = gets . chomp . split 3 . times do | i | l [ i ] = l [ i ] . to_i end l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "i = gets . chomp . to_i i . times do a , b , c = gets . chomp . split a , b , c = a . to_i , b . to_i , c . to_i if a ** 2 == b ** 2 + c ** 2 || b ** 2 == a ** 2 + c ** 2 || c ** 2 == a ** 2 + b ** 2 puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do l = gets . chomp . split 3 . times do | i | l [ i ] = l [ i ] . to_i end l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i while n > 0 a = gets . split . map ( & :to_i ) a . sort! if a [ 2 ] ** 2 == a [ 0 ] ** 2 + + a [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end a . clear n -= 1 end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i while n > 0 a = gets . split . map ( & :to_i ) a . sort! if a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end a . clear n -= 1 end",
    "label": 5
  },
  {
    "code": "$N = gets . chomp . to_i while $N > 0 do arr = [ ] gets . split ( ' ' ) . each do | value | arr . push ( value . to_i ) end arr . sort! if ( arr [ 0 ] ** 2 + arr [ 1 ] ** 2 ) == arr [ 2 ] ** 2 puts ' YES ' else puts ' NO ' end $N -= 1 end",
    "label": 5
  },
  {
    "code": "class Triangle def initialize ( array ) @lengths = array . sort! end attr_accessor :lengths def right_triangle ? ( @lengths [ 0 ] ** 2 ) + ( @lengths [ 1 ] ** 2 ) == @lengths [ 2 ] ** 2 end end case_num = gets . to_i case_num . times do puts Triangle . new ( gets . split ( \" \" ) . map ( & :to_i ) ) . right_triangle? ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "def triangle ( a , b , c ) if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end end gets . to_i . times do arr = gets . split . map ( & :to_i ) triangle ( * arr . sort ) end",
    "label": 5
  },
  {
    "code": "def pythagorean_check ( a , b , c ) check_result = if a ** 2 == b ** 2 + c ** 2 || b ** 2 == a ** 2 + c ** 2 || c ** 2 == a ** 2 + b ** 2 \" YES \" else \" NO \" end return check_result end DATA_NUM = gets . to_i DATA_NUM . times do a , b , c = gets . chomp . split ( ' ' ) . map! ( & :to_i ) puts pythagorean_check ( a , b , c ) end",
    "label": 5
  },
  {
    "code": "gets . chop . to_i . times do a , b , c = gets . chop . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts :YES else puts :NO end end",
    "label": 5
  },
  {
    "code": "gets . chop . to_i . times do a , b , c = gets . chop . split . map ( & :to_i ) . sort puts ( c ** 2 == a ** 2 + b ** 2 ) ? :YES : :NO end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a = gets . split . map ( & :to_i ) . sort if a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . chomp . to_i . times do a , b , c = gets . chomp . split . map ( & :to_i ) . sort puts ( c ** 2 == a ** 2 + b ** 2 ) ? :YES : :NO end",
    "label": 5
  },
  {
    "code": "gets ARGF . each_line do | line | l = line . split . map ( & :to_i ) l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets ARGF . each do | line | ary = line . split . map ( & :to_i ) . sort! puts ( ( ary [ 0 ] ** 2 + ary [ 1 ] ** 2 ) == ary [ 2 ] ** 2 ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets ARGF . each_line do | line | a , b , c = line . split . map ( & :to_i ) . sort if ( a ** 2 + b ** 2 ) == c ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets while line = gets do vals = line . chomp . split ( ) . map ( & :to_i ) vals . sort! if vals . last * vals . last == vals [ 0 ] * vals [ 0 ] + vals [ 1 ] * vals [ 1 ] puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do numbers = gets . split . map ( & :to_f ) numbers . sort! Math . sqrt ( numbers [ 0 ] ** 2 + numbers [ 1 ] ** 2 ) == numbers [ 2 ] ? ( puts \" YES \" ) : ( puts \" NO \" ) end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i ans = Array . new ( n , 0 ) for i in 0 .. n - 1 do arr = [ ] arr = gets . chomp . split . map ( & :to_i ) arr . sort! if arr [ 2 ] ** 2 == arr [ 0 ] ** 2 + arr [ 1 ] ** 2 ans [ i ] += 1 end end for i in 0 .. n - 1 do if ans [ i ] == 1 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "num = STDIN . gets . to_i for i in 1 .. num do data = STDIN . gets num = data . split ( ) a = num [ 0 ] . to_i b = num [ 1 ] . to_i c = num [ 2 ] . to_i a2 = Math . sqrt ( b * b + c * c ) b2 = Math . sqrt ( c * c + a * a ) c2 = Math . sqrt ( a * a + b * b ) if ( ( a == a2 ) || ( b == b2 ) || ( c == c2 ) ) then print ( \" YES \\n \" ) else print ( \" NO \\n \" ) end end",
    "label": 5
  },
  {
    "code": "i = gets a = Array . new ( 2 ) while a = gets c = a . split ( \" \" ) b = c . map ( & :to_i ) . sort if ( b [ 2 ] ** 2 ) == ( ( b [ 1 ] ** 2 ) + ( b [ 0 ] ** 2 ) ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . chomp . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "num = gets . to_i num . times do a , b , c = gets . split . map ( & :to_i ) if ( a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2 ) puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do li = gets . split ( \" \" ) . map ( & :to_i ) . sort! puts ( li [ 0 ] ** 2 + li [ 1 ] ** 2 == li [ 2 ] ** 2 ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "for i in 0 .. gets . to_i - 1 n = gets . split . map ( & :to_i ) . puts n [ 0 ] ** 2 + n [ 1 ] ** 2 == n [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i ( 1 .. n ) . each do a , b , c = gets . split . map ( & :to_i ) . sort puts ( a * a + b * b == c * c ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "num = gets for j in 1 .. ( num . to_i ) data = gets triangle = data . split ( ' ' ) . map { | i | i . to_i } . sort if triangle [ 0 ] ** 2 + triangle [ 1 ] ** 2 == triangle [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split ( ' ' ) . map ( & :to_i ) . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "num = gets . to_i while num > 0 do a , b , c = gets . split . map ( & :to_i ) if a ** 2 + b ** 2 == c ** 2 || a ** 2 + c ** 2 == b ** 2 || b ** 2 + c ** 2 == a ** 2 then puts ( \" YES \" ) else puts ( \" NO \" ) end num -= 1 end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . map { | e | e * e } right = a + b == c || b + c == a || c + a == b puts right ? :YES : :NO }",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . sort . map { | e | e * e } puts a + b == c ? :YES : :NO }",
    "label": 5
  },
  {
    "code": "_ = gets $< . each_line do | line | a , b , c = line . split . map ( & :to_i ) . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "gets . chomp . to_i . times do | i | l = gets . chomp . split ( \" \" ) . map ( & :to_i ) . sort puts l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do side = gets . split . map ( & :to_i ) isRight = false 0 . upto ( 2 ) do | i | if side [ i ] ** 2 + side [ ( i + 1 ) % 3 ] ** 2 == side [ ( i + 2 ) % 3 ] ** 2 then isRight = true end end puts isRight ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do data = gets . chomp . split ( \" \" ) . map ( & :to_i ) data . sort! if data [ 2 ] ** 2 == data [ 0 ] ** 2 + data [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets ; while s = gets do a = s . split ( \" \" ) . map ( & :to_i ) ; a . sort! ; i = a [ 0 ] ** 2 + a [ 1 ] ** 2 ; puts i == a [ 2 ] ** 2 ? \" YES \" : \" NO \" ; end",
    "label": 5
  },
  {
    "code": "data = [ ] n = gets . to_i while ( n != 0 ) data = gets data = data . split ( nil ) data = data . map { | n | n . to_i } data . sort! if ( ( data [ 2 ] ** 2 ) == ( data [ 1 ] ** 2 ) + ( data [ 0 ] ** 2 ) ) puts ( \" YES \" ) else puts ( \" NO \" ) end n = n - 1 ; end",
    "label": 5
  },
  {
    "code": "line = STDIN . gets . chomp . to_i arg = [ ] line . times do arg << STDIN . gets . chomp end arg . each do | l | arr = l . split ( ' ' ) . map ( & :to_i ) max = arr . delete_at ( arr . index ( arr . max ) ) if max ** 2 == arr [ 0 ] ** 2 + arr [ 1 ] ** 2 puts \" YES \\n \" else puts \" NO \\n \" end end",
    "label": 5
  },
  {
    "code": "def triangle? a , b , c ( ( a ** 2 ) + ( b ** 2 ) ) == ( c ** 2 ) end count = STDIN . gets . chomp . to_i count . times do | i | ( a , b , c ) = STDIN . gets . chomp . split ( \" \" ) . map ( & :to_i ) . sort output = triangle? ( a , b , c ) ? ' YES ' : ' NO ' puts output end",
    "label": 5
  },
  {
    "code": "n = gets . to_i STDIN . each_line { | l | a , b , c = l . split ( ) . map { | v | v . to_i } . sort if a * a + b * b == c * c puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "inputs = [ ] num = STDIN . gets . chomp . to_i num . times do input = STDIN . gets . chomp inputs << input . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } end inputs . each do | i | result = i [ 0 ] == i [ 1 ] + i [ 2 ] ? ' YES ' : ' NO ' puts result end",
    "label": 5
  },
  {
    "code": "inputs = [ ] STDIN . gets . chomp . to_i . times do input = STDIN . gets . chomp inputs << input . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } end inputs . each do | i | result = i [ 0 ] == i [ 1 ] + i [ 2 ] ? ' YES ' : ' NO ' puts result end",
    "label": 5
  },
  {
    "code": "inputs = [ ] STDIN . gets . chomp . to_i . times . map do inputs << STDIN . gets . chomp . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } end inputs . each do | i | result = i [ 0 ] == i [ 1 ] + i [ 2 ] ? ' YES ' : ' NO ' puts result end",
    "label": 5
  },
  {
    "code": "inputs = Array . new ( STDIN . gets . chomp . to_i ) { STDIN . gets . chomp . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } } inputs . each do | i | result = i [ 0 ] == i [ 1 ] + i [ 2 ] ? ' YES ' : ' NO ' puts result end",
    "label": 5
  },
  {
    "code": "Array . new ( STDIN . gets . chomp . to_i ) { STDIN . gets . chomp . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } } . each do | i | result = i [ 0 ] == i [ 1 ] + i [ 2 ] ? ' YES ' : ' NO ' puts result end",
    "label": 5
  },
  {
    "code": "Array . new ( STDIN . gets . chomp . to_i ) { STDIN . gets . chomp . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } } . each do | i | puts i [ 0 ] == i [ 1 ] + i [ 2 ] ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "Array . new ( STDIN . gets . chomp . to_i ) { STDIN . gets . chomp . split . map ( & :to_i ) . sort . reverse . map { | i | i ** 2 } } . each do | x , y , z | puts x == y + z ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { a = gets . split . map ( & :to_i ) s = \" NO \" 2 . downto ( 0 ) { | i | if a [ i ] ** 2 + a [ i - 1 ] ** 2 == a [ i - 2 ] ** 2 s = \" YES \" break end } puts s }",
    "label": 5
  },
  {
    "code": "N = gets . chomp . to_i N . times do a , b , c = gets . split . map { | i | i . to_i } . sort if c ** 2 == a ** 2 + b ** 2 puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { d = gets . chomp . split ( \" \" ) . map & :to_i d . sort! if ( d [ 0 ] ** 2 + d [ 1 ] ** 2 ) == d [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { edges = gets . chomp . split . map ( & :to_i ) edges . sort! if edges [ 0 ] ** 2 + edges [ 1 ] ** 2 == edges [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "inputArray = Array . new rows = gets . to_i i = 0 rows . times do temp = gets inputArray [ i ] , inputArray [ i + 1 ] , inputArray [ i + 2 ] = temp . split ( \" \" ) . map ( & :to_i ) i += 3 end i = 0 inputArray . map! { | n | n ** 2 } test = Array . new rows . times do test = [ inputArray [ i ] , inputArray [ i + 1 ] , inputArray [ i + 2 ] ] test . sort! if test [ 0 ] + test [ 1 ] == test [ 2 ] puts \" YES \" else puts \" NO \" end i += 3 end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a , b , c = gets . chomp . split ( ' ' ) . map ( & :to_i ) . sort { | i , j | j <=> i } puts a ** 2 == b ** 2 + c ** 2 ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "def righttriangle ( a , b , c ) f = [ a , b , c ] mx = f . max f . delete_at ( f . index ( mx ) ) f . inject ( 0 ) { | acc , x | acc + x * x } == mx * mx end class Main def initialize fh = STDIN n = fh . gets . to_i while fh . gets do a , b , c = $_ . split . map { | x | x . to_i } puts righttriangle ( a , b , c ) ? \" YES \" : \" NO \" end end end if $0 == __FILE__ then Main . new end",
    "label": 5
  },
  {
    "code": "cnt = gets . to_i ss = [ ] cnt . times do | i | ss = gets . to_s . split ( \" \" ) . map ( & :to_i ) if ( ss [ 0 ] * ss [ 0 ] + ss [ 1 ] * ss [ 1 ] - ss [ 2 ] * ss [ 2 ] == 0 or ss [ 0 ] * ss [ 0 ] - ss [ 1 ] * ss [ 1 ] + ss [ 2 ] * ss [ 2 ] == 0 or - ss [ 0 ] * ss [ 0 ] + ss [ 1 ] * ss [ 1 ] + ss [ 2 ] * ss [ 2 ] == 0 ) then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . to_s . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { date = gets date = date . split date [ 0 ] = date [ 0 ] . to_i date [ 1 ] = date [ 1 ] . to_i date [ 2 ] = date [ 2 ] . to_i if ( date [ 0 ] ** 2 ) == ( date [ 1 ] ** 2 ) + ( date [ 2 ] ** 2 ) then puts \" YES \" elsif ( date [ 1 ] ** 2 ) == ( date [ 0 ] ** 2 ) + ( date [ 2 ] ** 2 ) then puts \" YES \" elsif ( date [ 2 ] ** 2 ) == ( date [ 1 ] ** 2 ) + ( date [ 0 ] ** 2 ) then puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "sum = 0 while n = gets a = n . to_i while sides = gets str_side = sides . split int_side = str_side . map ( & :to_i ) int_side . sort! if int_side [ - 1 ] ** 2 == ( int_side [ - 2 ] ** 2 ) + ( int_side [ - 3 ] ** 2 ) puts \" YES \" sum += 1 if sum == a break end else puts \" NO \" sum += 1 if sum == a break end end end break end",
    "label": 5
  },
  {
    "code": "num = [ ] i = 0 roop = gets . to_i while i < roop a = gets num = [ ] num = a . split ( nil ) num = num . map { | n | n . to_i } num . sort! if ( num [ 2 ] ** 2 ) == ( ( num [ 1 ] ** 2 ) + ( num [ 0 ] ** 2 ) ) puts \" YES \" else puts \" NO \" end i = i + 1 end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . sort puts c * c == a * a + b * b ? :YES : :NO }",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets readlines . map { | s | s . split . map ( & :to_i ) . sort } . each { | a , b , c | if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets readlines . map { | s | s . split . map ( & :to_i ) . sort } . each { | a , b , c | puts a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" }",
    "label": 5
  },
  {
    "code": "n = gets readlines . map { | s | s . split . map ( & :to_i ) . sort } . each { | a , b , c | puts a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" }",
    "label": 5
  },
  {
    "code": "gets readlines . map { | s | s . split . map ( & :to_i ) . sort } . each { | a , b , c | if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "N = gets . to_i N . times do length_list = gets ( ) . split ( ) . map ( & :to_i ) . to_a hypotenuse = length_list . max cathetus_list = length_list - [ hypotenuse ] cathetus_list_size = cathetus_list . size if cathetus_list_size != 2 || ! cathetus_list . kind_of? ( Array ) puts \" NO \" elsif ( hypotenuse ** 2 ) == ( cathetus_list [ 0 ] ** 2 + cathetus_list [ 1 ] ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "t = gets . to_i t . times do | i | a = gets . split . map ( & :to_i ) . sort puts a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "$< . map ( & :split ) [ 1 .. - 1 ] . map { | e | e . map ( & :to_i ) . sort } . each { | e | Math . hypot ( e [ 0 ] , e [ 1 ] ) == e [ 2 ] ? puts ( \" YES \" ) : puts ( \" NO \" ) }",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c , = gets . split . map ( & :to_i ) . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "num = [ ] i = 0 roop = gets . to_i while i < roop a = gets num = [ ] num = a . split ( nil ) num = num . map { | n | n . to_i } num . sort! if ( num [ 2 ] ** 2 ) == ( ( num [ 1 ] ** 2 ) + ( num [ 0 ] ** 2 ) ) puts \" YES \" else puts \" NO \" end i += 1 end",
    "label": 5
  },
  {
    "code": "def is_right_triangle ( a , b , c ) ( a * a == b * b + c * c ) || ( b * b == a * a + c * c ) || ( c * c == a * a + b * b ) end n = STDIN . gets while line = STDIN . gets line . chomp! arr = line . split ( \" \" ) if is_right_triangle ( arr [ 0 ] . to_i , arr [ 1 ] . to_i , arr [ 2 ] . to_i ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times { a , b , c = gets . chomp . split ( \" \" ) . map { | i | i . to_i } if ( [ a , b , c ] . max ** 2 ) * 2 == a ** 2 + b ** 2 + c ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i v = [ ] n . times do | i | ( a , b , c ) = gets . chomp . split ( \" \" ) a = a . to_i b = b . to_i c = c . to_i if c > b && c > a && a * a + b * b == c * c v [ i ] = ' YES ' elsif a < b && b > c && a * a + c * c == b * b v [ i ] = ' YES ' elsif b < a && c < a && b * b + c * c == a * a v [ i ] = ' YES ' else v [ i ] = ' NO ' end end n . times do | i | puts v [ i ] end",
    "label": 5
  },
  {
    "code": "$< . map ( & :split ) [ 1 .. - 1 ] . map { | e | e . map ( & :to_i ) . sort } . each { | e | Math . hypot ( e [ 0 ] , e [ 1 ] ) == e [ 2 ] ? puts ( \" YES \" ) : puts ( \" NO \" ) }",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == b ** 2 + a ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . chomp . split ( ) . map ( & :to_i ) . sort ( ) puts a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets while io = gets sorted = io . chomp . split ( \" \" ) . map ( & :to_i ) . sort if sorted [ 0 ] ** 2 + sorted [ 1 ] ** 2 == sorted [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do ary = gets . chomp . split . map ( & :to_i ) max = ary . max index = ary . index ( max ) ary . delete_at ( index ) a , b = ary if max ** 2 == a ** 2 + b ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "def sq ( n ) n * n end num = gets . to_i num . times { ( a , b , c ) = gets . split ( \" \" ) . collect { | s | s . to_i } . sort puts ( sq ( a ) + sq ( b ) ) == sq ( c ) ? \" YES \" : \" NO \" }",
    "label": 5
  },
  {
    "code": "n = gets . to_i for i in 1 .. n do a , b , c = gets . chomp! . split ( \" \" ) . map ( & :to_i ) if a < b then temp = a a = b b = temp end if a < c then temp = a a = c c = temp end if b < c then temp = b b = c c = temp end if ( a ** 2 ) == ( ( b ** 2 ) + ( c ** 2 ) ) then puts \" YES \\n \" else puts \" NO \\n \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { arr = gets . split . map ( & :to_i ) . sort if arr [ 0 ] ** 2 + arr [ 1 ] ** 2 == arr [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . sort ; puts c * c == a * a + b * b ? :YES : :NO }",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort puts c * c == a * a + b * b ? :YES : :NO end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? :YES : :NO end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "list = [ ] N = STDIN . gets while line = STDIN . gets a , b , c = line . chomp! . split . map! ( & :to_i ) . sort puts a * a + b * b == c * c ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do arr = gets . split . map ( & :to_i ) . sort puts ( arr [ 0 ] ** 2 + arr [ 1 ] ** 2 == arr [ 2 ] ** 2 ? ' YES ' : ' NO ' ) end",
    "label": 5
  },
  {
    "code": "gets while str = gets do array = str . chomp . split ( \" \" ) . map ( & :to_i ) array = array . sort if array [ 2 ] * array [ 2 ] == array [ 1 ] * array [ 1 ] + array [ 0 ] * array [ 0 ] puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . sort ; puts c * c == a * a + b * b ? :YES : :NO }",
    "label": 5
  },
  {
    "code": "n = gets . chomp! . to_i n . times do tris = gets . chomp! . split ( \" \" ) . map ( & :to_i ) tris . sort! . map! { | elem | elem = elem ** 2 } puts ( tris . pop ) == tris . reduce ( :+ ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { a , b , c = gets . split ( \" \" ) . map ( & :to_i ) . sort ; puts ( a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" ) }",
    "label": 5
  },
  {
    "code": "num = gets . chomp . to_i num . times do input = gets . split ( \" \\s \" ) . map ( & :to_i ) . sort if input [ 2 ] ** 2 == input [ 0 ] ** 2 + input [ 1 ] ** 2 then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "line = gets while input = gets ans = [ ] input = input . split ( \" \" ) . map ( & :to_i ) . sort a , b , c = input if ( a ** 2 + b ** 2 == c ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . split [ 0 ] . to_i 1 . upto ( n ) do | i | line = gets a , b , c = line . split . map ( & :to_i ) . sort if a ** 2 + b ** 2 == c ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i ( ) i = 0 while i < n do a , b , c = gets . split ( ' ' ) . map ( & :to_i ) if ( a ** 2 + b ** 2 == c ** 2 || b ** 2 + c ** 2 == a ** 2 || a ** 2 + c ** 2 == b ** 2 ) then print ( \" YES \\n \" ) else print ( \" NO \\n \" ) end i += 1 end",
    "label": 5
  },
  {
    "code": "t = gets . to_i t . times do | i | a , b , c = gets . split . map { | item | item . to_i } . sort puts a * a + b * b == c * c ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "num = gets . to_i num . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "num = gets . to_i num . times do a , b , c = gets . split . map ( & :to_i ) . sort puts ( ( ( a ** 2 ) + ( b ** 2 ) ) == ( c ** 2 ) ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { input = gets . split ( \" \" ) a , b , c = input [ 0 ] . to_i , input [ 1 ] . to_i , input [ 2 ] . to_i a = a ** 2 ; b = b ** 2 ; c = c ** 2 if a == b + c || b == a + c || c == a + b puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . sort ; puts c * c == a * a + b * b ? :YES : :NO }",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { s = gets . split ( ) 3 . times { | i | s [ i ] = s [ i ] . to_i } s . sort! if s [ 2 ] ** 2 == ( s [ 0 ] ** 2 ) + ( s [ 1 ] ** 2 ) puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "gets . to_i . times { puts gets . split . map { | a | a . to_i ** 2 } . inject ( :^ ) > 0 ? \" NO \" : \" YES \" }",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times . each { ( a , b , c ) = gets . split ( ) . map ( & :to_i ) . sort ( ) puts ( a ** 2 + b ** 2 == c ** 2 ) ? ' YES ' : ' NO ' }",
    "label": 5
  },
  {
    "code": "gets . to_i . times do c = [ ] a = gets for b in a . split c << b . to_i * b . to_i end c . sort! puts c [ 0 ] . to_i + c [ 1 ] . to_i == c [ 2 ] . to_i ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do arry = gets . split ( ) . map ( & :to_i ) . sort ( ) puts arry [ 0 ] ** 2 + arry [ 1 ] ** 2 == arry [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = STDIN . gets . to_i n . times { a , b , c = STDIN . gets . split ( \" \" ) . map ( & :to_i ) . sort if ( c ** 2 == a ** 2 + b ** 2 ) puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "if __FILE__ == $0 n = gets . to_i n . times { args = gets . split ( \" \" ) . map { | e | e . to_i } . sort result = ( ( ( args [ 0 ] ** 2 ) + ( args [ 1 ] ** 2 ) ) == args [ 2 ] ** 2 ) if result puts \" YES \" else puts \" NO \" end } end",
    "label": 5
  },
  {
    "code": "num = [ ] i = 0 roop = gets . to_i while i < roop a = gets num = [ ] num = a . split ( nil ) num = num . map { | n | n . to_i } num . sort! if ( num [ 2 ] ** 2 ) == ( ( num [ 1 ] ** 2 ) + ( num [ 0 ] ** 2 ) ) puts \" YES \" else puts \" NO \" end i += 1 end",
    "label": 5
  },
  {
    "code": "kaisu = gets . to_i kaisu . times { | i | data = gets . split ( nil ) 3 . times { | j | data [ j ] = data [ j ] . to_i } data . sort! leftSide = data [ 2 ] . to_i ** 2 rightSide = data [ 1 ] . to_i ** 2 + data [ 0 ] . to_i ** 2 if leftSide == rightSide puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "a = gets . to_i for i in 0 ... a ans = [ ] q , w , e = gets . split ( \" \" ) . map ( & :to_i ) ; ans . push ( q , w , e ) ans . sort! if ans [ 0 ] ** 2 + ans [ 1 ] ** 2 == ans [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "$a = [ 0 ] $a . clear n = gets . to_i n . times { $a = gets . split $a . sort 3 . times { | i | $a [ i ] = $a [ i ] . to_i } $a = $a . sort if $a [ 0 ] * $a [ 0 ] + $a [ 1 ] * $a [ 1 ] == $a [ 2 ] * $a [ 2 ] puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "gets . to_i . times { | n | a , b , c = gets . split . map ( & :to_i ) . sort puts c * c == ( a * a ) + ( b * b ) ? \" YES \" : \" NO \" }",
    "label": 5
  },
  {
    "code": "count = gets . to_i count . times do list = gets . split . map ( & :to_i ) . sort puts ( ( list [ 2 ] ** 2 == list [ 1 ] ** 2 + list [ 0 ] ** 2 ) ? \" YES \" : \" NO \" ) end",
    "label": 5
  },
  {
    "code": "YES = \" YES \" NO = \" NO \" def sq ( x ) return x * x end gets . to_i . times do puts -> ( l ) { if sq ( l [ 0 ] ) + sq ( l [ 1 ] ) == sq ( l [ 2 ] ) return YES elsif sq ( l [ 1 ] ) + sq ( l [ 2 ] ) == sq ( l [ 0 ] ) return YES elsif sq ( l [ 2 ] ) + sq ( l [ 0 ] ) == sq ( l [ 1 ] ) return YES end return NO } . call gets . split ( ' ' ) . map ( & :to_i ) end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { n = gets . split . map ( & :to_i ) . sort ; puts n . pop == Math :: hypot ( * n ) ? \" YES \" : \" NO \" }",
    "label": 5
  },
  {
    "code": "gets readlines . map ( & :split ) . each do | l | l = l . map ( & :to_i ) . sort if l [ 2 ] * l [ 2 ] == l [ 1 ] * l [ 1 ] + l [ 0 ] * l [ 0 ] puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets while gets do arr = $_ . split . map ( & :to_i ) . sort ( ) puts ( arr [ 2 ] ** 2 == arr [ 1 ] ** 2 + arr [ 0 ] ** 2 ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "arr = Array . new numberOflines = gets . to_i numberOflines . times do arr << gets end arr . each do | i | a = i . split ( \" \" ) a . map! { | j | j . to_i } a . sort! if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "a = Array . new N = gets . to_i N . times do a << gets . split ( \" \" ) . map ( & :to_i ) . sort end a . each do | x , y , z | if ( z ** 2 == x ** 2 + y ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i rec = Array . new ans = Array . new n . times { rec = gets . split ( \" \" ) . map ( & :to_i ) rec . sort! { | a , b | a <=> b } x , y , z = rec [ 0 ] . to_i , rec [ 1 ] . to_i , rec [ 2 ] . to_i a = x * x + y * y b = z * z if a == b puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets . to_i rec = Array . new ans = Array . new n . times { rec = gets . split ( \" \" ) . map ( & :to_i ) rec . sort! { | a , b | a <=> b } x , y , z = rec [ 0 ] . to_i , rec [ 1 ] . to_i , rec [ 2 ] . to_i a = x * x + y * y b = z * z if a == b puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets . to_i rec = Array . new ans = Array . new n . times { rec = gets . split ( \" \" ) . map ( & :to_i ) rec . sort! { | a , b | a <=> b } x , y , z = rec [ 0 ] , rec [ 1 ] , rec [ 2 ] a = x * x + y * y b = z * z if a == b puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "def checkTriangle ( i , j , k ) a = ( i ** 2 + j ** 2 == k ** 2 ) b = ( i ** 2 + k ** 2 == j ** 2 ) c = ( j ** 2 + k ** 2 == i ** 2 ) return a | b | c end N = gets . to_i inputs = Array . new ( N ) { | x | x = gets . split ( ) } for a , b , c in inputs puts checkTriangle ( a . to_i , b . to_i , c . to_i ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "getcnt = gets . to_i def Check ( a , b , c ) if a ** 2 == ( b ** 2 + c ** 2 ) return true else return false end end getcnt . times { ( a , b , c ) = gets . split data = [ a . to_i , b . to_i , c . to_i ] if Check ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) || Check ( data [ 2 ] , data [ 0 ] , data [ 1 ] ) || Check ( data [ 1 ] , data [ 2 ] , data [ 0 ] ) puts ( \" YES \" ) else puts ( \" NO \" ) end }",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times . each do a , b , c = gets . split ( / \\s / ) . map ( & :to_i ) . sort puts ( c * c == ( a * a + b * b ) ) ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { puts gets . split . map { | i | i . to_i ** 2 } . inject ( :^ ) == 0 ? \" YES \" : \" NO \" }",
    "label": 5
  },
  {
    "code": "gets ; $< . map { | l | puts l . split . inject ( 0 ) { | s , n | s ^ n . to_i ** 2 } > 0 ? \" NO \" : \" YES \" }",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do set = gets . chomp . split . map ( & :to_i ) set . sort_by! { | v | v } if set [ 0 ] ** 2 + set [ 1 ] ** 2 == set [ 2 ] ** 2 puts :YES else puts :NO end end",
    "label": 5
  },
  {
    "code": "count = gets . to_i for i in 1 .. count a = gets a = a . split ( \" \" ) a [ 0 ] = a [ 0 ] . to_i a [ 1 ] = a [ 1 ] . to_i a [ 2 ] = a [ 2 ] . to_i a = a . sort if a [ 2 ] * a [ 2 ] == a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do arr = gets . split ' ' arr = arr . map { | x | x . to_i } arr . sort! if arr [ 2 ] * arr [ 2 ] == arr [ 1 ] * arr [ 1 ] + arr [ 0 ] * arr [ 0 ] then puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i for m in 0 ... n input = gets . split ( \" \" ) . map { | a , v | ; a . strip ? a . strip . to_i : a . to_i } . sort . reverse puts ( ( input [ 0 ] ** 2 ) == ( input [ 1 ] ** 2 + input [ 2 ] ** 2 ) ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do | i | a = gets break if a == nil b = a . split ( \" \" ) b . map! { | item | item . to_i } b . sort! if ( b [ 2 ] ** 2 ) == ( b [ 1 ] ** 2 ) + ( b [ 0 ] ** 2 ) then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { a , b , c = gets . split . map ( & :to_i ) . sort! if a * a + b * b == c * c puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "ans = Array . new range = gets . to_i range . times do | i | data = gets . split ( / \\s / ) num1 = Math . sqrt ( data [ 0 ] . to_i * data [ 0 ] . to_i + data [ 1 ] . to_i * data [ 1 ] . to_i ) num2 = Math . sqrt ( data [ 1 ] . to_i * data [ 1 ] . to_i + data [ 2 ] . to_i * data [ 2 ] . to_i ) num3 = Math . sqrt ( data [ 2 ] . to_i * data [ 2 ] . to_i + data [ 0 ] . to_i * data [ 0 ] . to_i ) if data [ 2 ] . to_i == num1 || data [ 0 ] . to_i == num2 || data [ 1 ] . to_i == num3 ans [ i ] = \" YES \" else ans [ i ] = \" NO \" end end ans . each do | j | puts j end",
    "label": 5
  },
  {
    "code": "cicle = gets . to_i cicle . times do siz = gets lines = siz . split ( \" \" ) max = 0 sum = 0 aa = lines [ 0 ] . to_i ** 2 bb = lines [ 1 ] . to_i ** 2 cc = lines [ 2 ] . to_i ** 2 if ( ( aa - bb - cc ) == 0 ) puts \" YES \" elsif ( ( bb - cc - aa ) == 0 ) puts \" YES \" elsif ( ( cc - aa - bb ) == 0 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "lines = ARGF . gets . to_i lines . times do a , b , c = ARGF . gets . split ( \" \" ) . map { | x | x . to_i } . sort puts ( c * c == a * a + b * b ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split ( ) . map ( & :to_i ) . sort ( ) puts ( c ** 2 == a ** 2 + b ** 2 ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "def main t = gets . chomp . to_i ( 1 .. t ) . each do | ca | edge = gets . chomp . split ( / \\s / ) . collect { | x | x . to_i } edge = edge . sort if edge [ 0 ] ** 2 + edge [ 1 ] ** 2 == edge [ - 1 ] ** 2 puts \" YES \" else puts \" NO \" end end end main",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { d = gets s = d . split ( \" \" ) . map ( & :to_i ) if s [ 0 ] ** 2 + s [ 1 ] ** 2 == s [ 2 ] ** 2 then puts \" YES \" elsif s [ 1 ] ** 2 + s [ 2 ] ** 2 == s [ 0 ] ** 2 then puts \" YES \" elsif s [ 2 ] ** 2 + s [ 0 ] ** 2 == s [ 1 ] ** 2 then puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "gets . chomp . to_i . times do set = gets . chomp . split . map ( & :to_i ) set . sort_by! { | v | v } if set [ 0 ] ** 2 + set [ 1 ] ** 2 == set [ 2 ] ** 2 puts :YES else puts :NO end end",
    "label": 5
  },
  {
    "code": "_ = gets $stdin . each_line do | line | a , b , c = line . split . map { | e | e . to_i } if a ** 2 + b ** 2 == c ** 2 || b ** 2 + c ** 2 == a ** 2 || c ** 2 + a ** 2 == b ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "def triangle ( args ) args . sort . each_cons ( 3 ) do | a , b , c | a ** 2 + b ** 2 == c ** 2 ? puts ( \" YES \" ) : puts ( \" NO \" ) end end gets . chomp . to_i . times do triangle ( gets . chomp . split ( ' ' ) . map! { | elm | elm . to_i } ) end",
    "label": 5
  },
  {
    "code": "YES = \" YES \" NO = \" NO \" def sq ( x ) return x * x end gets . to_i . times do puts -> ( l ) { if sq ( l [ 0 ] ) + sq ( l [ 1 ] ) == sq ( l [ 2 ] ) return YES elsif sq ( l [ 1 ] ) + sq ( l [ 2 ] ) == sq ( l [ 0 ] ) return YES elsif sq ( l [ 2 ] ) + sq ( l [ 0 ] ) == sq ( l [ 1 ] ) return YES end return NO } . call gets . split ( ' ' ) . map ( & :to_i ) end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort! puts c ** 2 == a ** 2 + b ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times { x , y , z = gets . split . map ( & :to_i ) if x ** 2 == y ** 2 + z ** 2 || y ** 2 == z ** 2 + x ** 2 || z ** 2 == x ** 2 + y ** 2 puts \" YES \" ; else puts \" NO \" ; end }",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a , b , c = gets . split . map ( & :to_i ) . sort puts a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = STDIN . gets . to_i n . times do a , b , c = STDIN . gets . split . map ( & :to_i ) . sort puts ( a ** 2 + b ** 2 == c ** 2 ) ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "i = gets . to_i i . times do a , b , c = gets . split ( \" \" ) . map { | i | i . to_i } . sort puts a ** 2 + b ** 2 == c ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { num = gets . split ( \" \" ) a , b , c = num [ 0 ] . to_i , num [ 1 ] . to_i , num [ 2 ] . to_i a , b , c = a ** 2 , b ** 2 , c ** 2 if a + b == c || b + c == a || a + c == b then puts ( \" YES \" ) else puts ( \" NO \" ) end }",
    "label": 5
  },
  {
    "code": "roop = gets . to_i for i in 0 ... roop do data = gets hai = data . split hai . collect! { | i | i . to_i } hai . sort! if hai [ 0 ] ** 2 + hai [ 1 ] ** 2 == hai [ 2 ] ** 2 then print \" YES \\n \" else print \" NO \\n \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a , b , c = gets . split . map ( & :to_i ) . sort if c ** 2 == b ** 2 + a ** 2 puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "size = gets . to_i size . times do sides = STDIN . readline . split ( \" \" ) . map ( & :to_i ) long = sides . max sides . each_with_index do | v , i | if v == long sides . delete_at ( i ) break end end if long ** 2 == sides [ 0 ] ** 2 + sides [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "size = gets . to_i size . times do sides = STDIN . readline . split ( \" \" ) . map ( & :to_i ) long = sides . max sides . each_with_index do | v , i | if v == long sides . delete_at ( i ) break end end if long ** 2 == sides [ 0 ] ** 2 + sides [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "count = STDIN . gets . chomp . to_i while count != 0 sannpenn = STDIN . gets . chomp . split ( \" \\s \" ) sannpenn . map! { | item | item . to_i } sannpenn . sort! count += - 1 if ( sannpenn [ 0 ] ** 2 + sannpenn [ 1 ] ** 2 ) == sannpenn [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do a = gets . split . map ( & :to_i ) . sort puts a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . to_i count = 0 while count < n a = gets . split . map ( & :to_i ) . sort! if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end count += 1 end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a = gets . split ( \" \" ) . map ( & :to_i ) . sort puts ( a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 ) ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "count = gets . chomp . to_i result = [ ] count . times do a , b , c = gets . chomp . split . map ( & :to_i ) . sort if a ** 2 + b ** 2 == c ** 2 result << ' YES ' else result << ' NO ' end end result . each { | ans | puts ans }",
    "label": 5
  },
  {
    "code": "repeat = gets for i in 1 .. repeat . to_i do line = gets test = line . split ( / \\s + / ) tmp = [ ] tmp [ 0 ] = test [ 0 ] . to_i tmp [ 1 ] = test [ 1 ] . to_i tmp [ 2 ] = test [ 2 ] . to_i if tmp [ 0 ] < tmp [ 1 ] then te = tmp [ 0 ] tmp [ 0 ] = tmp [ 1 ] tmp [ 1 ] = te end if tmp [ 0 ] < tmp [ 2 ] then te = tmp [ 0 ] tmp [ 0 ] = tmp [ 2 ] tmp [ 2 ] = te end if tmp [ 0 ] * tmp [ 0 ] == tmp [ 1 ] * tmp [ 1 ] + tmp [ 2 ] * tmp [ 2 ] then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do ary = gets . split ( \" \" ) . collect do | x | x . to_i end ary . sort! if ary [ 0 ] ** 2 + ary [ 1 ] ** 2 == ary [ 2 ] ** 2 then puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i arr = [ ] n . times do arr << gets . split . map ( & :to_i ) end arr . each do | ia | ia . sort! if ( ( ia [ 0 ] ** 2 + ia [ 1 ] ** 2 ) == ia [ 2 ] ** 2 ) puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "ARGF . gets while line = ARGF . gets do a , b , c = line . split . map ( & :to_i ) . sort res = ( a ** 2 ) + ( b ** 2 ) == c ** 2 puts res ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "num = gets ( ) . to_i judges = Array . new num . times do sides = gets ( ) . split ( ) . map { | x | x . to_i } sides . sort! if ( sides [ 0 ] * sides [ 0 ] + sides [ 1 ] * sides [ 1 ] == sides [ 2 ] * sides [ 2 ] ) then judges . push ( \" YES \" ) else judges . push ( \" NO \" ) end end num . times do | n | puts judges [ n ] end",
    "label": 5
  },
  {
    "code": "cnt = gets . to_i results = [ ] cnt . times do a , b , c = gets . split ( \" \" ) . map ( & :to_i ) . sort results << ( a * a + b * b == c * c ? \" YES \" : \" NO \" ) end puts results",
    "label": 5
  },
  {
    "code": "STDIN . to_a [ 1 .. - 1 ] . each do | value | value =~ / ^( \\d +) ( \\d +) ( \\d +)$ / array = [ $1 . to_i , $2 . to_i , $3 . to_i ] array . sort! if ( ( array [ 0 ] ** 2 + array [ 1 ] ** 2 ) == array [ 2 ] ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "set = gets arr = Array . new ( 3 ) while line = gets do num = line . split arr [ 0 ] = num [ 0 ] . to_i arr [ 1 ] = num [ 1 ] . to_i arr [ 2 ] = num [ 2 ] . to_i arr_s = arr . sort a = arr_s [ 0 ] ** 2 + arr_s [ 1 ] ** 2 if a == arr_s [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do arr = gets . split ( ) . map ( & :to_i ) . sort ( ) puts arr [ 0 ] ** 2 + arr [ 1 ] ** 2 == arr [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "gets . to_i . times do array = gets . split ( ) . map ( & :to_i ) . sort ( ) puts array [ 0 ] ** 2 + array [ 1 ] ** 2 == array [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "finish = gets . chomp i = 0 answer = [ ] while i < finish . to_i array = gets . split if array [ 0 ] . to_i > array [ 1 ] . to_i array [ 0 ] , array [ 1 ] = array [ 1 ] , array [ 0 ] end if array [ 1 ] . to_i > array [ 2 ] . to_i array [ 1 ] , array [ 2 ] = array [ 2 ] , array [ 1 ] end if array [ 0 ] . to_i > array [ 1 ] . to_i array [ 0 ] , array [ 1 ] = array [ 1 ] , array [ 0 ] end if array [ 2 ] . to_i ** 2 == array [ 0 ] . to_i ** 2 + array [ 1 ] . to_i ** 2 answer [ i ] = \" YES \" else answer [ i ] = \" NO \" end i = i + 1 end puts answer",
    "label": 5
  },
  {
    "code": "t = gets . to_i t . times do | i | a = gets . split . map ( & :to_i ) . sort puts a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "a = [ ] i = 0 while input = gets a << input . split . map ( & :to_i ) end while i < a [ 0 ] [ 0 ] i += 1 a [ i ] . sort! if a [ i ] [ 0 ] ** 2 + a [ i ] [ 1 ] ** 2 == a [ i ] [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do a = gets . chomp . split . map { | s | s . to_i } . sort if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "gets while gets a , b , c = $_ . split . map ( & :to_i ) . sort puts a * a + b * b == c * c ? ' YES ' : ' NO ' end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do l = gets . chomp . split 3 . times do | i | l [ i ] = l [ i ] . to_i end l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do a , b , c = gets . chomp . split a = a . to_i b = b . to_i c = c . to_i if a ** 2 + b ** 2 == c ** 2 puts \" YES \" elsif a ** 2 + c ** 2 == b ** 2 puts \" YES \" elsif b ** 2 + c ** 2 == a ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "k = gets . chomp . to_i def is_tri ( a , b , c ) if a ** 2 + b ** 2 == c ** 2 || a ** 2 + c ** 2 == b ** 2 || b ** 2 + c ** 2 == a ** 2 return 0 else return 1 end end for i in 0 .. k - 1 n = gets . chomp . split a = n [ 0 ] . to_i b = n [ 1 ] . to_i c = n [ 2 ] . to_i rsl = is_tri ( a , b , c ) if rsl == 0 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times do xs = gets . split . map ( & :to_i ) . sort puts xs [ 0 ] ** 2 + xs [ 1 ] ** 2 == xs [ 2 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i for i in 1 .. n ( a , b , c ) = gets . chomp . split . map ( & :to_i ) . sort if c ** 2 == a ** 2 + b ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "date_set = gets . chomp . to_f date_count = 0 loop do break if date_count == date_set ( a , b , c ) = gets . chomp . split . map ( & :to_f ) . sort if c . to_f ** 2 == a . to_f ** 2 + b . to_f ** 2 puts \" YES \" else puts \" NO \" end date_count += 1 end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i data = [ ] for i in 1 .. ( n ) data = gets . chomp . split ( \" \" ) data [ 0 ] = data [ 0 ] . to_i data [ 1 ] = data [ 1 ] . to_i data [ 2 ] = data [ 2 ] . to_i data = data . sort if data [ 0 ] * data [ 0 ] + data [ 1 ] * data [ 1 ] == data [ 2 ] * data [ 2 ] puts ( \" YES \" ) else puts ( \" NO \" ) end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i for i in 0 .. ( n - 1 ) a = gets . split ( ' ' ) . map { | item | item . to_i } a = a . sort if a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "def right_triangle? ( sides ) sides . sort! ( sides [ 0 ] ** 2 ) + ( sides [ 1 ] ** 2 ) == sides [ 2 ] ** 2 end gets . to_i . times { | i | right_triangle? ( gets . split ( \" \" ) . map ( & :to_i ) ) ? puts ( ' YES ' ) : puts ( ' NO ' ) }",
    "label": 5
  },
  {
    "code": "while line = gets value = line . chomp list = value . split if list . length != 3 next end res_list = [ ] res_list << list [ 0 ] . to_i res_list << list [ 1 ] . to_i res_list << list [ 2 ] . to_i rlist = res_list . sort rlist [ 0 ] *= rlist [ 0 ] rlist [ 1 ] *= rlist [ 1 ] rlist [ 2 ] *= rlist [ 2 ] if ( ( rlist [ 0 ] + rlist [ 1 ] ) == rlist [ 2 ] ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . to_i n . times { sides = gets . chomp . split . map ( & :to_i ) sides . sort! if sides [ 0 ] ** 2 + sides [ 1 ] ** 2 == sides [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end }",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do line = gets . chomp . split 3 . times do | i | line [ i ] = line [ i ] . to_i end line . sort! if line [ 0 ] ** 2 + line [ 1 ] ** 2 == line [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "$< . readlines . drop ( 1 ) . each do | l | a , b , c = l . split . map ( & :to_i ) . sort puts ( ( a * a + b * b == c * c ) ? \" YES \" : \" NO \" ) end",
    "label": 5
  },
  {
    "code": "i = gets . to_i i . times do a , b , c = gets . split ( ' ' ) . map ( & :to_i ) . sort if a ** 2 + b ** 2 == c ** 2 puts ' YES ' else puts ' NO ' end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do l = gets . chomp . split 3 . times do | i | l [ i ] = l [ i ] . to_i end l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do l = gets . chomp . split 3 . times do | i | l [ i ] = l [ i ] . to_i end l . sort! if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i ln = [ ] def sqpls ( i , j ) num = i * i + j * j return num end n . times do | i | ln [ i ] = gets . chomp . split 3 . times do | j | ln [ i ] [ j ] = ln [ i ] [ j ] . to_i end end n . times do | i | if sqpls ( ln [ i ] [ 0 ] , ln [ i ] [ 1 ] ) == sqpls ( ln [ i ] [ 2 ] , 0 ) || sqpls ( ln [ i ] [ 1 ] , ln [ i ] [ 2 ] ) == sqpls ( ln [ i ] [ 0 ] , 0 ) || sqpls ( ln [ i ] [ 2 ] , ln [ i ] [ 0 ] ) == sqpls ( ln [ i ] [ 1 ] , 0 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "t = gets . to_i t . times do | i | a = gets . split . map ( & :to_i ) . sort puts a [ 2 ] ** 2 == a [ 0 ] ** 2 + a [ 1 ] ** 2 ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i length = [ ] for i in 0 ... n data = gets . chomp . to_s length [ i ] = data . split . map! { | x | x . to_i } . sort! end for i in 0 ... n if length [ i ] [ 0 ] ** 2 + length [ i ] [ 1 ] ** 2 == length [ i ] [ 2 ] ** 2 puts \" YES \" elsif puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "date_set = gets . chomp . to_f date_count = 0 loop do break if date_count == date_set ( a , b , c ) = gets . chomp . split . map ( & :to_f ) . sort if c . to_f ** 2 == a . to_f ** 2 + b . to_f ** 2 puts \" YES \" else puts \" NO \" end date_count += 1 end",
    "label": 5
  },
  {
    "code": "j = [ ] m = gets . to_i m . times { | i | a , b , c = gets . split . map ( & :to_i ) . sort! if a ** 2 + b ** 2 == c ** 2 h = \" YES \" j << h else d = \" NO \" j << d end } m . times { | i | puts j [ i ] }",
    "label": 5
  },
  {
    "code": "N = gets . to_i N . times do x = gets ( ) y = x . split ( ) a = y [ 0 ] . to_i b = y [ 1 ] . to_i c = y [ 2 ] . to_i aa = a * a bb = b * b cc = c * c if aa == bb + cc puts \" YES \" elsif bb == aa + cc puts \" YES \" elsif cc == bb + aa puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "N = gets . chomp! . to_i N . times do data = gets . chomp! . split ( ' ' ) data . collect! do | s | i = s . to_i i *= i end a = data [ 0 ] ; b = data [ 1 ] ; c = data [ 2 ] res = a + b == c || b + c == a || c + a == b puts res ? \" YES \" : \" NO \" end",
    "label": 5
  },
  {
    "code": "t = gets . to_i t . times do line = gets . split . map! ( & :to_i ) . sort if line [ 2 ] ** 2 == line [ 0 ] ** 2 + line [ 1 ] ** 2 puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "n = gets . chomp . to_i n . times do line = gets numbers = line . split ( nil ) . map ( & :to_i ) if ( numbers [ 0 ] ** 2 + numbers [ 1 ] ** 2 == numbers [ 2 ] ** 2 ) || ( numbers [ 1 ] ** 2 + numbers [ 2 ] ** 2 == numbers [ 0 ] ** 2 ) || ( numbers [ 2 ] ** 2 + numbers [ 0 ] ** 2 == numbers [ 1 ] ** 2 ) puts \" YES \" else puts \" NO \" end end",
    "label": 5
  },
  {
    "code": "answer = Array . new times = $stdin . gets . to_i 1 . upto ( times ) { line = $stdin . gets nums = line . split ( / \\s / ) nums . map! { | r | r . to_i } nums . sort! a = nums [ 0 ] b = nums [ 1 ] c = nums [ 2 ] if a * a + b * b == c * c answer << \" YES \" else answer << \" NO \" end } answer . each { | ans | puts ans }",
    "label": 5
  },
  {
    "code": "n = gets . to_i while n > 0 do s = gets . split ( nil ) a = s [ 0 ] . to_i b = s [ 1 ] . to_i c = s [ 2 ] . to_i d = b * b + c * c - a * a e = a * a + c * c - b * b f = a * a + b * b - c * c flg = 0 if d == 0 then print ( \" YES \\n \" ) flg = 1 end if e == 0 then print ( \" YES \\n \" ) flg = 1 end if f == 0 then print ( \" YES \\n \" ) flg = 1 end if flg == 0 print ( \" NO \\n \" ) end n = n - 1 end",
    "label": 5
  },
  {
    "code": "while input = gets a , b , c , d , e , f = input . chomp . split ( \" \" ) . map ( & :to_f ) l = d / a m = ( l * c - f ) n = ( l * b - e ) if a != 0 y = m / n x = ( c - b * y ) / a else a == 0 y = c / b if b != 0 x = ( f - e * ( c / b ) ) / d end printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) + 0.000 y = ( c * d - a * f ) / ( b * d - a * e ) + 0.000 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split ( \" \" ) . map ( & :to_f ) y = a == 0 ? c / b : ( f - ( d * c / a ) ) / ( e - ( b * d / a ) ) x = d == 0 ? ( c - ( b * y ) ) / a : ( f - e * y ) / d x = 0 if x . abs == 0.0 y = 0 if y . abs == 0.0 puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while data = gets data2 = data . split ( \" \" ) data2 . map! { | x | x . to_f } x = ( data2 [ 5 ] * data2 [ 1 ] - data2 [ 2 ] * data2 [ 4 ] ) / ( data2 [ 1 ] * data2 [ 3 ] - data2 [ 0 ] * data2 [ 4 ] ) y = ( data2 [ 2 ] - data2 [ 0 ] * x ) / data2 [ 1 ] puts \" end",
    "label": 5
  },
  {
    "code": "coefficients = [ ] while gets data = $_ . split data . length . times do | i | data [ i ] = data [ i ] . to_f end coefficients . push data end coefficients . length . times do | i | x = ( coefficients [ i ] [ 2 ] * coefficients [ i ] [ 4 ] - coefficients [ i ] [ 1 ] * coefficients [ i ] [ 5 ] ) / ( coefficients [ i ] [ 0 ] * coefficients [ i ] [ 4 ] - coefficients [ i ] [ 3 ] * coefficients [ i ] [ 1 ] ) y = ( coefficients [ i ] [ 2 ] * coefficients [ i ] [ 3 ] - coefficients [ i ] [ 0 ] * coefficients [ i ] [ 5 ] ) / ( coefficients [ i ] [ 1 ] * coefficients [ i ] [ 3 ] - coefficients [ i ] [ 0 ] * coefficients [ i ] [ 4 ] ) printf ( \" %.3f %.3f \\n \" , x + 0.0 , y + 0.0 ) end",
    "label": 5
  },
  {
    "code": "while ( str = gets ) a , b , c , d , e , f = str . split ( \" \" ) . map ( & :to_f ) if a * b * d * e != 0 puts [ sprintf ( \" %.3f \" , ( ( c - f * ( b / e ) ) / ( a - d * ( b / e ) ) ) . round ( 3 ) ) , sprintf ( \" %.3f \" , ( ( c - f * ( a / d ) ) / ( b - e * ( a / d ) ) ) . round ( 3 ) ) ] . join ( \" \" ) else if a == 0 puts [ sprintf ( \" %.3f \" , ( ( f - e * ( c / b ) ) / d ) . round ( 3 ) ) , sprintf ( \" %.3f \" , ( c / b ) . round ( 3 ) ) ] . join ( \" \" ) elsif b == 0 puts [ sprintf ( \" %.3f \" , ( c / a ) . round ( 3 ) ) , sprintf ( \" %.3f \" , ( ( f - d * ( c / a ) ) / e ) . round ( 3 ) ) ] . join ( \" \" ) elsif d == 0 puts [ sprintf ( \" %.3f \" , ( ( c - b * ( f / e ) ) / a ) . round ( 3 ) ) , sprintf ( \" %.3f \" , ( f / e ) . round ( 3 ) ) ] . join ( \" \" ) else puts [ sprintf ( \" %.3f \" , ( f / d ) . round ( 3 ) ) , sprintf ( \" %.3f \" , ( ( c - a * ( f / d ) ) / b ) . round ( 3 ) ) ] . join ( \" \" ) end end end",
    "label": 5
  },
  {
    "code": "while dataset = gets do if dataset . chomp! == ' ' break end dataArray = Array . new dataArray = dataset . split ( ' ' ) a = dataArray [ 0 ] . to_i b = dataArray [ 1 ] . to_i c = dataArray [ 2 ] . to_i d = dataArray [ 3 ] . to_i e = dataArray [ 4 ] . to_i f = dataArray [ 5 ] . to_i x = 1.0 / ( a * e - b * d ) * ( e * c - b * f ) y = 1.0 / ( a * e - b * d ) * ( - d * c + a * f ) x = ( x * 1000 ) . round / 1000.0 y = ( y * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while dataset = gets do if dataset . chomp! == ' ' break end dataArray = Array . new dataArray = dataset . split ( ' ' ) a = dataArray [ 0 ] . to_i b = dataArray [ 1 ] . to_i c = dataArray [ 2 ] . to_i d = dataArray [ 3 ] . to_i e = dataArray [ 4 ] . to_i f = dataArray [ 5 ] . to_i x = 1.0 / ( a * e - b * d ) * ( e * c - b * f ) y = 1.0 / ( a * e - b * d ) * ( - d * c + a * f ) x = ( x * 1000 ) . round / 1000.0 y = ( y * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "$< . map { | l | a , b , c , d , e , f = l . split . map & :to_f puts \" %.3f %.3f \" %[ 0+(e*c-b*f)/x=a*e-b*d,0+(a*f-d*c)/x ] }",
    "label": 5
  },
  {
    "code": "$< . map { | l | a , b , c , d , e , f = l . split . map & :to_f puts \" %.3f %.3f \" %[ 0+(e*c-b*f)/x=a*e-b*d,(a*f-d*c)/x ] }",
    "label": 5
  },
  {
    "code": "a , b , c , d , e , f = $F . map & :to_f $_ = \" %.3f %.3f \" %[ 0+(c*e-b*f)/g=a*e-b*d,(a*f-c*d)/g ]",
    "label": 5
  },
  {
    "code": "require ' matrix ' while input = gets do a , b , c , d , e , f = input . split . map ( & :to_f ) m = Matrix [ [ a , b ] , [ d , e ] ] v = Vector [ c , f ] puts ( m . inv * v ) . to_a . map { | x | sprintf ( \" %.3f \" , x . to_f ) } . to_s . gsub ( / [ \\[ \\] \\, \\\" ] / , \" \" ) end",
    "label": 5
  },
  {
    "code": "while ( input = gets ) != nil a , b , c , d , e , f = input . split ( \" \" ) . map { | num | num . to_f } d = ( a * e - b * d ) * 1.00 x = ( e * c - f * b ) / d y = ( c - a * x ) / b puts ( sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) ) end",
    "label": 5
  },
  {
    "code": "module Input def numread ( ) s = gets ( ) . split ( ) p = Array . new ( ) for i in 0 ... s . size ( ) p [ i ] = s [ i ] . to_i ( ) end return p end module_function : numread end include Input loop { if ( STDIN . eof ( ) ) break end w = numread ( ) x = ( w [ 2 ] * w [ 4 ] - w [ 1 ] * w [ 5 ] ) . to_f / ( w [ 0 ] * w [ 4 ] - w [ 1 ] * w [ 3 ] ) + 0.00001 y = ( w [ 2 ] * w [ 3 ] - w [ 0 ] * w [ 5 ] ) . to_f / ( w [ 1 ] * w [ 3 ] - w [ 0 ] * w [ 4 ] ) + 0.00001 print ( sprintf ( \" %.3f %.3f \\n \" , x , y ) ) }",
    "label": 5
  },
  {
    "code": "def calc_x ( a , b , c , d , e , f ) ( e * c - b * f ) / ( a * e - b * d ) end def calc_y ( a , b , c , d , e , f ) ( c - a * calc_x ( a , b , c , d , e , f ) ) / b end loop do s = gets break if s . nil? a , b , c , d , e , f = s . chomp . split . map ( & :to_f ) x = calc_x ( a , b , c , d , e , f ) y = calc_y ( a , b , c , d , e , f ) puts \" end",
    "label": 5
  },
  {
    "code": "while v = gets a , b , c , d , e , f = v . split . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) + 0.000 y = ( a * f - c * d ) / ( a * e - b * d ) + 0.000 printf \" %.3f %.3f \\n \" , x , y end",
    "label": 5
  },
  {
    "code": "a , b , c , d , e , f = $F . map & :to_f $_ = \" %.3f %.3f \" %[ 0+(c*e-b*f)/g=a*e-b*d,(a*f-c*d)/g ]",
    "label": 5
  },
  {
    "code": "num = [ ] while a = gets num = a . split ( nil ) num . map! { | n | n . to_f } x = ( num [ 2 ] * num [ 4 ] - num [ 1 ] * num [ 5 ] ) / ( num [ 0 ] * num [ 4 ] - num [ 1 ] * num [ 3 ] ) y = ( num [ 2 ] * num [ 3 ] - num [ 0 ] * num [ 5 ] ) / ( num [ 1 ] * num [ 3 ] - num [ 0 ] * num [ 4 ] ) puts printf ( \" %.3f %.3f \" , x + 0 , y + 0 ) end",
    "label": 5
  },
  {
    "code": "require ' matrix ' while line = gets data = line . split . map ( & :to_f ) a = Matrix . rows ( [ [ data [ 0 ] , data [ 1 ] ] , [ data [ 3 ] , data [ 4 ] ] ] ) y = Matrix . column_vector ( [ data [ 2 ] , data [ 5 ] ] ) x = a . inv * y result = [ ] x . each do | i | result << sprintf ( \" % end puts result.join( \" \" ) end",
    "label": 5
  },
  {
    "code": "STDIN . each { | s | a , b , c , d , e , f = s . split ( \" \" ) . map! { | d | d . to_f } z1 = b * d - e * a z2 = c * d - f * a y = z2 / z1 x = ( - ( b * y ) + c ) / a printf ( \" %.3f %.3f \\n \" , x , y ) }",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) x = Rational ( b * f - c * e , b * d - a * e ) y = Rational ( a * f - d * c , a * e - b * d ) printf \" %.3f %.3f \\n \" , x , y end",
    "label": 5
  },
  {
    "code": "require ' matrix ' until $stdin . eof? a , b , c , d , e , f = gets . split . map ( & :to_i ) mat = Matrix [ [ a , b ] , [ d , e ] ] pair = Matrix [ [ c ] , [ f ] ] result = mat . inv * pair x , y = result [ 0 , 0 ] . to_f , result [ 1 , 0 ] . to_f puts \" %.3f %.3f \" % [ x , y ] end",
    "label": 5
  },
  {
    "code": "while line = gets num = line . split ( ' ' ) . map ( & :to_f ) a , b , c , d , e , f = num x = ( ( b * f - c * e ) / ( b * d - a * e ) ) y = ( ( c * d - a * f ) / ( b * d - a * e ) ) x3 = sprintf ( \" %.3f \" , x ) y3 = sprintf ( \" %.3f \" , y ) if x3 == \" -0.000 \" x3 = \" 0.000 \" end if y3 == \" -0.000 \" y3 = \" 0.000 \" end print x3 + \" \" + y3 + \" \\n \" end",
    "label": 5
  },
  {
    "code": "while s = gets nums = s . split . map ( & :to_f ) a , b , c , d , e , f = nums x = ( c * e - b * f ) / ( a * e - b * d ) y = ( a * f - c * d ) / ( a * e - b * d ) x = x . round ( 3 ) y = y . round ( 3 ) x = x != 0 ? x : 0 y = y != 0 ? y : 0 puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "require ' matrix ' while gets a = $_ . split . map { | s | s . to_i } v = Matrix [ [ a [ 0 ] , a [ 1 ] ] , [ a [ 3 ] , a [ 4 ] ] ] . inv * Vector [ a [ 2 ] , a [ 5 ] ] puts v . to_a . map { | r | sprintf ( \" %.3f \" , r . to_f . round ( 3 ) ) } . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "args = [ ] while line = gets do a , b , c , d , e , f = line . split . map ( & :to_f ) y = ( a * f - d * c ) / ( a * e - d * b ) x = ( c - b * y ) / a puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( e * c - b * f ) / ( a * e - b * d ) + 0.0 y = ( d * c - a * f ) / ( d * b - a * e ) + 0.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , p , c , d , q = line . split . map ( & :to_f ) z = a * d - b * c x = ( p * d - b * q ) / z + 0.0 y = ( a * q - p * c ) / z + 0.0 puts \" %.3f %.3f \" % [ x , y ] end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_i ) ans1 = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 ans2 = ( ( a * f - d * c ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , ans1 , ans2 ) end",
    "label": 5
  },
  {
    "code": "def solve ( a , b , c , d , e , f ) x = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 y = ( ( a * f - d * c ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 return x , y end while line = gets line . chomp! a , b , c , d , e , f = line . chomp . split ( \" \" ) . map { | item | item . to_f } result = solve ( a , b , c , d , e , f ) puts \" %.3f %.3f \" % [ result [ 0 ] , result [ 1 ] ] end",
    "label": 5
  },
  {
    "code": "def solve ( a1 , b1 , c1 , a2 , b2 , c2 ) x = ( c1 * b2 - c2 * b1 ) / ( a1 * b2 - a2 * b1 ) x = 0.0 if x == - 0.0 y = ( a1 * c2 - a2 * c1 ) / ( a1 * b2 - a2 * b1 ) y = 0.0 if y == - 0.0 return x , y end $< . each do | l | a , b , c , d , e , f = l . split . map ( & :to_f ) x , y = solve ( a , b , c , d , e , f ) printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "require ' matrix ' while gets a = $_ . split . map { | s | s . to_i } v = Matrix [ [ a [ 0 ] , a [ 1 ] ] , [ a [ 3 ] , a [ 4 ] ] ] . inv * Vector [ a [ 2 ] , a [ 5 ] ] puts v . to_a . map { | r | sprintf ( \" %.3f \" , r . to_f . round ( 3 ) ) } . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "require ' matrix ' while gets a , b , c , d , e , f = $_ . split . map ( & :to_f ) v = Matrix [ [ a , b ] , [ d , e ] ] . inverse * Vector [ c , f ] printf ( \" %.3f %.3f \\n \" , * v ) end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_f ) y = ( a * f - c * d ) / ( a * e - b * d ) x = ( c - b * ( ( a * f - c * d ) / ( a * e - b * d ) ) ) / a puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_f ) y = ( a * f - c * d ) / ( a * e - b * d ) x = ( c - b * ( ( a * f - c * d ) / ( a * e - b * d ) ) ) / a puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "class Simultaneous def initialize ( input ) @a , @b , @c , @d , @e , @f = input . split ( \" \" ) . map ( & :to_f ) end attr_accessor :a , :b , :c , :d , :e , :f def calc x = ( @c * @e - @b * @f ) / ( @a * @e - @b * @d ) . to_f y = ( @c * @d - @a * @f ) / ( @b * @d - @a * @e ) . to_f x = 0 if x . abs == 0.0 y = 0 if y . abs == 0.0 return [ x , y ] end end while data = gets ans = Simultaneous . new ( data ) . calc puts sprintf ( \" %.3f %.3f \" , ans [ 0 ] , ans [ 1 ] ) end",
    "label": 5
  },
  {
    "code": "while pair = gets a , b , c , d , e , f = pair . split ( ' ' ) a = a . to_f b = b . to_f c = c . to_f d = d . to_f e = e . to_f f = f . to_f base = a * e - b * d x = ( c * e - f * b ) / base ; y = ( a * f - c * d ) / base ; puts ' %.3f ' % ( x + 0 ) . to_s << ' ' << ' %.3f ' % y . to_s end",
    "label": 5
  },
  {
    "code": "require \" matrix \" while gets a , b , c , d , e , f = $_ . split . map ( & :to_i ) ans = Matrix [ [ a , b ] , [ d , e ] ] . lup . solve ( [ c , f ] ) . to_a . map { | i | i . to_f . round ( 3 ) } puts \" %.3f %.3f \" % ans end",
    "label": 5
  },
  {
    "code": "require \" matrix \" while gets a , b , c , d , e , f = $_ . split . map ( & :to_i ) ans = Matrix [ [ a , b ] , [ d , e ] ] . lup . solve ( [ c , f ] ) . to_a . map ( & :to_f ) puts \" %.3f %.3f \" % ans end",
    "label": 5
  },
  {
    "code": "require \" matrix \" while gets a , b , c , d , e , f = $_ . split . map ( & :to_i ) puts \" %.3f %.3f \" % Matrix [ [ a , b ] , [ d , e ] ] . lup . solve ( [ c , f ] ) . to_a . map ( & :to_f ) end",
    "label": 5
  },
  {
    "code": "module Gauss def self . calc ( a ) a . length . times do | k | pivot = a [ k ] [ k ] i = k i . upto ( a [ k ] . length - 1 ) do | j | a [ k ] [ j ] /= pivot end a . length . times do | j | if ( j != k ) d = a [ j ] [ k ] l = k l . upto ( a [ k ] . length - 1 ) do | m | a [ j ] [ m ] -= d * a [ k ] [ m ] end end end end a end end while line = gets a , b , c , d , e , f = line . chomp . split . map ( & :to_f ) g = [ [ a , b , c ] , [ d , e , f ] ] answer = Gauss . calc ( g ) puts sprintf ( ' %.3f %.3f ' , answer [ 0 ] [ 2 ] + 0.0 , answer [ 1 ] [ 2 ] + 0.0 ) end",
    "label": 5
  },
  {
    "code": "module GaussJordan def self . calc ( a ) a . length . times do | k | pivot = a [ k ] [ k ] i = k i . upto ( a [ k ] . length - 1 ) do | j | a [ k ] [ j ] /= pivot end a . length . times do | j | if ( j != k ) d = a [ j ] [ k ] l = k l . upto ( a [ k ] . length - 1 ) do | m | a [ j ] [ m ] -= d * a [ k ] [ m ] end end end end a end end while line = gets a , b , c , d , e , f = line . chomp . split . map ( & :to_f ) g = [ [ a , b , c ] , [ d , e , f ] ] answer = GaussJordan . calc ( g ) puts sprintf ( ' %.3f %.3f ' , answer [ 0 ] [ 2 ] + 0.0 , answer [ 1 ] [ 2 ] + 0.0 ) end",
    "label": 5
  },
  {
    "code": "module GaussJordan def self . calc ( a ) a . length . times do | k | pivot = a [ k ] [ k ] i = k i . upto ( a [ k ] . length - 1 ) do | j | a [ k ] [ j ] /= pivot end a . length . times do | j | if j != k d = a [ j ] [ k ] l = k l . upto ( a [ k ] . length - 1 ) do | m | a [ j ] [ m ] -= d * a [ k ] [ m ] end end end end a end end while line = gets a , b , c , d , e , f = line . chomp . split . map ( & :to_f ) g = [ [ a , b , c ] , [ d , e , f ] ] answer = GaussJordan . calc ( g ) puts sprintf ( ' %.3f %.3f ' , answer [ 0 ] [ 2 ] + 0.0 , answer [ 1 ] [ 2 ] + 0.0 ) end",
    "label": 5
  },
  {
    "code": "module GaussJordan def self . calc ( a ) a . length . times do | k | pivot = a [ k ] [ k ] i = k i . upto ( a [ k ] . length - 1 ) do | j | a [ k ] [ j ] /= pivot end a . length . times do | j | if j != k d = a [ j ] [ k ] l = k l . upto ( a [ k ] . length - 1 ) do | m | a [ j ] [ m ] -= d * a [ k ] [ m ] end end end end a end end while line = gets a , b , c , d , e , f = line . chomp . split . map ( & :to_f ) g = [ [ a , b , c ] , [ d , e , f ] ] answer = GaussJordan . calc ( g ) puts sprintf ( ' %.3f %.3f ' , answer [ 0 ] [ 2 ] + 0.0 , answer [ 1 ] [ 2 ] + 0.0 ) end",
    "label": 5
  },
  {
    "code": "require ' matrix ' $stdin = DATA if $stdin . eof? ARGF . each_line do | line | a , b , c , d , e , f = line . split . map ( & :to_r ) mat_a = Matrix [ [ a , b ] , [ d , e ] ] . inverse mat_b = Matrix [ [ c ] , [ f ] ] mat_s = mat_a * mat_b puts mat_s . column ( 0 ) . to_a . map ( & :to_f ) . map { | e | \" %1.3f \" % e . round ( 3 ) } . join ( \" \\s \" ) end",
    "label": 5
  },
  {
    "code": "ARGF . each_line do | line | a , b , c , d , e , f = line . split . map ( & :to_f ) if a == 0 y = c / b x = ( f - e * y ) / d elsif b == 0 x = c / a y = ( f - d * x ) / e elsif d == 0 y = f / e x = ( c - b * y ) / a elsif e == 0 x = f / d y = ( c - a * x ) / b end unless x || y y = ( ( c / a ) - ( f / d ) ) / ( ( b / a ) - ( e / d ) ) x = ( c - b * y ) / a end puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . chomp . split . map ( & :to_f ) case when d * e != 0 g = b / e h = a / d x = c - g * f x = ( x == 0.0 ) ? x : x / ( a - g * d ) y = c - h * f y = ( y == 0.0 ) ? y : y / ( b - h * e ) when a * b != 0 g = e / b h = d / a x = f - g * c x = ( x == 0.0 ) ? x : x / ( d - g * a ) y = f - h * c y = ( y == 0.0 ) ? y : y / ( e - h * b ) when a == 0 x = f / d y = c / b when b == 0 x = c / a y = f / e end puts sprintf ( \" %1.3f %1.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_f ) matrix = [ [ a , b ] , [ d , e ] ] m2 = [ [ c ] , [ f ] ] inv = [ [ matrix [ 1 ] [ 1 ] , matrix [ 0 ] [ 1 ] * - 1 ] , [ matrix [ 1 ] [ 0 ] * - 1 , matrix [ 0 ] [ 0 ] ] ] c = matrix [ 0 ] [ 0 ] * matrix [ 1 ] [ 1 ] - matrix [ 1 ] [ 0 ] * matrix [ 0 ] [ 1 ] 2 . times do | i | 2 . times do | j | inv [ i ] [ j ] /= c end end x = inv [ 0 ] [ 0 ] * m2 [ 0 ] [ 0 ] + inv [ 0 ] [ 1 ] * m2 [ 1 ] [ 0 ] y = inv [ 1 ] [ 0 ] * m2 [ 0 ] [ 0 ] + inv [ 1 ] [ 1 ] * m2 [ 1 ] [ 0 ] puts \" end",
    "label": 5
  },
  {
    "code": "STDOUT . sync = true num = [ ] while data = STDIN . gets do num = data . split ( ) . map! ( & :to_f ) y = ( num [ 2 ] * num [ 3 ] - num [ 0 ] * num [ 5 ] ) / ( num [ 1 ] * num [ 3 ] - num [ 0 ] * num [ 4 ] ) x = ( num [ 2 ] - num [ 1 ] * y ) / num [ 0 ] puts \" %.3f %.3f \" % [ x , y ] end",
    "label": 5
  },
  {
    "code": "while a = gets a , b , c , d , e , f = a . split . map ( & :to_f ) x = ( c - b * ( d * c - a * f ) / ( d * b - a * e ) ) / a ; y = ( d * c - a * f ) / ( d * b - a * e ) puts \" end",
    "label": 5
  },
  {
    "code": "while io = gets a , b , c , d , e , f = io . split ( \" \" ) . map ( & :to_f ) delta = a * e - b * d x = ( ( e * c - b * f ) / delta ) . round ( 3 ) y = ( a * f - c * d ) / delta . round ( 3 ) if x == 0 x = 0.000 end if y == 0 y = 0.000 end puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_i ) x = ( ( e * c - b * f ) / ( a * e - b * d ) . to_f ) . round ( 4 ) y = ( ( a * f - d * c ) / ( a * e - b * d ) . to_f ) . round ( 4 ) x = x . abs if x . zero? y = y . abs if y . zero? printf ( \" %4.3f %4.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while true do begin littlenum = 0.000001 a1 , b1 , c1 , a2 , b2 , c2 = gets . split ( \" \" ) . map ( & :to_f ) printf ( \" %.3f %.3f \\n \" , ( b2 * c1 - b1 * c2 ) / ( a1 * b2 - b1 * a2 ) + littlenum , ( a1 * c2 - c1 * a2 ) / ( a1 * b2 - b1 * a2 ) + littlenum ) rescue break end end",
    "label": 5
  },
  {
    "code": "while n = gets arr = n . split . map ( & :to_f ) printf ( \" %.3f %.3f \\n \" , ( arr [ 2 ] * arr [ 4 ] - arr [ 1 ] * arr [ 5 ] ) / ( arr [ 0 ] * arr [ 4 ] - arr [ 1 ] * arr [ 3 ] ) + 0.000 , ( arr [ 2 ] * arr [ 3 ] - arr [ 0 ] * arr [ 5 ] ) / ( arr [ 1 ] * arr [ 3 ] - arr [ 0 ] * arr [ 4 ] ) + 0.000 ) end",
    "label": 5
  },
  {
    "code": "def abs ( n ) return ( n > 0 ) ? n : - n end def sgn ( n ) return ( n >= 0 ) ? \" \" : \" - \" end while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( ( c * e - b * f ) / ( a * e - b * d ) * 1000 ) . round ( 0 ) y = ( ( - c * d + a * f ) / ( a * e - b * d ) * 1000 ) . round ( 0 ) xs = sgn ( x ) ys = sgn ( y ) xa = abs ( x ) ya = abs ( y ) printf \" %s%d.%03d %s%d.%03d \\n \" , xs , xa / 1000 , xa % 1000 , ys , ya / 1000 , ya % 1000 end",
    "label": 5
  },
  {
    "code": "while values = gets a , b , c , d , e , f = values . split ( ' ' ) . map { | i | i . to_f } if a == 0 y = ( c / b ) x = ( ( f - e * y ) / d ) elsif b == 0 x = ( c / a ) y = ( ( f - d * x ) / e ) elsif d == 0 y = ( f / e ) x = ( ( c - b * y ) / a ) elsif e == 0 x = ( f / d ) y = ( ( c - a * x ) / b ) else x = ( ( b * f - c * e ) / ( b * d - a * e ) ) y = ( ( c - a * x ) / b ) end if x == 0 x = x . to_s . delete ( \" - \" ) . to_f end if y == 0 y = y . to_s . delete ( \" - \" ) . to_f end puts \" end",
    "label": 5
  },
  {
    "code": "data = Array . new ( ) i = 0 x = Array . new ( ) y = Array . new ( ) while true data [ i ] = gets break if data [ i ] == nil data [ i ] = data [ i ] . split ( \" \" ) a = data [ i ] [ 0 ] . to_f b = data [ i ] [ 1 ] . to_f c = data [ i ] [ 2 ] . to_f d = data [ i ] [ 3 ] . to_f e = data [ i ] [ 4 ] . to_f f = data [ i ] [ 5 ] . to_f y [ i ] = ( ( ( c * ( d / a ) ) - f ) / ( ( ( d / a ) * b ) - e ) ) . round ( 3 ) x [ i ] = ( ( c - b * y [ i ] ) / a ) . round ( 3 ) i += 1 end ( x . size ) . times do | i | puts \" end",
    "label": 5
  },
  {
    "code": "$< . each_line do | line | a1 , b1 , c1 , a2 , b2 , c2 = line . split . map ( & :to_f ) a = ( a1 * b2 - a2 * b1 ) x = ( c1 * b2 - c2 * b1 ) / a + 0 y = ( a1 * c2 - a2 * c1 ) / a + 0 printf \" %.3f %.3f \\n \" , x , y end",
    "label": 5
  },
  {
    "code": "while line = gets d = line . chomp . split ( \" \" ) . map ( & :to_f ) printf ( \" %.03f %.03f \\n \" , 0 + ( d [ 2 ] * d [ 4 ] - d [ 1 ] * d [ 5 ] ) / ( d [ 0 ] * d [ 4 ] - d [ 1 ] * d [ 3 ] ) , 0 + ( d [ 2 ] * d [ 3 ] - d [ 0 ] * d [ 5 ] ) / ( d [ 1 ] * d [ 3 ] - d [ 0 ] * d [ 4 ] ) ) end",
    "label": 5
  },
  {
    "code": "while data = gets a , b , c , d , e , f = data . chomp . split ( \" \" ) . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) y = ( c * d - a * f ) / ( b * d - a * e ) x = 0 . to_f if x . zero? y = 0 . to_f if y . zero? puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "data = [ ] while data = gets data = data . split ( nil ) data . map! { | n | n . to_f } x = ( data [ 2 ] * data [ 4 ] - data [ 1 ] * data [ 5 ] ) / ( data [ 0 ] * data [ 4 ] - data [ 1 ] * data [ 3 ] ) y = ( data [ 2 ] * data [ 3 ] - data [ 0 ] * data [ 5 ] ) / ( data [ 1 ] * data [ 3 ] - data [ 0 ] * data [ 4 ] ) puts printf ( \" %.3f %.3f \" , x + 0 , y + 0 ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split ( \" \" ) . map ( & :to_i ) det = ( a * e - b * d ) if det != 0 x = ( ( e * c - b * f ) * 1.0 / det * 1000 ) . round / 1000.0 y = ( ( - c * d + a * f ) * 1.0 / det * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , x , y ) end end",
    "label": 5
  },
  {
    "code": "STDIN . read . chomp . split ( \" \\n \" ) . each do | list | a , b , c , d , e , f = list . split . map ( & :to_f ) x = ( b * f - c * e ) / ( b * d - a * e ) y = ( a * f - c * d ) / ( a * e - d * b ) puts [ x . zero? && x . abs || x , y . zero? && y . abs || y ] . map { | i | format ( ' %.3f ' , i ) } . join ( ' ' ) end",
    "label": 5
  },
  {
    "code": "STDIN . read . chomp . split ( \" \\n \" ) . each do | list | a , b , c , d , e , f = list . split . map ( & :to_f ) x = ( b * f - c * e ) / ( b * d - a * e ) y = ( a * f - c * d ) / ( a * e - d * b ) puts [ x , y ] . map { | i | format ( ' %.3f ' , i . zero? && i . abs || i ) } . join ( ' ' ) end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_i ) ans1 = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 ans2 = ( ( a * f - d * c ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , ans1 , ans2 ) end",
    "label": 5
  },
  {
    "code": "while buf = gets do a , b , c , d , e , f = buf . split . map ( & :to_i ) x = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 y = ( ( a * f - c * d ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while buf = gets do a , b , c , d , e , f = buf . split . map ( & :to_i ) x = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 y = ( ( a * f - c * d ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "loop do line = gets break if line . nil? a , b , c , d , e , f = line . chomp . split ( ' ' ) . map ( & :to_f ) y = ( ( c * d ) - ( f * a ) ) / ( ( b * d ) - ( e * a ) ) x = ( c - b * y ) / a printf ( \" %.3f %.3f \\n \" , x . round ( 4 ) , y . round ( 4 ) ) end",
    "label": 5
  },
  {
    "code": "def rnd ( x ) return ( x * 1000 ) . round . to_f / 1000 end def sim ( v ) a , b , c , d , e , f = v det = a * e - b * d x = ( e * c - b * f ) . to_f / det y = ( - c * d + a * f ) . to_f / det return [ x , y ] end class Main def initialize fh = STDIN v = [ ] while fh . gets do v . push ( $_ . split . map { | x | x . to_i } ) end v . each { | f | x , y = sim ( f ) printf ( \" %.3f %.3f \\n \" , rnd ( x ) , rnd ( y ) ) } end end if $0 == __FILE__ then Main . new end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( b * f - c * e ) / ( b * d - a * e ) y = ( c - a * x ) / b puts \" end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( b * f - c * e ) / ( b * d - a * e ) y = ( c - a * x ) / b puts sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( b * f - c * e ) / ( b * d - a * e ) y = ( c - a * x ) / b puts sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) boo = a * d bb = ( boo / a ) * b cc = ( boo / a ) * c ee = ( boo / d ) * e ff = ( boo / d ) * f x = bb - ee w = cc - ff if ( ( a != 0 ) && ( d != 0 ) ) v = w / x an = c - b * v ans = an / a else if ( a == 0 ) v = c / b an = f - e * v ans = an / d else v = f / e an = c - b * v ans = an / a end end printf ( \" %.3f %.3f \\n \" , ans , v ) end",
    "label": 5
  },
  {
    "code": "if __FILE__ == $0 while a = gets num = [ ] num = a . split ( nil ) num = num . map { | n | n . to_f } a = num [ 0 ] b = num [ 1 ] c = num [ 2 ] d = num [ 3 ] e = num [ 4 ] f = num [ 5 ] y = ( c * d - a * f ) / ( b * d - a * e ) x = ( c - b * y ) / a puts \" end end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) y = ( a * f - c * d ) / ( a * e - b * d ) puts format ( ' %.3f ' , x . round ( 3 ) + 0 ) + \" \\s \" + format ( ' %.3f ' , y . round ( 3 ) + 0 ) end",
    "label": 5
  },
  {
    "code": "loop do line = gets break unless line a , b , c , d , e , f = line . split . map ( & :to_f ) det = a * e - b * d x = ( e * c - b * f ) / det ; y = ( a * f - c * d ) / det x = 0.0 if x == - 0.0 y = 0.0 if y == - 0.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "require \" matrix \" $< . map { | a | a . split . map ( & :to_i ) } . each do | a | Matrix [ [ a [ 0 ] , a [ 1 ] ] , [ a [ 3 ] , a [ 4 ] ] ] . lup . solve ( [ a [ 2 ] , a [ 5 ] ] ) . map { | b | b . to_f . round ( 3 ) } . tap { | c | print format ( \" %.3f %.3f \\n \" , c [ 0 ] , c [ 1 ] ) } end",
    "label": 5
  },
  {
    "code": "while formula = gets formulas = formula . split ( ' ' ) . map ( & :to_f ) f_x = ( ( formulas [ 2 ] * formulas [ 4 ] ) - ( formulas [ 1 ] * formulas [ 5 ] ) ) / ( ( formulas [ 0 ] * formulas [ 4 ] ) - ( formulas [ 1 ] * formulas [ 3 ] ) ) f_y = ( ( formulas [ 0 ] * formulas [ 5 ] ) - ( formulas [ 2 ] * formulas [ 3 ] ) ) / ( ( formulas [ 0 ] * formulas [ 4 ] ) - ( formulas [ 1 ] * formulas [ 3 ] ) ) x = f_x . round ( 3 ) y = f_y . round ( 3 ) x = x != 0 ? x : 0 y = y != 0 ? y : 0 puts sprintf ( ' %.3f %.3f ' , x , y ) end",
    "label": 5
  },
  {
    "code": "while abcdef = STDIN . gets abcdef . chomp! a , b , c , d , e , f = abcdef . split ( \" \" ) . map { | item | item . to_i } x = ( c * e - b * f ) / ( a * e - d * b ) . to_f . round ( 3 ) y = ( c * d - a * f ) / ( b * d - a * e ) . to_f . round ( 3 ) if x . zero? then x = 0 end if y . zero? then y = 0 end puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while str = gets a , b , c , d , e , f = str . split ( ' ' ) . map ( & :to_f ) x = ( b * f - e * c ) / ( b * d - e * a ) y = ( c - a * x ) / b x = 0.0 if x . round ( 3 ) == - 0.000 y = 0.0 if y . round ( 3 ) == - 0.000 puts sprintf ( ' %.3f %.3f ' , x . round ( 3 ) , y . round ( 3 ) ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split ( \" \" ) . map { | i | i . to_f } x = ( ( c * e - f * b ) / ( a * e - b * d ) ) y = ( ( c * d - a * f ) / ( b * d - a * e ) ) puts \" %.3f %.3f \" % [ x + 0 , y + 0 ] end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . chomp . split . map ( & :to_f ) detA = a * e - b * d detA1 = c * e - b * f detA2 = a * f - c * d printf ( \" %.3f %.3f \\n \" , detA1 / detA + 0 , detA2 / detA + 0 ) end",
    "label": 5
  },
  {
    "code": "if __FILE__ == $0 while line = gets a , b , c , d , e , f = line . chomp! . split ( \" \" ) . map ( & :to_i ) y = ( ( a . to_f * f ) - ( c . to_f * d ) ) / ( ( a . to_f * e ) - ( b . to_f * d ) ) x = ( c . to_f / a ) - ( ( b . to_f / a ) * y ) print ( format ( \" %.3f \" , x ) , \" \" , format ( \" %.3f \" , y ) , \" \\n \" ) end end",
    "label": 5
  },
  {
    "code": "readlines . each { | data | a , b , c , d , e , f = data . split . map ( & :to_f ) x = ( c * e - f * b ) / ( a * e - b * d ) y = ( f * a - c * d ) / ( a * e - b * d ) puts sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) }",
    "label": 5
  },
  {
    "code": "while data = gets a , b , c , d , e , f = data . split . map ( & :to_f ) x = ( c * e - f * b ) / ( a * e - b * d ) y = ( f * a - c * d ) / ( a * e - b * d ) puts sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) end",
    "label": 5
  },
  {
    "code": "while line = gets line = line . split ( \" \" ) a = line [ 0 ] . to_f b = line [ 1 ] . to_f c = line [ 2 ] . to_f d = line [ 3 ] . to_f e = line [ 4 ] . to_f f = line [ 5 ] . to_f y = ( a * f - c * d ) / ( a * e - b * d ) x = ( c - b * y ) / a puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) det = ( a * e - b * d ) / 1000.0 printf \" %.3f %.3f \\n \" , ( ( c * e - b * f ) / det ) . round / 1000.0 , ( ( a * f - c * d ) / det ) . round / 1000.0 end",
    "label": 5
  },
  {
    "code": "while i = gets do a , b , c , d , e , f = i . split . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) + 0.000 y = ( f * a - c * d ) / ( a * e - d * b ) + 0.000 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "list = [ ] while line = STDIN . gets a , b , c , d , e , f = line . chomp! . split . map! ( & :to_f ) x = ( c * e - f * b ) / ( a * e - d * b ) y = ( c * d - f * a ) / ( b * d - e * a ) puts \" end",
    "label": 5
  },
  {
    "code": "while str = gets do a , b , c , d , e , f = str . chomp . split ( \" \" ) . map ( & :to_f ) y = ( c * d - a * f ) / ( b * d - a * e ) x = ( c - b * y ) / a puts sprintf ( \" %.3f \" , x . round ( 3 ) ) + \" \" + sprintf ( \" %.3f \" , y . round ( 3 ) ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . chomp! . split ( \" \" ) . map ( & :to_f ) x = ( b * f - c * e ) / ( b * d - a * e ) . round ( 3 ) + 0 y = ( a * f - c * d ) / ( a * e - b * d ) . round ( 3 ) + 0 puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "require \" matrix \" $< . map { | a | a . split . map ( & :to_i ) } . each do | a | Matrix [ [ a [ 0 ] , a [ 1 ] ] , [ a [ 3 ] , a [ 4 ] ] ] . lup . solve ( [ a [ 2 ] , a [ 5 ] ] ) . map { | b | b . to_f . round ( 3 ) } . tap { | c | print format ( \" %.3f %.3f \\n \" , c [ 0 ] , c [ 1 ] ) } end",
    "label": 5
  },
  {
    "code": "while gets a , b , c , d , e , f = $_ . split . map ( & :to_f ) x = a * e - b * d printf \" %.3f %.3f \\n \" , ( e * c - b * f ) / x + 0 , ( a * f - d * c ) / x + 0 end",
    "label": 5
  },
  {
    "code": "while s = gets do a , b , c , d , e , f = s . split ( ) . map ( & :to_f ) z = a * e - b * d x = ( c * e - f * b ) / z + 0.000 y = ( f * a - c * d ) / z + 0.000 puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while line = gets ( a , b , c , d , e , f ) = line . split ( ) . map ( & :to_f ) z = a * e - b * d x = ( c * e - b * f ) == 0 ? 0.0 : ( c * e - b * f ) / z y = ( a * f - c * d ) == 0 ? 0.0 : ( a * f - c * d ) / z puts sprintf ( \" %.3f %.3f \" , x . to_s , y . to_s ) end",
    "label": 5
  },
  {
    "code": "while line = gets ( a , b , c , d , e , f ) = line . split ( ) . map ( & :to_f ) z = a * e - b * d x = ( c * e - b * f ) == 0 ? 0.0 : ( c * e - b * f ) / z y = ( a * f - c * d ) == 0 ? 0.0 : ( a * f - c * d ) / z puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while STDIN . gets do a , b , c , d , e , f = $_ . split ( \" \" ) . map ( & :to_i ) / / ratio = d.to_f /a aa = a * ratio bb = b * ratio cc = c * ratio coe_y = bb - e right = cc - f y = right / coe_y / / coe_x = a right = c - b*y x = right / coe_x puts \" %.3f %.3f \" % [ x , y ] end",
    "label": 5
  },
  {
    "code": "if __FILE__ == $0 while line = gets args = line . split ( \" \" ) . map { | e | e . to_f } a = args [ 0 ] b = args [ 1 ] c = args [ 2 ] d = args [ 3 ] e = args [ 4 ] f = args [ 5 ] y = ( a * f - d * c ) / ( a * e - d * b ) x = ( c - b * y ) / a puts \" end end",
    "label": 5
  },
  {
    "code": "num = [ ] while a = gets num = a . split ( nil ) num = num . map { | n | n . to_f } x = ( ( num [ 2 ] * num [ 4 ] ) - ( num [ 5 ] * num [ 1 ] ) ) / ( ( num [ 0 ] * num [ 4 ] ) - ( num [ 3 ] * num [ 1 ] ) ) y = ( ( num [ 2 ] * num [ 3 ] ) - ( num [ 5 ] * num [ 0 ] ) ) / ( ( num [ 1 ] * num [ 3 ] ) - ( num [ 4 ] * num [ 0 ] ) ) puts sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . split . map ( & :to_i ) ans1 = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 ans2 = ( ( a * f - d * c ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 printf ( \" %.3f %.3f \\n \" , ans1 , ans2 ) end",
    "label": 5
  },
  {
    "code": "while line = gets do -> ( l ) { a = l [ 0 ] b = l [ 1 ] c = l [ 2 ] d = l [ 3 ] e = l [ 4 ] f = l [ 5 ] delta = 1.0 / ( a * e - b * d ) ; x = ( e * c - b * f ) * delta y = ( a * f - d * c ) * delta printf \" %.3f %.3f \\n \" , x + 1e-9 , y + 1e-9 } . call line . split ( ' ' ) . map ( & :to_f ) end",
    "label": 5
  },
  {
    "code": "def getX ( a , b , c , d , e , f ) denominator = a * e - b * d numerator = c * e - b * f x = numerator / denominator x = 0.0 if x == - 0.0 return x end def getY ( a , b , c , d , e , f ) denominator = b * d - a * e numerator = c * d - a * f y = numerator / denominator y = 0.0 if y == - 0.0 return y end f = Array . new ( 6 ) while input = gets value = input . split ( / \\s * \\s * / ) for i in 0 ... value . size f [ i ] = value [ i ] . to_f end puts sprintf ( \" %.3f %.3f \" , getX ( f [ 0 ] , f [ 1 ] , f [ 2 ] , f [ 3 ] , f [ 4 ] , f [ 5 ] ) , getY ( f [ 0 ] , f [ 1 ] , f [ 2 ] , f [ 3 ] , f [ 4 ] , f [ 5 ] ) ) end",
    "label": 5
  },
  {
    "code": "while gets a , b , c , d , e , f = $_ . split . map ( & :to_f ) x = a * e - b * d printf \" %.3f %.3f \\n \" , ( e * c - b * f ) / x + 0 , ( a * f - d * c ) / x + 0 end",
    "label": 5
  },
  {
    "code": "while gets a , b , c , d , e , f = $_ . split . map ( & :to_f ) x = a * e - b * d printf \" %.3f %.3f \\n \" , ( e * c - b * f ) / x + 0 , ( a * f - d * c ) / x + 0 end",
    "label": 5
  },
  {
    "code": "readlines . map ( & :split ) . each do | l | a , b , c , d , e , f = l . map ( & :to_f ) puts sprintf ( \" %.3f %.3f \" , ( c * e - f * b ) / ( a * e - d * b ) + 0.000 , ( c * d - f * a ) / ( b * d - a * e ) + 0.000 ) end",
    "label": 5
  },
  {
    "code": "while line = STDIN . gets if ( / exit / =~ line ) break end temp = line . scan ( / \\d +|- \\d + / ) a = temp [ 0 ] . to_f b = temp [ 1 ] . to_f c = temp [ 2 ] . to_f d = temp [ 3 ] . to_f e = temp [ 4 ] . to_f f = temp [ 5 ] . to_f x = ( c * e - b * f ) / ( a * e - b * d ) y = ( c * d - f * a ) / ( b * d - e * a ) if x == - 0 then x = 0 end if y == 0 then y = 0 end print sprintf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "puts $< . map { | z | a , b , c , d , e , f = z . split . map ( & :to_f ) ; x = a * e - b * d ; \" %.3f %.3f \" %[ (e*c-b*f)/x+0,(a*f-d*c)/x+0 ] }",
    "label": 5
  },
  {
    "code": "require \" matrix \" arr = Array . new while line = gets arr << line end arr . each do | i | c = i . split ( \" \" ) c . map! { | i | i . to_f } a = Matrix [ [ c [ 0 ] , c [ 1 ] ] , [ c [ 3 ] , c [ 4 ] ] ] b = Vector [ c [ 2 ] , c [ 5 ] ] res = a . inverse * b printf ( \" %.3f %.3f \\n \" , res [ 0 ] , res [ 1 ] ) ; end",
    "label": 5
  },
  {
    "code": "require ' matrix ' def solve ( line ) a = Matrix [ [ line [ 0 ] . to_f , line [ 1 ] . to_f ] , [ line [ 3 ] . to_f , line [ 4 ] . to_f ] ] b = Vector [ line [ 2 ] . to_f , line [ 5 ] . to_f ] s = a . inv * b return s . to_a end inputs = [ ] while ( line = gets ) != nil inputs . push ( line . split ( ) ) end for i in inputs s = solve ( i ) puts printf ( \" % end",
    "label": 5
  },
  {
    "code": "while gets do a , b , c , d , e , f = $_ . split ( / \\s / ) . map ( & :to_f ) z = ( b * d - a * e ) y = ( c * d - a * f ) / z + 0.000 x = ( b * f - c * e ) / z + 0.000 puts sprintf ( \" %.3f \\s %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while gets do a , b , c , d , e , f = $_ . split ( / \\s / ) . map ( & :to_f ) z = ( b * d - a * e ) y = ( c * d - a * f ) / z + 0.000 x = ( b * f - c * e ) / z + 0.000 puts sprintf ( \" %.3f \\s %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "STDIN . each { | l | a , b , c , d , e , f = l . split . map ( & :to_f ) ; s = a * e - b * d ; printf \" %.3f %.3f \\n \" , 0 + e * c / s - b * f / s , 0 + a * f / s - d * c / s }",
    "label": 5
  },
  {
    "code": "$< . map { | l | a , b , c , d , e , f = l . split . map ( & :to_f ) ; s = a * e - b * d ; printf \" %.3f %.3f \\n \" , 0 + e * c / s - b * f / s , 0 + a * f / s - d * c / s }",
    "label": 5
  },
  {
    "code": "while gets do a , b , c , d , e , f = $_ . split ( / \\s / ) . map ( & :to_f ) z = b * d - a * e x = ( b * f - c * e ) / z y = ( c * d - a * f ) / z x = 0.0 if x == 0 y = 0.0 if y == 0 puts sprintf ( \" %.3f \\s %.3f \" , x . round ( 3 ) , y . round ( 3 ) ) end",
    "label": 5
  },
  {
    "code": "while gets do a , b , c , d , e , f = $_ . split ( / \\s / ) . map ( & :to_f ) z = b * d - a * e x = ( b * f - c * e ) / z + 0.000 y = ( c * d - a * f ) / z + 0.000 puts sprintf ( \" %.3f \\s %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "a = [ ] while line = gets c = line . chomp . split . map ( & :to_f ) a [ 0 ] = ( ( c [ 2 ] * c [ 4 ] - c [ 1 ] * c [ 5 ] ) / ( c [ 0 ] * c [ 4 ] - c [ 1 ] * c [ 3 ] ) ) . round ( 3 ) a [ 1 ] = ( ( c [ 2 ] * c [ 3 ] - c [ 0 ] * c [ 5 ] ) / ( c [ 1 ] * c [ 3 ] - c [ 0 ] * c [ 4 ] ) ) . round ( 3 ) a . map! { | v | v == 0 ? 0 : v } puts sprintf ( \" %.3f %.3f \" , a [ 0 ] , a [ 1 ] ) end",
    "label": 5
  },
  {
    "code": "while data = gets a = data . chomp . split 6 . times do | i | a [ i ] = a [ i ] . to_f end d = a [ 0 ] * a [ 4 ] - a [ 1 ] * a [ 3 ] x = ( ( a [ 2 ] * a [ 4 ] - a [ 1 ] * a [ 5 ] ) * 1000 ) . round / d / 1000 y = ( ( - a [ 2 ] * a [ 3 ] + a [ 0 ] * a [ 5 ] ) * 1000 ) . round / d / 1000 x = 0 if - 0.001 < x && x < 0.001 y = 0 if - 0.001 < y && y < 0.001 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while ( input = STDIN . gets ) != nil do if input == \" \\n \" break end data = [ 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 ] input = input . split ( \" \" ) for i in 0 .. 5 data [ i ] = input [ i ] . to_f end num = ( data [ 0 ] * data [ 4 ] ) - ( data [ 1 ] * data [ 3 ] ) x = ( data [ 4 ] * data [ 2 ] + ( data [ 1 ] * - 1 ) * data [ 5 ] ) / num + 0 y = ( ( data [ 3 ] * - 1 ) * data [ 2 ] + data [ 0 ] * data [ 5 ] ) / num + 0 print sprintf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while true line = gets break if line == nil a , b , c , d , e , f = line . split . map { | x | x . to_f } x = ( c * e - b * f ) / ( a * e - b * d ) y = ( a * f - d * c ) / ( a * e - b * d ) x = 0.0 if x . zero? y = 0.0 if y . zero? puts sprintf ( \" %.3f %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while tmp = gets a , b , c , d , e , f = tmp . split . map ( & :to_f ) puts sprintf ( \" %.3f %.3f \" , 1e-9 + 1 . * ( c * e - b * f ) / ( a * e - b * d ) , 1e-9 + 1 . * ( a * f - c * d ) / ( a * e - b * d ) ) end",
    "label": 5
  },
  {
    "code": "while ( input = STDIN . gets ) != nil do if input == \" \\n \" break end data = [ 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 ] input = input . split ( \" \" ) for i in 0 .. 5 data [ i ] = input [ i ] . to_f end num = ( data [ 0 ] * data [ 4 ] ) - ( data [ 1 ] * data [ 3 ] ) x = ( data [ 4 ] * data [ 2 ] + ( data [ 1 ] * - 1 ) * data [ 5 ] ) / num + 0 y = ( ( data [ 3 ] * - 1 ) * data [ 2 ] + data [ 0 ] * data [ 5 ] ) / num + 0 print sprintf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "def solve ( eq ) m = [ ] m << eq [ 0 .. 2 ] m << eq [ 3 .. 5 ] r0 = m [ 0 ] [ 0 ] m [ 0 ] . map! { | x | x / r0 } r1 = - m [ 1 ] [ 0 ] m [ 1 ] . map! . with_index { | x , i | x + r1 * m [ 0 ] [ i ] } r1 = m [ 1 ] [ 1 ] m [ 1 ] . map! { | x | x / r1 } r0 = - m [ 0 ] [ 1 ] m [ 0 ] . map! . with_index { | x , i | x + r0 * m [ 1 ] [ i ] } [ m [ 0 ] [ 2 ] , m [ 1 ] [ 2 ] ] end eqs = ARGF . each_line . map { | line | line . split ( \" \" ) . map { | v | v . to_f } } eqs . each do | eq | solution = solve ( eq ) puts solution . map { | x | \" %.3f \" . % ( x ) } . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "while ( line = gets ) do a , b , c , d , e , f = line . split ( ) . map ( & :to_f ) c /= a b /= a a /= a f -= ( c * d ) e -= ( b * d ) d -= ( a * d ) f /= e d /= e e /= e c -= ( f * b ) a -= ( d * b ) b -= ( e * b ) c = ( c * ( 10 ** 3 ) ) . round c = ( c * ( 10 ** - 3 ) ) f = ( f * ( 10 ** 3 ) ) . round f = ( f * ( 10 ** - 3 ) ) printf ( \" %.3f %.3f \\n \" , c + 0.0 , f + 0.0 ) end",
    "label": 5
  },
  {
    "code": "def main while nums = gets nums = nums . chomp . split ( / \\s / ) . collect { | x | x . to_i } x , y = solves nums puts \" %.3f %.3f \" % [ x , y ] end end def solves nums a , b , c , d , e , f = nums x = ( 1.0 * c * e - f * b ) / ( a * e - d * b ) y = ( 1.0 * c * d - f * a ) / ( b * d - a * e ) x = 0.000 if x . abs <= 0.000001 y = 0.000 if y . abs <= 0.000001 [ x , y ] end main",
    "label": 5
  },
  {
    "code": "while n = gets s = n . split ( \" \" ) . map ( & :to_f ) x = ( s [ 2 ] * s [ 4 ] - s [ 1 ] * s [ 5 ] ) / ( s [ 0 ] * s [ 4 ] - s [ 1 ] * s [ 3 ] ) y = ( s [ 2 ] - s [ 0 ] * x ) / s [ 1 ] x = 0.0 if x . zero? y = 0.0 if y . zero? printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while gets do a , b , c , d , e , f = $_ . split ( / \\s / ) . map ( & :to_f ) z = ( b * d - a * e ) y = ( c * d - a * f ) / z + 0.000 x = ( b * f - c * e ) / z + 0.000 puts sprintf ( \" %.3f \\s %.3f \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while get = gets do a , b , c , d , e , f = get . chomp . split ( \" \" ) . map ( & :to_i ) x = ( ( c * e - b * f ) * 1.0 / ( a * e - b * d ) * 1000.0 ) . round / 1000.0 y = ( ( f * a - c * d ) * 1.0 / ( a * e - d * b ) * 1000.0 ) . round / 1000.0 puts sprintf ( \" %.3f \" , x ) + sprintf ( \" %.3f \" , y ) end",
    "label": 5
  },
  {
    "code": "$stdin . each_line do | line | a , b , c , d , e , f = line . split . map { | i | i . to_f } x = ( c * e - f * b ) / ( a * e - d * b ) . round ( 4 ) x = ( x == 0 ) ? 0 : x y = ( a * f - d * c ) / ( a * e - d * b ) . round ( 4 ) y = ( y == 0 ) ? 0 : y printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "def calc_simultaneeous ( args ) x = y = 0 args . each_cons ( 6 ) do | a , b , c , d , e , f | y = ( f - d * c / a ) / ( e - ( d * b / a ) ) x = ( c - b * y ) / a end printf \" %.3f %.3f \" , x , y end while input = gets puts calc_simultaneeous ( input . chomp . split ( ' ' ) . map! { | elm | elm . to_f } ) end",
    "label": 5
  },
  {
    "code": "def calc_simultaneeous ( args ) x = y = 0 args . each_cons ( 6 ) do | a , b , c , d , e , f | y = ( f - d * c / a ) / ( e - ( d * b / a ) ) x = ( c - b * y ) / a end \" %.3f %.3f \" %[ x, y ] end while input = gets puts calc_simultaneeous ( input . chomp . split ( ' ' ) . map! { | elm | elm . to_f } ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b , c , d , e , f = line . split . map ( & :to_f ) x = Rational ( b * f - c * e , b * d - a * e ) y = Rational ( a * f - d * c , a * e - b * d ) printf \" %.3f %.3f \\n \" , x , y end",
    "label": 5
  },
  {
    "code": "require ' mathn ' STDIN . each_line do | line | m = line . split . map ( & :to_i ) . each_slice ( 3 ) . to_a m . reverse! if m [ 0 ] [ 0 ] . zero? a = m [ 0 ] [ 0 ] d = m [ 1 ] [ 0 ] 1 . upto ( 2 ) do | i | m [ 0 ] [ i ] /= a m [ 1 ] [ i ] -= d * m [ 0 ] [ i ] end y = m [ 1 ] [ 2 ] / m [ 1 ] [ 1 ] x = m [ 0 ] [ 2 ] - m [ 0 ] [ 1 ] * y puts \" %.3f %.3f \" % [ x , y ] end",
    "label": 5
  },
  {
    "code": "while gets a , b , c , d , e , f = $_ . chomp . split . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) y = ( c - a * x ) / b puts \" %.3f %.3f \" % [ x . round ( 3 ) . zero? ? 0 : x , y . round ( 3 ) . zero? ? 0 : y ] end",
    "label": 5
  },
  {
    "code": "while gets a , b , c , d , e , f = $_ . chomp . split . map ( & :to_f ) x = ( c * e - b * f ) / ( a * e - b * d ) y = ( c - a * x ) / b puts sprintf ( \" %.3f %.3f \" , x . zero? ? 0 : x , y . zero? ? 0 : y ) end",
    "label": 5
  },
  {
    "code": "while aaa = gets array = aaa . chomp . split ( \" \\s \" ) array . map! { | item | item . to_f } a = array [ 0 ] ; b = array [ 1 ] ; c = array [ 2 ] d = array [ 3 ] ; e = array [ 4 ] ; f = array [ 5 ] y = ( d * c - a * f ) / ( d * b - a * e ) x = ( c - b * y ) / a print sprintf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "input = gets ( nil ) input . split ( \" \\n \" ) . each do | l | a , b , c , d , e , f = l . split ( \" \" ) . map ( & :to_f ) x = ( ( c * e - b * f ) / ( a * e - d * b ) ) . round ( 3 ) x = 0.000 if x . zero? y = ( ( c * d - a * f ) / ( b * d - a * e ) ) . round ( 3 ) y = 0.000 if y . zero? printf \" %.3f %.3f \\n \" , x , y end",
    "label": 5
  },
  {
    "code": "while nums = gets a , b , c , d , e , f = nums . chomp . split . map ( & :to_f ) x = ( ( a * e - b * d ) . zero? || ( c * e - b * f ) . zero? ) ? 0 : ( c * e - b * f ) / ( a * e - b * d ) y = ( ( - a * x + c ) . zero? || b . zero? ) ? 0 : ( - a * x + c ) / b puts \" end",
    "label": 5
  },
  {
    "code": "while str = gets a , b , c , d , e , f = str . split ( ' ' ) . map ( & :to_f ) y = ( a * f - d * c ) / ( a * e - d * b ) x = ( c - b * y ) / a puts sprintf ( ' %.03f %.03f ' , x , y ) end",
    "label": 5
  },
  {
    "code": "require ' matrix ' while line = ARGF . gets do a1 , b1 , z1 , a2 , b2 , z2 = line . split . map ( & :to_i ) m1 = Matrix . column_vector [ z1 , z2 ] m2 = Matrix [ [ a1 , b1 ] , [ a2 , b2 ] ] result = ( m2 ** - 1 ) * m1 puts result . map { | e | \" %5.3f \" % e } . column ( 0 ) . to_a . join ( \" \\s \" ) end",
    "label": 5
  },
  {
    "code": "EPS = 1.0e-9 while input = gets do a , b , c , d , e , f = input . split ( \" \" ) . collect do | x | x . to_f end num1 = ( c * e - b * f ) / ( a * e - b * d ) num2 = ( a * f - c * d ) / ( a * e - b * d ) print \" %.3f \" % ( num1 + EPS ) , \" \" , \" %.3f \" % ( num2 + EPS ) , \" \\n \" end",
    "label": 5
  },
  {
    "code": "def f ( line ) a , b , c , d , e , f = line . split ( \" \" ) . map ( & :to_f ) y = ( a * f - d * c ) / ( a * e - d * b ) x = ( c - b * y ) / a sprintf ( \" %.3f %.3f \" , x , y ) end while line = gets puts f ( line ) end",
    "label": 5
  },
  {
    "code": "STDIN . each do | value | a , b , c , d , e , f = value . split . map ( & :to_i ) x = ( ( e * c - b * f ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 y = ( ( a * f - d * c ) * 1.0 / ( a * e - b * d ) * 1000 ) . round / 1000.0 puts sprintf ( \" %.3f %.3f \" , x . to_f , y . to_f ) end",
    "label": 5
  },
  {
    "code": "while data = gets do if data == nil break end nums = data . split ( ) . map ( & :to_f ) a = 1 / ( nums [ 0 ] * nums [ 4 ] - nums [ 1 ] * nums [ 3 ] ) x = ( nums [ 4 ] * nums [ 2 ] - nums [ 1 ] * nums [ 5 ] ) * a y = ( nums [ 0 ] * nums [ 5 ] - nums [ 3 ] * nums [ 2 ] ) * a puts sprintf ( \" %.3f %.3f \" , x + 0.0 , y + 0.0 ) end",
    "label": 5
  },
  {
    "code": "while ( line = gets ) a , b , c , d , e , f = line . chop . split ( / \\s + / ) . map { | s | s . to_f } if ( a != 0 ) b /= a c /= a e -= d * b f -= d * c y = f / e x = c - b * y else y = c / b x = ( f - e * y ) / d end printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while set = gets ( ) if ( set . nil? or set == \" \\n \" or set == \" \\n \\r \" ) then break end a , b , c , d , e , f = set . split ( ) . map { | x | x . to_f } y = ( d * c - a * f ) / ( d * b - a * e ) x = ( c - b * y ) / a printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "while input = gets a = input . split . map ( & :to_i ) i = ( a [ 1 ] * a [ 5 ] - a [ 4 ] * a [ 2 ] ) / ( a [ 3 ] * a [ 1 ] - a [ 0 ] * a [ 4 ] ) . to_f + 0.000 j = ( a [ 0 ] * a [ 5 ] - a [ 2 ] * a [ 3 ] ) / ( a [ 0 ] * a [ 4 ] - a [ 1 ] * a [ 3 ] ) . to_f + 0.000 print sprintf ( \" %.3f \" , i ) print \" \\s \" puts sprintf ( \" %.3f \" , j ) end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b , c , d , e , f = line . split . map ( & :to_f ) det = a * e - b * d a1 , b1 , d1 , e1 = e / det , - b / det , - d / det , a / det x , y = a1 * c + b1 * f , d1 * c + e1 * f printf \" %.3f %.3f \\n \" , x , y end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b , c , d , e , f = line . chop . split ( / \\s + / ) . map { | s | s . to_f } x = ( e * c - b * f ) / ( a * e - b * d ) + 0.0 y = ( d * c - a * f ) / ( d * b - a * e ) + 0.0 printf ( \" %.3f %.3f \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "require \" matrix \" while input = gets input = input . chomp . split . map ( & :to_i ) a = Matrix [ [ input [ 0 ] , input [ 1 ] ] , [ input [ 3 ] , input [ 4 ] ] ] b = Vector [ input [ 2 ] , input [ 5 ] ] puts ( a . inv * b ) . map { | i | \" % end",
    "label": 5
  },
  {
    "code": "$< . readlines . each do | l | a , b , c , d , e , f = l . split . map ( & :to_i ) r = a * e - b * d x = ( c * e - b * f ) / r . to_f y = ( a * f - c * d ) / r . to_f x = x . abs if x == 0 y = y . abs if y == 0 printf ( \" %.3f %.3f \\n \" , x . round ( 4 ) , y . round ( 4 ) ) end",
    "label": 5
  },
  {
    "code": "n = gets until n . nil? nn = n . split ( \" \" ) . map { | k | k . to_f } a = nn [ 0 ] b = nn [ 1 ] c = nn [ 2 ] d = nn [ 3 ] e = nn [ 4 ] f = nn [ 5 ] x = 0 y = 0 if c * e - b * f == 0 x = 0 else x = ( ( c * e - b * f ) / ( a * e - b * d ) ) . round ( 3 ) end if c * d - a * f == 0 y = 0 else y = ( ( c * d - a * f ) / ( b * d - a * e ) ) . round ( 3 ) end puts \" n = gets end",
    "label": 5
  },
  {
    "code": "answer = Array . new while linebuf = $stdin . gets line = linebuf . split ( / \\s / ) line . map! { | n | n . to_f } a = line [ 0 ] ; b = line [ 1 ] ; c = line [ 2 ] d = line [ 3 ] ; e = line [ 4 ] ; f = line [ 5 ] di = a * e - b * d x1 = e * c - b * f x2 = f * a - c * d u1 = x1 / di u2 = x2 / di answer << [ u1 , u2 ] end answer . each { | n | s1 = sprintf ( \" %.03f \" , n [ 0 ] ) s1 = \" 0.000 \" if s1 == \" -0.000 \" s2 = sprintf ( \" %.03f \" , n [ 1 ] ) s2 = \" 0.000 \" if s1 == \" -0.000 \" printf ( \" %s %s \\n \" , s1 , s2 ) }",
    "label": 5
  },
  {
    "code": "def solve2 ns a , b , c , d , e , f = ns det = a * e - b * d x = ( c * e / det ) - ( b * f / det ) y = ( a * f / det ) - ( c * d / det ) [ x , y ] end while ln = gets ns = ln . split . map ( & :to_f ) puts \" %.3f %.3f \" % solve2 ( ns ) end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if a % b == 0 return b else return gcd ( b , a % b ) end end while gets != nil a , b = $_ . split . map ( & :to_i ) . sort c = gcd ( a , b ) d = a * b / c puts c . to_s + \" \" + d . to_s end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if a % b == 0 return b else return gcd ( b , a % b ) end end while gets != nil a , b = $_ . split . map ( & :to_i ) . sort c = gcd ( a , b ) d = a * b / c puts c . to_s + \" \" + d . to_s end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if ( a < b ) tmp = a ; a = b ; b = tmp end while ( ( c = a % b ) > 0 ) a = b b = c end return b end while ( line = gets ) a , b = line . chop . split ( \" \" ) . map { | s | s . to_i } g = gcd ( a , b ) l = a * b / g printf ( \" %d %d \\n \" , g , l ) end",
    "label": 5
  },
  {
    "code": "while input = gets input = input . chomp . split ( \" \" ) a = input [ 0 ] . to_i b = input [ 1 ] . to_i print ( a . gcd ( b ) , \" \" , a . lcm ( b ) ) puts ( ) end",
    "label": 5
  },
  {
    "code": "def gcd ( m , n ) if ( ( 0 == m ) || ( 0 == n ) ) return 0 ; end while m != n if m > n m = m - n else n = n - m end end return m end def lcm ( m , n ) if ( 0 == m ) || ( 0 == n ) return 0 end return ( ( m / gcd ( m , n ) ) * n ) end while line = gets a , b = line . split . map ( & :to_i ) printf ( \" %d %d \\n \" , gcd ( a , b ) , lcm ( a , b ) ) end",
    "label": 5
  },
  {
    "code": "while num = gets a , b = num . split . map ( & :to_i ) num1 = a . gcd ( b ) num2 = a . lcm ( b ) puts \" end",
    "label": 5
  },
  {
    "code": "def find_the_LCM array array . length . times do | i | array [ i ] = array [ i ] . to_i end i = 1 while true if array [ 0 ] * i % array [ 1 ] == 0 break end i += 1 end return array [ 0 ] * i end def find_the_GCD array array . length . times do | i | array [ i ] = array [ i ] . to_i end x , y , r = array [ 0 ] , array [ 1 ] , array [ 0 ] % array [ 1 ] until r == 0 x = y y = r r = x % y end return y end numbers = [ ] while gets numbers . push $_ . split end i = 0 while i < numbers . length print \" i += 1 end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split ( \" \" ) . map ( & :to_i ) puts sprintf ( \" %d %d \" , a . gcd ( b ) , a . lcm ( b ) ) end",
    "label": 5
  },
  {
    "code": "while data = gets a , b = data . split ( \" \" ) puts \" end",
    "label": 5
  },
  {
    "code": "def lcm ( a , b ) i = 1 while true if ( a * i ) % b == 0 break end i += 1 end return a * i end def gcd ( a , b ) if a > b x , y = a , b else x , y = b , a end r = x % y until r == 0 x = y y = r r = x % y end return y end numbers = [ ] while gets data = $_ . split 2 . times do | i | data [ i ] = data [ i ] . to_i end numbers . push data end i = 0 while i < numbers . length puts \" i += 1 end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if a % b == 0 return b else return gcd ( b , a % b ) end end while ( str = gets ) a , b = str . split ( \" \" ) . map ( & :to_i ) puts [ gcd ( a , b ) , ( a * b ) / gcd ( a , b ) ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "$< . map { | l | a , b = l . split . map & :to_i puts a . gcdlcm ( b ) * \" \" }",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) if ( x . to_i == 0 || y . to_i == 0 ) return 0 end while ( ( r = x % y ) != 0 ) x = y y = r end return y end def lcd ( x , y ) if ( x . to_i == 0 || y . to_i == 0 ) return 0 end return x * y / gcd ( x , y ) end while line = gets num = line . split ( \" \" ) puts gcd ( num [ 0 ] . to_i , num [ 1 ] . to_i ) . to_s + \" \" + lcd ( num [ 0 ] . to_i , num [ 1 ] . to_i ) . to_s end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if b == 0 then a else gcd b , a % b end end while str = gets do arr = str . split ( nil ) . map { | s | s . to_i } g = gcd arr [ 0 ] , arr [ 1 ] l = arr [ 0 ] * arr [ 1 ] / g print g , \" \" , l , \" \\n \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if b > a if a % b == 0 b else gcd ( b , a % b ) end end def lcm ( a , b ) a * b / gcd ( a , b ) end while line = gets break if line == \" \\n \" a , b = line . split puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if b > a a % b == 0 ? b : gcd ( b , a % b ) end def lcm ( a , b ) a * b / gcd ( a , b ) end while line = gets break if line == \" \\n \" a , b = line . split puts \" end",
    "label": 5
  },
  {
    "code": "def g ( a , b ) a , b = b , a if b > a a % b == 0 ? b : g ( b , a % b ) end def l ( a , b ) a * b / g ( a , b ) end while s = gets ; a , b = s . split ; puts \"",
    "label": 5
  },
  {
    "code": "$_ = eval ( $_ . sub ( \" \" , \" .gcdlcm \" ) ) * \" \"",
    "label": 5
  },
  {
    "code": "puts $< . map { | l | eval ( l . sub \" \" , \" .gcdlcm \" ) * \" \" }",
    "label": 5
  },
  {
    "code": "while input = gets do a , b = input . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "module Input def numread ( ) s = gets ( ) . split ( ) p = Array . new ( ) for i in 0 ... s . size ( ) p [ i ] = s [ i ] . to_i ( ) end return p end module_function : numread end include Input def gcd ( x , y ) w = y % x if ( w == 0 ) return x else return gcd ( w , x ) end end loop { if ( STDIN . eof ( ) ) break end w = numread ( ) w . sort! ( ) s = gcd ( w [ 0 ] , w [ 1 ] ) l = w [ 0 ] * w [ 1 ] / s print ( s , \" \" , l , \" \\n \" ) }",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) return a if b . zero? gcd ( b , a . modulo ( b ) ) end def lcm ( a , b ) a * b / gcd ( a , b ) end loop do s = gets break if s . nil? a , b = s . chomp . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) while ( r = x % y ) != 0 x = y y = r end return y end def lcm ( x , y ) x * y / gcd ( x , y ) end while v = gets m , n = v . split . map ( & :to_i ) printf ( \" %d %d \\n \" , gcd ( m , n ) , lcm ( m , n ) ) end",
    "label": 5
  },
  {
    "code": "puts \"",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) a_times_b = a * b gcd = 1 loop do c = a % b if c == 0 gcd = b break else a , b = b , c end end lcm = a_times_b / gcd puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "while input = gets input = input . chomp . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while gets a , b = $_ . chomp . split ( nil ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def eucly ( arr ) ans = arr [ 0 ] % arr [ 1 ] if ans == 0 return arr [ 1 ] else eucly ( [ arr [ 1 ] , ans ] ) end end while line = gets num = line . split ( ' ' ) . map ( & :to_i ) arr = [ ] if num [ 0 ] < num [ 1 ] arr [ 0 ] , arr [ 1 ] = num [ 1 ] , num [ 0 ] else arr = num end gcd = eucly ( arr ) lcm = num [ 0 ] * num [ 1 ] / gcd print gcd . to_s + \" \" + lcm . to_s + \" \\n \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) while ( b != 0 ) do r = a % b ; a = b ; b = r ; end return a ; end until $stdin . eof? a , b = gets . split ( ' ' ) . map ( & :to_i ) gcd = gcd ( a , b ) lcm = ( a * b ) / gcd puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) r = x % y return y if r == 0 gcd ( y , r ) end def lcm ( x , y , gcd ) return ( x * y ) / gcd end array = [ ] while line = gets do x , y = line . split . map ( & :to_i ) gcd = gcd ( x , y ) lcm = lcm ( x , y , gcd ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a % b while b > 0 a end def lcm ( a , b ) ( a * b / gcd ( a , b ) ) . to_i end while line = gets a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "$< . each do | l | a , b = l . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( m , n ) if m < n gcd ( n , m ) elsif n == 0 m else gcd ( n , m % n ) end end while gets x , y = $_ . split . map ( & :to_i ) g = gcd ( x , y ) puts [ g , x * y / g ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "while data = gets a , b = data . chomp . split a , b = a . to_i , b . to_i m = a * b r = a % b while r > 0 a = b b = r r = a % b end print b , \" \" , m / b , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while data = gets a , b = data . chomp . split a , b = a . to_i , b . to_i m = a * b r = a % b while r > 0 a = b b = r r = a % b end print b , \" \" , m / b , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while n = gets a , b = n . chomp . split a , b = a . to_i , b . to_i m = a * b r = a % b while r > 0 a = b b = r r = a % b end print b , \" \" , m / b , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while data = gets a , b = data . chomp . split a , b = a . to_i , b . to_i m = a * b r = a % b while r > 0 a = b b = r r = a % b end puts b . to_s + ' ' + ( m / b ) . to_s end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) tmp = [ ] if a > b tmp << a << b << 0 else tmp << b << a << 0 end n = 0 while true i = 1 while true tmp [ ( n + 2 ) % 3 ] = tmp [ n % 3 ] - tmp [ ( n + 1 ) % 3 ] * i if tmp [ ( n + 2 ) % 3 ] == 0 return tmp [ ( n + 1 ) % 3 ] elsif tmp [ ( n + 2 ) % 3 ] < tmp [ ( n + 1 ) % 3 ] break end i += 1 end n += 1 end end while line = gets do c , d = line . split . map ( & :to_i ) g = gcd c , d l = ( c / g ) * d puts \" end",
    "label": 5
  },
  {
    "code": "while pair = gets a , b = pair . split ( ' ' ) a = a . to_i b = b . to_i puts a . gcdlcm ( b ) . join ( ' ' ) end",
    "label": 5
  },
  {
    "code": "require \" rational \" while line = gets data = line . split ( \" \" ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a % b while b > 0 return a end while line = gets do a , b = line . split . map ( & :to_i ) g = gcd ( a , b ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a < b mod = a % b if mod == 0 b else gcd ( b , mod ) end end def lcm ( a , b ) a * b / gcd ( a , b ) end while line = gets a , b = line . chomp . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if ( r = a % b ) == 0 return b else gcd ( b , r ) end end while line = gets do datas = line . split . map ( & :to_i ) datas . sort! g = gcd ( datas [ 1 ] , datas [ 0 ] ) l = datas [ 0 ] * datas [ 1 ] / g puts \" end",
    "label": 5
  },
  {
    "code": "ARGF . each do | line | a , b = line . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join ( \" \\s \" ) end",
    "label": 5
  },
  {
    "code": "class Array def lcm self . inject { | a , b | a . lcm ( b ) } end def gcd self . inject { | a , b | a . gcd ( b ) } end end ARGF . each do | line | a , b = line . split . map ( & :to_i ) gcd = [ a , b ] . gcd lcm = [ a , b ] . lcm puts \" end",
    "label": 5
  },
  {
    "code": "ARGF . each do | line | a , b = line . split . map ( & :to_i ) gcd = a . gcd ( b ) lcm = a . lcm ( b ) puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b = line . chomp . split . map ( & :to_i ) a , b = b , a if a < b x , y = a , b while ( r = a % b ) != 0 do a = b b = r end puts \" end",
    "label": 5
  },
  {
    "code": "ARGF . each_line do | line | a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while gets a , b = $_ . split . map ( & :to_i ) puts \" %d %d \" % a . gcdlcm ( b ) end",
    "label": 5
  },
  {
    "code": "STDOUT . sync = true def gcd ( x , y ) while ( ( z = x % y ) != 0 ) do x = y ; y = z ; end return y end def lcm ( x , y ) return x * y / gcd ( x , y ) end while data = STDIN . gets do num = data . split ( ) . map! ( & :to_i ) ans_g = gcd ( num [ 0 ] , num [ 1 ] ) ans_l = lcm ( num [ 0 ] , num [ 1 ] ) printf ( \" %d %d \\n \" , ans_g , ans_l ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) if a >= b m , n = a , b else n , m = a , b end loop do break m if n == 0 m , n = n , m % n end gcd = m lcm = a * b / gcd print \" end",
    "label": 5
  },
  {
    "code": "while gets a , b = $_ . split . map & :to_i y = [ a , b ] while y . uniq . size != 1 y . sort! y [ 1 ] -= y [ 0 ] end x = a * b / y [ 0 ] puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if a < b a , b = b , a end while b > 0 r = a % b a = b b = r end return a end def lcm ( a , b ) if a == 0 || b == 0 puts \" Error \" return 0 end return ( a * b / gcd ( a , b ) ) . to_i end while true do begin a , b = gets . split ( \" \" ) . map ( & :to_i ) printf ( \" %d %d \\n \" , gcd ( a , b ) , lcm ( a , b ) ) rescue break end end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) gcd ( b , a ) if b > a return b if ( r = a % b ) == 0 gcd ( b , r ) end def lcm ( a , b ) a * b / gcd ( a , b ) end while line = gets a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( n , m ) if n % m == 0 m else gcd ( m , n % m ) end end while line = gets m , n = line . split . map ( & :to_i ) gcd = gcd ( m , n ) lcm = m * n / gcd puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) return a if b == 0 gcd ( b , a % b ) end def lcm ( a , b ) return a * b / gcd ( a , b ) end while line = gets a , b = line . split . map ( & :to_i ) print gcd ( a , b ) , \" \" , lcm ( a , b ) , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) gcd , lcm = a . gcdlcm ( b ) puts [ gcd , lcm ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "$< . each_line do | line | a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "data = Array . new ( ) i = 0 ans = Array . new ( ) while true data [ i ] = gets break if data [ i ] == nil data [ i ] = data [ i ] . split ( \" \" ) ans [ i ] = data [ i ] [ 0 ] . to_i . gcdlcm ( data [ i ] [ 1 ] . to_i ) i += 1 end i . times do | i | puts \" end",
    "label": 5
  },
  {
    "code": "def gcd_and_lcm ( nums ) a = nums . max b = nums . min until b == 0 tmp = b b = a % b a = tmp end gcd = tmp lcm = nums . max * nums . min / gcd return [ gcd , lcm ] end while line = gets data = line . chomp . split ( \" \" ) . map ( & :to_i ) puts gcd_and_lcm ( data ) . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "while s = gets do a , b = s . split . map ( & :to_i ) puts [ a . gcd ( b ) , a . lcm ( b ) ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) a , b = [ x , y ] . max , [ x , y ] . min until b == 0 a , b = b , a % b end return a end while line = gets x , y = line . chomp . split ( \" \" ) . map ( & :to_i ) gcd = gcd ( x , y ) lcm = x * y / gcd puts \" end",
    "label": 5
  },
  {
    "code": "data = [ ] while data = gets data = data . split ( nil ) data . map! { | n | n . to_i } data . sort! a = data [ 0 ] b = data [ 1 ] r = b % a while r != 0 b = a a = r r = b % a end ans = a a = data [ 0 ] b = data [ 1 ] while a % b != 0 a = a + data [ 0 ] end puts printf ( \" %d %d \" , ans , a ) end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) loop { if b == 0 return a end a , b = b , a % b } end STDIN . each_line { | l | a , b = l . split ( ) . map { | v | v . to_i } g = gcd ( a , b ) print \" %d %d \\n \" % [ g , ( a * b ) / g ] }",
    "label": 5
  },
  {
    "code": "def get_gcd ( elems ) a = elems [ - 2 ] b = elems [ - 1 ] rest = a % b return b if rest . zero? return b if rest == b get_gcd ( [ b , rest ] ) end STDIN . read . chomp . split ( \" \\n \" ) . each do | list | elems = list . split . map ( & :to_i ) . sort_by { | i | - i } gcd = get_gcd elems lcm = elems . inject ( :* ) / gcd puts \" end",
    "label": 5
  },
  {
    "code": "def get_gcd ( a , b ) rest = a % b return b if rest . zero? || rest == b get_gcd ( b , rest ) end STDIN . read . chomp . split ( \" \\n \" ) . each do | list | elems = list . split . map ( & :to_i ) . sort_by { | i | - i } gcd = get_gcd * elems lcm = elems . inject ( :* ) / gcd puts \" end",
    "label": 5
  },
  {
    "code": "def get_gcd ( a , b ) rest = a % b return b if rest . zero? || rest == b get_gcd ( b , rest ) end STDIN . read . chomp . split ( \" \\n \" ) . each do | list | elems = list . split . map ( & :to_i ) . sort_by ( & :-@ ) gcd = get_gcd ( * elems ) lcm = elems . inject ( :* ) / gcd puts \" end",
    "label": 5
  },
  {
    "code": "require \" prime \" while line = gets a , b = line . chomp . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "testCase = Array . new i = 0 STDIN . each_line do | line | testCase [ i ] , testCase [ i + 1 ] = line . split ( \" \" ) . map ( & :to_i ) i += 2 end i = 0 cases = testCase . length / 2 cases . times do print testCase [ i ] . gcd ( testCase [ i + 1 ] ) print \" \" puts testCase [ i ] . lcm ( testCase [ i + 1 ] ) i += 2 end",
    "label": 5
  },
  {
    "code": "a = [ ] b = [ ] count = 0 while n = gets ax , bx = n . chomp . split ( \" \" ) a [ count ] , b [ count ] = ax . to_i , bx . to_i count += 1 end for i in 0 .. count - 1 aa = a [ i ] bb = b [ i ] if b [ i ] > a [ i ] a [ i ] = b [ i ] b [ i ] = aa end while b [ i ] != 0 c = a [ i ] % b [ i ] a [ i ] = b [ i ] b [ i ] = c end puts a [ i ] . to_s + \" \" + ( ( aa / a [ i ] ) * ( bb / a [ i ] ) * a [ i ] ) . to_s end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a < b if b == 0 a else gcd ( b , a % b ) end end def lcm ( a , b ) a / gcd ( a , b ) * b end while line = gets a , b = line . chomp . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "fh = STDIN while fh . gets do a , b = $_ . split . map { | x | x . to_i } gcd_ = a . gcd ( b ) lcm_ = a * b / gcd_ printf ( \" %d %d \\n \" , gcd_ , lcm_ ) end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b = line . split . map ( & :to_i ) . sort lcm = a * b while a > 0 do r = b % a b = a a = r end puts \" end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b = line . split . map ( & :to_i ) . sort lcm = a * b while ( r = b % a ) > 0 do b = a a = r end puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b = line . split . map ( & :to_i ) . sort lcm = a * b while ( r = b % a ) > 0 do b = a a = r end puts \" end",
    "label": 5
  },
  {
    "code": "$stdin . each_line do | line | a , b = line . split . map ( & :to_i ) . sort lcm = a * b while ( r = b % a ) > 0 do b = a a = r end puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b = line . split . map ( & :to_i ) . sort lcm = a * b while ( r = b % a ) > 0 do b = a a = r end puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) gcd = a . gcd ( b ) puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets ( a , b ) = line . split . map ( & :to_i ) if b < a big = a small = b else big = b small = a end tmp1 = big tmp2 = small while ( tmp1 % small ) != 0 tmp1 += big end least_common_multiple = tmp1 while true q = a / b ; r = a % b ; break if ( r == 0 ) a = b ; b = r ; end printf ( \" %d %d \\n \" , b , least_common_multiple ) end",
    "label": 5
  },
  {
    "code": "while line = gets num = [ ] num = line . split ( nil ) . map { | n | n . to_i } . sort! avoid = [ num [ 0 ] , num [ 1 ] ] while num [ 0 ] != num [ 1 ] num [ 1 ] = num [ 1 ] - num [ 0 ] num . sort! end max = num [ 0 ] x = avoid [ 0 ] / max y = avoid [ 1 ] / max min = x * y * max puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets n = line . split ( \" \" ) . map { | e | e . to_i } puts \" end",
    "label": 5
  },
  {
    "code": "while gets a , b = $_ . split . map ( & :to_i ) puts [ a . gcd ( b ) , a . lcm ( b ) ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "loop do line = gets break unless line a , b = line . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join ( ' ' ) end",
    "label": 5
  },
  {
    "code": "$< . map { | a | a . split . map ( & :to_i ) } . each { | a | puts \"",
    "label": 5
  },
  {
    "code": "def Gcd ( a , b ) tmp = 0 while ( a % b != 0 ) tmp = b b = a % b a = tmp end return b end def Lcm ( a , b ) return a * b / Gcd ( a , b ) end while nums = gets a , b = nums . split ( ' ' ) . map ( & :to_i ) puts sprintf ( \" %d %d \" , Gcd ( a , b ) , Lcm ( a , b ) ) end",
    "label": 5
  },
  {
    "code": "while line = gets do a , b = line . split . map ( & :to_i ) print \" end",
    "label": 5
  },
  {
    "code": "a , b = $_ . split . map & :to_i ; puts \"",
    "label": 5
  },
  {
    "code": "$< . each { | i | a , b = i . split . map & :to_i ; puts \"",
    "label": 5
  },
  {
    "code": "a , b = $_ . split . map ( & :to_i ) print \"",
    "label": 5
  },
  {
    "code": "$< . map { | i | a , b = i . split . map & :to_i ; puts \"",
    "label": 5
  },
  {
    "code": "puts $< . map { | i | a , b = i . split . map & :to_i ; \"",
    "label": 5
  },
  {
    "code": "a , b = $F . map & :to_i ; puts \"",
    "label": 5
  },
  {
    "code": "a , b = $F . map & :to_i ; puts a . gcdlcm ( b ) . join \" \"",
    "label": 5
  },
  {
    "code": "a , b = $F . map & :to_i ; puts a . gcdlcm ( b ) * \" \"",
    "label": 5
  },
  {
    "code": "puts $< . map { | l | a , b = l . split . map & :to_i ; a . gcdlcm ( b ) * \" \" }",
    "label": 5
  },
  {
    "code": "a , b = $_ . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join \" \"",
    "label": 5
  },
  {
    "code": "def calc_gcd ( a , b ) if b > 0 then calc_gcd ( b , a % b ) else a end end def calc_lcm ( a , b ) ( a / calc_gcd ( a , b ) ) * b end while line = STDIN . gets line . chomp! arr = line . split ( \" \" ) gcd = calc_gcd ( arr [ 0 ] . to_i , arr [ 1 ] . to_i ) lcm = calc_lcm ( arr [ 0 ] . to_i , arr [ 1 ] . to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def get_kouyakusu ( a , b ) loop do rem = b % a return a if rem == 0 a , b = rem , a end nil end while str = gets break if str . nil? || str . empty? a , b = str . split ( ' ' ) . map ( & :to_i ) . sort koyakusu = get_kouyakusu ( a , b ) raise ' No result ' unless koyakusu kobaisu = ( a * b / koyakusu ) puts \" end",
    "label": 5
  },
  {
    "code": "def koyaku ( a , b ) loop do rem = b % a return a if rem == 0 a , b = rem , a end end def kobai ( a , b ) ( a * b ) / koyaku ( a , b ) end while str = gets a , b = str . split ( ' ' ) . map ( & :to_i ) . sort puts \" end",
    "label": 5
  },
  {
    "code": "def koyakusu ( a , b ) loop do rem = b % a return a if rem == 0 a , b = rem , a end end def kobaisu ( a , b ) a * b / koyakusu ( a , b ) end while str = gets a , b = str . split ( ' ' ) . map ( & :to_i ) . sort puts \" end",
    "label": 5
  },
  {
    "code": "def kouyakusu ( a , b ) loop do rem = b % a return a if rem == 0 a , b = rem , a end end def kobaisu ( a , b ) a * b / kouyakusu ( a , b ) end while str = gets a , b = str . split ( ) . map ( & :to_i ) . sort puts \" end",
    "label": 5
  },
  {
    "code": "def koyakusu ( a , b ) loop do rem = b % a return a if rem == 0 b , a = a , rem end end def kobaisu ( a , b ) ( a * b ) / koyakusu ( a , b ) end while str = gets a , b = str . split ( ' ' ) . map ( & :to_i ) . sort puts \" end",
    "label": 5
  },
  {
    "code": "def kouyakusu ( a , b ) loop do rem = b % a return a if rem == 0 a , b = rem , a end end def kobaisu ( a , b ) ( a * b ) / kouyakusu ( a , b ) end while str = gets a , b = str . split ( ' ' ) . map ( & :to_i ) . sort puts \" end",
    "label": 5
  },
  {
    "code": "while data = gets if data == nil break end x = 1 y = 1 z = 1 gcd = [ ] gcda = [ ] gcdb = [ ] lcma = [ ] lcmb = [ ] a , b = data . split ( \" \" ) . map { | num | num . to_i } i = 2 while i <= a || i <= b if a % i == 0 && b % i == 0 gcd << i a = a / i b = b / i redo elsif a % i == 0 gcda << i a = a / i redo elsif b % i == 0 gcdb << i b = b / i redo end i += 1 end gcda . each do | i | x = x * i end gcdb . each do | i | y = y * i end gcd . each do | i | z = z * i end puts \" end",
    "label": 5
  },
  {
    "code": "while data = gets x = 1 y = 1 z = 1 gcd = [ ] gcda = [ ] gcdb = [ ] lcma = [ ] lcmb = [ ] a , b = data . split ( \" \" ) . map { | num | num . to_i } i = 2 while i <= a || i <= b if a % i == 0 && b % i == 0 gcd << i a = a / i b = b / i redo elsif a % i == 0 gcda << i a = a / i redo elsif b % i == 0 gcdb << i b = b / i redo end i += 1 end gcda . each do | i | x = x * i end gcdb . each do | i | y = y * i end gcd . each do | i | z = z * i end puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . chomp . split . map ( & :to_i ) gcd = a . gcd ( b ) lcm = a * b / gcd puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) while a != 0 a , b = b % a , a end return b end readlines . map ( & :chomp ) . each { | l | a , b = l . split . map ( & :to_i ) . sort gcd = gcd ( a , b ) lcm = a * b / gcd puts [ gcd , lcm ] . join ( \" \" ) }",
    "label": 5
  },
  {
    "code": "while a = gets b , c = a . split . map & :to_i d , e = b , c while e != 0 d , e = e , d if e < d e %= d end puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) return x if y < 1 return gcd ( y , x % y ) end while line = gets a , b = line . split . map ( & :to_i ) a , b = b , a if a < b c = gcd ( a , b ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a % b while b > 0 a end while line = STDIN . gets a , b = line . chomp! . split . map! ( & :to_i ) . sort . reverse g = gcd ( a , b ) l = a * b / g puts \" end",
    "label": 5
  },
  {
    "code": "def euq ( a , b ) b , a = a , b if a < b loop { ( a % b ) . zero? ? ( return b ) : ( a , b = b , a % b ) } end while i = gets m , n = i . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while cin = gets a , b = cin . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if b > a while ( c = a % b ) != 0 a , b = b , c end b end def lcm ( a , b ) a * b / gcd ( a , b ) end while line = gets a , b = line . split . map ( & :to_i ) gcd = gcd ( a , b ) lcm = lcm ( a , b ) puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . chomp! . split ( \" \" ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if b == 0 a else gcd ( b , a % b ) end end def lcm ( a , b ) a * b / gcd ( a , b ) end def main ( ) while a = gets c = a . split ( ' ' ) . map ( & :to_i ) print gcd ( c [ 0 ] , c [ 1 ] ) print ' ' puts lcm ( c [ 0 ] , c [ 1 ] ) end end 3 main ( )",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "$< . map { | a | a . split . map ( & :to_i ) } . each do | a | print ( \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map { | item | item . to_i } printf ( \" %d %d \\n \" , a . gcd ( b ) , a . lcm ( b ) ) end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a > b until a == 0 a , b = b % a , a end return b end def lcm ( a , b ) a * b / gcd ( a , b ) end while gets do a , b = $_ . chomp . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "loop do line = gets break unless line a , b = line . split ( \" \" ) . map { | i | i . to_i } puts a . gcdlcm ( b ) . join ( ' ' ) end",
    "label": 5
  },
  {
    "code": "require ' rational ' while line = gets do a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while s = gets a , b = s . split . map ( & :to_i ) m , n = a , b begin k = m % n ; m = n ; n = k end while k != 0 puts \" end",
    "label": 5
  },
  {
    "code": "class Integer def gcd ( other ) min = self . abs max = other . abs while min > 0 tmp = min min = max % min max = tmp end max end def lcm ( other ) g = self . gcd ( other ) self * other / g end end while STDIN . gets do a , b = $_ . split ( \" \" ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "require ' rational ' ; while gets do a , b = $_ . split . map ( & :to_i ) ; puts \"",
    "label": 5
  },
  {
    "code": "require ' rational ' ; while gets do a , b = $_ . split . map ( & :to_i ) ; puts \"",
    "label": 5
  },
  {
    "code": "require ' rational ' ; while gets a , b = $_ . split . map ( & :to_i ) ; puts \"",
    "label": 5
  },
  {
    "code": "class EuclideanAlgorithmCalcurator def get_gcd ( m , n ) if n == 0 return m ; end return get_gcd ( n , m % n ) end def get_lcd ( m , n ) return ( m * n ) / get_gcd ( m , n ) end end if __FILE__ == $0 while line = gets args = line . split ( \" \" ) . map { | e | e . to_i } m = args [ 0 ] >= args [ 1 ] ? args [ 0 ] : args [ 1 ] n = m == args [ 0 ] ? args [ 1 ] : args [ 0 ] calcurator = EuclideanAlgorithmCalcurator . new puts \" end end",
    "label": 5
  },
  {
    "code": "require ' rational ' ; while gets a , b = $_ . split . map & :to_i ; puts \"",
    "label": 5
  },
  {
    "code": "def rec x , y z = [ x , y ] . max % [ x , y ] . min return [ x , y ] . min if z == 0 rec z , [ x , y ] . min end while line = gets do a , b = line . split . map ( & :to_i ) ans1 = rec a , b ans2 = ans1 * ( a / ans1 ) * ( b / ans1 ) printf ( \" %d %d \\n \" , ans1 , ans2 ) end",
    "label": 5
  },
  {
    "code": "while line = gets do if line == \" \" then break end - > ( a , b ) { printf \" %d %d \\n \" , a . gcd ( b ) , a . lcm ( b ) } . call * line . split ( ' ' ) . map ( & :to_i ) end",
    "label": 5
  },
  {
    "code": "$< . map { | x | n , m = x . split . map ( & :to_i ) ; puts [ n . gcd ( m ) , n . lcm ( m ) ] . join \" \" }",
    "label": 5
  },
  {
    "code": "$< . map { | x | n , m = x . split . map ( & :to_i ) ; puts [ n . gcd ( m ) , n . lcm ( m ) ] * \" \" }",
    "label": 5
  },
  {
    "code": "readlines . map ( & :split ) . each do | l | a , b = l . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( m , n ) n , m = m , n if m > n loop do r = n % m break if r == 0 n , m = m , r end m end def lcm ( m , n ) n , m = m , n if m > n r = 1 loop do return m * r if ( m * r ) % n == 0 r + = 1 end end while gets a , b = $_ . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "arr = Array . new while line = gets arr << line end arr . each do | i | a = i . split ( \" \" ) b = a [ 0 ] . to_i c = a [ 1 ] . to_i puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets rec = line . split ( \" \" ) . map ( & :to_i ) x , y = rec [ 0 ] . to_i , rec [ 1 ] . to_i s = x * y while true k = x % y x = y y = k break if k == 0 end lcm = s / x puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets rec = line . split ( \" \" ) . map ( & :to_i ) x , y = rec [ 0 ] . to_i , rec [ 1 ] . to_i s = x * y while true k = x % y x = y y = k gcd = x break if k == 0 end lcm = s / gcd puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets rec = line . split ( \" \" ) . map ( & :to_i ) x , y = rec [ 0 ] , rec [ 1 ] s = x * y while true k = x % y x = y y = k break if k == 0 end lcm = s / x puts \" end",
    "label": 5
  },
  {
    "code": "require ' rational ' ; while gets a , b = $_ . split . map & :to_i puts a . gcdlcm ( b ) * ' ' end",
    "label": 5
  },
  {
    "code": "def calcGCD ( a , b ) m = [ a , b ] . max n = [ a , b ] . min while n > 0 if ( n == 0 ) break else nn = n n = m % n m = nn end end return m end inputs = [ ] while ( line = gets ) != nil inputs . push ( line . split ( ) ) end for i , j in inputs a = i . to_i b = j . to_i g = calcGCD ( a , b ) l = a * b / g puts printf ( \" %d %d \" , g , l ) end",
    "label": 5
  },
  {
    "code": "STDIN . each do | line | a , b = line . split ( \" \" ) . map ( & :to_i ) g = a . gcd ( b ) puts \" end",
    "label": 5
  },
  {
    "code": "def get_GCD ( a , b ) while ( ( r = a % b ) != 0 ) do a = b b = r end b end def get_LCM ( a , b , gcd ) a * b / gcd end while s = gets do a , b = s . split ( / \\s / ) . map ( & :to_i ) . sort gcd = get_GCD ( a , b ) lcm = get_LCM ( a , b , gcd ) puts \" end",
    "label": 5
  },
  {
    "code": "def get_GCD ( a , b ) while ( ( r = a % b ) != 0 ) do a = b b = r end b end def get_LCM ( a , b , gcd ) a * b / gcd end while s = gets do a , b = s . split ( / \\s / ) . map ( & :to_i ) gcd = get_GCD ( a , b ) lcm = get_LCM ( a , b , gcd ) puts \" end",
    "label": 5
  },
  {
    "code": "def get_GCD ( a , b ) while ( ( r = a % b ) != 0 ) do a = b b = r end b end def get_LCM ( a , b , gcd ) a * b / gcd end while s = gets do a , b = s . split ( / \\s / ) . map ( & :to_i ) . sort gcd = get_GCD ( a , b ) lcm = get_LCM ( a , b , gcd ) puts \" end",
    "label": 5
  },
  {
    "code": "STDIN . each { | l | a , b = l . split . map ( & :to_i ) ; puts a . gcdlcm ( b ) . join \" \" }",
    "label": 5
  },
  {
    "code": "$< . map { | l | a , b = l . split . map ( & :to_i ) ; puts a . gcdlcm ( b ) . join \" \" }",
    "label": 5
  },
  {
    "code": "def get_GCD ( a , b ) while ( ( r = a % b ) != 0 ) do a = b b = r end b end def get_LCM ( a , b , gcd ) a * b / gcd end while s = gets do a , b = s . split ( / \\s / ) . map ( & :to_i ) . sort gcd = get_GCD ( a , b ) lcm = get_LCM ( a , b , gcd ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) while ( ( r = a % b ) != 0 ) do a = b b = r end b end def lcm ( n , m , g ) ( n * m ) / g end while gets do a , b = $_ . split ( / \\s / ) . map ( & :to_i ) . sort g = gcd ( a , b ) l = lcm ( a , b , g ) puts \" end",
    "label": 5
  },
  {
    "code": "class Array def product ( ary ) temp = self . clone result = [ ] ary . each do | v | if temp . include? ( v ) result << temp . delete_at ( temp . index ( v ) ) end end result end end def gcd ( i ) gcd_div = self . prime_div2 . product ( i . prime_div2 ) gcg_div . inject { | memo , item | memo * item } end def lcm ( i ) lcm_div = self . prime_div2 + i . prime_div2 lcm_div = lcm_div - self . prime_div2 . product ( i . prime_div2 ) lcm_div . inject { | memo , item | memo * item } end def eratosthenes ( n ) list = Array . new ( n - 1 ) . map . with_index { | i , k | k + 2 } result = [ 1 ] while list . last >= result . last ** 2 p = list . shift result << p list . delete_if { | v | v % p == 0 } end result . shift result = result + list end def prime_div k = self c = 0 result = [ ] eratosthenes ( n / 2 ) . each do | i | c = 0 if k % i == 0 while k % i == 0 k = k / i result << k end end end result end while line = gets imput = line . chomp . split . map ( & :to_i ) print imput [ 0 ] . gcd ( imput [ 1 ] ) , \" \" , imput [ 0 ] . lcm ( imput [ 1 ] ) , \" \\n \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a < b loop do r = a % b break if r == 0 a , b = b , r end return b end def lcm ( a , b ) a * b / gcd ( a , b ) end while gets do a , b = $_ . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a < b loop do r = a % b break if r == 0 a , b = b , r end return b end def lcm ( a , b ) return a * b / gcd ( a , b ) end while gets do a , b = $_ . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while true do line = gets break if line == nil nums = line . split . map { | x | x . to_i } nums . sort! lcm = 0 gcd = 0 i = 1 while true do if ( nums [ 1 ] * i ) % nums [ 0 ] == 0 then lcm = nums [ 1 ] * i break end i += 1 end i = 1 while true do if ( nums [ 0 ] % i == 0 && nums [ 1 ] % ( nums [ 0 ] / i ) == 0 ) then gcd = nums [ 0 ] / i break end i += 1 end puts \" end",
    "label": 5
  },
  {
    "code": "while tmp = gets a , b = tmp . split . map { | n | n . to_i } puts \" end",
    "label": 5
  },
  {
    "code": "def gcd x , y return y != 0 ? gcd ( y , x % y ) : x end while tmp = gets a , b = tmp . split . map { | n | n . to_i } puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if b . zero? a else gcd ( b , a % b ) end end def lcm ( a , b ) d = gcd ( a , b ) d * ( a / d ) * ( b / d ) end pairs = ARGF . each_line . map { | line | line . split ( \" \" ) . map { | x | x . to_i } } pairs . each do | a , b | puts [ gcd ( a , b ) , lcm ( a , b ) ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "Signal . trap ( :INT ) { exit ( 0 ) } base_arr = Array . new ( 50000 , true ) base_arr [ 0 ] = false base_arr [ 1 ] = false i = 2 50000 . times do if base_arr [ i ] == true for j in ( 2 .. 50000 ) do if i * j < 50000 base_arr [ i * j ] = false else break end end end i += 1 end def prime_dec ( x , base_arr ) prime_arr = [ 1 ] 50000 . times do | i | if base_arr [ i ] == true tmp = Math . sqrt ( x ) . to_i tmp . times do | j | break if x == 1 if ( x % i ) == 0 prime_arr . push i x /= i redo end end end end prime_arr . push x return prime_arr end while str = gets nums = str . split ( \" \" ) num0 = nums [ 0 ] . to_i num1 = nums [ 1 ] . to_i arr0 = prime_dec ( num0 , base_arr ) arr1 = prime_dec ( num1 , base_arr ) gcd = 1 gcd_arr = arr0 && arr1 gcd_arr . size . times do | i | gcd *= gcd_arr [ i ] end puts \" end",
    "label": 5
  },
  {
    "code": "while num = gets num = num . split ( ) . map ( & :to_i ) . sort buf = num [ 0 ] * num [ 1 ] while num [ 1 ] % num [ 0 ] != 0 temp = num [ 0 ] num [ 0 ] = num [ 1 ] % num [ 0 ] num [ 1 ] = temp end num [ 1 ] = buf / num [ 0 ] puts \" end",
    "label": 5
  },
  {
    "code": "def main while nums = gets a , b = nums . chomp . split ( / \\s / ) . collect { | x | x . to_i } g , l = a . gcdlcm ( b ) puts \" end end main",
    "label": 5
  },
  {
    "code": "require \" rational \" while t = gets s = t . split ( \" \" ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "$stdin . each_line do | line | a , b = line . split . map { | e | e . to_i } printf ( \" %d %d \\n \" , a . gcd ( b ) , a . lcm ( b ) ) end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . sort! . reverse . map ( & :to_i ) m , n = a , b while n != 0 tmp = n n = m % n m = tmp end print \" end",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) print \" end",
    "label": 5
  },
  {
    "code": "require ' rational ' ; puts $< . map { | e | a , b = e . split . map & :to_i ; a . gcdlcm ( b ) * ' ' }",
    "label": 5
  },
  {
    "code": "while line = gets a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( * nums ) return nums . inject do | a , b | a , b = b , a % b until b . zero? a end end def lcm ( * nums ) return nums . inject { | a , b | a * b / gcd ( a , b ) } end $< . each_line do | line | a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( m , n ) return m if n == 0 return gcd ( n , m % n ) end def lcm ( m , n , g ) return m * n / g end while gets do a , b = $_ . chomp . split ( / / ) . map ( & :to_i ) g = gcd ( a , b ) l = lcm ( a , b , g ) puts \" end",
    "label": 5
  },
  {
    "code": "while line = gets num = line . split ( \" \" ) a , b = num [ 0 ] . to_i , num [ 1 ] . to_i gcd = a . gcd ( b ) lcm = a * b / gcd puts \" end",
    "label": 5
  },
  {
    "code": "while data = gets data . chomp hai = data . split hai . collect! { | i | i . to_i } hai . sort . reverse! a = hai [ 0 ] b = hai [ 1 ] while ( r = a % b ) != 0 a = b b = r end print b , \" \" , hai [ 0 ] * hai [ 1 ] / b , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while input = gets array = input . chomp . split ( \" \\s \" ) x = array [ 0 ] . to_i y = array [ 1 ] . to_i while x != y if x < y y = y - x else x = x - y end end print x , \" \" , ( array [ 0 ] . to_i * array [ 1 ] . to_i ) / x , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while ln = gets x , y = ln . split . map ( & :to_i ) puts x . gcdlcm ( y ) . join ( ' ' ) end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) return b . zero? ? a : gcd ( b , a % b ) end while ln = gets x , y = ln . split . map ( & :to_i ) g = gcd ( x , y ) puts \" end",
    "label": 5
  },
  {
    "code": "input = gets ( nil ) input . split ( \" \\n \" ) . each do | l | a , b = l . split ( \" \" ) . map ( & :to_i ) printf \" %d %d \\n \" , a . gcd ( b ) , a . lcm ( b ) end",
    "label": 5
  },
  {
    "code": "while line = $stdin . gets do a , b = line . split ( \" \" ) . collect { | x | x . to_i } c = a d = b if c < d c , d = d , c end while d != 0 c , d = d , c % d end $stdout . print c , \" \" , ( a * b ) / c , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while line = $stdin . gets do a , b = line . split ( \" \" ) . collect { | x | x . to_i } $stdout . print \" end",
    "label": 5
  },
  {
    "code": "require \" rational \" while line = gets test = line . split ( / \\s + / ) tmp = [ ] tmp [ 0 ] = test [ 0 ] . to_i tmp [ 1 ] = test [ 1 ] . to_i test [ 0 ] = tmp [ 0 ] . gcd ( tmp [ 1 ] ) test [ 1 ] = tmp [ 0 ] . lcm ( tmp [ 1 ] ) print test [ 0 ] print ( \" \" ) puts test [ 1 ] end",
    "label": 5
  },
  {
    "code": "class Array def gcd self . inject { | a , b | a . gcd ( b ) } end def lcm self . inject { | a , b | a . lcm ( b ) } end end while str = gets a = str . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while line = ARGF . gets do a , b = line . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join ( \" \\s \" ) end",
    "label": 5
  },
  {
    "code": "class Array def lcm self . inject do | a , b | a * b / self . gcd end end def gcd self . inject do | a , b | a , b = b , a if a < b return a if b == 0 arr = b , a % b arr . gcd end end end while str = gets a = str . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while input = gets do a , b = input . split ( \" \" ) . collect do | x | x . to_i end ac = a bc = b if ac < bc mem = ac ac = bc bc = mem end until bc == 0 do mem = ac % bc ac = bc bc = mem end print ac , \" \" , a * b / ac , \" \\n \" end",
    "label": 5
  },
  {
    "code": "while data = gets a , b = data . chomp . split a , b = a . to_i , b . to_i m = a * b r = a % b while r > 0 a = b b = r r = a % b end print b , \" \" , m / b , \" \\n \" end",
    "label": 5
  },
  {
    "code": "gcd = -> ( a , b ) { b == 0 ? a : gcd [ b , a % b ] } while line = gets a , b = line . split ( \" \" ) . map ( & :to_i ) g = gcd [ a , b ] puts \" end",
    "label": 5
  },
  {
    "code": "while nums = gets do a , b = nums . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while nums = gets do a , b = nums . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "require ' rational ' while line = gets do a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if ( a < b ) tmp = a ; a = b ; b = tmp end while ( ( c = a % b ) > 0 ) a = b b = c end return b end while ( line = gets ) a , b = line . chop . split ( \" \" ) . map { | s | s . to_i } g = gcd ( a , b ) l = a * b / g printf ( \" %d %d \\n \" , g , l ) end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a > b loop do b , a = a , b % a break if a == 0 end b end def lcm ( a , b ) a * b / gcd ( a , b ) end while gets do a , b = $_ . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a < b loop do break if b == 0 a , b = b , a % b end return a end while gets do a , b = $_ . split ( ' ' ) . map ( & :to_i ) gn = gcd ( a , b ) puts \" end",
    "label": 5
  },
  {
    "code": "while ( true ) do set = gets ( ) if ( set . nil? or set == \" \\n \" or set == \" \\n \\r \" ) then break end a , b = set . split ( ) . map { | x | x . to_i } yakusu = Array . new ( ) ( 2 .. 9 ) . each do | n | while ( true ) do if a % n != 0 || b % n != 0 then break end yakusu . push ( n ) a = a / n b = b / n end end saidai = 1 yakusu . each do | y | saidai = saidai * y end puts \" end",
    "label": 5
  },
  {
    "code": "while set = gets ( ) if ( set . nil? or set == \" \\n \" or set == \" \\n \\r \" ) then break end a , b = set . split ( ) . map { | x | x . to_i } yakusu = Array . new ( ) ( 2 .. 9 ) . each do | n | while a % n == 0 and b % n == 0 yakusu . push ( n ) a = a / n b = b / n end end saidai = 1 yakusu . each do | y | saidai = saidai * y end puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a < b until b == 0 a , b = b , a % b end return a end def lcm ( a , b ) a * b / gcd ( a , b ) end while gets do a , b = $_ . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a > b until a == 0 a , b = b % a , a end return b end def lcm ( a , b ) a * b / gcd ( a , b ) end while gets do a , b = $_ . chomp . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if b === 0 return a end return gcd ( b , a % b ) end def lcm ( a , b ) return a * b / gcd ( a , b ) end while line = gets array = line . chomp . split ( ' ' ) . map ( & :to_i ) a = array [ 0 ] b = array [ 1 ] x = gcd ( a , b ) y = lcm ( a , b ) printf ( \" %d %d \\n \" , x , y ) end",
    "label": 5
  },
  {
    "code": "class Array def lcm inject ( :lcm ) end def gcd inject ( :gcd ) end end while input = gets a , b = input . split ( ) . map ( & :to_i ) i = [ a , b ] . lcm j = [ a , b ] . gcd puts ( \" end",
    "label": 5
  },
  {
    "code": "while n = gets ( a , b ) = n . chomp . split a = a . to_i b = b . to_i x = a * b if a < b tmp = a a = b b = tmp end r = a % b while r != 0 a = b b = r r = a % b end puts b . to_s + \" \" + ( x / b ) . to_s end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if a % b == 0 return b else return gcd ( b , a % b ) end end while ( str = gets ) a , b = str . split ( \" \" ) . map ( & :to_i ) puts [ gcd ( a , b ) , ( a * b ) / gcd ( a , b ) ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "while data = gets a , b = data . chomp . split a , b = a . to_i , b . to_i m = a * b r = a % b while r > 0 a = b b = r r = a % b end print b , \" \" , m / b , \" \\n \" end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) if ( a < b ) tmp = a ; a = b ; b = tmp end while ( ( c = a % b ) > 0 ) a = b b = c end return b end while ( line = gets ) a , b = line . chop . split ( \" \" ) . map { | s | s . to_i } g = gcd ( a , b ) l = a * b / g printf ( \" %d %d \\n \" , g , l ) end",
    "label": 5
  },
  {
    "code": "STDIN . each_line do | line | a , b = line . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) if ( y > x ) tmp = y y = x x = tmp end if ( x % y == 0 ) return y else return gcd ( y , x % y ) end end while ( str = gets ) a , b = str . split ( \" \" ) . map ( & :to_i ) puts [ gcd ( a , b ) , ( a * b ) / gcd ( a , b ) ] . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "while a = gets a = a . split ( ' ' ) . map { | i | i . to_i } puts \" end",
    "label": 5
  },
  {
    "code": "def cal ( a , b ) if ( ( r = a % b ) != 0 ) cal ( b , r ) ; else return b ; end end while n = gets a , b = n . chomp . split a , b = a . to_i , b . to_i g = cal ( a , b ) l = a * b / g puts \" end",
    "label": 5
  },
  {
    "code": "def calc_gcd ( m , n ) while true do tmp = n n = m % n m = tmp return m if n == 0 end end def calc_gcm ( m , n , gcd ) m * n / gcd end while line = gets do a , b = line . chop . split ( / \\s + / ) . map { | s | s . to_i } gcd = calc_gcd ( a , b ) gcm = calc_gcm ( a , b , gcd ) puts ( \" end",
    "label": 5
  },
  {
    "code": "while line = gets value = line . chomp list = value . split a = list [ 0 ] . to_i b = list [ 1 ] . to_i gcd = a . gcd ( b ) lcm = a . lcm ( b ) print gcd . to_s + \" \" + lcm . to_s + \" \\n \" end",
    "label": 5
  },
  {
    "code": "while input = gets a , b = input . chomp . split . map ( & :to_i ) puts a . gcdlcm ( b ) . join ( \" \" ) end",
    "label": 5
  },
  {
    "code": "$< . readlines . each do | l | a , b = l . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def gcd ( x , y ) if ( y == 0 ) return x else return gcd ( y , x % y ) end end while data = gets a , b = data . chomp . split a , b = a . to_i , b . to_i g = gcd ( a , b ) l = ( a * b ) / g print g , \" \" , l , \" \\n \" end",
    "label": 5
  },
  {
    "code": "a = [ ] b = [ ] i = 0 def calc_gcd ( a , b ) if a % b == 0 return b else return calc_gcd ( b , a % b ) end end while true ln = gets if ln == nil break end a [ i ] , b [ i ] = ln . chomp . split a [ i ] , b [ i ] = a [ i ] . to_i , b [ i ] . to_i i = i + 1 end for j in 0 .. ( i - 1 ) gcd = calc_gcd ( a [ j ] , b [ j ] ) lcm = a [ j ] * b [ j ] / gcd puts gcd . to_s + \" \" + lcm . to_s end",
    "label": 5
  },
  {
    "code": "x = gets until x . nil? y = x . split ( \" \" ) . map { | k | k . to_i } ans = y [ 0 ] . gcdlcm ( y [ 1 ] ) puts \" x = gets end",
    "label": 5
  },
  {
    "code": "def gcd ( a , b ) a , b = b , a if a > b until a == 0 a , b = b % a , a end return b end def lcm ( a , b ) a * b / gcd ( a , b ) end while gets do a , b = $_ . chomp . split ( ' ' ) . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "while gets a , b = $_ . split . map ( & :to_i ) puts \" end",
    "label": 5
  },
  {
    "code": "def get_gcm ( a , b ) while ( r = a % b ) > 0 a = b b = r end return b end def get_lcm ( a , b ) gcm = get_gcm ( a , b ) return a * b / gcm end answer = Array . new while linestr = $stdin . gets line = linestr . split ( / \\s / ) a = line [ 0 ] . to_i b = line [ 1 ] . to_i if a < b t = a a = b b = t end answer << [ get_gcm ( a , b ) , get_lcm ( a , b ) ] end answer . each { | a | printf ( \" %d %d \\n \" , a [ 0 ] , a [ 1 ] ) }",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "s = gets . chomp . to_s puts s . reverse",
    "label": 5
  },
  {
    "code": "str = gets . chomp . to_s puts str . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . to_s . reverse",
    "label": 5
  },
  {
    "code": "input = gets . chomp puts ( input . reverse )",
    "label": 5
  },
  {
    "code": "word = gets . chomp puts word . reverse",
    "label": 5
  },
  {
    "code": "while str = gets puts str . chomp . reverse end",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "str = gets . chomp . split ( \" \" ) str . reverse! str . length . times do | i | a = str [ i ] print a end puts",
    "label": 5
  },
  {
    "code": "str = gets . chomp puts str . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chop . reverse",
    "label": 5
  },
  {
    "code": "while line = gets puts line . chomp . reverse end",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . split ( / / ) . reverse . join",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "s = gets . chomp puts s . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "$< . map { | b | puts b . split ( / / ) . tap { | c | c . pop } . reverse * \" \" }",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "STDIN . each_char . reverse_each { | s | print s if s != \" \\n \" } print \" \\n \"",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "puts gets . chomp . reverse",
    "label": 5
  },
  {
    "code": "line = gets str = line [ 0 .. ( line . length - 2 ) ] ans = \" a \" * str . length index = str . length - 1 str . each_char do | char | ans [ index ] = char index += - 1 end puts ans",
    "label": 5
  },
  {
    "code": "a = gets . chomp . to_s puts a . reverse",
    "label": 5
  },
  {
    "code": "puts gets . strip . reverse",
    "label": 5
  },
  {
    "code": "puts gets . strip . each_char . inject ( \" \" ) { | res , char | char + res }",
    "label": 5
  }
]