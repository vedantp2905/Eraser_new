[
  {
    "code": "import sys from sys import stdin input = stdin . readline class Point ( object ) : epsilon = 1e-10 def __init__ ( self , x = 0.0 , y = 0.0 ) : if isinstance ( x , tuple ) : self . x = x [ 0 ] self . y = x [ 1 ] else : self . x = x self . y = y def __add__ ( self , other ) : return Point ( self . x + other . x , self . y + other . y ) def __sub__ ( self , other ) : return Point ( self . x - other . x , self . y - other . y ) def __mul__ ( self , other ) : return Point ( other * self . x , other * self . y ) def __truediv__ ( self , other ) : return Point ( self . x / other , self . y / other ) def __lt__ ( self , other ) : if self . x == other . x : return self . y < other . y else : return self . x < other . x def __eq__ ( self , other ) : from math import fabs if fabs ( self . x - other . x ) < Point . epsilon and fabs ( self . y - other . y ) < Point . epsilon : return True else : return False def norm ( self ) : return self . x * self . x + self . y * self . y def __abs__ ( self ) : return sqrt ( self . norm ( ) ) def ccw ( self , p0 , p1 ) : a = Vector ( p1 - p0 ) b = Vector ( self - p0 ) if Vector . cross ( a , b ) > Point . epsilon : return 1 elif Vector . cross ( a , b ) < - Point . epsilon : return - 1 elif Vector . dot ( a , b ) < - Point . epsilon : return 2 elif a . norm ( ) < b . norm ( ) : return - 2 else : return 0 def project ( self , s ) : base = Vector ( s . p2 - s . p1 ) a = Vector ( self - s . p1 ) r = Vector . dot ( a , base ) r /= base . norm ( ) return s . p1 + base * r def reflect ( self , s ) : proj = self . project ( s ) return self + ( proj - self ) * 2 def distance ( self , s ) : if Vector . dot ( s . p2 - s . p1 , self - s . p1 ) < 0.0 : return abs ( self - s . p1 ) if Vector . dot ( s . p1 - s . p2 , self - s . p2 ) < 0.0 : return abs ( self - s . p2 ) return abs ( Vector . cross ( s . p2 - s . p1 , self - s . p1 ) / abs ( s . p2 - s . p1 ) ) class Vector ( Point ) : def __init__ ( self , x = 0.0 , y = 0.0 ) : if isinstance ( x , tuple ) : self . x = x [ 0 ] self . y = x [ 1 ] elif isinstance ( x , Point ) : self . x = x . x self . y = x . y else : self . x = x self . y = y def __add__ ( self , other ) : return Vector ( self . x + other . x , self . y + other . y ) def __sub__ ( self , other ) : return Vector ( self . x - other . x , self . y - other . y ) def __mul__ ( self , other ) : return Vector ( other * self . x , other * self . y ) def __truediv__ ( self , other ) : return Vector ( self . x / other , self . y / other ) @ classmethod def dot ( cls , a , b ) : return a . x * b . x + a . y * b . y @ classmethod def cross ( cls , a , b ) : return a . x * b . y - a . y * b . x @ classmethod def is_orthogonal ( cls , a , b ) : return abs ( Vector . dot ( a , b ) ) < Vector . epsilon @ classmethod def is_parallel ( cls , a , b ) : return abs ( Vector . cross ( a , b ) ) < Vector . epsilon class Segment ( object ) : def __init__ ( self , p1 = Point ( ) , p2 = Point ( ) ) : if isinstance ( p1 , Point ) : self . p1 = p1 self . p2 = p2 elif isinstance ( p1 , tuple ) : self . p1 = Point ( p1 [ 0 ] , p1 [ 1 ] ) self . p2 = Point ( p2 [ 0 ] , p2 [ 1 ] ) def intersect ( self , s ) : ans1 = s . p1 . ccw ( self . p1 , self . p2 ) * s . p2 . ccw ( self . p1 , self . p2 ) ans2 = self . p1 . ccw ( s . p1 , s . p2 ) * self . p2 . ccw ( s . p1 , s . p2 ) return ans1 <= 0 and ans2 <= 0 def cross_point ( self , s ) : base = s . p2 - s . p1 d1 = abs ( Vector . cross ( base , self . p1 - s . p1 ) ) d2 = abs ( Vector . cross ( base , self . p2 - s . p1 ) ) t = d1 / ( d1 + d2 ) return self . p1 + ( self . p2 - self . p1 ) * t def distance ( self , s ) : if self . intersect ( s ) : return 0.0 d1 = s . p1 . distance ( self ) d2 = s . p2 . distance ( self ) d3 = self . p1 . distance ( s ) d4 = self . p2 . distance ( s ) return min ( d1 , d2 , d3 , d4 ) @ classmethod def is_orthogonal ( cls , s1 , s2 ) : a = Vector ( s1 . p2 - s1 . p1 ) b = Vector ( s2 . p2 - s2 . p1 ) return Vector . is_orthogonal ( a , b ) @ classmethod def is_parallel ( cls , s1 , s2 ) : a = Vector ( s1 . p2 - s1 . p1 ) b = Vector ( s2 . p2 - s2 . p1 ) return Vector . is_parallel ( a , b ) class Line ( Segment ) : pass class Cirle ( object ) : def __init__ ( self , x , y = Point ( ) , r = 1.0 ) : if isinstance ( x , Point ) : self . c = x self . r = y elif isinstance ( x , tuple ) : self . c = Point ( x [ 0 ] , x [ 1 ] ) self . r = r def cross_points ( self , s ) : if isinstance ( s , Segment ) : pr = self . c . project ( s ) e = ( s . p2 - s . p1 ) / abs ( s . p2 - s . p1 ) base = sqrt ( self . r * self . r - ( pr - self . c ) . norm ( ) ) return pr + e * base , pr - e * base elif isinstance ( s , Cirle ) : c2 = s d = abs ( self . c - c2 . c ) a = acos ( ( self . r * self . r + d * d - c2 . r * c2 . r ) / ( 2 * self . r * d ) ) t = atan2 ( c2 . c . y - self . c . y , c2 . c . x - self . c . x ) temp1 = Point ( cos ( t + a ) * self . r , sin ( t + a ) * self . r ) temp2 = Point ( cos ( t - a ) * self . r , sin ( t - a ) * self . r ) return self . c + temp1 , self . c + temp2 def contains ( polygon , p ) : n = len ( polygon ) x = False for i in range ( n ) : a = polygon [ i ] - p b = polygon [ ( i + 1 ) % n ] - p if abs ( Vector . cross ( a , b ) ) < Point . epsilon and Vector . dot ( a , b ) < Point . epsilon : return 1 if a . y > b . y : temp = a a = b b = temp if a . y < Point . epsilon and Point . epsilon < b . y and Vector . cross ( a , b ) > Point . epsilon : x = not x return 2 if x else 0 def main ( args ) : n = int ( input ( ) ) for _ in range ( n ) : x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) a = Point ( x1 , y1 ) b = Point ( x2 , y2 ) c = Point ( x3 , y3 ) d = Point ( x4 , y4 ) AB = Segment ( a , b ) CD = Segment ( c , d ) result = Segment . is_parallel ( AB , CD ) if result : print ( ' YES ' ) else : print ( ' NO ' ) if __name__ == ' __main__ ' : main ( sys . argv [ 1 : ] )",
    "label": 0
  },
  {
    "code": "import sys from sys import stdin input = stdin . readline class Point ( object ) : epsilon = 1e-10 def __init__ ( self , x = 0.0 , y = 0.0 ) : if isinstance ( x , tuple ) : self . x = x [ 0 ] self . y = x [ 1 ] else : self . x = x self . y = y def __add__ ( self , other ) : return Point ( self . x + other . x , self . y + other . y ) def __sub__ ( self , other ) : return Point ( self . x - other . x , self . y - other . y ) def __mul__ ( self , other ) : return Point ( other * self . x , other * self . y ) def __truediv__ ( self , other ) : return Point ( self . x / other , self . y / other ) def __lt__ ( self , other ) : if self . x == other . x : return self . y < other . y else : return self . x < other . x def __eq__ ( self , other ) : from math import fabs if fabs ( self . x - other . x ) < Point . epsilon and fabs ( self . y - other . y ) < Point . epsilon : return True else : return False def norm ( self ) : return self . x * self . x + self . y * self . y def __abs__ ( self ) : return sqrt ( self . norm ( ) ) def ccw ( self , p0 , p1 ) : a = Vector ( p1 - p0 ) b = Vector ( self - p0 ) if Vector . cross ( a , b ) > Point . epsilon : return 1 elif Vector . cross ( a , b ) < - Point . epsilon : return - 1 elif Vector . dot ( a , b ) < - Point . epsilon : return 2 elif a . norm ( ) < b . norm ( ) : return - 2 else : return 0 def project ( self , s ) : base = Vector ( s . p2 - s . p1 ) a = Vector ( self - s . p1 ) r = Vector . dot ( a , base ) r /= base . norm ( ) return s . p1 + base * r def reflect ( self , s ) : proj = self . project ( s ) return self + ( proj - self ) * 2 def distance ( self , s ) : if Vector . dot ( s . p2 - s . p1 , self - s . p1 ) < 0.0 : return abs ( self - s . p1 ) if Vector . dot ( s . p1 - s . p2 , self - s . p2 ) < 0.0 : return abs ( self - s . p2 ) return abs ( Vector . cross ( s . p2 - s . p1 , self - s . p1 ) / abs ( s . p2 - s . p1 ) ) class Vector ( Point ) : def __init__ ( self , x = 0.0 , y = 0.0 ) : if isinstance ( x , tuple ) : self . x = x [ 0 ] self . y = x [ 1 ] elif isinstance ( x , Point ) : self . x = x . x self . y = x . y else : self . x = x self . y = y def __add__ ( self , other ) : return Vector ( self . x + other . x , self . y + other . y ) def __sub__ ( self , other ) : return Vector ( self . x - other . x , self . y - other . y ) def __mul__ ( self , other ) : return Vector ( other * self . x , other * self . y ) def __truediv__ ( self , other ) : return Vector ( self . x / other , self . y / other ) @ classmethod def dot ( cls , a , b ) : return a . x * b . x + a . y * b . y @ classmethod def cross ( cls , a , b ) : return a . x * b . y - a . y * b . x @ classmethod def is_orthogonal ( cls , a , b ) : return Vector . dot ( a , b ) == 0.0 @ classmethod def is_parallel ( cls , a , b ) : return Vector . cross ( a , b ) == 0.0 class Segment ( object ) : def __init__ ( self , p1 = Point ( ) , p2 = Point ( ) ) : if isinstance ( p1 , Point ) : self . p1 = p1 self . p2 = p2 elif isinstance ( p1 , tuple ) : self . p1 = Point ( p1 [ 0 ] , p1 [ 1 ] ) self . p2 = Point ( p2 [ 0 ] , p2 [ 1 ] ) def intersect ( self , s ) : ans1 = s . p1 . ccw ( self . p1 , self . p2 ) * s . p2 . ccw ( self . p1 , self . p2 ) ans2 = self . p1 . ccw ( s . p1 , s . p2 ) * self . p2 . ccw ( s . p1 , s . p2 ) return ans1 <= 0 and ans2 <= 0 def cross_point ( self , s ) : base = s . p2 - s . p1 d1 = abs ( Vector . cross ( base , self . p1 - s . p1 ) ) d2 = abs ( Vector . cross ( base , self . p2 - s . p1 ) ) t = d1 / ( d1 + d2 ) return self . p1 + ( self . p2 - self . p1 ) * t def distance ( self , s ) : if self . intersect ( s ) : return 0.0 d1 = s . p1 . distance ( self ) d2 = s . p2 . distance ( self ) d3 = self . p1 . distance ( s ) d4 = self . p2 . distance ( s ) return min ( d1 , d2 , d3 , d4 ) @ classmethod def is_orthogonal ( cls , s1 , s2 ) : a = Vector ( s1 . p2 - s1 . p1 ) b = Vector ( s2 . p2 - s2 . p1 ) return Vector . is_orthogonal ( a , b ) @ classmethod def is_parallel ( cls , s1 , s2 ) : a = Vector ( s1 . p2 - s1 . p1 ) b = Vector ( s2 . p2 - s2 . p1 ) return Vector . is_parallel ( a , b ) class Line ( Segment ) : pass class Cirle ( object ) : def __init__ ( self , x , y = Point ( ) , r = 1.0 ) : if isinstance ( x , Point ) : self . c = x self . r = y elif isinstance ( x , tuple ) : self . c = Point ( x [ 0 ] , x [ 1 ] ) self . r = r def cross_points ( self , s ) : if isinstance ( s , Segment ) : pr = self . c . project ( s ) e = ( s . p2 - s . p1 ) / abs ( s . p2 - s . p1 ) base = sqrt ( self . r * self . r - ( pr - self . c ) . norm ( ) ) return pr + e * base , pr - e * base elif isinstance ( s , Cirle ) : c2 = s d = abs ( self . c - c2 . c ) a = acos ( ( self . r * self . r + d * d - c2 . r * c2 . r ) / ( 2 * self . r * d ) ) t = atan2 ( c2 . c . y - self . c . y , c2 . c . x - self . c . x ) temp1 = Point ( cos ( t + a ) * self . r , sin ( t + a ) * self . r ) temp2 = Point ( cos ( t - a ) * self . r , sin ( t - a ) * self . r ) return self . c + temp1 , self . c + temp2 def contains ( polygon , p ) : n = len ( polygon ) x = False for i in range ( n ) : a = polygon [ i ] - p b = polygon [ ( i + 1 ) % n ] - p if abs ( Vector . cross ( a , b ) ) < Point . epsilon and Vector . dot ( a , b ) < Point . epsilon : return 1 if a . y > b . y : temp = a a = b b = temp if a . y < Point . epsilon and Point . epsilon < b . y and Vector . cross ( a , b ) > Point . epsilon : x = not x return 2 if x else 0 def main ( args ) : for line in sys . stdin : polygon = [ ] x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , line . split ( ) ) polygon . append ( Point ( x1 , y1 ) ) polygon . append ( Point ( x2 , y2 ) ) polygon . append ( Point ( x3 , y3 ) ) result = contains ( polygon , Point ( xp , yp ) ) if result == 2 : print ( ' YES ' ) else : print ( ' NO ' ) if __name__ == ' __main__ ' : main ( sys . argv [ 1 : ] )",
    "label": 0
  },
  {
    "code": "def paint ( masu , data ) : masu [ data [ 1 ] ] [ data [ 0 ] ] += 1 if data [ 2 ] == 1 : if data [ 0 ] != 0 : masu [ data [ 1 ] ] [ data [ 0 ] - 1 ] + = 1 if data [ 0 ] != 9 : masu [ data [ 1 ] ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 0 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] ] + = 1 if data [ 1 ] != 9 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] ] + = 1 elif data [ 2 ] == 2 : if data [ 0 ] != 0 : masu [ data [ 1 ] ] [ data [ 0 ] - 1 ] + = 1 if data [ 0 ] != 9 : masu [ data [ 1 ] ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 0 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] ] + = 1 if data [ 1 ] != 9 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] ] + = 1 if data [ 1 ] != 9 and data [ 0 ] != 9 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 9 and data [ 0 ] != 0 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] - 1 ] + = 1 if data [ 1 ] != 0 and data [ 0 ] != 9 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 0 and data [ 0 ] != 0 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] - 1 ] + = 1 elif data [ 2 ] == 3 : if data [ 0 ] != 0 : masu [ data [ 1 ] ] [ data [ 0 ] - 1 ] + = 1 if data [ 0 ] != 9 : masu [ data [ 1 ] ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 0 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] ] + = 1 if data [ 1 ] != 9 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] ] + = 1 if data [ 1 ] != 9 and data [ 0 ] != 9 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 9 and data [ 0 ] != 0 : masu [ data [ 1 ] + 1 ] [ data [ 0 ] - 1 ] + = 1 if data [ 1 ] != 0 and data [ 0 ] != 9 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] + 1 ] + = 1 if data [ 1 ] != 0 and data [ 0 ] != 0 : masu [ data [ 1 ] - 1 ] [ data [ 0 ] - 1 ] + = 1 if data [ 1 ] >= 2 : masu [ data [ 1 ] - 2 ] [ data [ 0 ] ] + = 1 if data [ 1 ] <= 7 : masu [ data [ 1 ] + 2 ] [ data [ 0 ] ] + = 1 if data [ 0 ] >= 2 : masu [ data [ 1 ] ] [ data [ 0 ] - 2 ] + = 1 if data [ 0 ] <= 7 : masu [ data [ 1 ] ] [ data [ 0 ] + 2 ] + = 1 return masu masu = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] def keisan ( masu ) : max = 0 num1 = 0 for na in range ( 10 ) : for ma in range ( 10 ) : if masu [ na ] [ ma ] == 0 : num1 + = 1 if masu [ na ] [ ma ] > max : max = masu [ na ] [ ma ] print ( num1 ) print ( max ) while True : try : x , y , s = list ( map ( int , input ( ) . split ( ' , ' ) ) ) data = [ x , y , s ] masu2 = paint ( masu , data ) except : break keisan ( masu2 )",
    "label": 0
  },
  {
    "code": "import sys from decimal import Decimal def is_parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : d1x = x2 - x1 d1y = y2 - y1 d2x = x4 - x3 d2y = y4 - y3 return d1x * d2y == d1y * d2x def main ( ) : n = int ( sys . stdin . readline ( ) . strip ( ) ) for _ in range ( n ) : data = sys . stdin . readline ( ) . strip ( ) . split ( ' ' ) x1 = Decimal ( data [ 0 ] ) y1 = Decimal ( data [ 1 ] ) x2 = Decimal ( data [ 2 ] ) y2 = Decimal ( data [ 3 ] ) x3 = Decimal ( data [ 4 ] ) y3 = Decimal ( data [ 5 ] ) x4 = Decimal ( data [ 6 ] ) y4 = Decimal ( data [ 7 ] ) if is_parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : print ( ' YES ' ) else : print ( ' NO ' ) if __name__ == ' __main__ ' : main ( )",
    "label": 0
  },
  {
    "code": "import sys class Paper ( object ) : def __init__ ( self , x = None , y = None ) : if x == None : self . x = 10 else : self . x = x if y == None : self . y = 10 else : self . y = y t = [ 0 ] * self . x self . sheet = [ t [ : ] for _ in range ( self . y ) ] def drop_ink ( self , ink ) : x , y , s = ink if s == 1 : self . process_ink ( x , y ) self . process_ink ( x + 1 , y ) self . process_ink ( x - 1 , y ) self . process_ink ( x , y + 1 ) self . process_ink ( x , y - 1 ) elif s == 2 : self . process_ink ( x - 1 , y - 1 ) self . process_ink ( x , y - 1 ) self . process_ink ( x + 1 , y - 1 ) self . process_ink ( x - 1 , y ) self . process_ink ( x , y ) self . process_ink ( x + 1 , y ) self . process_ink ( x - 1 , y + 1 ) self . process_ink ( x , y + 1 ) self . process_ink ( x + 1 , y + 1 ) elif s == 3 : self . process_ink ( x , y - 2 ) self . process_ink ( x - 1 , y - 1 ) self . process_ink ( x , y - 1 ) self . process_ink ( x + 1 , y - 1 ) self . process_ink ( x - 2 , y ) self . process_ink ( x - 1 , y ) self . process_ink ( x , y ) self . process_ink ( x + 1 , y ) self . process_ink ( x + 2 , y ) self . process_ink ( x - 1 , y + 1 ) self . process_ink ( x , y + 1 ) self . process_ink ( x + 1 , y + 1 ) self . process_ink ( x , y + 2 ) def process_ink ( self , x , y ) : if 0 <= x < self . x and 0 <= y < self . y : self . sheet [ y ] [ x ] + = 1 def print_sheet ( self ) : for row in self . sheet : print ( row ) if __name__ == ' __main__ ' : ink_drops = [ ] for line in sys . stdin : ink_drops . append ( [ int ( x ) for x in line . strip ( ) . split ( ' , ' ) ] ) p = Paper ( 10 , 10 ) for ink in ink_drops : p . drop_ink ( ink ) white_cell = 0 max_ink = 0 for r in p . sheet : white_cell + = r . count ( 0 ) max_ink = max ( max ( r ) , max_ink ) print ( white_cell ) print ( max_ink )",
    "label": 0
  },
  {
    "code": "import math if __name__ == ' __main__ ' : n = int ( raw_input ( ) ) for i in xrange ( n ) : x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . strip ( ) . split ( ' ' ) ) if math . fabs ( ( y2 - y1 ) * ( x4 - x3 ) - ( y4 - y3 ) * ( x2 - x1 ) ) < 1e-10 : print ' YES ' else : print ' NO '",
    "label": 0
  },
  {
    "code": "sheet = [ [ 0 for _ in range ( 10 ) ] for _ in range ( 10 ) ] small_range = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) middle_range = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) ) large_range = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( - 1 , 1 ) , ( - 1 , 0 ) , ( - 2 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 0 , - 2 ) , ( 1 , - 1 ) ) def drop ( x , y , drop_range ) : for dx , dy in drop_range : newx , newy = x + dx , y + dy if 0 <= newx <= 9 and 0 <= newy <= 9 : sheet [ newx ] [ newy ] + = 1 while True : try : x , y , s = map ( int , input ( ) . split ( \" , \" ) ) if s == 1 : drop ( x , y , small_range ) elif s == 2 : drop ( x , y , middle_range ) else : drop ( x , y , large_range ) except EOFError : break zero_cnt = 0 max_ink = 0 for x in range ( 10 ) : for y in range ( 10 ) : ink = sheet [ x ] [ y ] if ink == 0 : zero_cnt + = 1 if max_ink < ink : max_ink = ink print ( zero_cnt ) print ( max_ink )",
    "label": 0
  },
  {
    "code": "def perpendicular_bisector ( p , q ) : x = ( q [ 0 ] - p [ 0 ] ) y = ( q [ 1 ] - p [ 1 ] ) return ( 2 * x , 2 * y , p [ 0 ] ** 2 - q [ 0 ] ** 2 + p [ 1 ] ** 2 - q [ 1 ] ** 2 ) def gauss_jordan_elimination ( Array ) : N = len ( Array ) if N == 0 : return ( True , Array ) else : M = len ( Array [ 0 ] ) A = [ ] for i in range ( len ( Array ) ) : A . append ( Array [ i ] [ : ] ) pivot = 0 L = min ( N , M ) while pivot < L : pivot_v = A [ pivot ] [ pivot ] pivot_row = pivot for i in range ( pivot + 1 , L ) : v = max ( A [ i ] [ pivot ] , - A [ i ] [ pivot ] ) if pivot_v < v : pivot_row = i pivot_v = v if pivot_row > pivot : for i in range ( M ) : A [ pivot ] [ i ] , A [ pivot_row ] [ i ] = A [ pivot_row ] [ i ] , A [ pivot ] [ i ] if pivot_v == 0 : return ( ' False ' , A ) inv_pivot = 1 / A [ pivot ] [ pivot ] A [ pivot ] [ pivot ] = 1 for i in range ( pivot + 1 , M ) : A [ pivot ] [ i ] * = inv_pivot for i in range ( N ) : if i == pivot : continue t = - 1 * A [ i ] [ pivot ] A [ i ] [ pivot ] = 0 for j in range ( pivot + 1 , M ) : A [ i ] [ j ] + = t * A [ pivot ] [ j ] pivot += 1 return ( ' True ' , A ) n = int ( input ( ) ) for _ in range ( n ) : x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) a = list ( perpendicular_bisector ( ( x1 , y1 ) , ( x2 , y2 ) ) ) b = list ( perpendicular_bisector ( ( x1 , y1 ) , ( x3 , y3 ) ) ) c = [ a , b ] state , c = gauss_jordan_elimination ( c ) x = - c [ 0 ] [ 2 ] y = - c [ 1 ] [ 2 ] r = ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) ** 0.5 print ( ' {0:.3f} {1:.3f} {2:.3f} ' . format ( round ( x , 3 ) , round ( y , 3 ) , round ( r , 3 ) ) )",
    "label": 0
  },
  {
    "code": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy sys . setrecursionlimit ( 10 ** 7 ) inf = 10 ** 20 mod = 10 ** 9 + 7 def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] def LS ( ) : return sys . stdin . readline ( ) . split ( ) def I ( ) : return int ( sys . stdin . readline ( ) ) def F ( ) : return float ( sys . stdin . readline ( ) ) def S ( ) : return input ( ) class Matrix ( ) : def __init__ ( self , A ) : self . A = A self . row = len ( A ) self . col = len ( A [ 0 ] ) def __iter__ ( self ) : return self . A . __iter__ ( ) def __getitem__ ( self , i ) : return self . A . __getitem__ ( i ) def __add__ ( self , B ) : aa = self . A bb = B . A return Matrix ( [ [ aa [ i ] [ j ] + bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) def __sub__ ( self , B ) : aa = self . A bb = B . A return Matrix ( [ [ aa [ i ] [ j ] - bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) def __mul__ ( self , B ) : aa = self . A bb = B . A a = [ ] for i in range ( self . row ) : ai = aa [ i ] r = [ ] for j in range ( B . col ) : r . append ( sum ( [ ai [ k ] * bb [ k ] [ j ] for k in range ( self . col ) ] ) ) a . append ( r ) return Matrix ( a ) def __truediv__ ( self , x ) : pass def lu ( self ) : size = self . row T = copy . deepcopy ( self . A ) L = [ [ 0 ] * size for _ in range ( size ) ] U = [ [ 0 ] * size for _ in range ( size ) ] for i in range ( size ) : for j in range ( i , size ) : L [ j ] [ i ] = T [ j ] [ i ] for j in range ( i , size ) : U [ i ] [ j ] = T [ i ] [ j ] / T [ i ] [ i ] for j in range ( i + 1 , size ) : for k in range ( i + 1 , size ) : T [ j ] [ k ] -= L [ j ] [ i ] * U [ i ] [ k ] return Matrix ( L ) , Matrix ( U ) def __str__ ( self ) : return self . A . __str__ ( ) def solve_se ( A , b ) : n = A . row L , U = A . lu ( ) y = [ ] for i in range ( n ) : t = b [ i ] for k in range ( i ) : t - = L [ i ] [ k ] * y [ k ] y . append ( t / L [ i ] [ i ] ) x = [ 0 ] * n for i in range ( n - 1 , - 1 , - 1 ) : t = y [ i ] for k in range ( i + 1 , n ) : t - = U [ i ] [ k ] * x [ k ] x [ i ] = t return x def main ( ) : sa = [ s for s in sys . stdin . read ( ) . split ( ' \\n ' ) if s ] r = [ ] for s in sa : a , b , c , d , e , f = [ int ( c ) for c in s . split ( ) ] A = Matrix ( [ [ a , b ] , [ d , e ] ] ) B = [ c , f ] x = solve_se ( A , B ) r . append ( ' ' . join ( map ( lambda t : ' {:01.3f} ' . format ( 1.0 * t ) , x ) ) ) return ' \\n ' . join ( r ) print ( main ( ) )",
    "label": 0
  },
  {
    "code": "class Point ( object ) : def __init__ ( self , x , y ) : self . x = x self . y = y def __str__ ( self ) : return \" x = {0}, y = {1} \" . format ( self . x , self . y ) class Line ( Point ) : eps = 10 ** ( - 10 ) def __init__ ( self , p1 , p2 ) : self . p1 = p1 self . p2 = p2 def isParallel ( self , another_p ) : try : angle1 = ( self . p1 . y - self . p2 . y ) / ( self . p1 . x - self . p2 . x ) angle2 = ( another_p . p1 . y - another_p . p2 . y ) / ( another_p . p1 . x - another_p . p2 . x ) if angle1 >= angle2 - self . eps and angle1 <= angle2 + self . eps : return True else : return False except ZeroDivisionError : if self . p1 . x == self . p2 . x and another_p . p1 . x == another_p . p2 . x : return True else : return False n = int ( input ( ) ) for i in range ( n ) : x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) A = Point ( x1 , y1 ) B = Point ( x2 , y2 ) C = Point ( x3 , y3 ) D = Point ( x4 , y4 ) AB = Line ( A , B ) CD = Line ( C , D ) if AB . isParallel ( CD ) : print ( \" YES \" ) else : print ( \" NO \" )",
    "label": 0
  },
  {
    "code": "public class Main { private static final int BEGIN = 1 ; private static final int END = 9 ; public static void main ( String [ ] args ) { for ( int i = BEGIN ; i <= END ; i ++ ) { for ( int j = BEGIN ; j <= END ; j ++ ) { System . out . println ( createMultiplicationLine ( i , j ) ) ; } } } protected static String createMultiplicationLine ( int i , int j ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( i ) ; buffer . append ( \" x \" ) ; buffer . append ( j ) ; buffer . append ( \" = \" ) ; buffer . append ( i * j ) ; return buffer . toString ( ) ; } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String args [ ] ) { System . out . println ( \" 1x1=1 \" ) ; System . out . println ( \" 1x2=2 \" ) ; System . out . println ( \" 1x3=3 \" ) ; System . out . println ( \" 1x4=4 \" ) ; System . out . println ( \" 1x5=5 \" ) ; System . out . println ( \" 1x6=6 \" ) ; System . out . println ( \" 1x7=7 \" ) ; System . out . println ( \" 1x8=8 \" ) ; System . out . println ( \" 1x9=9 \" ) ; System . out . println ( \" 2x1=2 \" ) ; System . out . println ( \" 2x2=4 \" ) ; System . out . println ( \" 2x3=6 \" ) ; System . out . println ( \" 2x4=8 \" ) ; System . out . println ( \" 2x5=10 \" ) ; System . out . println ( \" 2x6=12 \" ) ; System . out . println ( \" 2x7=14 \" ) ; System . out . println ( \" 2x8=16 \" ) ; System . out . println ( \" 2x9=18 \" ) ; System . out . println ( \" 3x1=3 \" ) ; System . out . println ( \" 3x2=6 \" ) ; System . out . println ( \" 3x3=9 \" ) ; System . out . println ( \" 3x4=12 \" ) ; System . out . println ( \" 3x5=15 \" ) ; System . out . println ( \" 3x6=18 \" ) ; System . out . println ( \" 3x7=21 \" ) ; System . out . println ( \" 3x8=24 \" ) ; System . out . println ( \" 3x9=27 \" ) ; System . out . println ( \" 4x1=4 \" ) ; System . out . println ( \" 4x2=8 \" ) ; System . out . println ( \" 4x3=12 \" ) ; System . out . println ( \" 4x4=16 \" ) ; System . out . println ( \" 4x5=20 \" ) ; System . out . println ( \" 4x6=24 \" ) ; System . out . println ( \" 4x7=28 \" ) ; System . out . println ( \" 4x8=32 \" ) ; System . out . println ( \" 4x9=36 \" ) ; System . out . println ( \" 5x1=5 \" ) ; System . out . println ( \" 5x2=10 \" ) ; System . out . println ( \" 5x3=15 \" ) ; System . out . println ( \" 5x4=20 \" ) ; System . out . println ( \" 5x5=25 \" ) ; System . out . println ( \" 5x6=30 \" ) ; System . out . println ( \" 5x7=35 \" ) ; System . out . println ( \" 5x8=40 \" ) ; System . out . println ( \" 5x9=45 \" ) ; System . out . println ( \" 6x1=6 \" ) ; System . out . println ( \" 6x2=12 \" ) ; System . out . println ( \" 6x3=18 \" ) ; System . out . println ( \" 6x4=24 \" ) ; System . out . println ( \" 6x5=30 \" ) ; System . out . println ( \" 6x6=36 \" ) ; System . out . println ( \" 6x7=42 \" ) ; System . out . println ( \" 6x8=48 \" ) ; System . out . println ( \" 6x9=54 \" ) ; System . out . println ( \" 7x1=7 \" ) ; System . out . println ( \" 7x2=14 \" ) ; System . out . println ( \" 7x3=21 \" ) ; System . out . println ( \" 7x4=28 \" ) ; System . out . println ( \" 7x5=35 \" ) ; System . out . println ( \" 7x6=42 \" ) ; System . out . println ( \" 7x7=49 \" ) ; System . out . println ( \" 7x8=56 \" ) ; System . out . println ( \" 7x9=63 \" ) ; System . out . println ( \" 8x1=8 \" ) ; System . out . println ( \" 8x2=16 \" ) ; System . out . println ( \" 8x3=24 \" ) ; System . out . println ( \" 8x4=32 \" ) ; System . out . println ( \" 8x5=40 \" ) ; System . out . println ( \" 8x6=48 \" ) ; System . out . println ( \" 8x7=56 \" ) ; System . out . println ( \" 8x8=64 \" ) ; System . out . println ( \" 8x9=72 \" ) ; System . out . println ( \" 9x1=9 \" ) ; System . out . println ( \" 9x2=18 \" ) ; System . out . println ( \" 9x3=27 \" ) ; System . out . println ( \" 9x4=36 \" ) ; System . out . println ( \" 9x5=45 \" ) ; System . out . println ( \" 9x6=54 \" ) ; System . out . println ( \" 9x7=63 \" ) ; System . out . println ( \" 9x8=72 \" ) ; System . out . println ( \" 9x9=81 \" ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String s ; int input = Integer . parseInt ( br . readLine ( ) ) ; List < String > rightAngleList = new ArrayList < String > ( ) ; for ( int i = 1 ; i <= input ; i ++ ) { s = br . readLine ( ) ; String [ ] num = s . split ( \" \" ) ; Integer [ ] side = convertArray ( num ) ; Arrays . sort ( side ) ; if ( side [ 2 ] * side [ 2 ] == side [ 1 ] * side [ 1 ] + side [ 0 ] * side [ 0 ] ) { rightAngleList . add ( \" YES \" ) ; } else { rightAngleList . add ( \" NO \" ) ; } } String [ ] rightAngles = rightAngleList . toArray ( new String [ 0 ] ) ; for ( String rightAngle : rightAngles ) { System . out . println ( rightAngle ) ; } } finally { br . close ( ) ; } } public static Integer [ ] convertArray ( String [ ] str ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( String num : str ) { list . add ( Integer . parseInt ( num ) ) ; } return list . toArray ( new Integer [ 0 ] ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private final static String NEGATIVE = \" NO \\n \" ; private final static String AFFIRMATIVE = \" YES \\n \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1024 ) ; int number = Integer . parseInt ( br . readLine ( ) ) ; int sides [ ] = new int [ 3 ] ; StringTokenizer tknz ; StringBuilder builder = new StringBuilder ( ) ; for ( ; 0 < number ; number -- ) { tknz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = Integer . parseInt ( tknz . nextToken ( ) ) ; } Arrays . sort ( sides ) ; if ( sides [ 0 ] * sides [ 1 ] * sides [ 2 ] % 60 != 0 ) { builder . append ( NEGATIVE ) ; } else if ( Math . pow ( sides [ 0 ] , 2 ) + Math . pow ( sides [ 1 ] , 2 ) != Math . pow ( sides [ 2 ] , 2 ) ) { builder . append ( NEGATIVE ) ; } else { builder . append ( AFFIRMATIVE ) ; } } System . out . print ( builder ) ; } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; String str = \" \" ; StringTokenizer st ; while ( ( str = br . readLine ( ) ) != null ) { st = new StringTokenizer ( str , \" \" ) ; if ( st . countTokens ( ) > 2 ) System . out . println ( \" Only 2 numbers per dataset allowed. \" ) ; int n1 ; int n2 ; try { n1 = Integer . parseInt ( st . nextToken ( ) ) ; n2 = Integer . parseInt ( st . nextToken ( ) ) ; if ( n1 < 0 || n2 < 0 || n1 > 1000000 || n2 > 1000000 ) System . out . println ( \" Out of range. 0 ??? a, b ??? 1,000,000 \" ) ; str = String . valueOf ( n1 + n2 ) ; System . out . println ( str . length ( ) ) ; } catch ( NumberFormatException e ) { System . out . println ( \" Only number as follows allowed: 0 ??? a, b ??? 1,000,000 \" ) ; } } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; try { line = br . readLine ( ) ; int n = Integer . parseInt ( line . trim ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { line = br . readLine ( ) ; String [ ] numbers = line . trim ( ) . split ( \" \" ) ; int [ ] sides = { Integer . parseInt ( numbers [ 0 ] ) , Integer . parseInt ( numbers [ 1 ] ) , Integer . parseInt ( numbers [ 2 ] ) } ; int maxSide = sides [ 0 ] > sides [ 1 ] && sides [ 0 ] > sides [ 2 ] ? 0 : sides [ 1 ] > sides [ 2 ] ? 1 : 2 ; int sum = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( j != maxSide ) { sum += sides [ j ] * sides [ j ] ; } } System . out . println ( sides [ maxSide ] * sides [ maxSide ] == sum ? \" YES \" : \" NO \" ) ; } } catch ( IOException e ) { } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . BufferedOutputStream ; import java . io . PrintWriter ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . io . IOException ; public class Main { public static void main ( String [ ] args ) { Scanner kb = new Scanner ( System . in ) ; out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int height [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { height [ i ] = kb . nextInt ( ) ; } Arrays . sort ( height ) ; System . out . println ( height [ 9 ] ) ; System . out . println ( height [ 8 ] ) ; System . out . println ( height [ 7 ] ) ; } public static PrintWriter out ; public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; public class Main { private static final int DATA_SET = 200 ; public static void main ( String [ ] args ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < String > inputDataList = new ArrayList < String > ( DATA_SET ) ; String input = null ; try { while ( ( input = in . readLine ( ) ) != null ) { inputDataList . add ( input ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } for ( String inputData : inputDataList ) { String [ ] data = inputData . split ( \" \" ) ; double result = Math . log10 ( Double . parseDouble ( data [ 0 ] ) + Double . parseDouble ( data [ 1 ] ) ) ; System . out . println ( new Double ( result ) . intValue ( ) + 1 ) ; } } }",
    "label": 1
  },
  {
    "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . * ; public class Main { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final String LINE_SPR = System . getProperty ( \" line.separator \" ) ; final int BIG_MOD = 1000000007 ; void run ( ) throws Exception { for ( int i = 1 ; i <= 9 ; i ++ ) for ( int j = 1 ; j <= 9 ; j ++ ) System . out . println ( i + \" x \" + j + \" = \" + ( i * j ) ) ; } void dumpObjArr ( Object [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] ) ; if ( i < n - 1 ) System . out . print ( \" \" ) ; } System . out . println ( \" \" ) ; } void dumpObjArr2 ( Object [ ] [ ] arr , int m , int n ) { for ( int j = 0 ; j < m ; j ++ ) dumpObjArr ( arr [ j ] , n ) ; } int ni ( ) throws Exception { return Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; } long nl ( ) throws Exception { return Long . parseLong ( br . readLine ( ) . trim ( ) ) ; } String ns ( ) throws Exception { return br . readLine ( ) ; } boolean isPrime ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int getPrime ( int n ) { List < Integer > primes = new ArrayList < Integer > ( ) ; primes . add ( 2 ) ; int count = 1 ; int x = 1 ; while ( primes . size ( ) < n ) { x += 2 ; int m = ( int ) Math . sqrt ( x ) ; for ( int p : primes ) { if ( p > m ) { primes . add ( x ) ; break ; } if ( x % p == 0 ) break ; } } return primes . get ( primes . size ( ) - 1 ) ; } void gcjPrint ( String str , int t ) { System . out . println ( \" Case # \" + t + \" : \" + str ) ; } public static void main ( String [ ] args ) throws Exception { new Main ( ) . run ( ) ; } }",
    "label": 1
  },
  {
    "code": "public class Main { public static void main ( String args [ ] ) { System . out . println ( \" 1x1=1 \" ) ; System . out . println ( \" 1x2=2 \" ) ; System . out . println ( \" 1x3=3 \" ) ; System . out . println ( \" 1x4=4 \" ) ; System . out . println ( \" 1x5=5 \" ) ; System . out . println ( \" 1x6=6 \" ) ; System . out . println ( \" 1x7=7 \" ) ; System . out . println ( \" 1x8=8 \" ) ; System . out . println ( \" 1x9=9 \" ) ; System . out . println ( \" 2x1=2 \" ) ; System . out . println ( \" 2x2=4 \" ) ; System . out . println ( \" 2x3=6 \" ) ; System . out . println ( \" 2x4=8 \" ) ; System . out . println ( \" 2x5=10 \" ) ; System . out . println ( \" 2x6=12 \" ) ; System . out . println ( \" 2x7=14 \" ) ; System . out . println ( \" 2x8=16 \" ) ; System . out . println ( \" 2x9=18 \" ) ; System . out . println ( \" 3x1=3 \" ) ; System . out . println ( \" 3x2=6 \" ) ; System . out . println ( \" 3x3=9 \" ) ; System . out . println ( \" 3x4=12 \" ) ; System . out . println ( \" 3x5=15 \" ) ; System . out . println ( \" 3x6=18 \" ) ; System . out . println ( \" 3x7=21 \" ) ; System . out . println ( \" 3x8=24 \" ) ; System . out . println ( \" 3x9=27 \" ) ; System . out . println ( \" 4x1=4 \" ) ; System . out . println ( \" 4x2=8 \" ) ; System . out . println ( \" 4x3=12 \" ) ; System . out . println ( \" 4x4=16 \" ) ; System . out . println ( \" 4x5=20 \" ) ; System . out . println ( \" 4x6=24 \" ) ; System . out . println ( \" 4x7=28 \" ) ; System . out . println ( \" 4x8=32 \" ) ; System . out . println ( \" 4x9=36 \" ) ; System . out . println ( \" 5x1=5 \" ) ; System . out . println ( \" 5x2=10 \" ) ; System . out . println ( \" 5x3=15 \" ) ; System . out . println ( \" 5x4=20 \" ) ; System . out . println ( \" 5x5=25 \" ) ; System . out . println ( \" 5x6=30 \" ) ; System . out . println ( \" 5x7=35 \" ) ; System . out . println ( \" 5x8=40 \" ) ; System . out . println ( \" 5x9=45 \" ) ; System . out . println ( \" 6x1=6 \" ) ; System . out . println ( \" 6x2=12 \" ) ; System . out . println ( \" 6x3=18 \" ) ; System . out . println ( \" 6x4=24 \" ) ; System . out . println ( \" 6x5=30 \" ) ; System . out . println ( \" 6x6=36 \" ) ; System . out . println ( \" 6x7=42 \" ) ; System . out . println ( \" 6x8=48 \" ) ; System . out . println ( \" 6x9=54 \" ) ; System . out . println ( \" 7x1=7 \" ) ; System . out . println ( \" 7x2=14 \" ) ; System . out . println ( \" 7x3=21 \" ) ; System . out . println ( \" 7x4=28 \" ) ; System . out . println ( \" 7x5=35 \" ) ; System . out . println ( \" 7x6=42 \" ) ; System . out . println ( \" 7x7=49 \" ) ; System . out . println ( \" 7x8=56 \" ) ; System . out . println ( \" 7x9=63 \" ) ; System . out . println ( \" 8x1=8 \" ) ; System . out . println ( \" 8x2=16 \" ) ; System . out . println ( \" 8x3=24 \" ) ; System . out . println ( \" 8x4=32 \" ) ; System . out . println ( \" 8x5=40 \" ) ; System . out . println ( \" 8x6=48 \" ) ; System . out . println ( \" 8x7=56 \" ) ; System . out . println ( \" 8x8=64 \" ) ; System . out . println ( \" 8x9=72 \" ) ; System . out . println ( \" 9x1=9 \" ) ; System . out . println ( \" 9x2=18 \" ) ; System . out . println ( \" 9x3=27 \" ) ; System . out . println ( \" 9x4=36 \" ) ; System . out . println ( \" 9x5=45 \" ) ; System . out . println ( \" 9x6=54 \" ) ; System . out . println ( \" 9x7=63 \" ) ; System . out . println ( \" 9x8=72 \" ) ; System . out . println ( \" 9x9=81 \" ) ; } }",
    "label": 1
  }
]